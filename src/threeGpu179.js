(() => {
    const REVISION = '179';
    const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
    const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
    const CullFaceNone = 0;
    const CullFaceBack = 1;
    const CullFaceFront = 2;
    const CullFaceFrontBack = 3;
    const BasicShadowMap = 0;
    const PCFShadowMap = 1;
    const PCFSoftShadowMap = 2;
    const VSMShadowMap = 3;
    const FrontSide = 0;
    const BackSide = 1;
    const DoubleSide = 2;
    const NoBlending = 0;
    const NormalBlending = 1;
    const AdditiveBlending = 2;
    const SubtractiveBlending = 3;
    const MultiplyBlending = 4;
    const CustomBlending = 5;
    const AddEquation = 100;
    const SubtractEquation = 101;
    const ReverseSubtractEquation = 102;
    const MinEquation = 103;
    const MaxEquation = 104;
    const ZeroFactor = 200;
    const OneFactor = 201;
    const SrcColorFactor = 202;
    const OneMinusSrcColorFactor = 203;
    const SrcAlphaFactor = 204;
    const OneMinusSrcAlphaFactor = 205;
    const DstAlphaFactor = 206;
    const OneMinusDstAlphaFactor = 207;
    const DstColorFactor = 208;
    const OneMinusDstColorFactor = 209;
    const SrcAlphaSaturateFactor = 210;
    const ConstantColorFactor = 211;
    const OneMinusConstantColorFactor = 212;
    const ConstantAlphaFactor = 213;
    const OneMinusConstantAlphaFactor = 214;
    const NeverDepth = 0;
    const AlwaysDepth = 1;
    const LessDepth = 2;
    const LessEqualDepth = 3;
    const EqualDepth = 4;
    const GreaterEqualDepth = 5;
    const GreaterDepth = 6;
    const NotEqualDepth = 7;
    const MultiplyOperation = 0;
    const MixOperation = 1;
    const AddOperation = 2;
    const NoToneMapping = 0;
    const LinearToneMapping = 1;
    const ReinhardToneMapping = 2;
    const CineonToneMapping = 3;
    const ACESFilmicToneMapping = 4;
    const CustomToneMapping = 5;
    const AgXToneMapping = 6;
    const NeutralToneMapping = 7;
    const AttachedBindMode = 'attached';
    const DetachedBindMode = 'detached';
    const UVMapping = 300;
    const CubeReflectionMapping = 301;
    const CubeRefractionMapping = 302;
    const EquirectangularReflectionMapping = 303;
    const EquirectangularRefractionMapping = 304;
    const CubeUVReflectionMapping = 306;
    const RepeatWrapping = 1000;
    const ClampToEdgeWrapping = 1001;
    const MirroredRepeatWrapping = 1002;
    const NearestFilter = 1003;
    const NearestMipmapNearestFilter = 1004;
    const NearestMipMapNearestFilter = 1004; // legacy
    const NearestMipmapLinearFilter = 1005;
    const NearestMipMapLinearFilter = 1005; // legacy
    const LinearFilter = 1006;
    const LinearMipmapNearestFilter = 1007;
    const LinearMipMapNearestFilter = 1007; // legacy
    const LinearMipmapLinearFilter = 1008;
    const LinearMipMapLinearFilter = 1008; // legacy
    const UnsignedByteType = 1009;
    const ByteType = 1010;
    const ShortType = 1011;
    const UnsignedShortType = 1012;
    const IntType = 1013;
    const UnsignedIntType = 1014;
    const FloatType = 1015;
    const HalfFloatType = 1016;
    const UnsignedShort4444Type = 1017;
    const UnsignedShort5551Type = 1018;
    const UnsignedInt248Type = 1020;
    const UnsignedInt5999Type = 35902;
    const AlphaFormat = 1021;
    const RGBFormat = 1022;
    const RGBAFormat = 1023;
    const LuminanceFormat = 1024;
    const LuminanceAlphaFormat = 1025;
    const DepthFormat = 1026;
    const DepthStencilFormat = 1027;
    const RedFormat = 1028;
    const RedIntegerFormat = 1029;
    const RGFormat = 1030;
    const RGIntegerFormat = 1031;
    const RGBIntegerFormat = 1032;
    const RGBAIntegerFormat = 1033;
    const RGB_S3TC_DXT1_Format = 33776;
    const RGBA_S3TC_DXT1_Format = 33777;
    const RGBA_S3TC_DXT3_Format = 33778;
    const RGBA_S3TC_DXT5_Format = 33779;
    const RGB_PVRTC_4BPPV1_Format = 35840;
    const RGB_PVRTC_2BPPV1_Format = 35841;
    const RGBA_PVRTC_4BPPV1_Format = 35842;
    const RGBA_PVRTC_2BPPV1_Format = 35843;
    const RGB_ETC1_Format = 36196;
    const RGB_ETC2_Format = 37492;
    const RGBA_ETC2_EAC_Format = 37496;
    const RGBA_ASTC_4x4_Format = 37808;
    const RGBA_ASTC_5x4_Format = 37809;
    const RGBA_ASTC_5x5_Format = 37810;
    const RGBA_ASTC_6x5_Format = 37811;
    const RGBA_ASTC_6x6_Format = 37812;
    const RGBA_ASTC_8x5_Format = 37813;
    const RGBA_ASTC_8x6_Format = 37814;
    const RGBA_ASTC_8x8_Format = 37815;
    const RGBA_ASTC_10x5_Format = 37816;
    const RGBA_ASTC_10x6_Format = 37817;
    const RGBA_ASTC_10x8_Format = 37818;
    const RGBA_ASTC_10x10_Format = 37819;
    const RGBA_ASTC_12x10_Format = 37820;
    const RGBA_ASTC_12x12_Format = 37821;
    const RGBA_BPTC_Format = 36492;
    const RGB_BPTC_SIGNED_Format = 36494;
    const RGB_BPTC_UNSIGNED_Format = 36495;
    const RED_RGTC1_Format = 36283;
    const SIGNED_RED_RGTC1_Format = 36284;
    const RED_GREEN_RGTC2_Format = 36285;
    const SIGNED_RED_GREEN_RGTC2_Format = 36286;
    const LoopOnce = 2200;

    const LoopRepeat = 2201;
    const LoopPingPong = 2202;
    const InterpolateDiscrete = 2300;
    const InterpolateLinear = 2301;
    const InterpolateSmooth = 2302;
    const ZeroCurvatureEnding = 2400;
    const ZeroSlopeEnding = 2401;
    const WrapAroundEnding = 2402;
    const NormalAnimationBlendMode = 2500;
    const AdditiveAnimationBlendMode = 2501;
    const TrianglesDrawMode = 0;
    const TriangleStripDrawMode = 1;
    const TriangleFanDrawMode = 2;
    const BasicDepthPacking = 3200;
    const RGBADepthPacking = 3201;
    const RGBDepthPacking = 3202;
    const RGDepthPacking = 3203;
    const TangentSpaceNormalMap = 0;
    const ObjectSpaceNormalMap = 1;
    // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
    const NoColorSpace = '';
    const SRGBColorSpace = 'srgb';
    const LinearSRGBColorSpace = 'srgb-linear';
    const LinearTransfer = 'linear';
    const SRGBTransfer = 'srgb';
    const ZeroStencilOp = 0;
    const KeepStencilOp = 7680;
    const ReplaceStencilOp = 7681;
    const IncrementStencilOp = 7682;
    const DecrementStencilOp = 7683;
    const IncrementWrapStencilOp = 34055;
    const DecrementWrapStencilOp = 34056;
    const InvertStencilOp = 5386;
    const NeverStencilFunc = 512;
    const LessStencilFunc = 513;
    const EqualStencilFunc = 514;
    const LessEqualStencilFunc = 515;
    const GreaterStencilFunc = 516;
    const NotEqualStencilFunc = 517;
    const GreaterEqualStencilFunc = 518;
    const AlwaysStencilFunc = 519;
    const NeverCompare = 512;
    const LessCompare = 513;
    const EqualCompare = 514;
    const LessEqualCompare = 515;
    const GreaterCompare = 516;
    const NotEqualCompare = 517;
    const GreaterEqualCompare = 518;
    const AlwaysCompare = 519;
    const StaticDrawUsage = 35044;
    const DynamicDrawUsage = 35048;
    const StreamDrawUsage = 35040;
    const StaticReadUsage = 35045;
    const DynamicReadUsage = 35049;
    const StreamReadUsage = 35041;
    const StaticCopyUsage = 35046;
    const DynamicCopyUsage = 35050;
    const StreamCopyUsage = 35042;
    const GLSL1 = '100';
    const GLSL3 = '300 es';
    const WebGLCoordinateSystem = 2000;
    const WebGPUCoordinateSystem = 2001;
    const TimestampQuery = {
        COMPUTE: 'compute',
        RENDER: 'render'
    };
    const InterpolationSamplingType = {
        PERSPECTIVE: 'perspective',
        LINEAR: 'linear',
        FLAT: 'flat'
    };
    const InterpolationSamplingMode = {
        NORMAL: 'normal',
        CENTROID: 'centroid',
        SAMPLE: 'sample',
        FIRST: 'first',
        EITHER: 'either'
    };



    class EventDispatcher {
        addEventListener(type, listener) {
            if (this._listeners === undefined) this._listeners = {};
            const listeners = this._listeners;
            if (listeners[type] === undefined) {
                listeners[type] = [];
            }
            if (listeners[type].indexOf(listener) === -1) {
                listeners[type].push(listener);
            }
        }
        hasEventListener(type, listener) {
            const listeners = this._listeners;
            if (listeners === undefined) return false;
            return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
        }
        removeEventListener(type, listener) {
            const listeners = this._listeners;
            if (listeners === undefined) return;
            const listenerArray = listeners[type];
            if (listenerArray !== undefined) {
                const index = listenerArray.indexOf(listener);
                if (index !== -1) {
                    listenerArray.splice(index, 1);
                }
            }
        }
        dispatchEvent(event) {
            const listeners = this._listeners;
            if (listeners === undefined) return;
            const listenerArray = listeners[event.type];
            if (listenerArray !== undefined) {
                event.target = this;
                // Make a copy, in case listeners are removed while iterating.
                const array = listenerArray.slice(0);
                for (let i = 0, l = array.length; i < l; i++) {
                    array[i].call(this, event);
                }
                event.target = null;
            }
        }
    }
    const _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];
    let _seed = 1234567;

    const DEG2RAD = Math.PI / 180;
    const RAD2DEG = 180 / Math.PI;
    function generateUUID() {
        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
        const d0 = Math.random() * 0xffffffff | 0;
        const d1 = Math.random() * 0xffffffff | 0;
        const d2 = Math.random() * 0xffffffff | 0;
        const d3 = Math.random() * 0xffffffff | 0;
        const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +
            _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +
            _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +
            _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];
        // .toLowerCase() here flattens concatenated strings to save heap memory space.
        return uuid.toLowerCase();
    }
    function clamp$1(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }
    function euclideanModulo(n, m) {
        // https://en.wikipedia.org/wiki/Modulo_operation
        return ((n % m) + m) % m;
    }
    function mapLinear(x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    }
    function inverseLerp(x, y, value) {
        // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
        if (x !== y) {
            return (value - x) / (y - x);
        } else {
            return 0;
        }
    }
    function lerp(x, y, t) {
        return (1 - t) * x + t * y;
    }
    function damp(x, y, lambda, dt) {
        return lerp(x, y, 1 - Math.exp(- lambda * dt));
    }
    function pingpong(x, length = 1) {
        // https://www.desmos.com/calculator/vcsjnyz7x4
        return length - Math.abs(euclideanModulo(x, length * 2) - length);
    }
    function smoothstep$1(x, min, max) {
        if (x <= min) return 0;
        if (x >= max) return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
    }
    function smootherstep(x, min, max) {
        if (x <= min) return 0;
        if (x >= max) return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
    }
    function randInt(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
    }
    function randFloat(low, high) {
        return low + Math.random() * (high - low);
    }
    function randFloatSpread(range) {
        return range * (0.5 - Math.random());
    }
    function seededRandom(s) {
        if (s !== undefined) _seed = s;
        // Mulberry32 generator
        let t = _seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
    function degToRad(degrees) {
        return degrees * DEG2RAD;
    }
    function radToDeg(radians) {
        return radians * RAD2DEG;
    }
    function isPowerOfTwo(value) {
        return (value & (value - 1)) === 0 && value !== 0;
    }
    function ceilPowerOfTwo(value) {
        return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
    }
    function floorPowerOfTwo(value) {
        return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    }
    function setQuaternionFromProperEuler(q, a, b, c, order) {
        const cos = Math.cos;
        const sin = Math.sin;
        const c2 = cos(b / 2);
        const s2 = sin(b / 2);
        const c13 = cos((a + c) / 2);
        const s13 = sin((a + c) / 2);
        const c1_3 = cos((a - c) / 2);
        const s1_3 = sin((a - c) / 2);
        const c3_1 = cos((c - a) / 2);
        const s3_1 = sin((c - a) / 2);
        switch (order) {
            case 'XYX':
                q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
                break;
            case 'YZY':
                q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
                break;
            case 'ZXZ':
                q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
                break;
            case 'XZX':
                q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
                break;
            case 'YXY':
                q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
                break;
            case 'ZYZ':
                q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
                break;
            default:
                console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
        }
    }
    function denormalize(value, array) {
        switch (array.constructor) {
            case Float32Array:
                return value;
            case Uint32Array:
                return value / 4294967295.0;
            case Uint16Array:
                return value / 65535.0;
            case Uint8Array:
                return value / 255.0;
            case Int32Array:
                return Math.max(value / 2147483647.0, -1);
            case Int16Array:
                return Math.max(value / 32767.0, -1);
            case Int8Array:
                return Math.max(value / 127.0, -1);
            default:
                throw new Error('Invalid component type.');
        }
    }
    function normalize$1(value, array) {
        switch (array.constructor) {
            case Float32Array:
                return value;
            case Uint32Array:
                return Math.round(value * 4294967295.0);
            case Uint16Array:
                return Math.round(value * 65535.0);
            case Uint8Array:
                return Math.round(value * 255.0);
            case Int32Array:
                return Math.round(value * 2147483647.0);
            case Int16Array:
                return Math.round(value * 32767.0);
            case Int8Array:
                return Math.round(value * 127.0);
            default:
                throw new Error('Invalid component type.');
        }
    }
    const MathUtils = {
        DEG2RAD: DEG2RAD,
        RAD2DEG: RAD2DEG,
        generateUUID: generateUUID,
        clamp: clamp$1,
        euclideanModulo: euclideanModulo,
        mapLinear: mapLinear,
        inverseLerp: inverseLerp,
        lerp: lerp,
        damp: damp,
        pingpong: pingpong,
        smoothstep: smoothstep$1,
        smootherstep: smootherstep,
        randInt: randInt,
        randFloat: randFloat,
        randFloatSpread: randFloatSpread,
        seededRandom: seededRandom,
        degToRad: degToRad,
        radToDeg: radToDeg,
        isPowerOfTwo: isPowerOfTwo,
        ceilPowerOfTwo: ceilPowerOfTwo,
        floorPowerOfTwo: floorPowerOfTwo,
        setQuaternionFromProperEuler: setQuaternionFromProperEuler,
        normalize: normalize$1,
        denormalize: denormalize
    };
    class Vector2 {
        constructor(x = 0, y = 0) {
            Vector2.prototype.isVector2 = true;
            this.x = x;
            this.y = y;
        }
        get width() {
            return this.x;
        }
        set width(value) {
            this.x = value;
        }
        get height() {
            return this.y;
        }
        set height(value) {
            this.y = value;
        }
        set(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }
        setScalar(scalar) {
            this.x = scalar;
            this.y = scalar;
            return this;
        }
        setX(x) {
            this.x = x;
            return this;
        }
        setY(y) {
            this.y = y;
            return this;
        }
        setComponent(index, value) {
            switch (index) {
                case 0: this.x = value; break;
                case 1: this.y = value; break;
                default: throw new Error('index is out of range: ' + index);
            }
            return this;
        }
        getComponent(index) {
            switch (index) {
                case 0: return this.x;
                case 1: return this.y;
                default: throw new Error('index is out of range: ' + index);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y);
        }
        copy(v) {
            this.x = v.x;
            this.y = v.y;
            return this;
        }
        add(v) {
            this.x += v.x;
            this.y += v.y;
            return this;
        }
        addScalar(s) {
            this.x += s;
            this.y += s;
            return this;
        }
        addVectors(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this;
        }
        addScaledVector(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            return this;
        }
        sub(v) {
            this.x -= v.x;
            this.y -= v.y;
            return this;
        }
        subScalar(s) {
            this.x -= s;
            this.y -= s;
            return this;
        }
        subVectors(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this;
        }
        multiply(v) {
            this.x *= v.x;
            this.y *= v.y;
            return this;
        }
        multiplyScalar(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            return this;
        }
        divide(v) {
            this.x /= v.x;
            this.y /= v.y;
            return this;
        }
        divideScalar(scalar) {
            return this.multiplyScalar(1 / scalar);
        }
        applyMatrix3(m) {
            const x = this.x, y = this.y;
            const e = m.elements;
            this.x = e[0] * x + e[3] * y + e[6];
            this.y = e[1] * x + e[4] * y + e[7];
            return this;
        }
        min(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            return this;
        }
        max(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            return this;
        }
        clamp(min, max) {
            // assumes min < max, componentwise
            this.x = clamp(this.x, min.x, max.x);
            this.y = clamp(this.y, min.y, max.y);
            return this;
        }
        clampScalar(minVal, maxVal) {
            this.x = clamp(this.x, minVal, maxVal);
            this.y = clamp(this.y, minVal, maxVal);
            return this;
        }
        clampLength(min, max) {
            const length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));
        }
        floor() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
        }
        ceil() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
        }
        round() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        }
        roundToZero() {
            this.x = Math.trunc(this.x);
            this.y = Math.trunc(this.y);
            return this;
        }
        negate() {
            this.x = - this.x;
            this.y = - this.y;
            return this;
        }
        dot(v) {
            return this.x * v.x + this.y * v.y;
        }
        cross(v) {
            return this.x * v.y - this.y * v.x;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        angle() {
            const angle = Math.atan2(- this.y, - this.x) + Math.PI;
            return angle;
        }
        angleTo(v) {
            const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
            if (denominator === 0) return Math.PI / 2;
            const theta = this.dot(v) / denominator;
            // clamp, to handle numerical problems
            return Math.acos(clamp$1(theta, -1, 1));
        }
        distanceTo(v) {
            return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
            const dx = this.x - v.x, dy = this.y - v.y;
            return dx * dx + dy * dy;
        }
        manhattanDistanceTo(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        }
        setLength(length) {
            return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            return this;
        }
        lerpVectors(v1, v2, alpha) {
            this.x = v1.x + (v2.x - v1.x) * alpha;
            this.y = v1.y + (v2.y - v1.y) * alpha;
            return this;
        }
        equals(v) {
            return ((v.x === this.x) && (v.y === this.y));
        }
        fromArray(array, offset = 0) {
            this.x = array[offset];
            this.y = array[offset + 1];
            return this;
        }
        toArray(array = [], offset = 0) {
            array[offset] = this.x;
            array[offset + 1] = this.y;
            return array;
        }
        fromBufferAttribute(attribute, index) {
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            return this;
        }
        rotateAround(center, angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            const x = this.x - center.x;
            const y = this.y - center.y;
            this.x = x * c - y * s + center.x;
            this.y = x * s + y * c + center.y;
            return this;
        }
        random() {
            this.x = Math.random();
            this.y = Math.random();
            return this;
        }
        *[Symbol.iterator]() {
            yield this.x;
            yield this.y;
        }
    }
    class Quaternion {
        constructor(x = 0, y = 0, z = 0, w = 1) {
            this.isQuaternion = true;
            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;
        }
        static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
            // fuzz-free, array-based Quaternion SLERP operation
            let x0 = src0[srcOffset0 + 0],
                y0 = src0[srcOffset0 + 1],
                z0 = src0[srcOffset0 + 2],
                w0 = src0[srcOffset0 + 3];
            const x1 = src1[srcOffset1 + 0],
                y1 = src1[srcOffset1 + 1],
                z1 = src1[srcOffset1 + 2],
                w1 = src1[srcOffset1 + 3];
            if (t === 0) {
                dst[dstOffset + 0] = x0;
                dst[dstOffset + 1] = y0;
                dst[dstOffset + 2] = z0;
                dst[dstOffset + 3] = w0;
                return;
            }
            if (t === 1) {
                dst[dstOffset + 0] = x1;
                dst[dstOffset + 1] = y1;
                dst[dstOffset + 2] = z1;
                dst[dstOffset + 3] = w1;
                return;
            }
            if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                let s = 1 - t;
                const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
                    dir = (cos >= 0 ? 1 : -1),
                    sqrSin = 1 - cos * cos;
                // Skip the Slerp for tiny steps to avoid numeric problems:
                if (sqrSin > Number.EPSILON) {
                    const sin = Math.sqrt(sqrSin),
                        len = Math.atan2(sin, cos * dir);
                    s = Math.sin(s * len) / sin;
                    t = Math.sin(t * len) / sin;
                }
                const tDir = t * dir;
                x0 = x0 * s + x1 * tDir;
                y0 = y0 * s + y1 * tDir;
                z0 = z0 * s + z1 * tDir;
                w0 = w0 * s + w1 * tDir;
                // Normalize in case we just did a lerp:
                if (s === 1 - t) {
                    const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                    x0 *= f;
                    y0 *= f;
                    z0 *= f;
                    w0 *= f;
                }
            }
            dst[dstOffset] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
        }
        static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
            const x0 = src0[srcOffset0];
            const y0 = src0[srcOffset0 + 1];
            const z0 = src0[srcOffset0 + 2];
            const w0 = src0[srcOffset0 + 3];
            const x1 = src1[srcOffset1];
            const y1 = src1[srcOffset1 + 1];
            const z1 = src1[srcOffset1 + 2];
            const w1 = src1[srcOffset1 + 3];
            dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
            dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
            dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
            dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
            return dst;
        }
        get x() {
            return this._x;
        }
        set x(value) {
            this._x = value;
            this._onChangeCallback();
        }
        get y() {
            return this._y;
        }
        set y(value) {
            this._y = value;
            this._onChangeCallback();
        }
        get z() {
            return this._z;
        }
        set z(value) {
            this._z = value;
            this._onChangeCallback();
        }
        get w() {
            return this._w;
        }
        set w(value) {
            this._w = value;
            this._onChangeCallback();
        }
        set(x, y, z, w) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;
            this._onChangeCallback();
            return this;
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(quaternion) {
            this._x = quaternion.x;
            this._y = quaternion.y;
            this._z = quaternion.z;
            this._w = quaternion.w;
            this._onChangeCallback();
            return this;
        }
        setFromEuler(euler, update = true) {
            const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
            // http://www.mathworks.com/matlabcentral/fileexchange/
            // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //	content/SpinCalc.m
            const cos = Math.cos;
            const sin = Math.sin;
            const c1 = cos(x / 2);
            const c2 = cos(y / 2);
            const c3 = cos(z / 2);
            const s1 = sin(x / 2);
            const s2 = sin(y / 2);
            const s3 = sin(z / 2);
            switch (order) {
                case 'XYZ':
                    this._x = s1 * c2 * c3 + c1 * s2 * s3;
                    this._y = c1 * s2 * c3 - s1 * c2 * s3;
                    this._z = c1 * c2 * s3 + s1 * s2 * c3;
                    this._w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 'YXZ':
                    this._x = s1 * c2 * c3 + c1 * s2 * s3;
                    this._y = c1 * s2 * c3 - s1 * c2 * s3;
                    this._z = c1 * c2 * s3 - s1 * s2 * c3;
                    this._w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                case 'ZXY':
                    this._x = s1 * c2 * c3 - c1 * s2 * s3;
                    this._y = c1 * s2 * c3 + s1 * c2 * s3;
                    this._z = c1 * c2 * s3 + s1 * s2 * c3;
                    this._w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 'ZYX':
                    this._x = s1 * c2 * c3 - c1 * s2 * s3;
                    this._y = c1 * s2 * c3 + s1 * c2 * s3;
                    this._z = c1 * c2 * s3 - s1 * s2 * c3;
                    this._w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                case 'YZX':
                    this._x = s1 * c2 * c3 + c1 * s2 * s3;
                    this._y = c1 * s2 * c3 + s1 * c2 * s3;
                    this._z = c1 * c2 * s3 - s1 * s2 * c3;
                    this._w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 'XZY':
                    this._x = s1 * c2 * c3 - c1 * s2 * s3;
                    this._y = c1 * s2 * c3 - s1 * c2 * s3;
                    this._z = c1 * c2 * s3 + s1 * s2 * c3;
                    this._w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                default:
                    console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
            }
            if (update === true) this._onChangeCallback();
            return this;
        }
        setFromAxisAngle(axis, angle) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
            const halfAngle = angle / 2, s = Math.sin(halfAngle);
            this._x = axis.x * s;
            this._y = axis.y * s;
            this._z = axis.z * s;
            this._w = Math.cos(halfAngle);
            this._onChangeCallback();
            return this;
        }
        setFromRotationMatrix(m) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            const te = m.elements,
                m11 = te[0], m12 = te[4], m13 = te[8],
                m21 = te[1], m22 = te[5], m23 = te[9],
                m31 = te[2], m32 = te[6], m33 = te[10],
                trace = m11 + m22 + m33;
            if (trace > 0) {
                const s = 0.5 / Math.sqrt(trace + 1.0);
                this._w = 0.25 / s;
                this._x = (m32 - m23) * s;
                this._y = (m13 - m31) * s;
                this._z = (m21 - m12) * s;
            } else if (m11 > m22 && m11 > m33) {
                const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                this._w = (m32 - m23) / s;
                this._x = 0.25 * s;
                this._y = (m12 + m21) / s;
                this._z = (m13 + m31) / s;
            } else if (m22 > m33) {
                const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                this._w = (m13 - m31) / s;
                this._x = (m12 + m21) / s;
                this._y = 0.25 * s;
                this._z = (m23 + m32) / s;
            } else {
                const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                this._w = (m21 - m12) / s;
                this._x = (m13 + m31) / s;
                this._y = (m23 + m32) / s;
                this._z = 0.25 * s;
            }
            this._onChangeCallback();
            return this;
        }
        setFromUnitVectors(vFrom, vTo) {
            // assumes direction vectors vFrom and vTo are normalized
            let r = vFrom.dot(vTo) + 1;
            if (r < 1e-8) { // the epsilon value has been discussed in #31286
                // vFrom and vTo point in opposite directions
                r = 0;
                if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                    this._x = - vFrom.y;
                    this._y = vFrom.x;
                    this._z = 0;
                    this._w = r;
                } else {
                    this._x = 0;
                    this._y = - vFrom.z;
                    this._z = vFrom.y;
                    this._w = r;
                }
            } else {
                // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
                this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
                this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
                this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
                this._w = r;
            }
            return this.normalize();
        }
        angleTo(q) {
            return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
        }
        rotateTowards(q, step) {
            const angle = this.angleTo(q);
            if (angle === 0) return this;
            const t = Math.min(1, step / angle);
            this.slerp(q, t);
            return this;
        }
        identity() {
            return this.set(0, 0, 0, 1);
        }
        invert() {
            return this.conjugate();
        }
        conjugate() {
            this._x *= -1;
            this._y *= -1;
            this._z *= -1;
            this._onChangeCallback();
            return this;
        }
        dot(v) {
            return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
            let l = this.length();
            if (l === 0) {
                this._x = 0;
                this._y = 0;
                this._z = 0;
                this._w = 1;
            } else {
                l = 1 / l;
                this._x = this._x * l;
                this._y = this._y * l;
                this._z = this._z * l;
                this._w = this._w * l;
            }
            this._onChangeCallback();
            return this;
        }
        multiply(q) {
            return this.multiplyQuaternions(this, q);
        }
        premultiply(q) {
            return this.multiplyQuaternions(q, this);
        }
        multiplyQuaternions(a, b) {
            // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
            const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
            const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
            this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
            this._onChangeCallback();
            return this;
        }
        slerp(qb, t) {
            if (t === 0) return this;
            if (t === 1) return this.copy(qb);
            const x = this._x, y = this._y, z = this._z, w = this._w;
            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
            if (cosHalfTheta < 0) {
                this._w = - qb._w;
                this._x = - qb._x;
                this._y = - qb._y;
                this._z = - qb._z;
                cosHalfTheta = - cosHalfTheta;
            } else {
                this.copy(qb);
            }
            if (cosHalfTheta >= 1.0) {
                this._w = w;
                this._x = x;
                this._y = y;
                this._z = z;
                return this;
            }
            const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
            if (sqrSinHalfTheta <= Number.EPSILON) {
                const s = 1 - t;
                this._w = s * w + t * this._w;
                this._x = s * x + t * this._x;
                this._y = s * y + t * this._y;
                this._z = s * z + t * this._z;
                this.normalize(); // normalize calls _onChangeCallback()
                return this;
            }
            const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
            const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
            const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
                ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            this._w = (w * ratioA + this._w * ratioB);
            this._x = (x * ratioA + this._x * ratioB);
            this._y = (y * ratioA + this._y * ratioB);
            this._z = (z * ratioA + this._z * ratioB);
            this._onChangeCallback();
            return this;
        }
        slerpQuaternions(qa, qb, t) {
            return this.copy(qa).slerp(qb, t);
        }
        random() {
            // Ken Shoemake
            // Uniform random rotations
            // D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.
            const theta1 = 2 * Math.PI * Math.random();
            const theta2 = 2 * Math.PI * Math.random();
            const x0 = Math.random();
            const r1 = Math.sqrt(1 - x0);
            const r2 = Math.sqrt(x0);
            return this.set(
                r1 * Math.sin(theta1),
                r1 * Math.cos(theta1),
                r2 * Math.sin(theta2),
                r2 * Math.cos(theta2),
            );
        }
        equals(quaternion) {
            return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
        }
        fromArray(array, offset = 0) {
            this._x = array[offset];
            this._y = array[offset + 1];
            this._z = array[offset + 2];
            this._w = array[offset + 3];
            this._onChangeCallback();
            return this;
        }
        toArray(array = [], offset = 0) {
            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._w;
            return array;
        }
        fromBufferAttribute(attribute, index) {
            this._x = attribute.getX(index);
            this._y = attribute.getY(index);
            this._z = attribute.getZ(index);
            this._w = attribute.getW(index);
            this._onChangeCallback();
            return this;
        }
        toJSON() {
            return this.toArray();
        }
        _onChange(callback) {
            this._onChangeCallback = callback;
            return this;
        }
        _onChangeCallback() { }
        *[Symbol.iterator]() {
            yield this._x;
            yield this._y;
            yield this._z;
            yield this._w;
        }
    }
    class Vector3 {
        constructor(x = 0, y = 0, z = 0) {
            Vector3.prototype.isVector3 = true;
            this.x = x;
            this.y = y;
            this.z = z;
        }
        set(x, y, z) {
            if (z === undefined) z = this.z; // sprite.scale.set(x,y)
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        setScalar(scalar) {
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            return this;
        }
        setX(x) {
            this.x = x;
            return this;
        }
        setY(y) {
            this.y = y;
            return this;
        }
        setZ(z) {
            this.z = z;
            return this;
        }
        setComponent(index, value) {
            switch (index) {
                case 0: this.x = value; break;
                case 1: this.y = value; break;
                case 2: this.z = value; break;
                default: throw new Error('index is out of range: ' + index);
            }
            return this;
        }
        getComponent(index) {
            switch (index) {
                case 0: return this.x;
                case 1: return this.y;
                case 2: return this.z;
                default: throw new Error('index is out of range: ' + index);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z);
        }
        copy(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            return this;
        }
        add(v) {
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            return this;
        }
        addScalar(s) {
            this.x += s;
            this.y += s;
            this.z += s;
            return this;
        }
        addVectors(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this;
        }
        addScaledVector(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            return this;
        }
        sub(v) {
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            return this;
        }
        subScalar(s) {
            this.x -= s;
            this.y -= s;
            this.z -= s;
            return this;
        }
        subVectors(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this;
        }
        multiply(v) {
            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;
            return this;
        }
        multiplyScalar(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            return this;
        }
        multiplyVectors(a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            return this;
        }
        applyEuler(euler) {
            return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
        }
        applyAxisAngle(axis, angle) {
            return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
        }
        applyMatrix3(m) {
            const x = this.x, y = this.y, z = this.z;
            const e = m.elements;
            this.x = e[0] * x + e[3] * y + e[6] * z;
            this.y = e[1] * x + e[4] * y + e[7] * z;
            this.z = e[2] * x + e[5] * y + e[8] * z;
            return this;
        }
        applyNormalMatrix(m) {
            return this.applyMatrix3(m).normalize();
        }
        applyMatrix4(m) {
            const x = this.x, y = this.y, z = this.z;
            const e = m.elements;
            const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
            this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
            this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
            this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
            return this;
        }
        applyQuaternion(q) {
            // quaternion q is assumed to have unit length
            const vx = this.x, vy = this.y, vz = this.z;
            const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
            // t = 2 * cross( q.xyz, v );
            const tx = 2 * (qy * vz - qz * vy);
            const ty = 2 * (qz * vx - qx * vz);
            const tz = 2 * (qx * vy - qy * vx);
            // v + q.w * t + cross( q.xyz, t );
            this.x = vx + qw * tx + qy * tz - qz * ty;
            this.y = vy + qw * ty + qz * tx - qx * tz;
            this.z = vz + qw * tz + qx * ty - qy * tx;
            return this;
        }
        project(camera) {
            return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
        }
        unproject(camera) {
            return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
        }
        transformDirection(m) {
            // input: THREE.Matrix4 affine matrix
            // vector interpreted as a direction
            const x = this.x, y = this.y, z = this.z;
            const e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z;
            this.y = e[1] * x + e[5] * y + e[9] * z;
            this.z = e[2] * x + e[6] * y + e[10] * z;
            return this.normalize();
        }
        divide(v) {
            this.x /= v.x;
            this.y /= v.y;
            this.z /= v.z;
            return this;
        }
        divideScalar(scalar) {
            return this.multiplyScalar(1 / scalar);
        }
        min(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            return this;
        }
        max(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            return this;
        }
        clamp(min, max) {
            // assumes min < max, componentwise
            this.x = clamp(this.x, min.x, max.x);
            this.y = clamp(this.y, min.y, max.y);
            this.z = clamp(this.z, min.z, max.z);
            return this;
        }
        clampScalar(minVal, maxVal) {
            this.x = clamp(this.x, minVal, maxVal);
            this.y = clamp(this.y, minVal, maxVal);
            this.z = clamp(this.z, minVal, maxVal);
            return this;
        }
        clampLength(min, max) {
            const length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));
        }
        floor() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            return this;
        }
        ceil() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            return this;
        }
        round() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            return this;
        }
        roundToZero() {
            this.x = Math.trunc(this.x);
            this.y = Math.trunc(this.y);
            this.z = Math.trunc(this.z);
            return this;
        }
        negate() {
            this.x = - this.x;
            this.y = - this.y;
            this.z = - this.z;
            return this;
        }
        dot(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        }
        // TODO lengthSquared?
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
            return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            return this;
        }
        lerpVectors(v1, v2, alpha) {
            this.x = v1.x + (v2.x - v1.x) * alpha;
            this.y = v1.y + (v2.y - v1.y) * alpha;
            this.z = v1.z + (v2.z - v1.z) * alpha;
            return this;
        }
        cross(v) {
            return this.crossVectors(this, v);
        }
        crossVectors(a, b) {
            const ax = a.x, ay = a.y, az = a.z;
            const bx = b.x, by = b.y, bz = b.z;
            this.x = ay * bz - az * by;
            this.y = az * bx - ax * bz;
            this.z = ax * by - ay * bx;
            return this;
        }
        projectOnVector(v) {
            const denominator = v.lengthSq();
            if (denominator === 0) return this.set(0, 0, 0);
            const scalar = v.dot(this) / denominator;
            return this.copy(v).multiplyScalar(scalar);
        }
        projectOnPlane(planeNormal) {
            _vector$c.copy(this).projectOnVector(planeNormal);
            return this.sub(_vector$c);
        }
        reflect(normal) {
            return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
        }
        angleTo(v) {
            const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
            if (denominator === 0) return Math.PI / 2;
            const theta = this.dot(v) / denominator;
            // clamp, to handle numerical problems
            return Math.acos(clamp$1(theta, -1, 1));
        }
        distanceTo(v) {
            return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
            const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
            return dx * dx + dy * dy + dz * dz;
        }
        manhattanDistanceTo(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        }
        setFromSpherical(s) {
            return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
        }
        setFromSphericalCoords(radius, phi, theta) {
            const sinPhiRadius = Math.sin(phi) * radius;
            this.x = sinPhiRadius * Math.sin(theta);
            this.y = Math.cos(phi) * radius;
            this.z = sinPhiRadius * Math.cos(theta);
            return this;
        }
        setFromCylindrical(c) {
            return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
        }
        setFromCylindricalCoords(radius, theta, y) {
            this.x = radius * Math.sin(theta);
            this.y = y;
            this.z = radius * Math.cos(theta);
            return this;
        }
        setFromMatrixPosition(m) {
            const e = m.elements;
            this.x = e[12];
            this.y = e[13];
            this.z = e[14];
            return this;
        }
        setFromMatrixScale(m) {
            const sx = this.setFromMatrixColumn(m, 0).length();
            const sy = this.setFromMatrixColumn(m, 1).length();
            const sz = this.setFromMatrixColumn(m, 2).length();
            this.x = sx;
            this.y = sy;
            this.z = sz;
            return this;
        }
        setFromMatrixColumn(m, index) {
            return this.fromArray(m.elements, index * 4);
        }
        setFromMatrix3Column(m, index) {
            return this.fromArray(m.elements, index * 3);
        }
        setFromEuler(e) {
            this.x = e._x;
            this.y = e._y;
            this.z = e._z;
            return this;
        }
        setFromColor(c) {
            this.x = c.r;
            this.y = c.g;
            this.z = c.b;
            return this;
        }
        equals(v) {
            return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
        }
        fromArray(array, offset = 0) {
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            return this;
        }
        toArray(array = [], offset = 0) {
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            return array;
        }
        fromBufferAttribute(attribute, index) {
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            this.z = attribute.getZ(index);
            return this;
        }
        random() {
            this.x = Math.random();
            this.y = Math.random();
            this.z = Math.random();
            return this;
        }
        randomDirection() {
            // https://mathworld.wolfram.com/SpherePointPicking.html
            const theta = Math.random() * Math.PI * 2;
            const u = Math.random() * 2 - 1;
            const c = Math.sqrt(1 - u * u);
            this.x = c * Math.cos(theta);
            this.y = u;
            this.z = c * Math.sin(theta);
            return this;
        }
        *[Symbol.iterator]() {
            yield this.x;
            yield this.y;
            yield this.z;
        }
    }
    const _vector$c = /*@__PURE__*/ new Vector3();
    const _quaternion$4 = /*@__PURE__*/ new Quaternion();
    class Matrix3 {
        constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            Matrix3.prototype.isMatrix3 = true;
            this.elements = [
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ];
            if (n11 !== undefined) {
                this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
            }
        }
        set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            const te = this.elements;
            te[0] = n11; te[1] = n21; te[2] = n31;
            te[3] = n12; te[4] = n22; te[5] = n32;
            te[6] = n13; te[7] = n23; te[8] = n33;
            return this;
        }
        identity() {
            this.set(
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            );
            return this;
        }
        copy(m) {
            const te = this.elements;
            const me = m.elements;
            te[0] = me[0]; te[1] = me[1]; te[2] = me[2];
            te[3] = me[3]; te[4] = me[4]; te[5] = me[5];
            te[6] = me[6]; te[7] = me[7]; te[8] = me[8];
            return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
            xAxis.setFromMatrix3Column(this, 0);
            yAxis.setFromMatrix3Column(this, 1);
            zAxis.setFromMatrix3Column(this, 2);
            return this;
        }
        setFromMatrix4(m) {
            const me = m.elements;
            this.set(
                me[0], me[4], me[8],
                me[1], me[5], me[9],
                me[2], me[6], me[10]
            );
            return this;
        }
        multiply(m) {
            return this.multiplyMatrices(this, m);
        }
        premultiply(m) {
            return this.multiplyMatrices(m, this);
        }
        multiplyMatrices(a, b) {
            const ae = a.elements;
            const be = b.elements;
            const te = this.elements;
            const a11 = ae[0], a12 = ae[3], a13 = ae[6];
            const a21 = ae[1], a22 = ae[4], a23 = ae[7];
            const a31 = ae[2], a32 = ae[5], a33 = ae[8];
            const b11 = be[0], b12 = be[3], b13 = be[6];
            const b21 = be[1], b22 = be[4], b23 = be[7];
            const b31 = be[2], b32 = be[5], b33 = be[8];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31;
            te[3] = a11 * b12 + a12 * b22 + a13 * b32;
            te[6] = a11 * b13 + a12 * b23 + a13 * b33;
            te[1] = a21 * b11 + a22 * b21 + a23 * b31;
            te[4] = a21 * b12 + a22 * b22 + a23 * b32;
            te[7] = a21 * b13 + a22 * b23 + a23 * b33;
            te[2] = a31 * b11 + a32 * b21 + a33 * b31;
            te[5] = a31 * b12 + a32 * b22 + a33 * b32;
            te[8] = a31 * b13 + a32 * b23 + a33 * b33;
            return this;
        }
        multiplyScalar(s) {
            const te = this.elements;
            te[0] *= s; te[3] *= s; te[6] *= s;
            te[1] *= s; te[4] *= s; te[7] *= s;
            te[2] *= s; te[5] *= s; te[8] *= s;
            return this;
        }
        determinant() {
            const te = this.elements;
            const a = te[0], b = te[1], c = te[2],
                d = te[3], e = te[4], f = te[5],
                g = te[6], h = te[7], i = te[8];
            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        }
        invert() {
            const te = this.elements,
                n11 = te[0], n21 = te[1], n31 = te[2],
                n12 = te[3], n22 = te[4], n32 = te[5],
                n13 = te[6], n23 = te[7], n33 = te[8],
                t11 = n33 * n22 - n32 * n23,
                t12 = n32 * n13 - n33 * n12,
                t13 = n23 * n12 - n22 * n13,
                det = n11 * t11 + n21 * t12 + n31 * t13;
            if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n31 * n23 - n33 * n21) * detInv;
            te[2] = (n32 * n21 - n31 * n22) * detInv;
            te[3] = t12 * detInv;
            te[4] = (n33 * n11 - n31 * n13) * detInv;
            te[5] = (n31 * n12 - n32 * n11) * detInv;
            te[6] = t13 * detInv;
            te[7] = (n21 * n13 - n23 * n11) * detInv;
            te[8] = (n22 * n11 - n21 * n12) * detInv;
            return this;
        }
        transpose() {
            let tmp;
            const m = this.elements;
            tmp = m[1]; m[1] = m[3]; m[3] = tmp;
            tmp = m[2]; m[2] = m[6]; m[6] = tmp;
            tmp = m[5]; m[5] = m[7]; m[7] = tmp;
            return this;
        }
        getNormalMatrix(matrix4) {
            return this.setFromMatrix4(matrix4).invert().transpose();
        }
        transposeIntoArray(r) {
            const m = this.elements;
            r[0] = m[0];
            r[1] = m[3];
            r[2] = m[6];
            r[3] = m[1];
            r[4] = m[4];
            r[5] = m[7];
            r[6] = m[2];
            r[7] = m[5];
            r[8] = m[8];
            return this;
        }
        setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
            const c = Math.cos(rotation);
            const s = Math.sin(rotation);
            this.set(
                sx * c, sx * s, - sx * (c * cx + s * cy) + cx + tx,
                - sy * s, sy * c, - sy * (- s * cx + c * cy) + cy + ty,
                0, 0, 1
            );
            return this;
        }
        scale(sx, sy) {
            this.premultiply(_m3.makeScale(sx, sy));
            return this;
        }
        rotate(theta) {
            this.premultiply(_m3.makeRotation(- theta));
            return this;
        }
        translate(tx, ty) {
            this.premultiply(_m3.makeTranslation(tx, ty));
            return this;
        }
        // for 2D Transforms
        makeTranslation(x, y) {
            if (x.isVector2) {
                this.set(
                    1, 0, x.x,
                    0, 1, x.y,
                    0, 0, 1
                );
            } else {
                this.set(
                    1, 0, x,
                    0, 1, y,
                    0, 0, 1
                );
            }
            return this;
        }
        makeRotation(theta) {
            // counterclockwise
            const c = Math.cos(theta);
            const s = Math.sin(theta);
            this.set(
                c, - s, 0,
                s, c, 0,
                0, 0, 1
            );
            return this;
        }
        makeScale(x, y) {
            this.set(
                x, 0, 0,
                0, y, 0,
                0, 0, 1
            );
            return this;
        }
        equals(matrix) {
            const te = this.elements;
            const me = matrix.elements;
            for (let i = 0; i < 9; i++) {
                if (te[i] !== me[i]) return false;
            }
            return true;
        }
        fromArray(array, offset = 0) {
            for (let i = 0; i < 9; i++) {
                this.elements[i] = array[i + offset];
            }
            return this;
        }
        toArray(array = [], offset = 0) {
            const te = this.elements;
            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];
            return array;
        }
        clone() {
            return new this.constructor().fromArray(this.elements);
        }
    }
    const _m3 = /*@__PURE__*/ new Matrix3();
    function arrayNeedsUint32(array) {
        // assumes larger values usually on last
        for (let i = array.length - 1; i >= 0; --i) {
            if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
        }
        return false;
    }
    const TYPED_ARRAYS = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: Uint8ClampedArray,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    function getTypedArray(type, buffer) {
        return new TYPED_ARRAYS[type](buffer);
    }
    function createElementNS(name) {
        return document.createElementNS('http://www.w3.org/1999/xhtml', name);
    }
    function createCanvasElement() {
        const canvas = createElementNS('canvas');
        canvas.style.display = 'block';
        return canvas;
    }
    const _cache = {};
    function warnOnce(message) {
        if (message in _cache) return;
        _cache[message] = true;
        console.warn(message);
    }
    function probeAsync(gl, sync, interval) {
        return new Promise(function (resolve, reject) {
            function probe() {
                switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                    case gl.WAIT_FAILED:
                        reject();
                        break;
                    case gl.TIMEOUT_EXPIRED:
                        setTimeout(probe, interval);
                        break;
                    default:
                        resolve();
                }
            }
            setTimeout(probe, interval);
        });
    }
    const LINEAR_REC709_TO_XYZ = /*@__PURE__*/ new Matrix3().set(
        0.4123908, 0.3575843, 0.1804808,
        0.2126390, 0.7151687, 0.0721923,
        0.0193308, 0.1191948, 0.9505322
    );
    const XYZ_TO_LINEAR_REC709 = /*@__PURE__*/ new Matrix3().set(
        3.2409699, -1.5373832, -0.4986108,
        -0.9692436, 1.8759675, 0.0415551,
        0.0556301, -0.203977, 1.0569715
    );
    function createColorManagement() {
        const ColorManagement = {
            enabled: true,
            workingColorSpace: LinearSRGBColorSpace,
            spaces: {},
            convert: function (color, sourceColorSpace, targetColorSpace) {
                if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
                    return color;
                }
                if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {
                    color.r = SRGBToLinear(color.r);
                    color.g = SRGBToLinear(color.g);
                    color.b = SRGBToLinear(color.b);
                }
                if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {
                    color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);
                    color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);
                }
                if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {
                    color.r = LinearToSRGB(color.r);
                    color.g = LinearToSRGB(color.g);
                    color.b = LinearToSRGB(color.b);
                }
                return color;
            },
            workingToColorSpace: function (color, targetColorSpace) {
                return this.convert(color, this.workingColorSpace, targetColorSpace);
            },
            colorSpaceToWorking: function (color, sourceColorSpace) {
                return this.convert(color, sourceColorSpace, this.workingColorSpace);
            },
            getPrimaries: function (colorSpace) {
                return this.spaces[colorSpace].primaries;
            },
            getTransfer: function (colorSpace) {
                if (colorSpace === NoColorSpace) return LinearTransfer;
                return this.spaces[colorSpace].transfer;
            },
            getLuminanceCoefficients: function (target, colorSpace = this.workingColorSpace) {
                return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);
            },
            define: function (colorSpaces) {
                Object.assign(this.spaces, colorSpaces);
            },
            // Internal APIs
            _getMatrix: function (targetMatrix, sourceColorSpace, targetColorSpace) {
                return targetMatrix
                    .copy(this.spaces[sourceColorSpace].toXYZ)
                    .multiply(this.spaces[targetColorSpace].fromXYZ);
            },
            _getDrawingBufferColorSpace: function (colorSpace) {
                return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;
            },
            _getUnpackColorSpace: function (colorSpace = this.workingColorSpace) {
                return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;
            },
            // Deprecated
            fromWorkingColorSpace: function (color, targetColorSpace) {
                warnOnce('THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().'); // @deprecated, r177
                return ColorManagement.workingToColorSpace(color, targetColorSpace);
            },
            toWorkingColorSpace: function (color, sourceColorSpace) {
                warnOnce('THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().'); // @deprecated, r177
                return ColorManagement.colorSpaceToWorking(color, sourceColorSpace);
            },
        };

        const REC709_PRIMARIES = [0.640, 0.330, 0.300, 0.600, 0.150, 0.060];
        const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];
        const D65 = [0.3127, 0.3290];
        ColorManagement.define({
            [LinearSRGBColorSpace]: {
                primaries: REC709_PRIMARIES,
                whitePoint: D65,
                transfer: LinearTransfer,
                toXYZ: LINEAR_REC709_TO_XYZ,
                fromXYZ: XYZ_TO_LINEAR_REC709,
                luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
                workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
                outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
            },
            [SRGBColorSpace]: {
                primaries: REC709_PRIMARIES,
                whitePoint: D65,
                transfer: SRGBTransfer,
                toXYZ: LINEAR_REC709_TO_XYZ,
                fromXYZ: XYZ_TO_LINEAR_REC709,
                luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
                outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
            },
        });
        return ColorManagement;
    }
    const ColorManagement = /*@__PURE__*/ createColorManagement();
    function SRGBToLinear(c) {
        return (c < 0.04045) ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
    }
    function LinearToSRGB(c) {
        return (c < 0.0031308) ? c * 12.92 : 1.055 * (Math.pow(c, 0.41666)) - 0.055;
    }
    let _canvas;
    class ImageUtils {
        static getDataURL(image, type = 'image/png') {
            if (/^data:/i.test(image.src)) {
                return image.src;
            }
            if (typeof HTMLCanvasElement === 'undefined') {
                return image.src;
            }
            let canvas;
            if (image instanceof HTMLCanvasElement) {
                canvas = image;
            } else {
                if (_canvas === undefined) _canvas = createElementNS('canvas');
                _canvas.width = image.width;
                _canvas.height = image.height;
                const context = _canvas.getContext('2d');
                if (image instanceof ImageData) {
                    context.putImageData(image, 0, 0);
                } else {
                    context.drawImage(image, 0, 0, image.width, image.height);
                }
                canvas = _canvas;
            }
            return canvas.toDataURL(type);
        }
        static sRGBToLinear(image) {
            if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||
                (typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||
                (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {
                const canvas = createElementNS('canvas');
                canvas.width = image.width;
                canvas.height = image.height;
                const context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, image.width, image.height);
                const imageData = context.getImageData(0, 0, image.width, image.height);
                const data = imageData.data;
                for (let i = 0; i < data.length; i++) {
                    data[i] = SRGBToLinear(data[i] / 255) * 255;
                }
                context.putImageData(imageData, 0, 0);
                return canvas;
            } else if (image.data) {
                const data = image.data.slice(0);
                for (let i = 0; i < data.length; i++) {
                    if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
                        data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
                    } else {
                        // assuming float
                        data[i] = SRGBToLinear(data[i]);
                    }
                }
                return {
                    data: data,
                    width: image.width,
                    height: image.height
                };
            } else {
                console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');
                return image;
            }
        }
    }
    let _sourceId = 0;
    class Source {
        constructor(data = null) {
            this.isSource = true;
            Object.defineProperty(this, 'id', { value: _sourceId++ });
            this.uuid = generateUUID();
            this.data = data;
            this.dataReady = true;
            this.version = 0;
        }
        getSize(target) {
            const data = this.data;
            if (data instanceof HTMLVideoElement) {
                target.set(data.videoWidth, data.videoHeight, 0);
            } else if (data instanceof VideoFrame) {
                target.set(data.displayHeight, data.displayWidth, 0);
            } else if (data !== null) {
                target.set(data.width, data.height, data.depth || 0);
            } else {
                target.set(0, 0, 0);
            }
            return target;
        }
        set needsUpdate(value) {
            if (value === true) this.version++;
        }
        toJSON(meta) {
            const isRootObject = (meta === undefined || typeof meta === 'string');
            if (!isRootObject && meta.images[this.uuid] !== undefined) {
                return meta.images[this.uuid];
            }
            const output = {
                uuid: this.uuid,
                url: ''
            };
            const data = this.data;
            if (data !== null) {
                let url;
                if (Array.isArray(data)) {
                    // cube texture
                    url = [];
                    for (let i = 0, l = data.length; i < l; i++) {
                        if (data[i].isDataTexture) {
                            url.push(serializeImage(data[i].image));
                        } else {
                            url.push(serializeImage(data[i]));
                        }
                    }
                } else {
                    // texture
                    url = serializeImage(data);
                }
                output.url = url;
            }
            if (!isRootObject) {
                meta.images[this.uuid] = output;
            }
            return output;
        }
    }
    function serializeImage(image) {
        if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||
            (typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||
            (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {
            // default images
            return ImageUtils.getDataURL(image);
        } else {
            if (image.data) {
                // images of DataTexture
                return {
                    data: Array.from(image.data),
                    width: image.width,
                    height: image.height,
                    type: image.data.constructor.name
                };
            } else {
                console.warn('THREE.Texture: Unable to serialize Texture.');
                return {};
            }
        }
    }
    let _textureId = 0;
    const _tempVec3 = /*@__PURE__*/ new Vector3();
    class Texture extends EventDispatcher {
        constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
            super();
            this.isTexture = true;
            Object.defineProperty(this, 'id', { value: _textureId++ });
            this.uuid = generateUUID();
            this.name = '';
            this.source = new Source(image);
            this.mipmaps = [];
            this.mapping = mapping;
            this.channel = 0;
            this.wrapS = wrapS;
            this.wrapT = wrapT;
            this.magFilter = magFilter;
            this.minFilter = minFilter;
            this.anisotropy = anisotropy;
            this.format = format;
            this.internalFormat = null;
            this.type = type;
            this.offset = new Vector2(0, 0);
            this.repeat = new Vector2(1, 1);
            this.center = new Vector2(0, 0);
            this.rotation = 0;
            this.matrixAutoUpdate = true;
            this.matrix = new Matrix3();
            this.generateMipmaps = true;
            this.premultiplyAlpha = false;
            this.flipY = true;
            this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
            this.colorSpace = colorSpace;
            this.userData = {};
            this.updateRanges = [];
            this.version = 0;
            this.onUpdate = null;
            this.renderTarget = null;
            this.isRenderTargetTexture = false;
            this.isArrayTexture = image && image.depth && image.depth > 1 ? true : false;
            this.pmremVersion = 0;
        }
        get width() {
            return this.source.getSize(_tempVec3).x;
        }
        get height() {
            return this.source.getSize(_tempVec3).y;
        }
        get depth() {
            return this.source.getSize(_tempVec3).z;
        }
        get image() {
            return this.source.data;
        }
        set image(value = null) {
            this.source.data = value;
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        addUpdateRange(start, count) {
            this.updateRanges.push({ start, count });
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(source) {
            this.name = source.name;
            this.source = source.source;
            this.mipmaps = source.mipmaps.slice(0);
            this.mapping = source.mapping;
            this.channel = source.channel;
            this.wrapS = source.wrapS;
            this.wrapT = source.wrapT;
            this.magFilter = source.magFilter;
            this.minFilter = source.minFilter;
            this.anisotropy = source.anisotropy;
            this.format = source.format;
            this.internalFormat = source.internalFormat;
            this.type = source.type;
            this.offset.copy(source.offset);
            this.repeat.copy(source.repeat);
            this.center.copy(source.center);
            this.rotation = source.rotation;
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrix.copy(source.matrix);
            this.generateMipmaps = source.generateMipmaps;
            this.premultiplyAlpha = source.premultiplyAlpha;
            this.flipY = source.flipY;
            this.unpackAlignment = source.unpackAlignment;
            this.colorSpace = source.colorSpace;
            this.renderTarget = source.renderTarget;
            this.isRenderTargetTexture = source.isRenderTargetTexture;
            this.isArrayTexture = source.isArrayTexture;
            this.userData = JSON.parse(JSON.stringify(source.userData));
            this.needsUpdate = true;
            return this;
        }
        setValues(values) {
            for (const key in values) {
                const newValue = values[key];
                if (newValue === undefined) {
                    console.warn(`THREE.Texture.setValues(): parameter '${key}' has value of undefined.`);
                    continue;
                }
                const currentValue = this[key];
                if (currentValue === undefined) {
                    console.warn(`THREE.Texture.setValues(): property '${key}' does not exist.`);
                    continue;
                }
                if ((currentValue && newValue) && (currentValue.isVector2 && newValue.isVector2)) {
                    currentValue.copy(newValue);
                } else if ((currentValue && newValue) && (currentValue.isVector3 && newValue.isVector3)) {
                    currentValue.copy(newValue);
                } else if ((currentValue && newValue) && (currentValue.isMatrix3 && newValue.isMatrix3)) {
                    currentValue.copy(newValue);
                } else {
                    this[key] = newValue;
                }
            }
        }
        toJSON(meta) {
            const isRootObject = (meta === undefined || typeof meta === 'string');
            if (!isRootObject && meta.textures[this.uuid] !== undefined) {
                return meta.textures[this.uuid];
            }
            const output = {
                metadata: {
                    version: 4.7,
                    type: 'Texture',
                    generator: 'Texture.toJSON'
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(meta).uuid,
                mapping: this.mapping,
                channel: this.channel,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                internalFormat: this.internalFormat,
                type: this.type,
                colorSpace: this.colorSpace,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                generateMipmaps: this.generateMipmaps,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (Object.keys(this.userData).length > 0) output.userData = this.userData;
            if (!isRootObject) {
                meta.textures[this.uuid] = output;
            }
            return output;
        }
        dispose() {
            this.dispatchEvent({ type: 'dispose' });
        }
        transformUv(uv) {
            if (this.mapping !== UVMapping) return uv;
            uv.applyMatrix3(this.matrix);
            if (uv.x < 0 || uv.x > 1) {
                switch (this.wrapS) {
                    case RepeatWrapping:
                        uv.x = uv.x - Math.floor(uv.x);
                        break;
                    case ClampToEdgeWrapping:
                        uv.x = uv.x < 0 ? 0 : 1;
                        break;
                    case MirroredRepeatWrapping:
                        if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                            uv.x = Math.ceil(uv.x) - uv.x;
                        } else {
                            uv.x = uv.x - Math.floor(uv.x);
                        }
                        break;
                }
            }
            if (uv.y < 0 || uv.y > 1) {
                switch (this.wrapT) {
                    case RepeatWrapping:
                        uv.y = uv.y - Math.floor(uv.y);
                        break;
                    case ClampToEdgeWrapping:
                        uv.y = uv.y < 0 ? 0 : 1;
                        break;
                    case MirroredRepeatWrapping:
                        if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                            uv.y = Math.ceil(uv.y) - uv.y;
                        } else {
                            uv.y = uv.y - Math.floor(uv.y);
                        }
                        break;
                }
            }
            if (this.flipY) {
                uv.y = 1 - uv.y;
            }
            return uv;
        }
        set needsUpdate(value) {
            if (value === true) {
                this.version++;
                this.source.needsUpdate = true;
            }
        }
        set needsPMREMUpdate(value) {
            if (value === true) {
                this.pmremVersion++;
            }
        }
    }
    Texture.DEFAULT_IMAGE = null;
    Texture.DEFAULT_MAPPING = UVMapping;
    Texture.DEFAULT_ANISOTROPY = 1;
    class Vector4 {
        constructor(x = 0, y = 0, z = 0, w = 1) {
            Vector4.prototype.isVector4 = true;
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        get width() {
            return this.z;
        }
        set width(value) {
            this.z = value;
        }
        get height() {
            return this.w;
        }
        set height(value) {
            this.w = value;
        }
        set(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        }
        setScalar(scalar) {
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            this.w = scalar;
            return this;
        }
        setX(x) {
            this.x = x;
            return this;
        }
        setY(y) {
            this.y = y;
            return this;
        }
        setZ(z) {
            this.z = z;
            return this;
        }
        setW(w) {
            this.w = w;
            return this;
        }
        setComponent(index, value) {
            switch (index) {
                case 0: this.x = value; break;
                case 1: this.y = value; break;
                case 2: this.z = value; break;
                case 3: this.w = value; break;
                default: throw new Error('index is out of range: ' + index);
            }
            return this;
        }
        getComponent(index) {
            switch (index) {
                case 0: return this.x;
                case 1: return this.y;
                case 2: return this.z;
                case 3: return this.w;
                default: throw new Error('index is out of range: ' + index);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = (v.w !== undefined) ? v.w : 1;
            return this;
        }
        add(v) {
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            this.w += v.w;
            return this;
        }
        addScalar(s) {
            this.x += s;
            this.y += s;
            this.z += s;
            this.w += s;
            return this;
        }
        addVectors(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
            return this;
        }
        addScaledVector(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            this.w += v.w * s;
            return this;
        }
        sub(v) {
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            this.w -= v.w;
            return this;
        }
        subScalar(s) {
            this.x -= s;
            this.y -= s;
            this.z -= s;
            this.w -= s;
            return this;
        }
        subVectors(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
            return this;
        }
        multiply(v) {
            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;
            this.w *= v.w;
            return this;
        }
        multiplyScalar(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            this.w *= scalar;
            return this;
        }
        applyMatrix4(m) {
            const x = this.x, y = this.y, z = this.z, w = this.w;
            const e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
            this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
            return this;
        }
        divide(v) {
            this.x /= v.x;
            this.y /= v.y;
            this.z /= v.z;
            this.w /= v.w;
            return this;
        }
        divideScalar(scalar) {
            return this.multiplyScalar(1 / scalar);
        }
        setAxisAngleFromQuaternion(q) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
            // q is assumed to be normalized
            this.w = 2 * Math.acos(q.w);
            const s = Math.sqrt(1 - q.w * q.w);
            if (s < 0.0001) {
                this.x = 1;
                this.y = 0;
                this.z = 0;
            } else {
                this.x = q.x / s;
                this.y = q.y / s;
                this.z = q.z / s;
            }
            return this;
        }
        setAxisAngleFromRotationMatrix(m) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            let angle, x, y, z; // variables for result
            const epsilon = 0.01,		// margin to allow for rounding errors
                epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
                te = m.elements,
                m11 = te[0], m12 = te[4], m13 = te[8],
                m21 = te[1], m22 = te[5], m23 = te[9],
                m31 = te[2], m32 = te[6], m33 = te[10];
            if ((Math.abs(m12 - m21) < epsilon) &&
                (Math.abs(m13 - m31) < epsilon) &&
                (Math.abs(m23 - m32) < epsilon)) {
                // singularity found
                // first check for identity matrix which must have +1 for all terms
                // in leading diagonal and zero in other terms
                if ((Math.abs(m12 + m21) < epsilon2) &&
                    (Math.abs(m13 + m31) < epsilon2) &&
                    (Math.abs(m23 + m32) < epsilon2) &&
                    (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
                    // this singularity is identity matrix so angle = 0
                    this.set(1, 0, 0, 0);
                    return this; // zero angle, arbitrary axis
                }
                // otherwise this singularity is angle = 180
                angle = Math.PI;
                const xx = (m11 + 1) / 2;
                const yy = (m22 + 1) / 2;
                const zz = (m33 + 1) / 2;
                const xy = (m12 + m21) / 4;
                const xz = (m13 + m31) / 4;
                const yz = (m23 + m32) / 4;
                if ((xx > yy) && (xx > zz)) {
                    // m11 is the largest diagonal term
                    if (xx < epsilon) {
                        x = 0;
                        y = 0.707106781;
                        z = 0.707106781;
                    } else {
                        x = Math.sqrt(xx);
                        y = xy / x;
                        z = xz / x;
                    }
                } else if (yy > zz) {
                    // m22 is the largest diagonal term
                    if (yy < epsilon) {
                        x = 0.707106781;
                        y = 0;
                        z = 0.707106781;
                    } else {
                        y = Math.sqrt(yy);
                        x = xy / y;
                        z = yz / y;
                    }
                } else {
                    // m33 is the largest diagonal term so base result on this
                    if (zz < epsilon) {
                        x = 0.707106781;
                        y = 0.707106781;
                        z = 0;
                    } else {
                        z = Math.sqrt(zz);
                        x = xz / z;
                        y = yz / z;
                    }
                }
                this.set(x, y, z, angle);
                return this; // return 180 deg rotation
            }
            // as we have reached here there are no singularities so we can handle normally
            let s = Math.sqrt((m32 - m23) * (m32 - m23) +
                (m13 - m31) * (m13 - m31) +
                (m21 - m12) * (m21 - m12)); // used to normalize
            if (Math.abs(s) < 0.001) s = 1;
            // prevent divide by zero, should not happen if matrix is orthogonal and should be
            // caught by singularity test above, but I've left it in just in case
            this.x = (m32 - m23) / s;
            this.y = (m13 - m31) / s;
            this.z = (m21 - m12) / s;
            this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
            return this;
        }
        setFromMatrixPosition(m) {
            const e = m.elements;
            this.x = e[12];
            this.y = e[13];
            this.z = e[14];
            this.w = e[15];
            return this;
        }
        min(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            this.w = Math.min(this.w, v.w);
            return this;
        }
        max(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            this.w = Math.max(this.w, v.w);
            return this;
        }
        clamp(min, max) {
            // assumes min < max, componentwise
            this.x = clamp(this.x, min.x, max.x);
            this.y = clamp(this.y, min.y, max.y);
            this.z = clamp(this.z, min.z, max.z);
            this.w = clamp(this.w, min.w, max.w);
            return this;
        }
        clampScalar(minVal, maxVal) {
            this.x = clamp(this.x, minVal, maxVal);
            this.y = clamp(this.y, minVal, maxVal);
            this.z = clamp(this.z, minVal, maxVal);
            this.w = clamp(this.w, minVal, maxVal);
            return this;
        }
        clampLength(min, max) {
            const length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));
        }
        floor() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            this.w = Math.floor(this.w);
            return this;
        }
        ceil() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            this.w = Math.ceil(this.w);
            return this;
        }
        round() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            this.w = Math.round(this.w);
            return this;
        }
        roundToZero() {
            this.x = Math.trunc(this.x);
            this.y = Math.trunc(this.y);
            this.z = Math.trunc(this.z);
            this.w = Math.trunc(this.w);
            return this;
        }
        negate() {
            this.x = - this.x;
            this.y = - this.y;
            this.z = - this.z;
            this.w = - this.w;
            return this;
        }
        dot(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
            return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            this.w += (v.w - this.w) * alpha;
            return this;
        }
        lerpVectors(v1, v2, alpha) {
            this.x = v1.x + (v2.x - v1.x) * alpha;
            this.y = v1.y + (v2.y - v1.y) * alpha;
            this.z = v1.z + (v2.z - v1.z) * alpha;
            this.w = v1.w + (v2.w - v1.w) * alpha;
            return this;
        }
        equals(v) {
            return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
        }
        fromArray(array, offset = 0) {
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            this.w = array[offset + 3];
            return this;
        }
        toArray(array = [], offset = 0) {
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            array[offset + 3] = this.w;
            return array;
        }
        fromBufferAttribute(attribute, index) {
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            this.z = attribute.getZ(index);
            this.w = attribute.getW(index);
            return this;
        }
        random() {
            this.x = Math.random();
            this.y = Math.random();
            this.z = Math.random();
            this.w = Math.random();
            return this;
        }
        *[Symbol.iterator]() {
            yield this.x;
            yield this.y;
            yield this.z;
            yield this.w;
        }
    }
    class RenderTarget extends EventDispatcher {

        constructor(width = 1, height = 1, options = {}) {
            super();
            options = Object.assign({
                generateMipmaps: false,
                internalFormat: null,
                minFilter: LinearFilter,
                depthBuffer: true,
                stencilBuffer: false,
                resolveDepthBuffer: true,
                resolveStencilBuffer: true,
                depthTexture: null,
                samples: 0,
                count: 1,
                depth: 1,
                multiview: false
            }, options);
            this.isRenderTarget = true;
            this.width = width;
            this.height = height;
            this.depth = options.depth;
            this.scissor = new Vector4(0, 0, width, height);
            this.scissorTest = false;
            this.viewport = new Vector4(0, 0, width, height);
            const image = { width: width, height: height, depth: options.depth };
            const texture = new Texture(image);
            this.textures = [];
            const count = options.count;
            for (let i = 0; i < count; i++) {
                this.textures[i] = texture.clone();
                this.textures[i].isRenderTargetTexture = true;
                this.textures[i].renderTarget = this;
            }
            this._setTextureOptions(options);
            this.depthBuffer = options.depthBuffer;
            this.stencilBuffer = options.stencilBuffer;
            this.resolveDepthBuffer = options.resolveDepthBuffer;
            this.resolveStencilBuffer = options.resolveStencilBuffer;
            this._depthTexture = null;
            this.depthTexture = options.depthTexture;
            this.samples = options.samples;
            this.multiview = options.multiview;
        }
        _setTextureOptions(options = {}) {
            const values = {
                minFilter: LinearFilter,
                generateMipmaps: false,
                flipY: false,
                internalFormat: null
            };
            if (options.mapping !== undefined) values.mapping = options.mapping;
            if (options.wrapS !== undefined) values.wrapS = options.wrapS;
            if (options.wrapT !== undefined) values.wrapT = options.wrapT;
            if (options.wrapR !== undefined) values.wrapR = options.wrapR;
            if (options.magFilter !== undefined) values.magFilter = options.magFilter;
            if (options.minFilter !== undefined) values.minFilter = options.minFilter;
            if (options.format !== undefined) values.format = options.format;
            if (options.type !== undefined) values.type = options.type;
            if (options.anisotropy !== undefined) values.anisotropy = options.anisotropy;
            if (options.colorSpace !== undefined) values.colorSpace = options.colorSpace;
            if (options.flipY !== undefined) values.flipY = options.flipY;
            if (options.generateMipmaps !== undefined) values.generateMipmaps = options.generateMipmaps;
            if (options.internalFormat !== undefined) values.internalFormat = options.internalFormat;
            for (let i = 0; i < this.textures.length; i++) {
                const texture = this.textures[i];
                texture.setValues(values);
            }
        }
        get texture() {
            return this.textures[0];
        }
        set texture(value) {
            this.textures[0] = value;
        }
        set depthTexture(current) {
            if (this._depthTexture !== null) this._depthTexture.renderTarget = null;
            if (current !== null) current.renderTarget = this;
            this._depthTexture = current;
        }
        get depthTexture() {
            return this._depthTexture;
        }
        setSize(width, height, depth = 1) {
            if (this.width !== width || this.height !== height || this.depth !== depth) {
                this.width = width;
                this.height = height;
                this.depth = depth;
                for (let i = 0, il = this.textures.length; i < il; i++) {
                    this.textures[i].image.width = width;
                    this.textures[i].image.height = height;
                    this.textures[i].image.depth = depth;
                    this.textures[i].isArrayTexture = this.textures[i].image.depth > 1;
                }
                this.dispose();
            }
            this.viewport.set(0, 0, width, height);
            this.scissor.set(0, 0, width, height);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(source) {
            this.width = source.width;
            this.height = source.height;
            this.depth = source.depth;
            this.scissor.copy(source.scissor);
            this.scissorTest = source.scissorTest;
            this.viewport.copy(source.viewport);
            this.textures.length = 0;
            for (let i = 0, il = source.textures.length; i < il; i++) {
                this.textures[i] = source.textures[i].clone();
                this.textures[i].isRenderTargetTexture = true;
                this.textures[i].renderTarget = this;
                // ensure image object is not shared, see #20328
                const image = Object.assign({}, source.textures[i].image);
                this.textures[i].source = new Source(image);
            }
            this.depthBuffer = source.depthBuffer;
            this.stencilBuffer = source.stencilBuffer;
            this.resolveDepthBuffer = source.resolveDepthBuffer;
            this.resolveStencilBuffer = source.resolveStencilBuffer;
            if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
            this.samples = source.samples;
            return this;
        }
        dispose() {
            this.dispatchEvent({ type: 'dispose' });
        }
    }
    class WebGLRenderTarget extends RenderTarget {
        constructor(width = 1, height = 1, options = {}) {
            super(width, height, options);
            this.isWebGLRenderTarget = true;
        }
    }
    class DataArrayTexture extends Texture {
        constructor(data = null, width = 1, height = 1, depth = 1) {
            super(null);
            this.isDataArrayTexture = true;
            this.image = { data, width, height, depth };
            this.magFilter = NearestFilter;
            this.minFilter = NearestFilter;
            this.wrapR = ClampToEdgeWrapping;
            this.generateMipmaps = false;
            this.flipY = false;
            this.unpackAlignment = 1;
            this.layerUpdates = new Set();
        }
        addLayerUpdate(layerIndex) {
            this.layerUpdates.add(layerIndex);
        }
        clearLayerUpdates() {
            this.layerUpdates.clear();
        }
    }
    class WebGLArrayRenderTarget extends WebGLRenderTarget {
        constructor(width = 1, height = 1, depth = 1, options = {}) {
            super(width, height, options);
            this.isWebGLArrayRenderTarget = true;
            this.depth = depth;
            this.texture = new DataArrayTexture(null, width, height, depth);
            this._setTextureOptions(options);
            this.texture.isRenderTargetTexture = true;
        }
    }
    class Data3DTexture extends Texture {
        constructor(data = null, width = 1, height = 1, depth = 1) {
            // We're going to add .setXXX() methods for setting properties later.
            // Users can still set in Data3DTexture directly.
            //
            //	const texture = new THREE.Data3DTexture( data, width, height, depth );
            // 	texture.anisotropy = 16;
            //
            // See #14839
            super(null);
            this.isData3DTexture = true;
            this.image = { data, width, height, depth };
            this.magFilter = NearestFilter;
            this.minFilter = NearestFilter;
            this.wrapR = ClampToEdgeWrapping;
            this.generateMipmaps = false;
            this.flipY = false;
            this.unpackAlignment = 1;
        }
    }
    class WebGL3DRenderTarget extends WebGLRenderTarget {
        constructor(width = 1, height = 1, depth = 1, options = {}) {
            super(width, height, options);
            this.isWebGL3DRenderTarget = true;
            this.depth = depth;
            this.texture = new Data3DTexture(null, width, height, depth);
            this._setTextureOptions(options);
            this.texture.isRenderTargetTexture = true;
        }
    }
    class Box3 {
        constructor(min = new Vector3(+ Infinity, + Infinity, + Infinity), max = new Vector3(- Infinity, - Infinity, - Infinity)) {
            this.isBox3 = true;
            this.min = min;
            this.max = max;
        }
        set(min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        }
        setFromArray(array) {
            this.makeEmpty();
            for (let i = 0, il = array.length; i < il; i += 3) {
                this.expandByPoint(_vector$b.fromArray(array, i));
            }
            return this;
        }
        setFromBufferAttribute(attribute) {
            this.makeEmpty();
            for (let i = 0, il = attribute.count; i < il; i++) {
                this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));
            }
            return this;
        }
        setFromPoints(points) {
            this.makeEmpty();
            for (let i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
            }
            return this;
        }
        setFromCenterAndSize(center, size) {
            const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
            this.min.copy(center).sub(halfSize);
            this.max.copy(center).add(halfSize);
            return this;
        }
        setFromObject(object, precise = false) {
            this.makeEmpty();
            return this.expandByObject(object, precise);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(box) {
            this.min.copy(box.min);
            this.max.copy(box.max);
            return this;
        }
        makeEmpty() {
            this.min.x = this.min.y = this.min.z = + Infinity;
            this.max.x = this.max.y = this.max.z = - Infinity;
            return this;
        }
        isEmpty() {
            // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
            return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
        }
        getCenter(target) {
            return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
            return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        }
        expandByVector(vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        }
        expandByScalar(scalar) {
            this.min.addScalar(- scalar);
            this.max.addScalar(scalar);
            return this;
        }
        expandByObject(object, precise = false) {
            // Computes the world-axis-aligned bounding box of an object (including its children),
            // accounting for both the object's, and children's, world transforms
            object.updateWorldMatrix(false, false);
            const geometry = object.geometry;
            if (geometry !== undefined) {
                const positionAttribute = geometry.getAttribute('position');
                // precise AABB computation based on vertex data requires at least a position attribute.
                // instancing isn't supported so far and uses the normal (conservative) code path.
                if (precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true) {
                    for (let i = 0, l = positionAttribute.count; i < l; i++) {
                        if (object.isMesh === true) {
                            object.getVertexPosition(i, _vector$b);
                        } else {
                            _vector$b.fromBufferAttribute(positionAttribute, i);
                        }
                        _vector$b.applyMatrix4(object.matrixWorld);
                        this.expandByPoint(_vector$b);
                    }
                } else {
                    if (object.boundingBox !== undefined) {
                        // object-level bounding box
                        if (object.boundingBox === null) {
                            object.computeBoundingBox();
                        }
                        _box$4.copy(object.boundingBox);

                    } else {
                        // geometry-level bounding box
                        if (geometry.boundingBox === null) {
                            geometry.computeBoundingBox();
                        }
                        _box$4.copy(geometry.boundingBox);
                    }
                    _box$4.applyMatrix4(object.matrixWorld);
                    this.union(_box$4);
                }
            }
            const children = object.children;
            for (let i = 0, l = children.length; i < l; i++) {
                this.expandByObject(children[i], precise);
            }
            return this;
        }
        containsPoint(point) {
            return point.x >= this.min.x && point.x <= this.max.x &&
                point.y >= this.min.y && point.y <= this.max.y &&
                point.z >= this.min.z && point.z <= this.max.z;
        }
        containsBox(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x &&
                this.min.y <= box.min.y && box.max.y <= this.max.y &&
                this.min.z <= box.min.z && box.max.z <= this.max.z;
        }
        getParameter(point, target) {
            // This can potentially have a divide by zero if the box
            // has a size dimension of 0.
            return target.set(
                (point.x - this.min.x) / (this.max.x - this.min.x),
                (point.y - this.min.y) / (this.max.y - this.min.y),
                (point.z - this.min.z) / (this.max.z - this.min.z)
            );
        }
        intersectsBox(box) {
            // using 6 splitting planes to rule out intersections.
            return box.max.x >= this.min.x && box.min.x <= this.max.x &&
                box.max.y >= this.min.y && box.min.y <= this.max.y &&
                box.max.z >= this.min.z && box.min.z <= this.max.z;
        }
        intersectsSphere(sphere) {
            // Find the point on the AABB closest to the sphere center.
            this.clampPoint(sphere.center, _vector$b);
            // If that point is inside the sphere, the AABB and sphere intersect.
            return _vector$b.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);
        }
        intersectsPlane(plane) {
            // We compute the minimum and maximum dot product values. If those values
            // are on the same side (back or front) of the plane, then there is no intersection.
            let min, max;
            if (plane.normal.x > 0) {
                min = plane.normal.x * this.min.x;
                max = plane.normal.x * this.max.x;
            } else {
                min = plane.normal.x * this.max.x;
                max = plane.normal.x * this.min.x;
            }
            if (plane.normal.y > 0) {
                min += plane.normal.y * this.min.y;
                max += plane.normal.y * this.max.y;
            } else {
                min += plane.normal.y * this.max.y;
                max += plane.normal.y * this.min.y;
            }
            if (plane.normal.z > 0) {
                min += plane.normal.z * this.min.z;
                max += plane.normal.z * this.max.z;
            } else {
                min += plane.normal.z * this.max.z;
                max += plane.normal.z * this.min.z;
            }
            return (min <= - plane.constant && max >= - plane.constant);
        }
        intersectsTriangle(triangle) {
            if (this.isEmpty()) {
                return false;
            }
            // compute box center and extents
            this.getCenter(_center);
            _extents.subVectors(this.max, _center);
            // translate triangle to aabb origin
            _v0$2.subVectors(triangle.a, _center);
            _v1$7.subVectors(triangle.b, _center);
            _v2$4.subVectors(triangle.c, _center);
            // compute edge vectors for triangle
            _f0.subVectors(_v1$7, _v0$2);
            _f1.subVectors(_v2$4, _v1$7);
            _f2.subVectors(_v0$2, _v2$4);
            // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
            // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
            // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
            let axes = [
                0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
                _f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
                - _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
            ];
            if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
                return false;
            }
            // test 3 face normals from the aabb
            axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
                return false;
            }
            // finally testing the face normal of the triangle
            // use already existing triangle edge vectors here
            _triangleNormal.crossVectors(_f0, _f1);
            axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
            return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
        }
        clampPoint(point, target) {
            return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
            return this.clampPoint(point, _vector$b).distanceTo(point);
        }
        getBoundingSphere(target) {
            if (this.isEmpty()) {
                target.makeEmpty();
            } else {
                this.getCenter(target.center);
                target.radius = this.getSize(_vector$b).length() * 0.5;
            }
            return target;
        }
        intersect(box) {
            this.min.max(box.min);
            this.max.min(box.max);
            // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
            if (this.isEmpty()) this.makeEmpty();
            return this;
        }
        union(box) {
            this.min.min(box.min);
            this.max.max(box.max);
            return this;
        }
        applyMatrix4(matrix) {
            // transform of empty box is an empty box.
            if (this.isEmpty()) return this;
            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
            _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
            _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
            _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
            _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
            _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
            _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
            _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
            this.setFromPoints(_points);
            return this;
        }
        translate(offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        }
        equals(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
        toJSON() {
            return {
                min: this.min.toArray(),
                max: this.max.toArray()
            };
        }
        fromJSON(json) {
            this.min.fromArray(json.min);
            this.max.fromArray(json.max);
            return this;
        }
    }
    const _points = [
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3()
    ];
    const _vector$b = /*@__PURE__*/ new Vector3();
    const _box$4 = /*@__PURE__*/ new Box3();
    // triangle centered vertices
    const _v0$2 = /*@__PURE__*/ new Vector3();
    const _v1$7 = /*@__PURE__*/ new Vector3();
    const _v2$4 = /*@__PURE__*/ new Vector3();
    // triangle edge vectors
    const _f0 = /*@__PURE__*/ new Vector3();
    const _f1 = /*@__PURE__*/ new Vector3();
    const _f2 = /*@__PURE__*/ new Vector3();
    const _center = /*@__PURE__*/ new Vector3();
    const _extents = /*@__PURE__*/ new Vector3();
    const _triangleNormal = /*@__PURE__*/ new Vector3();
    const _testAxis = /*@__PURE__*/ new Vector3();
    function satForAxes(axes, v0, v1, v2, extents) {
        for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
            _testAxis.fromArray(axes, i);
            // project the aabb onto the separating axis
            const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
            // project all 3 vertices of the triangle onto the separating axis
            const p0 = v0.dot(_testAxis);
            const p1 = v1.dot(_testAxis);
            const p2 = v2.dot(_testAxis);
            // actual test, basically see if either of the most extreme of the triangle points intersects r
            if (Math.max(- Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
                // points of the projected triangle are outside the projected half-length of the aabb
                // the axis is separating and we can exit
                return false;
            }
        }
        return true;
    }
    const _box$3 = /*@__PURE__*/ new Box3();
    const _v1$6 = /*@__PURE__*/ new Vector3();
    const _v2$3 = /*@__PURE__*/ new Vector3();
    class Sphere {
        constructor(center = new Vector3(), radius = -1) {
            this.isSphere = true;
            this.center = center;
            this.radius = radius;
        }
        set(center, radius) {
            this.center.copy(center);
            this.radius = radius;
            return this;
        }
        setFromPoints(points, optionalCenter) {
            const center = this.center;
            if (optionalCenter !== undefined) {
                center.copy(optionalCenter);
            } else {
                _box$3.setFromPoints(points).getCenter(center);
            }
            let maxRadiusSq = 0;
            for (let i = 0, il = points.length; i < il; i++) {
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
            }
            this.radius = Math.sqrt(maxRadiusSq);
            return this;
        }
        copy(sphere) {
            this.center.copy(sphere.center);
            this.radius = sphere.radius;
            return this;
        }
        isEmpty() {
            return (this.radius < 0);
        }
        makeEmpty() {
            this.center.set(0, 0, 0);
            this.radius = -1;
            return this;
        }
        containsPoint(point) {
            return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
        }
        distanceToPoint(point) {
            return (point.distanceTo(this.center) - this.radius);
        }
        intersectsSphere(sphere) {
            const radiusSum = this.radius + sphere.radius;
            return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
        }
        intersectsBox(box) {
            return box.intersectsSphere(this);
        }
        intersectsPlane(plane) {
            return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(point, target) {
            const deltaLengthSq = this.center.distanceToSquared(point);
            target.copy(point);
            if (deltaLengthSq > (this.radius * this.radius)) {
                target.sub(this.center).normalize();
                target.multiplyScalar(this.radius).add(this.center);
            }
            return target;
        }
        getBoundingBox(target) {
            if (this.isEmpty()) {
                // Empty sphere produces empty bounding box
                target.makeEmpty();
                return target;
            }
            target.set(this.center, this.center);
            target.expandByScalar(this.radius);
            return target;
        }
        applyMatrix4(matrix) {
            this.center.applyMatrix4(matrix);
            this.radius = this.radius * matrix.getMaxScaleOnAxis();
            return this;
        }
        translate(offset) {
            this.center.add(offset);
            return this;
        }
        expandByPoint(point) {
            if (this.isEmpty()) {
                this.center.copy(point);
                this.radius = 0;
                return this;
            }
            _v1$6.subVectors(point, this.center);
            const lengthSq = _v1$6.lengthSq();
            if (lengthSq > (this.radius * this.radius)) {
                // calculate the minimal sphere
                const length = Math.sqrt(lengthSq);
                const delta = (length - this.radius) * 0.5;
                this.center.addScaledVector(_v1$6, delta / length);
                this.radius += delta;
            }
            return this;
        }
        union(sphere) {
            if (sphere.isEmpty()) {
                return this;
            }
            if (this.isEmpty()) {
                this.copy(sphere);
                return this;
            }
            if (this.center.equals(sphere.center) === true) {
                this.radius = Math.max(this.radius, sphere.radius);
            } else {
                _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
                this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
                this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
            }
            return this;
        }
        equals(sphere) {
            return sphere.center.equals(this.center) && (sphere.radius === this.radius);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        toJSON() {
            return {
                radius: this.radius,
                center: this.center.toArray()
            };
        }
        fromJSON(json) {
            this.radius = json.radius;
            this.center.fromArray(json.center);
            return this;
        }
    }
    const _vector$a = /*@__PURE__*/ new Vector3();
    const _segCenter = /*@__PURE__*/ new Vector3();
    const _segDir = /*@__PURE__*/ new Vector3();
    const _diff = /*@__PURE__*/ new Vector3();
    const _edge1 = /*@__PURE__*/ new Vector3();
    const _edge2 = /*@__PURE__*/ new Vector3();
    const _normal$1 = /*@__PURE__*/ new Vector3();
    class Ray {
        constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
            this.origin = origin;
            this.direction = direction;
        }
        set(origin, direction) {
            this.origin.copy(origin);
            this.direction.copy(direction);
            return this;
        }
        copy(ray) {
            this.origin.copy(ray.origin);
            this.direction.copy(ray.direction);
            return this;
        }
        at(t, target) {
            return target.copy(this.origin).addScaledVector(this.direction, t);
        }
        lookAt(v) {
            this.direction.copy(v).sub(this.origin).normalize();
            return this;
        }
        recast(t) {
            this.origin.copy(this.at(t, _vector$a));
            return this;
        }
        closestPointToPoint(point, target) {
            target.subVectors(point, this.origin);
            const directionDistance = target.dot(this.direction);
            if (directionDistance < 0) {
                return target.copy(this.origin);
            }
            return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
        }
        distanceToPoint(point) {
            return Math.sqrt(this.distanceSqToPoint(point));
        }
        distanceSqToPoint(point) {
            const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
            // point behind the ray
            if (directionDistance < 0) {
                return this.origin.distanceToSquared(point);
            }
            _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
            return _vector$a.distanceToSquared(point);
        }
        distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
            // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
            // It returns the min distance between the ray and the segment
            // defined by v0 and v1
            // It can also set two optional targets :
            // - The closest point on the ray
            // - The closest point on the segment
            _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
            _segDir.copy(v1).sub(v0).normalize();
            _diff.copy(this.origin).sub(_segCenter);
            const segExtent = v0.distanceTo(v1) * 0.5;
            const a01 = - this.direction.dot(_segDir);
            const b0 = _diff.dot(this.direction);
            const b1 = - _diff.dot(_segDir);
            const c = _diff.lengthSq();
            const det = Math.abs(1 - a01 * a01);
            let s0, s1, sqrDist, extDet;
            if (det > 0) {
                // The ray and segment are not parallel.
                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;
                if (s0 >= 0) {
                    if (s1 >= - extDet) {
                        if (s1 <= extDet) {
                            // region 0
                            // Minimum at interior points of ray and segment.
                            const invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                        } else {
                            // region 1
                            s1 = segExtent;
                            s0 = Math.max(0, - (a01 * s1 + b0));
                            sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    } else {
                        // region 5
                        s1 = - segExtent;
                        s0 = Math.max(0, - (a01 * s1 + b0));
                        sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                } else {
                    if (s1 <= - extDet) {
                        // region 4
                        s0 = Math.max(0, - (- a01 * segExtent + b0));
                        s1 = (s0 > 0) ? - segExtent : Math.min(Math.max(- segExtent, - b1), segExtent);
                        sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    } else if (s1 <= extDet) {
                        // region 3
                        s0 = 0;
                        s1 = Math.min(Math.max(- segExtent, - b1), segExtent);
                        sqrDist = s1 * (s1 + 2 * b1) + c;
                    } else {
                        // region 2
                        s0 = Math.max(0, - (a01 * segExtent + b0));
                        s1 = (s0 > 0) ? segExtent : Math.min(Math.max(- segExtent, - b1), segExtent);
                        sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                }
            } else {
                // Ray and segment are parallel.
                s1 = (a01 > 0) ? - segExtent : segExtent;
                s0 = Math.max(0, - (a01 * s1 + b0));
                sqrDist = - s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
            if (optionalPointOnRay) {
                optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
            }
            if (optionalPointOnSegment) {
                optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
            }
            return sqrDist;
        }
        intersectSphere(sphere, target) {
            _vector$a.subVectors(sphere.center, this.origin);
            const tca = _vector$a.dot(this.direction);
            const d2 = _vector$a.dot(_vector$a) - tca * tca;
            const radius2 = sphere.radius * sphere.radius;
            if (d2 > radius2) return null;
            const thc = Math.sqrt(radius2 - d2);
            // t0 = first intersect point - entrance on front of sphere
            const t0 = tca - thc;
            // t1 = second intersect point - exit point on back of sphere
            const t1 = tca + thc;
            // test to see if t1 is behind the ray - if so, return null
            if (t1 < 0) return null;
            // test to see if t0 is behind the ray:
            // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
            // in order to always return an intersect point that is in front of the ray.
            if (t0 < 0) return this.at(t1, target);
            // else t0 is in front of the ray, so return the first collision point scaled by t0
            return this.at(t0, target);
        }
        intersectsSphere(sphere) {
            if (sphere.radius < 0) return false; // handle empty spheres, see #31187
            return this.distanceSqToPoint(sphere.center) <= (sphere.radius * sphere.radius);
        }
        distanceToPlane(plane) {
            const denominator = plane.normal.dot(this.direction);
            if (denominator === 0) {
                // line is coplanar, return origin
                if (plane.distanceToPoint(this.origin) === 0) {
                    return 0;
                }
                // Null is preferable to undefined since undefined means.... it is undefined
                return null;
            }
            const t = - (this.origin.dot(plane.normal) + plane.constant) / denominator;
            // Return if the ray never intersects the plane
            return t >= 0 ? t : null;
        }
        intersectPlane(plane, target) {
            const t = this.distanceToPlane(plane);
            if (t === null) {
                return null;
            }
            return this.at(t, target);
        }
        intersectsPlane(plane) {
            // check if the ray lies on the plane first
            const distToPoint = plane.distanceToPoint(this.origin);
            if (distToPoint === 0) {
                return true;
            }
            const denominator = plane.normal.dot(this.direction);
            if (denominator * distToPoint < 0) {
                return true;
            }
            // ray origin is behind the plane (and is pointing behind it)
            return false;
        }
        intersectBox(box, target) {
            let tmin, tmax, tymin, tymax, tzmin, tzmax;
            const invdirx = 1 / this.direction.x,
                invdiry = 1 / this.direction.y,
                invdirz = 1 / this.direction.z;
            const origin = this.origin;
            if (invdirx >= 0) {
                tmin = (box.min.x - origin.x) * invdirx;
                tmax = (box.max.x - origin.x) * invdirx;
            } else {
                tmin = (box.max.x - origin.x) * invdirx;
                tmax = (box.min.x - origin.x) * invdirx;
            }
            if (invdiry >= 0) {
                tymin = (box.min.y - origin.y) * invdiry;
                tymax = (box.max.y - origin.y) * invdiry;
            } else {
                tymin = (box.max.y - origin.y) * invdiry;
                tymax = (box.min.y - origin.y) * invdiry;
            }
            if ((tmin > tymax) || (tymin > tmax)) return null;
            if (tymin > tmin || isNaN(tmin)) tmin = tymin;
            if (tymax < tmax || isNaN(tmax)) tmax = tymax;
            if (invdirz >= 0) {
                tzmin = (box.min.z - origin.z) * invdirz;
                tzmax = (box.max.z - origin.z) * invdirz;
            } else {
                tzmin = (box.max.z - origin.z) * invdirz;
                tzmax = (box.min.z - origin.z) * invdirz;
            }
            if ((tmin > tzmax) || (tzmin > tmax)) return null;
            if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
            if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
            //return point closest to the ray (positive side)
            if (tmax < 0) return null;
            return this.at(tmin >= 0 ? tmin : tmax, target);
        }
        intersectsBox(box) {
            return this.intersectBox(box, _vector$a) !== null;
        }
        intersectTriangle(a, b, c, backfaceCulling, target) {
            // Compute the offset origin, edges, and normal.
            // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
            _edge1.subVectors(b, a);
            _edge2.subVectors(c, a);
            _normal$1.crossVectors(_edge1, _edge2);
            // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            let DdN = this.direction.dot(_normal$1);
            let sign;
            if (DdN > 0) {
                if (backfaceCulling) return null;
                sign = 1;
            } else if (DdN < 0) {
                sign = -1;
                DdN = - DdN;
            } else {
                return null;
            }
            _diff.subVectors(this.origin, a);
            const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
            // b1 < 0, no intersection
            if (DdQxE2 < 0) {
                return null;
            }
            const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
            // b2 < 0, no intersection
            if (DdE1xQ < 0) {
                return null;
            }
            // b1+b2 > 1, no intersection
            if (DdQxE2 + DdE1xQ > DdN) {
                return null;
            }
            // Line intersects triangle, check if ray does.
            const QdN = - sign * _diff.dot(_normal$1);
            // t < 0, no intersection
            if (QdN < 0) {
                return null;
            }
            // Ray intersects triangle.
            return this.at(QdN / DdN, target);
        }
        applyMatrix4(matrix4) {
            this.origin.applyMatrix4(matrix4);
            this.direction.transformDirection(matrix4);
            return this;
        }
        equals(ray) {
            return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    class Matrix4 {
        constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            Matrix4.prototype.isMatrix4 = true;
            this.elements = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
            if (n11 !== undefined) {
                this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
            }
        }
        set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            const te = this.elements;
            te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
            te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
            te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
            te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;
            return this;
        }
        identity() {
            this.set(
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            );
            return this;
        }
        clone() {
            return new Matrix4().fromArray(this.elements);
        }
        copy(m) {
            const te = this.elements;
            const me = m.elements;
            te[0] = me[0]; te[1] = me[1]; te[2] = me[2]; te[3] = me[3];
            te[4] = me[4]; te[5] = me[5]; te[6] = me[6]; te[7] = me[7];
            te[8] = me[8]; te[9] = me[9]; te[10] = me[10]; te[11] = me[11];
            te[12] = me[12]; te[13] = me[13]; te[14] = me[14]; te[15] = me[15];
            return this;
        }
        copyPosition(m) {
            const te = this.elements, me = m.elements;
            te[12] = me[12];
            te[13] = me[13];
            te[14] = me[14];
            return this;
        }
        setFromMatrix3(m) {
            const me = m.elements;
            this.set(
                me[0], me[3], me[6], 0,
                me[1], me[4], me[7], 0,
                me[2], me[5], me[8], 0,
                0, 0, 0, 1
            );
            return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
            xAxis.setFromMatrixColumn(this, 0);
            yAxis.setFromMatrixColumn(this, 1);
            zAxis.setFromMatrixColumn(this, 2);
            return this;
        }
        makeBasis(xAxis, yAxis, zAxis) {
            this.set(
                xAxis.x, yAxis.x, zAxis.x, 0,
                xAxis.y, yAxis.y, zAxis.y, 0,
                xAxis.z, yAxis.z, zAxis.z, 0,
                0, 0, 0, 1
            );
            return this;
        }
        extractRotation(m) {
            const te = this.elements;
            const me = m.elements;
            const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
            const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
            const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
            te[0] = me[0] * scaleX;
            te[1] = me[1] * scaleX;
            te[2] = me[2] * scaleX;
            te[3] = 0;
            te[4] = me[4] * scaleY;
            te[5] = me[5] * scaleY;
            te[6] = me[6] * scaleY;
            te[7] = 0;
            te[8] = me[8] * scaleZ;
            te[9] = me[9] * scaleZ;
            te[10] = me[10] * scaleZ;
            te[11] = 0;
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        }
        makeRotationFromEuler(euler) {
            const te = this.elements;
            const x = euler.x, y = euler.y, z = euler.z;
            const a = Math.cos(x), b = Math.sin(x);
            const c = Math.cos(y), d = Math.sin(y);
            const e = Math.cos(z), f = Math.sin(z);
            if (euler.order === 'XYZ') {
                const ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e;
                te[4] = - c * f;
                te[8] = d;
                te[1] = af + be * d;
                te[5] = ae - bf * d;
                te[9] = - b * c;
                te[2] = bf - ae * d;
                te[6] = be + af * d;
                te[10] = a * c;
            } else if (euler.order === 'YXZ') {
                const ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce + df * b;
                te[4] = de * b - cf;
                te[8] = a * d;
                te[1] = a * f;
                te[5] = a * e;
                te[9] = - b;
                te[2] = cf * b - de;
                te[6] = df + ce * b;
                te[10] = a * c;
            } else if (euler.order === 'ZXY') {
                const ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce - df * b;
                te[4] = - a * f;
                te[8] = de + cf * b;
                te[1] = cf + de * b;
                te[5] = a * e;
                te[9] = df - ce * b;
                te[2] = - a * d;
                te[6] = b;
                te[10] = a * c;
            } else if (euler.order === 'ZYX') {
                const ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e;
                te[4] = be * d - af;
                te[8] = ae * d + bf;
                te[1] = c * f;
                te[5] = bf * d + ae;
                te[9] = af * d - be;
                te[2] = - d;
                te[6] = b * c;
                te[10] = a * c;
            } else if (euler.order === 'YZX') {
                const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e;
                te[4] = bd - ac * f;
                te[8] = bc * f + ad;
                te[1] = f;
                te[5] = a * e;
                te[9] = - b * e;
                te[2] = - d * e;
                te[6] = ad * f + bc;
                te[10] = ac - bd * f;
            } else if (euler.order === 'XZY') {
                const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e;
                te[4] = - f;
                te[8] = d * e;
                te[1] = ac * f + bd;
                te[5] = a * e;
                te[9] = ad * f - bc;
                te[2] = bc * f - ad;
                te[6] = b * e;
                te[10] = bd * f + ac;
            }
            // bottom row
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            // last column
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        }
        makeRotationFromQuaternion(q) {
            return this.compose(_zero, q, _one);
        }
        lookAt(eye, target, up) {
            const te = this.elements;
            _z.subVectors(eye, target);
            if (_z.lengthSq() === 0) {
                // eye and target are in the same position
                _z.z = 1;
            }
            _z.normalize();
            _x.crossVectors(up, _z);
            if (_x.lengthSq() === 0) {
                // up and z are parallel
                if (Math.abs(up.z) === 1) {
                    _z.x += 0.0001;
                } else {
                    _z.z += 0.0001;
                }
                _z.normalize();
                _x.crossVectors(up, _z);
            }
            _x.normalize();
            _y.crossVectors(_z, _x);
            te[0] = _x.x; te[4] = _y.x; te[8] = _z.x;
            te[1] = _x.y; te[5] = _y.y; te[9] = _z.y;
            te[2] = _x.z; te[6] = _y.z; te[10] = _z.z;
            return this;
        }
        multiply(m) {
            return this.multiplyMatrices(this, m);
        }
        premultiply(m) {
            return this.multiplyMatrices(m, this);
        }
        multiplyMatrices(a, b) {
            const ae = a.elements;
            const be = b.elements;
            const te = this.elements;
            const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
            const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
            const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
            const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
            const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
            const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
            const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
            const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            return this;
        }
        multiplyScalar(s) {
            const te = this.elements;
            te[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;
            te[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;
            te[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;
            te[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;
            return this;
        }
        determinant() {
            const te = this.elements;
            const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
            const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
            const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
            const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
            //TODO: make this more efficient
            return (
                n41 * (
                    + n14 * n23 * n32
                    - n13 * n24 * n32
                    - n14 * n22 * n33
                    + n12 * n24 * n33
                    + n13 * n22 * n34
                    - n12 * n23 * n34
                ) +
                n42 * (
                    + n11 * n23 * n34
                    - n11 * n24 * n33
                    + n14 * n21 * n33
                    - n13 * n21 * n34
                    + n13 * n24 * n31
                    - n14 * n23 * n31
                ) +
                n43 * (
                    + n11 * n24 * n32
                    - n11 * n22 * n34
                    - n14 * n21 * n32
                    + n12 * n21 * n34
                    + n14 * n22 * n31
                    - n12 * n24 * n31
                ) +
                n44 * (
                    - n13 * n22 * n31
                    - n11 * n23 * n32
                    + n11 * n22 * n33
                    + n13 * n21 * n32
                    - n12 * n21 * n33
                    + n12 * n23 * n31
                )
            );
        }
        transpose() {
            const te = this.elements;
            let tmp;
            tmp = te[1]; te[1] = te[4]; te[4] = tmp;
            tmp = te[2]; te[2] = te[8]; te[8] = tmp;
            tmp = te[6]; te[6] = te[9]; te[9] = tmp;
            tmp = te[3]; te[3] = te[12]; te[12] = tmp;
            tmp = te[7]; te[7] = te[13]; te[13] = tmp;
            tmp = te[11]; te[11] = te[14]; te[14] = tmp;
            return this;
        }
        setPosition(x, y, z) {
            const te = this.elements;
            if (x.isVector3) {
                te[12] = x.x;
                te[13] = x.y;
                te[14] = x.z;
            } else {
                te[12] = x;
                te[13] = y;
                te[14] = z;
            }
            return this;
        }
        invert() {
            // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
            const te = this.elements,
                n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3],
                n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7],
                n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11],
                n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15],
                t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
                t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
                t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
                t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
            const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
            te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
            te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
            te[4] = t12 * detInv;
            te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
            te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
            te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
            te[8] = t13 * detInv;
            te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
            te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
            te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
            te[12] = t14 * detInv;
            te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
            te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
            te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
            return this;
        }
        scale(v) {
            const te = this.elements;
            const x = v.x, y = v.y, z = v.z;
            te[0] *= x; te[4] *= y; te[8] *= z;
            te[1] *= x; te[5] *= y; te[9] *= z;
            te[2] *= x; te[6] *= y; te[10] *= z;
            te[3] *= x; te[7] *= y; te[11] *= z;
            return this;
        }
        getMaxScaleOnAxis() {
            const te = this.elements;
            const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
            const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
            const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        }
        makeTranslation(x, y, z) {
            if (x.isVector3) {
                this.set(
                    1, 0, 0, x.x,
                    0, 1, 0, x.y,
                    0, 0, 1, x.z,
                    0, 0, 0, 1
                );
            } else {
                this.set(
                    1, 0, 0, x,
                    0, 1, 0, y,
                    0, 0, 1, z,
                    0, 0, 0, 1
                );
            }
            return this;
        }
        makeRotationX(theta) {
            const c = Math.cos(theta), s = Math.sin(theta);
            this.set(
                1, 0, 0, 0,
                0, c, - s, 0,
                0, s, c, 0,
                0, 0, 0, 1
            );
            return this;
        }
        makeRotationY(theta) {
            const c = Math.cos(theta), s = Math.sin(theta);
            this.set(
                c, 0, s, 0,
                0, 1, 0, 0,
                - s, 0, c, 0,
                0, 0, 0, 1
            );
            return this;
        }
        makeRotationZ(theta) {
            const c = Math.cos(theta), s = Math.sin(theta);
            this.set(
                c, - s, 0, 0,
                s, c, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            );
            return this;
        }
        makeRotationAxis(axis, angle) {
            // Based on http://www.gamedev.net/reference/articles/article1199.asp
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            const t = 1 - c;
            const x = axis.x, y = axis.y, z = axis.z;
            const tx = t * x, ty = t * y;
            this.set(
                tx * x + c, tx * y - s * z, tx * z + s * y, 0,
                tx * y + s * z, ty * y + c, ty * z - s * x, 0,
                tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
                0, 0, 0, 1
            );
            return this;
        }
        makeScale(x, y, z) {
            this.set(
                x, 0, 0, 0,
                0, y, 0, 0,
                0, 0, z, 0,
                0, 0, 0, 1
            );
            return this;
        }
        makeShear(xy, xz, yx, yz, zx, zy) {
            this.set(
                1, yx, zx, 0,
                xy, 1, zy, 0,
                xz, yz, 1, 0,
                0, 0, 0, 1
            );
            return this;
        }
        compose(position, quaternion, scale) {
            const te = this.elements;
            const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
            const x2 = x + x, y2 = y + y, z2 = z + z;
            const xx = x * x2, xy = x * y2, xz = x * z2;
            const yy = y * y2, yz = y * z2, zz = z * z2;
            const wx = w * x2, wy = w * y2, wz = w * z2;
            const sx = scale.x, sy = scale.y, sz = scale.z;
            te[0] = (1 - (yy + zz)) * sx;
            te[1] = (xy + wz) * sx;
            te[2] = (xz - wy) * sx;
            te[3] = 0;
            te[4] = (xy - wz) * sy;
            te[5] = (1 - (xx + zz)) * sy;
            te[6] = (yz + wx) * sy;
            te[7] = 0;
            te[8] = (xz + wy) * sz;
            te[9] = (yz - wx) * sz;
            te[10] = (1 - (xx + yy)) * sz;
            te[11] = 0;
            te[12] = position.x;
            te[13] = position.y;
            te[14] = position.z;
            te[15] = 1;
            return this;
        }
        decompose(position, quaternion, scale) {
            const te = this.elements;
            let sx = _v1$5.set(te[0], te[1], te[2]).length();
            const sy = _v1$5.set(te[4], te[5], te[6]).length();
            const sz = _v1$5.set(te[8], te[9], te[10]).length();
            // if determine is negative, we need to invert one scale
            const det = this.determinant();
            if (det < 0) sx = - sx;
            position.x = te[12];
            position.y = te[13];
            position.z = te[14];
            // scale the rotation part
            _m1$2.copy(this);
            const invSX = 1 / sx;
            const invSY = 1 / sy;
            const invSZ = 1 / sz;
            _m1$2.elements[0] *= invSX;
            _m1$2.elements[1] *= invSX;
            _m1$2.elements[2] *= invSX;
            _m1$2.elements[4] *= invSY;
            _m1$2.elements[5] *= invSY;
            _m1$2.elements[6] *= invSY;
            _m1$2.elements[8] *= invSZ;
            _m1$2.elements[9] *= invSZ;
            _m1$2.elements[10] *= invSZ;
            quaternion.setFromRotationMatrix(_m1$2);
            scale.x = sx;
            scale.y = sy;
            scale.z = sz;
            return this;
        }
        makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {
            const te = this.elements;
            const x = 2 * near / (right - left);
            const y = 2 * near / (top - bottom);
            const a = (right + left) / (right - left);
            const b = (top + bottom) / (top - bottom);
            let c, d;
            if (reversedDepth) {
                c = near / (far - near);
                d = (far * near) / (far - near);
            } else {
                if (coordinateSystem === WebGLCoordinateSystem) {
                    c = - (far + near) / (far - near);
                    d = (-2 * far * near) / (far - near);
                } else if (coordinateSystem === WebGPUCoordinateSystem) {
                    c = - far / (far - near);
                    d = (- far * near) / (far - near);
                } else {
                    throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem);
                }
            }
            te[0] = x; te[4] = 0; te[8] = a; te[12] = 0;
            te[1] = 0; te[5] = y; te[9] = b; te[13] = 0;
            te[2] = 0; te[6] = 0; te[10] = c; te[14] = d;
            te[3] = 0; te[7] = 0; te[11] = -1; te[15] = 0;
            return this;
        }
        makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {
            const te = this.elements;
            const x = 2 / (right - left);
            const y = 2 / (top - bottom);
            const a = - (right + left) / (right - left);
            const b = - (top + bottom) / (top - bottom);
            let c, d;
            if (reversedDepth) {
                c = 1 / (far - near);
                d = far / (far - near);
            } else {
                if (coordinateSystem === WebGLCoordinateSystem) {
                    c = -2 / (far - near);
                    d = - (far + near) / (far - near);
                } else if (coordinateSystem === WebGPUCoordinateSystem) {
                    c = -1 / (far - near);
                    d = - near / (far - near);
                } else {
                    throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem);
                }
            }
            te[0] = x; te[4] = 0; te[8] = 0; te[12] = a;
            te[1] = 0; te[5] = y; te[9] = 0; te[13] = b;
            te[2] = 0; te[6] = 0; te[10] = c; te[14] = d;
            te[3] = 0; te[7] = 0; te[11] = 0; te[15] = 1;
            return this;
        }
        equals(matrix) {
            const te = this.elements;
            const me = matrix.elements;
            for (let i = 0; i < 16; i++) {
                if (te[i] !== me[i]) return false;
            }
            return true;
        }
        fromArray(array, offset = 0) {
            for (let i = 0; i < 16; i++) {
                this.elements[i] = array[i + offset];
            }
            return this;
        }
        toArray(array = [], offset = 0) {
            const te = this.elements;
            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];
            array[offset + 9] = te[9];
            array[offset + 10] = te[10];
            array[offset + 11] = te[11];
            array[offset + 12] = te[12];
            array[offset + 13] = te[13];
            array[offset + 14] = te[14];
            array[offset + 15] = te[15];
            return array;
        }
    }
    const _v1$5 = /*@__PURE__*/ new Vector3();
    const _m1$2 = /*@__PURE__*/ new Matrix4();
    const _zero = /*@__PURE__*/ new Vector3(0, 0, 0);
    const _one = /*@__PURE__*/ new Vector3(1, 1, 1);
    const _x = /*@__PURE__*/ new Vector3();
    const _y = /*@__PURE__*/ new Vector3();
    const _z = /*@__PURE__*/ new Vector3();
    const _matrix$2 = /*@__PURE__*/ new Matrix4();
    const _quaternion$3 = /*@__PURE__*/ new Quaternion();
    class Euler {
        constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
            this.isEuler = true;
            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order;
        }
        get x() {
            return this._x;
        }
        set x(value) {
            this._x = value;
            this._onChangeCallback();
        }
        get y() {
            return this._y;
        }
        set y(value) {
            this._y = value;
            this._onChangeCallback();
        }
        get z() {
            return this._z;
        }
        set z(value) {
            this._z = value;
            this._onChangeCallback();
        }
        get order() {
            return this._order;
        }
        set order(value) {
            this._order = value;
            this._onChangeCallback();
        }
        set(x, y, z, order = this._order) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order;
            this._onChangeCallback();
            return this;
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(euler) {
            this._x = euler._x;
            this._y = euler._y;
            this._z = euler._z;
            this._order = euler._order;
            this._onChangeCallback();
            return this;
        }
        setFromRotationMatrix(m, order = this._order, update = true) {
            const te = m.elements;
            const m11 = te[0], m12 = te[4], m13 = te[8];
            const m21 = te[1], m22 = te[5], m23 = te[9];
            const m31 = te[2], m32 = te[6], m33 = te[10];
            switch (order) {
                case 'XYZ':
                    this._y = Math.asin(clamp$1(m13, -1, 1));
                    if (Math.abs(m13) < 0.9999999) {
                        this._x = Math.atan2(- m23, m33);
                        this._z = Math.atan2(- m12, m11);
                    } else {
                        this._x = Math.atan2(m32, m22);
                        this._z = 0;
                    }
                    break;
                case 'YXZ':
                    this._x = Math.asin(- clamp$1(m23, -1, 1));
                    if (Math.abs(m23) < 0.9999999) {
                        this._y = Math.atan2(m13, m33);
                        this._z = Math.atan2(m21, m22);
                    } else {
                        this._y = Math.atan2(- m31, m11);
                        this._z = 0;
                    }
                    break;
                case 'ZXY':
                    this._x = Math.asin(clamp$1(m32, -1, 1));
                    if (Math.abs(m32) < 0.9999999) {
                        this._y = Math.atan2(- m31, m33);
                        this._z = Math.atan2(- m12, m22);
                    } else {
                        this._y = 0;
                        this._z = Math.atan2(m21, m11);
                    }
                    break;
                case 'ZYX':
                    this._y = Math.asin(- clamp$1(m31, -1, 1));
                    if (Math.abs(m31) < 0.9999999) {
                        this._x = Math.atan2(m32, m33);
                        this._z = Math.atan2(m21, m11);
                    } else {
                        this._x = 0;
                        this._z = Math.atan2(- m12, m22);
                    }
                    break;
                case 'YZX':
                    this._z = Math.asin(clamp$1(m21, -1, 1));
                    if (Math.abs(m21) < 0.9999999) {
                        this._x = Math.atan2(- m23, m22);
                        this._y = Math.atan2(- m31, m11);
                    } else {
                        this._x = 0;
                        this._y = Math.atan2(m13, m33);
                    }
                    break;
                case 'XZY':
                    this._z = Math.asin(- clamp$1(m12, -1, 1));
                    if (Math.abs(m12) < 0.9999999) {
                        this._x = Math.atan2(m32, m22);
                        this._y = Math.atan2(m13, m11);
                    } else {
                        this._x = Math.atan2(- m23, m33);
                        this._y = 0;
                    }
                    break;
                default:
                    console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
            }
            this._order = order;
            if (update === true) this._onChangeCallback();
            return this;
        }
        setFromQuaternion(q, order, update) {
            _matrix$2.makeRotationFromQuaternion(q);
            return this.setFromRotationMatrix(_matrix$2, order, update);
        }
        setFromVector3(v, order = this._order) {
            return this.set(v.x, v.y, v.z, order);
        }
        reorder(newOrder) {
            _quaternion$3.setFromEuler(this);
            return this.setFromQuaternion(_quaternion$3, newOrder);
        }
        equals(euler) {
            return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
        }
        fromArray(array) {
            this._x = array[0];
            this._y = array[1];
            this._z = array[2];
            if (array[3] !== undefined) this._order = array[3];
            this._onChangeCallback();
            return this;
        }
        toArray(array = [], offset = 0) {
            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._order;
            return array;
        }
        _onChange(callback) {
            this._onChangeCallback = callback;
            return this;
        }
        _onChangeCallback() { }
        *[Symbol.iterator]() {
            yield this._x;
            yield this._y;
            yield this._z;
            yield this._order;
        }
    }
    Euler.DEFAULT_ORDER = 'XYZ';
    class Layers {
        constructor() {
            this.mask = 1 | 0;
        }
        set(layer) {
            this.mask = (1 << layer | 0) >>> 0;
        }
        enable(layer) {
            this.mask |= 1 << layer | 0;
        }
        enableAll() {
            this.mask = 0xffffffff | 0;
        }
        toggle(layer) {
            this.mask ^= 1 << layer | 0;
        }
        disable(layer) {
            this.mask &= ~(1 << layer | 0);
        }
        disableAll() {
            this.mask = 0;
        }
        test(layers) {
            return (this.mask & layers.mask) !== 0;
        }
        isEnabled(layer) {
            return (this.mask & (1 << layer | 0)) !== 0;
        }
    }
    let _object3DId = 0;
    const _v1$4 = /*@__PURE__*/ new Vector3();
    const _q1 = /*@__PURE__*/ new Quaternion();
    const _m1$1 = /*@__PURE__*/ new Matrix4();
    const _target = /*@__PURE__*/ new Vector3();
    const _position$3 = /*@__PURE__*/ new Vector3();
    const _scale$2 = /*@__PURE__*/ new Vector3();
    const _quaternion$2 = /*@__PURE__*/ new Quaternion();
    const _xAxis = /*@__PURE__*/ new Vector3(1, 0, 0);
    const _yAxis = /*@__PURE__*/ new Vector3(0, 1, 0);
    const _zAxis = /*@__PURE__*/ new Vector3(0, 0, 1);
    const _addedEvent = { type: 'added' };
    const _removedEvent = { type: 'removed' };
    const _childaddedEvent = { type: 'childadded', child: null };
    const _childremovedEvent = { type: 'childremoved', child: null };
    class Object3D extends EventDispatcher {
        constructor() {
            super();
            this.isObject3D = true;
            Object.defineProperty(this, 'id', { value: _object3DId++ });
            this.uuid = generateUUID();
            this.name = '';
            this.type = 'Object3D';
            this.parent = null;
            this.children = [];
            this.up = Object3D.DEFAULT_UP.clone();
            const position = new Vector3();
            const rotation = new Euler();
            const quaternion = new Quaternion();
            const scale = new Vector3(1, 1, 1);
            function onRotationChange() {
                quaternion.setFromEuler(rotation, false);
            }
            function onQuaternionChange() {
                rotation.setFromQuaternion(quaternion, undefined, false);
            }
            rotation._onChange(onRotationChange);
            quaternion._onChange(onQuaternionChange);
            Object.defineProperties(this, {
                position: {
                    configurable: true,
                    enumerable: true,
                    value: position
                },
                rotation: {
                    configurable: true,
                    enumerable: true,
                    value: rotation
                },
                quaternion: {
                    configurable: true,
                    enumerable: true,
                    value: quaternion
                },
                scale: {
                    configurable: true,
                    enumerable: true,
                    value: scale
                },
                modelViewMatrix: {
                    value: new Matrix4()
                },
                normalMatrix: {
                    value: new Matrix3()
                }
            });
            this.matrix = new Matrix4();
            this.matrixWorld = new Matrix4();
            this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
            this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer
            this.matrixWorldNeedsUpdate = false;
            this.layers = new Layers();
            this.visible = true;
            this.castShadow = false;
            this.receiveShadow = false;
            this.frustumCulled = true;
            this.renderOrder = 0;
            this.animations = [];
            this.customDepthMaterial = undefined;
            this.customDistanceMaterial = undefined;
            this.userData = {};
        }
        onBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) { }
        onAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) { }
        onBeforeRender( /* renderer, scene, camera, geometry, material, group */) { }
        onAfterRender( /* renderer, scene, camera, geometry, material, group */) { }
        applyMatrix4(matrix) {
            if (this.matrixAutoUpdate) this.updateMatrix();
            this.matrix.premultiply(matrix);
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(q) {
            this.quaternion.premultiply(q);
            return this;
        }
        setRotationFromAxisAngle(axis, angle) {
            // assumes axis is normalized
            this.quaternion.setFromAxisAngle(axis, angle);
        }
        setRotationFromEuler(euler) {
            this.quaternion.setFromEuler(euler, true);
        }
        setRotationFromMatrix(m) {
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            this.quaternion.setFromRotationMatrix(m);
        }
        setRotationFromQuaternion(q) {
            // assumes q is normalized
            this.quaternion.copy(q);
        }
        rotateOnAxis(axis, angle) {
            // rotate object on axis in object space
            // axis is assumed to be normalized
            _q1.setFromAxisAngle(axis, angle);
            this.quaternion.multiply(_q1);
            return this;
        }
        rotateOnWorldAxis(axis, angle) {
            // rotate object on axis in world space
            // axis is assumed to be normalized
            // method assumes no rotated parent
            _q1.setFromAxisAngle(axis, angle);
            this.quaternion.premultiply(_q1);
            return this;
        }
        rotateX(angle) {
            return this.rotateOnAxis(_xAxis, angle);
        }
        rotateY(angle) {
            return this.rotateOnAxis(_yAxis, angle);
        }
        rotateZ(angle) {
            return this.rotateOnAxis(_zAxis, angle);
        }
        translateOnAxis(axis, distance) {
            // translate object by distance along axis in object space
            // axis is assumed to be normalized
            _v1$4.copy(axis).applyQuaternion(this.quaternion);
            this.position.add(_v1$4.multiplyScalar(distance));
            return this;
        }
        translateX(distance) {
            return this.translateOnAxis(_xAxis, distance);
        }
        translateY(distance) {
            return this.translateOnAxis(_yAxis, distance);
        }
        translateZ(distance) {
            return this.translateOnAxis(_zAxis, distance);
        }
        localToWorld(vector) {
            this.updateWorldMatrix(true, false);
            return vector.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(vector) {
            this.updateWorldMatrix(true, false);
            return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
        }
        lookAt(x, y, z) {
            // This method does not support objects having non-uniformly-scaled parent(s)
            if (x.isVector3) {
                _target.copy(x);
            } else {
                _target.set(x, y, z);
            }
            const parent = this.parent;
            this.updateWorldMatrix(true, false);
            _position$3.setFromMatrixPosition(this.matrixWorld);
            if (this.isCamera || this.isLight) {
                _m1$1.lookAt(_position$3, _target, this.up);
            } else {
                _m1$1.lookAt(_target, _position$3, this.up);
            }
            this.quaternion.setFromRotationMatrix(_m1$1);
            if (parent) {
                _m1$1.extractRotation(parent.matrixWorld);
                _q1.setFromRotationMatrix(_m1$1);
                this.quaternion.premultiply(_q1.invert());
            }
        }
        add(object) {
            if (arguments.length > 1) {
                for (let i = 0; i < arguments.length; i++) {
                    this.add(arguments[i]);
                }
                return this;
            }
            if (object === this) {
                console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
                return this;
            }
            if (object && object.isObject3D) {
                object.removeFromParent();
                object.parent = this;
                this.children.push(object);
                object.dispatchEvent(_addedEvent);
                _childaddedEvent.child = object;
                this.dispatchEvent(_childaddedEvent);
                _childaddedEvent.child = null;
            } else {
                console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
            }
            return this;
        }
        remove(object) {
            if (arguments.length > 1) {
                for (let i = 0; i < arguments.length; i++) {
                    this.remove(arguments[i]);
                }
                return this;
            }
            const index = this.children.indexOf(object);
            if (index !== -1) {
                object.parent = null;
                this.children.splice(index, 1);
                object.dispatchEvent(_removedEvent);
                _childremovedEvent.child = object;
                this.dispatchEvent(_childremovedEvent);
                _childremovedEvent.child = null;
            }
            return this;
        }
        removeFromParent() {
            const parent = this.parent;
            if (parent !== null) {
                parent.remove(this);
            }
            return this;
        }
        clear() {
            return this.remove(... this.children);
        }
        attach(object) {
            // adds object as a child of this, while maintaining the object's world transform
            // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
            this.updateWorldMatrix(true, false);
            _m1$1.copy(this.matrixWorld).invert();
            if (object.parent !== null) {
                object.parent.updateWorldMatrix(true, false);
                _m1$1.multiply(object.parent.matrixWorld);
            }
            object.applyMatrix4(_m1$1);
            object.removeFromParent();
            object.parent = this;
            this.children.push(object);
            object.updateWorldMatrix(false, true);
            object.dispatchEvent(_addedEvent);
            _childaddedEvent.child = object;
            this.dispatchEvent(_childaddedEvent);
            _childaddedEvent.child = null;
            return this;
        }
        getObjectById(id) {
            return this.getObjectByProperty('id', id);
        }
        getObjectByName(name) {
            return this.getObjectByProperty('name', name);
        }
        getObjectByProperty(name, value) {
            if (this[name] === value) return this;
            for (let i = 0, l = this.children.length; i < l; i++) {
                const child = this.children[i];
                const object = child.getObjectByProperty(name, value);
                if (object !== undefined) {
                    return object;
                }
            }
            return undefined;
        }
        getObjectsByProperty(name, value, result = []) {
            if (this[name] === value) result.push(this);
            const children = this.children;
            for (let i = 0, l = children.length; i < l; i++) {
                children[i].getObjectsByProperty(name, value, result);
            }
            return result;
        }
        getWorldPosition(target) {
            this.updateWorldMatrix(true, false);
            return target.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(target) {
            this.updateWorldMatrix(true, false);
            this.matrixWorld.decompose(_position$3, target, _scale$2);
            return target;
        }
        getWorldScale(target) {
            this.updateWorldMatrix(true, false);
            this.matrixWorld.decompose(_position$3, _quaternion$2, target);
            return target;
        }
        getWorldDirection(target) {
            this.updateWorldMatrix(true, false);
            const e = this.matrixWorld.elements;
            return target.set(e[8], e[9], e[10]).normalize();
        }
        raycast( /* raycaster, intersects */) { }
        traverse(callback) {
            callback(this);
            const children = this.children;
            for (let i = 0, l = children.length; i < l; i++) {
                children[i].traverse(callback);
            }
        }
        traverseVisible(callback) {
            if (this.visible === false) return;
            callback(this);
            const children = this.children;
            for (let i = 0, l = children.length; i < l; i++) {
                children[i].traverseVisible(callback);
            }
        }
        traverseAncestors(callback) {
            const parent = this.parent;
            if (parent !== null) {
                callback(parent);
                parent.traverseAncestors(callback);
            }
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale);
            this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(force) {
            if (this.matrixAutoUpdate) this.updateMatrix();
            if (this.matrixWorldNeedsUpdate || force) {
                if (this.matrixWorldAutoUpdate === true) {
                    if (this.parent === null) {
                        this.matrixWorld.copy(this.matrix);
                    } else {
                        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                    }
                }
                this.matrixWorldNeedsUpdate = false;
                force = true;
            }
            // make sure descendants are updated if required
            const children = this.children;
            for (let i = 0, l = children.length; i < l; i++) {
                const child = children[i];
                child.updateMatrixWorld(force);
            }
        }
        updateWorldMatrix(updateParents, updateChildren) {
            const parent = this.parent;
            if (updateParents === true && parent !== null) {
                parent.updateWorldMatrix(true, false);
            }
            if (this.matrixAutoUpdate) this.updateMatrix();
            if (this.matrixWorldAutoUpdate === true) {
                if (this.parent === null) {
                    this.matrixWorld.copy(this.matrix);
                } else {
                    this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                }
            }
            // make sure descendants are updated
            if (updateChildren === true) {
                const children = this.children;
                for (let i = 0, l = children.length; i < l; i++) {
                    const child = children[i];
                    child.updateWorldMatrix(false, true);
                }
            }
        }
        toJSON(meta) {
            // meta is a string when called from JSON.stringify
            const isRootObject = (meta === undefined || typeof meta === 'string');
            const output = {};
            // meta is a hash used to collect geometries, materials.
            // not providing it implies that this is the root object
            // being serialized.
            if (isRootObject) {
                // initialize meta obj
                meta = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                };
                output.metadata = {
                    version: 4.7,
                    type: 'Object',
                    generator: 'Object3D.toJSON'
                };
            }
            // standard Object3D serialization
            const object = {};
            object.uuid = this.uuid;
            object.type = this.type;
            if (this.name !== '') object.name = this.name;
            if (this.castShadow === true) object.castShadow = true;
            if (this.receiveShadow === true) object.receiveShadow = true;
            if (this.visible === false) object.visible = false;
            if (this.frustumCulled === false) object.frustumCulled = false;
            if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
            if (Object.keys(this.userData).length > 0) object.userData = this.userData;
            object.layers = this.layers.mask;
            object.matrix = this.matrix.toArray();
            object.up = this.up.toArray();
            if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
            // object specific properties
            if (this.isInstancedMesh) {
                object.type = 'InstancedMesh';
                object.count = this.count;
                object.instanceMatrix = this.instanceMatrix.toJSON();
                if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
            }
            if (this.isBatchedMesh) {
                object.type = 'BatchedMesh';
                object.perObjectFrustumCulled = this.perObjectFrustumCulled;
                object.sortObjects = this.sortObjects;
                object.drawRanges = this._drawRanges;
                object.reservedRanges = this._reservedRanges;
                object.geometryInfo = this._geometryInfo.map(info => ({
                    ...info,
                    boundingBox: info.boundingBox ? info.boundingBox.toJSON() : undefined,
                    boundingSphere: info.boundingSphere ? info.boundingSphere.toJSON() : undefined
                }));
                object.instanceInfo = this._instanceInfo.map(info => ({ ...info }));
                object.availableInstanceIds = this._availableInstanceIds.slice();
                object.availableGeometryIds = this._availableGeometryIds.slice();
                object.nextIndexStart = this._nextIndexStart;
                object.nextVertexStart = this._nextVertexStart;
                object.geometryCount = this._geometryCount;
                object.maxInstanceCount = this._maxInstanceCount;
                object.maxVertexCount = this._maxVertexCount;
                object.maxIndexCount = this._maxIndexCount;
                object.geometryInitialized = this._geometryInitialized;
                object.matricesTexture = this._matricesTexture.toJSON(meta);
                object.indirectTexture = this._indirectTexture.toJSON(meta);
                if (this._colorsTexture !== null) {
                    object.colorsTexture = this._colorsTexture.toJSON(meta);
                }
                if (this.boundingSphere !== null) {
                    object.boundingSphere = this.boundingSphere.toJSON();
                }
                if (this.boundingBox !== null) {
                    object.boundingBox = this.boundingBox.toJSON();
                }
            }
            //
            function serialize(library, element) {
                if (library[element.uuid] === undefined) {
                    library[element.uuid] = element.toJSON(meta);
                }
                return element.uuid;
            }
            if (this.isScene) {
                if (this.background) {
                    if (this.background.isColor) {
                        object.background = this.background.toJSON();
                    } else if (this.background.isTexture) {
                        object.background = this.background.toJSON(meta).uuid;
                    }
                }
                if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
                    object.environment = this.environment.toJSON(meta).uuid;
                }
            } else if (this.isMesh || this.isLine || this.isPoints) {
                object.geometry = serialize(meta.geometries, this.geometry);
                const parameters = this.geometry.parameters;
                if (parameters !== undefined && parameters.shapes !== undefined) {
                    const shapes = parameters.shapes;
                    if (Array.isArray(shapes)) {
                        for (let i = 0, l = shapes.length; i < l; i++) {
                            const shape = shapes[i];
                            serialize(meta.shapes, shape);
                        }
                    } else {
                        serialize(meta.shapes, shapes);
                    }
                }
            }
            if (this.isSkinnedMesh) {
                object.bindMode = this.bindMode;
                object.bindMatrix = this.bindMatrix.toArray();
                if (this.skeleton !== undefined) {
                    serialize(meta.skeletons, this.skeleton);
                    object.skeleton = this.skeleton.uuid;
                }
            }
            if (this.material !== undefined) {
                if (Array.isArray(this.material)) {
                    const uuids = [];
                    for (let i = 0, l = this.material.length; i < l; i++) {
                        uuids.push(serialize(meta.materials, this.material[i]));
                    }
                    object.material = uuids;
                } else {
                    object.material = serialize(meta.materials, this.material);
                }
            }
            //
            if (this.children.length > 0) {
                object.children = [];
                for (let i = 0; i < this.children.length; i++) {
                    object.children.push(this.children[i].toJSON(meta).object);
                }
            }
            //
            if (this.animations.length > 0) {
                object.animations = [];
                for (let i = 0; i < this.animations.length; i++) {
                    const animation = this.animations[i];
                    object.animations.push(serialize(meta.animations, animation));
                }
            }
            if (isRootObject) {
                const geometries = extractFromCache(meta.geometries);
                const materials = extractFromCache(meta.materials);
                const textures = extractFromCache(meta.textures);
                const images = extractFromCache(meta.images);
                const shapes = extractFromCache(meta.shapes);
                const skeletons = extractFromCache(meta.skeletons);
                const animations = extractFromCache(meta.animations);
                const nodes = extractFromCache(meta.nodes);
                if (geometries.length > 0) output.geometries = geometries;
                if (materials.length > 0) output.materials = materials;
                if (textures.length > 0) output.textures = textures;
                if (images.length > 0) output.images = images;
                if (shapes.length > 0) output.shapes = shapes;
                if (skeletons.length > 0) output.skeletons = skeletons;
                if (animations.length > 0) output.animations = animations;
                if (nodes.length > 0) output.nodes = nodes;
            }
            output.object = object;
            return output;
            // extract data from the cache hash
            // remove metadata on each item
            // and return as array
            function extractFromCache(cache) {
                const values = [];
                for (const key in cache) {
                    const data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
        }
        clone(recursive) {
            return new this.constructor().copy(this, recursive);
        }
        copy(source, recursive = true) {
            this.name = source.name;
            this.up.copy(source.up);
            this.position.copy(source.position);
            this.rotation.order = source.rotation.order;
            this.quaternion.copy(source.quaternion);
            this.scale.copy(source.scale);
            this.matrix.copy(source.matrix);
            this.matrixWorld.copy(source.matrixWorld);
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
            this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
            this.layers.mask = source.layers.mask;
            this.visible = source.visible;
            this.castShadow = source.castShadow;
            this.receiveShadow = source.receiveShadow;
            this.frustumCulled = source.frustumCulled;
            this.renderOrder = source.renderOrder;
            this.animations = source.animations.slice();
            this.userData = JSON.parse(JSON.stringify(source.userData));
            if (recursive === true) {
                for (let i = 0; i < source.children.length; i++) {
                    const child = source.children[i];
                    this.add(child.clone());
                }
            }
            return this;
        }
    }
    Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3(0, 1, 0);
    Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
    Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
    const _v0$1 = /*@__PURE__*/ new Vector3();
    const _v1$3 = /*@__PURE__*/ new Vector3();
    const _v2$2 = /*@__PURE__*/ new Vector3();
    const _v3$2 = /*@__PURE__*/ new Vector3();
    const _vab = /*@__PURE__*/ new Vector3();
    const _vac = /*@__PURE__*/ new Vector3();
    const _vbc = /*@__PURE__*/ new Vector3();
    const _vap = /*@__PURE__*/ new Vector3();
    const _vbp = /*@__PURE__*/ new Vector3();
    const _vcp = /*@__PURE__*/ new Vector3();
    const _v40 = /*@__PURE__*/ new Vector4();
    const _v41 = /*@__PURE__*/ new Vector4();
    const _v42 = /*@__PURE__*/ new Vector4();
    class Triangle {
        constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
            this.a = a;
            this.b = b;
            this.c = c;
        }
        static getNormal(a, b, c, target) {
            target.subVectors(c, b);
            _v0$1.subVectors(a, b);
            target.cross(_v0$1);
            const targetLengthSq = target.lengthSq();
            if (targetLengthSq > 0) {
                return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
            }
            return target.set(0, 0, 0);
        }
        static getBarycoord(point, a, b, c, target) {
            // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
            _v0$1.subVectors(c, a);
            _v1$3.subVectors(b, a);
            _v2$2.subVectors(point, a);
            const dot00 = _v0$1.dot(_v0$1);
            const dot01 = _v0$1.dot(_v1$3);
            const dot02 = _v0$1.dot(_v2$2);
            const dot11 = _v1$3.dot(_v1$3);
            const dot12 = _v1$3.dot(_v2$2);
            const denom = (dot00 * dot11 - dot01 * dot01);
            // collinear or singular triangle
            if (denom === 0) {
                target.set(0, 0, 0);
                return null;
            }
            const invDenom = 1 / denom;
            const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
            const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
            // barycentric coordinates must always sum to 1
            return target.set(1 - u - v, v, u);
        }
        static containsPoint(point, a, b, c) {
            // if the triangle is degenerate then we can't contain a point
            if (this.getBarycoord(point, a, b, c, _v3$2) === null) {
                return false;
            }
            return (_v3$2.x >= 0) && (_v3$2.y >= 0) && ((_v3$2.x + _v3$2.y) <= 1);
        }
        static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
            if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
                target.x = 0;
                target.y = 0;
                if ('z' in target) target.z = 0;
                if ('w' in target) target.w = 0;
                return null;
            }
            target.setScalar(0);
            target.addScaledVector(v1, _v3$2.x);
            target.addScaledVector(v2, _v3$2.y);
            target.addScaledVector(v3, _v3$2.z);
            return target;
        }
        static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {
            _v40.setScalar(0);
            _v41.setScalar(0);
            _v42.setScalar(0);
            _v40.fromBufferAttribute(attr, i1);
            _v41.fromBufferAttribute(attr, i2);
            _v42.fromBufferAttribute(attr, i3);
            target.setScalar(0);
            target.addScaledVector(_v40, barycoord.x);
            target.addScaledVector(_v41, barycoord.y);
            target.addScaledVector(_v42, barycoord.z);
            return target;
        }
        static isFrontFacing(a, b, c, direction) {
            _v0$1.subVectors(c, b);
            _v1$3.subVectors(a, b);
            // strictly front facing
            return (_v0$1.cross(_v1$3).dot(direction) < 0) ? true : false;
        }
        set(a, b, c) {
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this;
        }
        setFromPointsAndIndices(points, i0, i1, i2) {
            this.a.copy(points[i0]);
            this.b.copy(points[i1]);
            this.c.copy(points[i2]);
            return this;
        }
        setFromAttributeAndIndices(attribute, i0, i1, i2) {
            this.a.fromBufferAttribute(attribute, i0);
            this.b.fromBufferAttribute(attribute, i1);
            this.c.fromBufferAttribute(attribute, i2);
            return this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(triangle) {
            this.a.copy(triangle.a);
            this.b.copy(triangle.b);
            this.c.copy(triangle.c);
            return this;
        }
        getArea() {
            _v0$1.subVectors(this.c, this.b);
            _v1$3.subVectors(this.a, this.b);
            return _v0$1.cross(_v1$3).length() * 0.5;
        }
        getMidpoint(target) {
            return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(target) {
            return Triangle.getNormal(this.a, this.b, this.c, target);
        }
        getPlane(target) {
            return target.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(point, target) {
            return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
        }
        getInterpolation(point, v1, v2, v3, target) {
            return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
        }
        containsPoint(point) {
            return Triangle.containsPoint(point, this.a, this.b, this.c);
        }
        isFrontFacing(direction) {
            return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
        }
        intersectsBox(box) {
            return box.intersectsTriangle(this);
        }
        closestPointToPoint(p, target) {
            const a = this.a, b = this.b, c = this.c;
            let v, w;
            // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
            // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
            // under the accompanying license; see chapter 5.1.5 for detailed explanation.
            // basically, we're distinguishing which of the voronoi regions of the triangle
            // the point lies in with the minimum amount of redundant computation.
            _vab.subVectors(b, a);
            _vac.subVectors(c, a);
            _vap.subVectors(p, a);
            const d1 = _vab.dot(_vap);
            const d2 = _vac.dot(_vap);
            if (d1 <= 0 && d2 <= 0) {
                // vertex region of A; barycentric coords (1, 0, 0)
                return target.copy(a);
            }
            _vbp.subVectors(p, b);
            const d3 = _vab.dot(_vbp);
            const d4 = _vac.dot(_vbp);
            if (d3 >= 0 && d4 <= d3) {
                // vertex region of B; barycentric coords (0, 1, 0)
                return target.copy(b);
            }
            const vc = d1 * d4 - d3 * d2;
            if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                v = d1 / (d1 - d3);
                // edge region of AB; barycentric coords (1-v, v, 0)
                return target.copy(a).addScaledVector(_vab, v);
            }
            _vcp.subVectors(p, c);
            const d5 = _vab.dot(_vcp);
            const d6 = _vac.dot(_vcp);
            if (d6 >= 0 && d5 <= d6) {
                // vertex region of C; barycentric coords (0, 0, 1)
                return target.copy(c);
            }
            const vb = d5 * d2 - d1 * d6;
            if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                w = d2 / (d2 - d6);
                // edge region of AC; barycentric coords (1-w, 0, w)
                return target.copy(a).addScaledVector(_vac, w);
            }
            const va = d3 * d6 - d5 * d4;
            if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
                _vbc.subVectors(c, b);
                w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                // edge region of BC; barycentric coords (0, 1-w, w)
                return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
            }
            // face region
            const denom = 1 / (va + vb + vc);
            // u = va * denom
            v = vb * denom;
            w = vc * denom;
            return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
        }
        equals(triangle) {
            return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
    }
    const _colorKeywords = {
        'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
        'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
        'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
        'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
        'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
        'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
        'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
        'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
        'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
        'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
        'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
        'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
        'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
        'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
        'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
        'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
        'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
        'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
        'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
        'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
        'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
        'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
        'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
        'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32
    };
    const _hslA = { h: 0, s: 0, l: 0 };
    const _hslB = { h: 0, s: 0, l: 0 };
    function hue2rgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
        return p;
    }
    class Color {
        constructor(r, g, b) {
            this.isColor = true;
            this.r = 1;
            this.g = 1;
            this.b = 1;
            return this.set(r, g, b);
        }
        set(r, g, b) {
            if (g === undefined && b === undefined) {
                // r is THREE.Color, hex or string
                const value = r;
                if (value && value.isColor) {
                    this.copy(value);
                } else if (typeof value === 'number') {
                    this.setHex(value);
                } else if (typeof value === 'string') {
                    this.setStyle(value);
                }
            } else {
                this.setRGB(r, g, b);
            }
            return this;
        }
        setScalar(scalar) {
            this.r = scalar;
            this.g = scalar;
            this.b = scalar;
            return this;
        }
        setHex(hex, colorSpace = SRGBColorSpace) {
            hex = Math.floor(hex);
            this.r = (hex >> 16 & 255) / 255;
            this.g = (hex >> 8 & 255) / 255;
            this.b = (hex & 255) / 255;
            ColorManagement.colorSpaceToWorking(this, colorSpace);
            return this;
        }
        setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
            this.r = r;
            this.g = g;
            this.b = b;
            ColorManagement.colorSpaceToWorking(this, colorSpace);
            return this;
        }
        setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
            // h,s,l ranges are in 0.0 - 1.0
            h = euclideanModulo(h, 1);
            s = clamp$1(s, 0, 1);
            l = clamp$1(l, 0, 1);
            if (s === 0) {
                this.r = this.g = this.b = l;
            } else {
                const p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
                const q = (2 * l) - p;
                this.r = hue2rgb(q, p, h + 1 / 3);
                this.g = hue2rgb(q, p, h);
                this.b = hue2rgb(q, p, h - 1 / 3);
            }
            ColorManagement.colorSpaceToWorking(this, colorSpace);
            return this;
        }
        setStyle(style, colorSpace = SRGBColorSpace) {
            function handleAlpha(string) {
                if (string === undefined) return;
                if (parseFloat(string) < 1) {
                    console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
                }
            }

            let m;
            if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
                // rgb / hsl
                let color;
                const name = m[1];
                const components = m[2];
                switch (name) {
                    case 'rgb':
                    case 'rgba':
                        if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                            // rgb(255,0,0) rgba(255,0,0,0.5)
                            handleAlpha(color[4]);
                            return this.setRGB(
                                Math.min(255, parseInt(color[1], 10)) / 255,
                                Math.min(255, parseInt(color[2], 10)) / 255,
                                Math.min(255, parseInt(color[3], 10)) / 255,
                                colorSpace
                            );
                        }
                        if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                            handleAlpha(color[4]);
                            return this.setRGB(
                                Math.min(100, parseInt(color[1], 10)) / 100,
                                Math.min(100, parseInt(color[2], 10)) / 100,
                                Math.min(100, parseInt(color[3], 10)) / 100,
                                colorSpace
                            );
                        }
                        break;
                    case 'hsl':
                    case 'hsla':
                        if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                            handleAlpha(color[4]);
                            return this.setHSL(
                                parseFloat(color[1]) / 360,
                                parseFloat(color[2]) / 100,
                                parseFloat(color[3]) / 100,
                                colorSpace
                            );
                        }
                        break;
                    default:
                        console.warn('THREE.Color: Unknown color model ' + style);
                }
            } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
                // hex color
                const hex = m[1];
                const size = hex.length;
                if (size === 3) {
                    // #ff0
                    return this.setRGB(
                        parseInt(hex.charAt(0), 16) / 15,
                        parseInt(hex.charAt(1), 16) / 15,
                        parseInt(hex.charAt(2), 16) / 15,
                        colorSpace
                    );
                } else if (size === 6) {
                    // #ff0000
                    return this.setHex(parseInt(hex, 16), colorSpace);
                } else {
                    console.warn('THREE.Color: Invalid hex color ' + style);
                }
            } else if (style && style.length > 0) {
                return this.setColorName(style, colorSpace);
            }
            return this;
        }
        setColorName(style, colorSpace = SRGBColorSpace) {
            // color keywords
            const hex = _colorKeywords[style.toLowerCase()];
            if (hex !== undefined) {
                // red
                this.setHex(hex, colorSpace);
            } else {
                // unknown color
                console.warn('THREE.Color: Unknown color ' + style);
            }
            return this;
        }
        clone() {
            return new this.constructor(this.r, this.g, this.b);
        }
        copy(color) {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
            return this;
        }
        copySRGBToLinear(color) {
            this.r = SRGBToLinear(color.r);
            this.g = SRGBToLinear(color.g);
            this.b = SRGBToLinear(color.b);
            return this;
        }
        copyLinearToSRGB(color) {
            this.r = LinearToSRGB(color.r);
            this.g = LinearToSRGB(color.g);
            this.b = LinearToSRGB(color.b);
            return this;
        }
        convertSRGBToLinear() {
            this.copySRGBToLinear(this);
            return this;
        }
        convertLinearToSRGB() {
            this.copyLinearToSRGB(this);
            return this;
        }
        getHex(colorSpace = SRGBColorSpace) {
            ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
            return Math.round(clamp$1(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp$1(_color.g * 255, 0, 255)) * 256 + Math.round(clamp$1(_color.b * 255, 0, 255));
        }
        getHexString(colorSpace = SRGBColorSpace) {
            return ('000000' + this.getHex(colorSpace).toString(16)).slice(-6);
        }
        getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
            // h,s,l ranges are in 0.0 - 1.0
            ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
            const r = _color.r, g = _color.g, b = _color.b;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let hue, saturation;
            const lightness = (min + max) / 2.0;
            if (min === max) {
                hue = 0;
                saturation = 0;
            } else {
                const delta = max - min;
                saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
                switch (max) {
                    case r: hue = (g - b) / delta + (g < b ? 6 : 0); break;
                    case g: hue = (b - r) / delta + 2; break;
                    case b: hue = (r - g) / delta + 4; break;
                }
                hue /= 6;
            }
            target.h = hue;
            target.s = saturation;
            target.l = lightness;
            return target;
        }
        getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
            ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
            target.r = _color.r;
            target.g = _color.g;
            target.b = _color.b;
            return target;
        }
        getStyle(colorSpace = SRGBColorSpace) {
            ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
            const r = _color.r, g = _color.g, b = _color.b;
            if (colorSpace !== SRGBColorSpace) {
                // Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
                return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;
            }
            return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;
        }
        offsetHSL(h, s, l) {
            this.getHSL(_hslA);
            return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
        }
        add(color) {
            this.r += color.r;
            this.g += color.g;
            this.b += color.b;
            return this;
        }
        addColors(color1, color2) {
            this.r = color1.r + color2.r;
            this.g = color1.g + color2.g;
            this.b = color1.b + color2.b;
            return this;
        }
        addScalar(s) {
            this.r += s;
            this.g += s;
            this.b += s;
            return this;
        }
        sub(color) {
            this.r = Math.max(0, this.r - color.r);
            this.g = Math.max(0, this.g - color.g);
            this.b = Math.max(0, this.b - color.b);
            return this;
        }
        multiply(color) {
            this.r *= color.r;
            this.g *= color.g;
            this.b *= color.b;
            return this;
        }
        multiplyScalar(s) {
            this.r *= s;
            this.g *= s;
            this.b *= s;
            return this;
        }
        lerp(color, alpha) {
            this.r += (color.r - this.r) * alpha;
            this.g += (color.g - this.g) * alpha;
            this.b += (color.b - this.b) * alpha;
            return this;
        }
        lerpColors(color1, color2, alpha) {
            this.r = color1.r + (color2.r - color1.r) * alpha;
            this.g = color1.g + (color2.g - color1.g) * alpha;
            this.b = color1.b + (color2.b - color1.b) * alpha;
            return this;
        }
        lerpHSL(color, alpha) {
            this.getHSL(_hslA);
            color.getHSL(_hslB);
            const h = lerp(_hslA.h, _hslB.h, alpha);
            const s = lerp(_hslA.s, _hslB.s, alpha);
            const l = lerp(_hslA.l, _hslB.l, alpha);
            this.setHSL(h, s, l);
            return this;
        }
        setFromVector3(v) {
            this.r = v.x;
            this.g = v.y;
            this.b = v.z;
            return this;
        }
        applyMatrix3(m) {
            const r = this.r, g = this.g, b = this.b;
            const e = m.elements;
            this.r = e[0] * r + e[3] * g + e[6] * b;
            this.g = e[1] * r + e[4] * g + e[7] * b;
            this.b = e[2] * r + e[5] * g + e[8] * b;
            return this;
        }
        equals(c) {
            return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
        }
        fromArray(array, offset = 0) {
            this.r = array[offset];
            this.g = array[offset + 1];
            this.b = array[offset + 2];
            return this;
        }
        toArray(array = [], offset = 0) {
            array[offset] = this.r;
            array[offset + 1] = this.g;
            array[offset + 2] = this.b;
            return array;
        }
        fromBufferAttribute(attribute, index) {
            this.r = attribute.getX(index);
            this.g = attribute.getY(index);
            this.b = attribute.getZ(index);
            return this;
        }
        toJSON() {
            return this.getHex();
        }
        *[Symbol.iterator]() {
            yield this.r;
            yield this.g;
            yield this.b;
        }
    }
    const _color = /*@__PURE__*/ new Color();
    Color.NAMES = _colorKeywords;
    let _materialId = 0;
    class Material extends EventDispatcher {
        constructor() {
            super();
            this.isMaterial = true;
            Object.defineProperty(this, 'id', { value: _materialId++ });
            this.uuid = generateUUID();
            this.name = '';
            this.type = 'Material';
            this.blending = NormalBlending;
            this.side = FrontSide;
            this.vertexColors = false;
            this.opacity = 1;
            this.transparent = false;
            this.alphaHash = false;
            this.blendSrc = SrcAlphaFactor;
            this.blendDst = OneMinusSrcAlphaFactor;
            this.blendEquation = AddEquation;
            this.blendSrcAlpha = null;
            this.blendDstAlpha = null;
            this.blendEquationAlpha = null;
            this.blendColor = new Color(0, 0, 0);
            this.blendAlpha = 0;
            this.depthFunc = LessEqualDepth;
            this.depthTest = true;
            this.depthWrite = true;
            this.stencilWriteMask = 0xff;
            this.stencilFunc = AlwaysStencilFunc;
            this.stencilRef = 0;
            this.stencilFuncMask = 0xff;
            this.stencilFail = KeepStencilOp;
            this.stencilZFail = KeepStencilOp;
            this.stencilZPass = KeepStencilOp;
            this.stencilWrite = false;
            this.clippingPlanes = null;
            this.clipIntersection = false;
            this.clipShadows = false;
            this.shadowSide = null;
            this.colorWrite = true;
            this.precision = null;
            this.polygonOffset = false;
            this.polygonOffsetFactor = 0;
            this.polygonOffsetUnits = 0;
            this.dithering = false;
            this.alphaToCoverage = false;
            this.premultipliedAlpha = false;
            this.forceSinglePass = false;
            this.allowOverride = true;
            this.visible = true;
            this.toneMapped = true;
            this.userData = {};
            this.version = 0;
            this._alphaTest = 0;
        }
        get alphaTest() {
            return this._alphaTest;
        }
        set alphaTest(value) {
            if (this._alphaTest > 0 !== value > 0) {
                this.version++;
            }
            this._alphaTest = value;
        }
        onBeforeRender( /* renderer, scene, camera, geometry, object, group */) { }
        onBeforeCompile( /* shaderobject, renderer */) { }
        customProgramCacheKey() {
            return this.onBeforeCompile.toString();
        }
        setValues(values) {
            if (values === undefined) return;
            for (const key in values) {
                const newValue = values[key];
                if (newValue === undefined) {
                    console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
                    continue;
                }
                const currentValue = this[key];
                if (currentValue === undefined) {
                    console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
                    continue;
                }
                if (currentValue && currentValue.isColor) {
                    currentValue.set(newValue);
                } else if ((currentValue && currentValue.isVector3) && (newValue && newValue.isVector3)) {
                    currentValue.copy(newValue);
                } else {
                    this[key] = newValue;
                }
            }
        }
        toJSON(meta) {
            const isRootObject = (meta === undefined || typeof meta === 'string');
            if (isRootObject) {
                meta = {
                    textures: {},
                    images: {}
                };
            }
            const data = {
                metadata: {
                    version: 4.7,
                    type: 'Material',
                    generator: 'Material.toJSON'
                }
            };
            // standard Material serialization
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '') data.name = this.name;
            if (this.color && this.color.isColor) data.color = this.color.getHex();
            if (this.roughness !== undefined) data.roughness = this.roughness;
            if (this.metalness !== undefined) data.metalness = this.metalness;
            if (this.sheen !== undefined) data.sheen = this.sheen;
            if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
            if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;
            if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
            if (this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
            if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
            if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;
            if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
            if (this.shininess !== undefined) data.shininess = this.shininess;
            if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
            if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
            if (this.clearcoatMap && this.clearcoatMap.isTexture) {
                data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
            }
            if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
                data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
            }
            if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
                data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
                data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
            }
            if (this.dispersion !== undefined) data.dispersion = this.dispersion;
            if (this.iridescence !== undefined) data.iridescence = this.iridescence;
            if (this.iridescenceIOR !== undefined) data.iridescenceIOR = this.iridescenceIOR;
            if (this.iridescenceThicknessRange !== undefined) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
            if (this.iridescenceMap && this.iridescenceMap.isTexture) {
                data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
            }
            if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
                data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
            }
            if (this.anisotropy !== undefined) data.anisotropy = this.anisotropy;
            if (this.anisotropyRotation !== undefined) data.anisotropyRotation = this.anisotropyRotation;
            if (this.anisotropyMap && this.anisotropyMap.isTexture) {
                data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
            }
            if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
            if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
            if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
            if (this.lightMap && this.lightMap.isTexture) {
                data.lightMap = this.lightMap.toJSON(meta).uuid;
                data.lightMapIntensity = this.lightMapIntensity;
            }
            if (this.aoMap && this.aoMap.isTexture) {
                data.aoMap = this.aoMap.toJSON(meta).uuid;
                data.aoMapIntensity = this.aoMapIntensity;
            }
            if (this.bumpMap && this.bumpMap.isTexture) {
                data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                data.bumpScale = this.bumpScale;
            }
            if (this.normalMap && this.normalMap.isTexture) {
                data.normalMap = this.normalMap.toJSON(meta).uuid;
                data.normalMapType = this.normalMapType;
                data.normalScale = this.normalScale.toArray();
            }
            if (this.displacementMap && this.displacementMap.isTexture) {
                data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                data.displacementScale = this.displacementScale;
                data.displacementBias = this.displacementBias;
            }
            if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
            if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
            if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
            if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
            if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
            if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
            if (this.envMap && this.envMap.isTexture) {
                data.envMap = this.envMap.toJSON(meta).uuid;
                if (this.combine !== undefined) data.combine = this.combine;
            }
            if (this.envMapRotation !== undefined) data.envMapRotation = this.envMapRotation.toArray();
            if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
            if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
            if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;
            if (this.gradientMap && this.gradientMap.isTexture) {
                data.gradientMap = this.gradientMap.toJSON(meta).uuid;
            }
            if (this.transmission !== undefined) data.transmission = this.transmission;
            if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
            if (this.thickness !== undefined) data.thickness = this.thickness;
            if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
            if (this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
            if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();
            if (this.size !== undefined) data.size = this.size;
            if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
            if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
            if (this.blending !== NormalBlending) data.blending = this.blending;
            if (this.side !== FrontSide) data.side = this.side;
            if (this.vertexColors === true) data.vertexColors = true;
            if (this.opacity < 1) data.opacity = this.opacity;
            if (this.transparent === true) data.transparent = true;
            if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
            if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
            if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
            if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
            if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
            if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
            if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
            if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
            if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
            if (this.depthTest === false) data.depthTest = this.depthTest;
            if (this.depthWrite === false) data.depthWrite = this.depthWrite;
            if (this.colorWrite === false) data.colorWrite = this.colorWrite;
            if (this.stencilWriteMask !== 0xff) data.stencilWriteMask = this.stencilWriteMask;
            if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
            if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
            if (this.stencilFuncMask !== 0xff) data.stencilFuncMask = this.stencilFuncMask;
            if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
            if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
            if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
            if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;
            // rotation (SpriteMaterial)
            if (this.rotation !== undefined && this.rotation !== 0) data.rotation = this.rotation;
            if (this.polygonOffset === true) data.polygonOffset = true;
            if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
            if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
            if (this.linewidth !== undefined && this.linewidth !== 1) data.linewidth = this.linewidth;
            if (this.dashSize !== undefined) data.dashSize = this.dashSize;
            if (this.gapSize !== undefined) data.gapSize = this.gapSize;
            if (this.scale !== undefined) data.scale = this.scale;
            if (this.dithering === true) data.dithering = true;
            if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
            if (this.alphaHash === true) data.alphaHash = true;
            if (this.alphaToCoverage === true) data.alphaToCoverage = true;
            if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
            if (this.forceSinglePass === true) data.forceSinglePass = true;
            if (this.wireframe === true) data.wireframe = true;
            if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
            if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
            if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
            if (this.flatShading === true) data.flatShading = true;
            if (this.visible === false) data.visible = false;
            if (this.toneMapped === false) data.toneMapped = false;
            if (this.fog === false) data.fog = false;
            if (Object.keys(this.userData).length > 0) data.userData = this.userData;
            // TODO: Copied from Object3D.toJSON
            function extractFromCache(cache) {
                const values = [];
                for (const key in cache) {
                    const data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
            if (isRootObject) {
                const textures = extractFromCache(meta.textures);
                const images = extractFromCache(meta.images);
                if (textures.length > 0) data.textures = textures;
                if (images.length > 0) data.images = images;
            }
            return data;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(source) {
            this.name = source.name;
            this.blending = source.blending;
            this.side = source.side;
            this.vertexColors = source.vertexColors;
            this.opacity = source.opacity;
            this.transparent = source.transparent;
            this.blendSrc = source.blendSrc;
            this.blendDst = source.blendDst;
            this.blendEquation = source.blendEquation;
            this.blendSrcAlpha = source.blendSrcAlpha;
            this.blendDstAlpha = source.blendDstAlpha;
            this.blendEquationAlpha = source.blendEquationAlpha;
            this.blendColor.copy(source.blendColor);
            this.blendAlpha = source.blendAlpha;
            this.depthFunc = source.depthFunc;
            this.depthTest = source.depthTest;
            this.depthWrite = source.depthWrite;
            this.stencilWriteMask = source.stencilWriteMask;
            this.stencilFunc = source.stencilFunc;
            this.stencilRef = source.stencilRef;
            this.stencilFuncMask = source.stencilFuncMask;
            this.stencilFail = source.stencilFail;
            this.stencilZFail = source.stencilZFail;
            this.stencilZPass = source.stencilZPass;
            this.stencilWrite = source.stencilWrite;
            const srcPlanes = source.clippingPlanes;
            let dstPlanes = null;
            if (srcPlanes !== null) {
                const n = srcPlanes.length;
                dstPlanes = new Array(n);
                for (let i = 0; i !== n; ++i) {
                    dstPlanes[i] = srcPlanes[i].clone();
                }
            }
            this.clippingPlanes = dstPlanes;
            this.clipIntersection = source.clipIntersection;
            this.clipShadows = source.clipShadows;
            this.shadowSide = source.shadowSide;
            this.colorWrite = source.colorWrite;
            this.precision = source.precision;
            this.polygonOffset = source.polygonOffset;
            this.polygonOffsetFactor = source.polygonOffsetFactor;
            this.polygonOffsetUnits = source.polygonOffsetUnits;
            this.dithering = source.dithering;
            this.alphaTest = source.alphaTest;
            this.alphaHash = source.alphaHash;
            this.alphaToCoverage = source.alphaToCoverage;
            this.premultipliedAlpha = source.premultipliedAlpha;
            this.forceSinglePass = source.forceSinglePass;
            this.visible = source.visible;
            this.toneMapped = source.toneMapped;
            this.userData = JSON.parse(JSON.stringify(source.userData));
            return this;
        }
        dispose() {
            this.dispatchEvent({ type: 'dispose' });
        }
        set needsUpdate(value) {
            if (value === true) this.version++;
        }
    }
    class MeshBasicMaterial extends Material {
        constructor(parameters) {
            super();
            this.isMeshBasicMaterial = true;
            this.type = 'MeshBasicMaterial';
            this.color = new Color(0xffffff); // diffuse
            this.map = null;
            this.lightMap = null;
            this.lightMapIntensity = 1.0;
            this.aoMap = null;
            this.aoMapIntensity = 1.0;
            this.specularMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.envMapRotation = new Euler();
            this.combine = MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = 0.98;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';
            this.fog = true;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.specularMap = source.specularMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.envMapRotation.copy(source.envMapRotation);
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.fog = source.fog;
            return this;
        }
    }
    // Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
    const _tables = /*@__PURE__*/ _generateTables();
    function _generateTables() {
        // float32 to float16 helpers
        const buffer = new ArrayBuffer(4);
        const floatView = new Float32Array(buffer);
        const uint32View = new Uint32Array(buffer);
        const baseTable = new Uint32Array(512);
        const shiftTable = new Uint32Array(512);
        for (let i = 0; i < 256; ++i) {
            const e = i - 127;
            // very small number (0, -0)
            if (e < -27) {
                baseTable[i] = 0x0000;
                baseTable[i | 0x100] = 0x8000;
                shiftTable[i] = 24;
                shiftTable[i | 0x100] = 24;
                // small number (denorm)
            } else if (e < -14) {
                baseTable[i] = 0x0400 >> (- e - 14);
                baseTable[i | 0x100] = (0x0400 >> (- e - 14)) | 0x8000;
                shiftTable[i] = - e - 1;
                shiftTable[i | 0x100] = - e - 1;
                // normal number
            } else if (e <= 15) {
                baseTable[i] = (e + 15) << 10;
                baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;
                shiftTable[i] = 13;
                shiftTable[i | 0x100] = 13;
                // large number (Infinity, -Infinity)
            } else if (e < 128) {
                baseTable[i] = 0x7c00;
                baseTable[i | 0x100] = 0xfc00;
                shiftTable[i] = 24;
                shiftTable[i | 0x100] = 24;
                // stay (NaN, Infinity, -Infinity)
            } else {
                baseTable[i] = 0x7c00;
                baseTable[i | 0x100] = 0xfc00;
                shiftTable[i] = 13;
                shiftTable[i | 0x100] = 13;
            }
        }
        // float16 to float32 helpers
        const mantissaTable = new Uint32Array(2048);
        const exponentTable = new Uint32Array(64);
        const offsetTable = new Uint32Array(64);
        for (let i = 1; i < 1024; ++i) {
            let m = i << 13; // zero pad mantissa bits
            let e = 0; // zero exponent
            // normalized
            while ((m & 0x00800000) === 0) {
                m <<= 1;
                e -= 0x00800000; // decrement exponent
            }
            m &= -8388609; // clear leading 1 bit
            e += 0x38800000; // adjust bias
            mantissaTable[i] = m | e;
        }
        for (let i = 1024; i < 2048; ++i) {
            mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);
        }
        for (let i = 1; i < 31; ++i) {
            exponentTable[i] = i << 23;
        }
        exponentTable[31] = 0x47800000;
        exponentTable[32] = 0x80000000;
        for (let i = 33; i < 63; ++i) {
            exponentTable[i] = 0x80000000 + ((i - 32) << 23);
        }
        exponentTable[63] = 0xc7800000;
        for (let i = 1; i < 64; ++i) {
            if (i !== 32) {
                offsetTable[i] = 1024;
            }
        }
        return {
            floatView: floatView,
            uint32View: uint32View,
            baseTable: baseTable,
            shiftTable: shiftTable,
            mantissaTable: mantissaTable,
            exponentTable: exponentTable,
            offsetTable: offsetTable
        };
    }
    function toHalfFloat(val) {
        if (Math.abs(val) > 65504) console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.');
        val = clamp$1(val, -65504, 65504);
        _tables.floatView[0] = val;
        const f = _tables.uint32View[0];
        const e = (f >> 23) & 0x1ff;
        return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e]);
    }
    function fromHalfFloat(val) {
        const m = val >> 10;
        _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] + _tables.exponentTable[m];
        return _tables.floatView[0];
    }
    class DataUtils {
        static toHalfFloat(val) {
            return toHalfFloat(val);
        }
        static fromHalfFloat(val) {
            return fromHalfFloat(val);
        }
    }
    const _vector$9 = /*@__PURE__*/ new Vector3();
    const _vector2$1 = /*@__PURE__*/ new Vector2();
    let _id$2 = 0;
    class BufferAttribute {
        constructor(array, itemSize, normalized = false) {
            if (Array.isArray(array)) {
                throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
            }
            this.isBufferAttribute = true;
            Object.defineProperty(this, 'id', { value: _id$2++ });
            this.name = '';
            this.array = array;
            this.itemSize = itemSize;
            this.count = array !== undefined ? array.length / itemSize : 0;
            this.normalized = normalized;
            this.usage = StaticDrawUsage;
            this.updateRanges = [];
            this.gpuType = FloatType;
            this.version = 0;
        }
        onUploadCallback() { }
        set needsUpdate(value) {
            if (value === true) this.version++;
        }
        setUsage(value) {
            this.usage = value;
            return this;
        }
        addUpdateRange(start, count) {
            this.updateRanges.push({ start, count });
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0;
        }
        copy(source) {
            this.name = source.name;
            this.array = new source.array.constructor(source.array);
            this.itemSize = source.itemSize;
            this.count = source.count;
            this.normalized = source.normalized;
            this.usage = source.usage;
            this.gpuType = source.gpuType;
            return this;
        }
        copyAt(index1, attribute, index2) {
            index1 *= this.itemSize;
            index2 *= attribute.itemSize;
            for (let i = 0, l = this.itemSize; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
            }
            return this;
        }
        copyArray(array) {
            this.array.set(array);
            return this;
        }
        applyMatrix3(m) {
            if (this.itemSize === 2) {
                for (let i = 0, l = this.count; i < l; i++) {
                    _vector2$1.fromBufferAttribute(this, i);
                    _vector2$1.applyMatrix3(m);
                    this.setXY(i, _vector2$1.x, _vector2$1.y);
                }
            } else if (this.itemSize === 3) {
                for (let i = 0, l = this.count; i < l; i++) {
                    _vector$9.fromBufferAttribute(this, i);
                    _vector$9.applyMatrix3(m);
                    this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
                }
            }
            return this;
        }
        applyMatrix4(m) {
            for (let i = 0, l = this.count; i < l; i++) {
                _vector$9.fromBufferAttribute(this, i);
                _vector$9.applyMatrix4(m);
                this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
            }
            return this;
        }
        applyNormalMatrix(m) {
            for (let i = 0, l = this.count; i < l; i++) {
                _vector$9.fromBufferAttribute(this, i);
                _vector$9.applyNormalMatrix(m);
                this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
            }
            return this;
        }
        transformDirection(m) {
            for (let i = 0, l = this.count; i < l; i++) {
                _vector$9.fromBufferAttribute(this, i);
                _vector$9.transformDirection(m);
                this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
            }
            return this;
        }
        set(value, offset = 0) {
            // Matching BufferAttribute constructor, do not normalize the array.
            this.array.set(value, offset);
            return this;
        }
        getComponent(index, component) {
            let value = this.array[index * this.itemSize + component];
            if (this.normalized) value = denormalize(value, this.array);
            return value;
        }
        setComponent(index, component, value) {
            if (this.normalized) value = normalize$1(value, this.array);
            this.array[index * this.itemSize + component] = value;
            return this;
        }
        getX(index) {
            let x = this.array[index * this.itemSize];
            if (this.normalized) x = denormalize(x, this.array);
            return x;
        }
        setX(index, x) {
            if (this.normalized) x = normalize$1(x, this.array);
            this.array[index * this.itemSize] = x;
            return this;
        }
        getY(index) {
            let y = this.array[index * this.itemSize + 1];
            if (this.normalized) y = denormalize(y, this.array);
            return y;
        }
        setY(index, y) {
            if (this.normalized) y = normalize$1(y, this.array);
            this.array[index * this.itemSize + 1] = y;
            return this;
        }
        getZ(index) {
            let z = this.array[index * this.itemSize + 2];
            if (this.normalized) z = denormalize(z, this.array);
            return z;
        }
        setZ(index, z) {
            if (this.normalized) z = normalize$1(z, this.array);
            this.array[index * this.itemSize + 2] = z;
            return this;
        }
        getW(index) {
            let w = this.array[index * this.itemSize + 3];
            if (this.normalized) w = denormalize(w, this.array);
            return w;
        }
        setW(index, w) {
            if (this.normalized) w = normalize$1(w, this.array);
            this.array[index * this.itemSize + 3] = w;
            return this;
        }
        setXY(index, x, y) {
            index *= this.itemSize;
            if (this.normalized) {
                x = normalize$1(x, this.array);
                y = normalize$1(y, this.array);
            }
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            return this;
        }
        setXYZ(index, x, y, z) {
            index *= this.itemSize;
            if (this.normalized) {
                x = normalize$1(x, this.array);
                y = normalize$1(y, this.array);
                z = normalize$1(z, this.array);
            }
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            return this;
        }
        setXYZW(index, x, y, z, w) {
            index *= this.itemSize;
            if (this.normalized) {
                x = normalize$1(x, this.array);
                y = normalize$1(y, this.array);
                z = normalize$1(z, this.array);
                w = normalize$1(w, this.array);
            }
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            this.array[index + 3] = w;
            return this;
        }
        onUpload(callback) {
            this.onUploadCallback = callback;
            return this;
        }
        clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
            const data = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.from(this.array),
                normalized: this.normalized
            };
            if (this.name !== '') data.name = this.name;
            if (this.usage !== StaticDrawUsage) data.usage = this.usage;
            return data;
        }
    }
    class Int8BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Int8Array(array), itemSize, normalized);
        }
    }
    class Uint8BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Uint8Array(array), itemSize, normalized);
        }
    }
    class Uint8ClampedBufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Uint8ClampedArray(array), itemSize, normalized);
        }
    }
    class Int16BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Int16Array(array), itemSize, normalized);
        }
    }
    class Uint16BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Uint16Array(array), itemSize, normalized);
        }
    }
    class Int32BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Int32Array(array), itemSize, normalized);
        }
    }
    class Uint32BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Uint32Array(array), itemSize, normalized);
        }
    }
    class Float16BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Uint16Array(array), itemSize, normalized);
            this.isFloat16BufferAttribute = true;
        }
        getX(index) {
            let x = fromHalfFloat(this.array[index * this.itemSize]);
            if (this.normalized) x = denormalize(x, this.array);
            return x;
        }
        setX(index, x) {
            if (this.normalized) x = normalize$1(x, this.array);
            this.array[index * this.itemSize] = toHalfFloat(x);
            return this;
        }
        getY(index) {
            let y = fromHalfFloat(this.array[index * this.itemSize + 1]);
            if (this.normalized) y = denormalize(y, this.array);
            return y;
        }
        setY(index, y) {
            if (this.normalized) y = normalize$1(y, this.array);
            this.array[index * this.itemSize + 1] = toHalfFloat(y);
            return this;
        }
        getZ(index) {
            let z = fromHalfFloat(this.array[index * this.itemSize + 2]);
            if (this.normalized) z = denormalize(z, this.array);
            return z;
        }
        setZ(index, z) {
            if (this.normalized) z = normalize$1(z, this.array);
            this.array[index * this.itemSize + 2] = toHalfFloat(z);
            return this;
        }
        getW(index) {
            let w = fromHalfFloat(this.array[index * this.itemSize + 3]);
            if (this.normalized) w = denormalize(w, this.array);
            return w;
        }
        setW(index, w) {
            if (this.normalized) w = normalize$1(w, this.array);
            this.array[index * this.itemSize + 3] = toHalfFloat(w);
            return this;
        }
        setXY(index, x, y) {
            index *= this.itemSize;
            if (this.normalized) {
                x = normalize$1(x, this.array);
                y = normalize$1(y, this.array);
            }
            this.array[index + 0] = toHalfFloat(x);
            this.array[index + 1] = toHalfFloat(y);
            return this;
        }
        setXYZ(index, x, y, z) {
            index *= this.itemSize;
            if (this.normalized) {
                x = normalize$1(x, this.array);
                y = normalize$1(y, this.array);
                z = normalize$1(z, this.array);
            }
            this.array[index + 0] = toHalfFloat(x);
            this.array[index + 1] = toHalfFloat(y);
            this.array[index + 2] = toHalfFloat(z);
            return this;
        }
        setXYZW(index, x, y, z, w) {
            index *= this.itemSize;
            if (this.normalized) {
                x = normalize$1(x, this.array);
                y = normalize$1(y, this.array);
                z = normalize$1(z, this.array);
                w = normalize$1(w, this.array);
            }
            this.array[index + 0] = toHalfFloat(x);
            this.array[index + 1] = toHalfFloat(y);
            this.array[index + 2] = toHalfFloat(z);
            this.array[index + 3] = toHalfFloat(w);
            return this;
        }
    }
    class Float32BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Float32Array(array), itemSize, normalized);
        }
    }
    let _id$1 = 0;
    const _m1 = /*@__PURE__*/ new Matrix4();
    const _obj = /*@__PURE__*/ new Object3D();
    const _offset = /*@__PURE__*/ new Vector3();
    const _box$2 = /*@__PURE__*/ new Box3();
    const _boxMorphTargets = /*@__PURE__*/ new Box3();
    const _vector$8 = /*@__PURE__*/ new Vector3();
    class BufferGeometry extends EventDispatcher {
        constructor() {
            super();
            this.isBufferGeometry = true;
            Object.defineProperty(this, 'id', { value: _id$1++ });
            this.uuid = generateUUID();
            this.name = '';
            this.type = 'BufferGeometry';
            this.index = null;
            this.indirect = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.morphTargetsRelative = false;
            this.groups = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.drawRange = { start: 0, count: Infinity };
            this.userData = {};
        }
        getIndex() {
            return this.index;
        }
        setIndex(index) {
            if (Array.isArray(index)) {
                this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
            } else {
                this.index = index;
            }
            return this;
        }
        setIndirect(indirect) {
            this.indirect = indirect;
            return this;
        }
        getIndirect() {
            return this.indirect;
        }
        getAttribute(name) {
            return this.attributes[name];
        }
        setAttribute(name, attribute) {
            this.attributes[name] = attribute;
            return this;
        }
        deleteAttribute(name) {
            delete this.attributes[name];
            return this;
        }
        hasAttribute(name) {
            return this.attributes[name] !== undefined;
        }
        addGroup(start, count, materialIndex = 0) {
            this.groups.push({
                start: start,
                count: count,
                materialIndex: materialIndex
            });
        }
        clearGroups() {
            this.groups = [];
        }
        setDrawRange(start, count) {
            this.drawRange.start = start;
            this.drawRange.count = count;
        }
        applyMatrix4(matrix) {
            const position = this.attributes.position;
            if (position !== undefined) {
                position.applyMatrix4(matrix);
                position.needsUpdate = true;
            }
            const normal = this.attributes.normal;
            if (normal !== undefined) {
                const normalMatrix = new Matrix3().getNormalMatrix(matrix);
                normal.applyNormalMatrix(normalMatrix);
                normal.needsUpdate = true;
            }
            const tangent = this.attributes.tangent;
            if (tangent !== undefined) {
                tangent.transformDirection(matrix);
                tangent.needsUpdate = true;
            }
            if (this.boundingBox !== null) {
                this.computeBoundingBox();
            }
            if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
            }
            return this;
        }
        applyQuaternion(q) {
            _m1.makeRotationFromQuaternion(q);
            this.applyMatrix4(_m1);
            return this;
        }
        rotateX(angle) {
            // rotate geometry around world x-axis
            _m1.makeRotationX(angle);
            this.applyMatrix4(_m1);
            return this;
        }
        rotateY(angle) {
            // rotate geometry around world y-axis
            _m1.makeRotationY(angle);
            this.applyMatrix4(_m1);
            return this;
        }
        rotateZ(angle) {
            // rotate geometry around world z-axis
            _m1.makeRotationZ(angle);
            this.applyMatrix4(_m1);
            return this;
        }
        translate(x, y, z) {
            // translate geometry
            _m1.makeTranslation(x, y, z);
            this.applyMatrix4(_m1);
            return this;
        }
        scale(x, y, z) {
            // scale geometry
            _m1.makeScale(x, y, z);
            this.applyMatrix4(_m1);
            return this;
        }
        lookAt(vector) {
            _obj.lookAt(vector);
            _obj.updateMatrix();
            this.applyMatrix4(_obj.matrix);
            return this;
        }
        center() {
            this.computeBoundingBox();
            this.boundingBox.getCenter(_offset).negate();
            this.translate(_offset.x, _offset.y, _offset.z);
            return this;
        }
        setFromPoints(points) {
            const positionAttribute = this.getAttribute('position');
            if (positionAttribute === undefined) {
                const position = [];
                for (let i = 0, l = points.length; i < l; i++) {
                    const point = points[i];
                    position.push(point.x, point.y, point.z || 0);
                }
                this.setAttribute('position', new Float32BufferAttribute(position, 3));
            } else {
                const l = Math.min(points.length, positionAttribute.count); // make sure data do not exceed buffer size
                for (let i = 0; i < l; i++) {
                    const point = points[i];
                    positionAttribute.setXYZ(i, point.x, point.y, point.z || 0);
                }
                if (points.length > positionAttribute.count) {
                    console.warn('THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.');
                }
                positionAttribute.needsUpdate = true;
            }
            return this;
        }
        computeBoundingBox() {
            if (this.boundingBox === null) {
                this.boundingBox = new Box3();
            }
            const position = this.attributes.position;
            const morphAttributesPosition = this.morphAttributes.position;
            if (position && position.isGLBufferAttribute) {
                console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this);
                this.boundingBox.set(
                    new Vector3(- Infinity, - Infinity, - Infinity),
                    new Vector3(+ Infinity, + Infinity, + Infinity)
                );
                return;
            }
            if (position !== undefined) {
                this.boundingBox.setFromBufferAttribute(position);
                // process morph attributes if present
                if (morphAttributesPosition) {
                    for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                        const morphAttribute = morphAttributesPosition[i];
                        _box$2.setFromBufferAttribute(morphAttribute);
                        if (this.morphTargetsRelative) {
                            _vector$8.addVectors(this.boundingBox.min, _box$2.min);
                            this.boundingBox.expandByPoint(_vector$8);
                            _vector$8.addVectors(this.boundingBox.max, _box$2.max);
                            this.boundingBox.expandByPoint(_vector$8);
                        } else {
                            this.boundingBox.expandByPoint(_box$2.min);
                            this.boundingBox.expandByPoint(_box$2.max);
                        }
                    }
                }
            } else {
                this.boundingBox.makeEmpty();
            }
            if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
                console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
            }
        }
        computeBoundingSphere() {
            if (this.boundingSphere === null) {
                this.boundingSphere = new Sphere();
            }
            const position = this.attributes.position;
            const morphAttributesPosition = this.morphAttributes.position;
            if (position && position.isGLBufferAttribute) {
                console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this);
                this.boundingSphere.set(new Vector3(), Infinity);
                return;
            }
            if (position) {
                // first, find the center of the bounding sphere
                const center = this.boundingSphere.center;
                _box$2.setFromBufferAttribute(position);
                // process morph attributes if present
                if (morphAttributesPosition) {
                    for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                        const morphAttribute = morphAttributesPosition[i];
                        _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                        if (this.morphTargetsRelative) {
                            _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
                            _box$2.expandByPoint(_vector$8);
                            _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
                            _box$2.expandByPoint(_vector$8);
                        } else {
                            _box$2.expandByPoint(_boxMorphTargets.min);
                            _box$2.expandByPoint(_boxMorphTargets.max);
                        }
                    }
                }
                _box$2.getCenter(center);
                // second, try to find a boundingSphere with a radius smaller than the
                // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
                let maxRadiusSq = 0;
                for (let i = 0, il = position.count; i < il; i++) {
                    _vector$8.fromBufferAttribute(position, i);
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
                }
                // process morph attributes if present
                if (morphAttributesPosition) {
                    for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                        const morphAttribute = morphAttributesPosition[i];
                        const morphTargetsRelative = this.morphTargetsRelative;
                        for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
                            _vector$8.fromBufferAttribute(morphAttribute, j);
                            if (morphTargetsRelative) {
                                _offset.fromBufferAttribute(position, j);
                                _vector$8.add(_offset);
                            }
                            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
                        }
                    }
                }
                this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                if (isNaN(this.boundingSphere.radius)) {
                    console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                }
            }
        }
        computeTangents() {
            const index = this.index;
            const attributes = this.attributes;
            // based on http://www.terathon.com/code/tangent.html
            // (per vertex tangents)
            if (index === null ||
                attributes.position === undefined ||
                attributes.normal === undefined ||
                attributes.uv === undefined) {
                console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
                return;
            }
            const positionAttribute = attributes.position;
            const normalAttribute = attributes.normal;
            const uvAttribute = attributes.uv;
            if (this.hasAttribute('tangent') === false) {
                this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
            }
            const tangentAttribute = this.getAttribute('tangent');
            const tan1 = [], tan2 = [];
            for (let i = 0; i < positionAttribute.count; i++) {
                tan1[i] = new Vector3();
                tan2[i] = new Vector3();
            }
            const vA = new Vector3(),
                vB = new Vector3(),
                vC = new Vector3(),
                uvA = new Vector2(),
                uvB = new Vector2(),
                uvC = new Vector2(),
                sdir = new Vector3(),
                tdir = new Vector3();
            function handleTriangle(a, b, c) {
                vA.fromBufferAttribute(positionAttribute, a);
                vB.fromBufferAttribute(positionAttribute, b);
                vC.fromBufferAttribute(positionAttribute, c);
                uvA.fromBufferAttribute(uvAttribute, a);
                uvB.fromBufferAttribute(uvAttribute, b);
                uvC.fromBufferAttribute(uvAttribute, c);
                vB.sub(vA);
                vC.sub(vA);
                uvB.sub(uvA);
                uvC.sub(uvA);
                const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);
                // silently ignore degenerate uv triangles having coincident or colinear vertices
                if (!isFinite(r)) return;
                sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, - uvB.y).multiplyScalar(r);
                tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, - uvC.x).multiplyScalar(r);
                tan1[a].add(sdir);
                tan1[b].add(sdir);
                tan1[c].add(sdir);
                tan2[a].add(tdir);
                tan2[b].add(tdir);
                tan2[c].add(tdir);
            }
            let groups = this.groups;
            if (groups.length === 0) {
                groups = [{
                    start: 0,
                    count: index.count
                }];
            }
            for (let i = 0, il = groups.length; i < il; ++i) {
                const group = groups[i];
                const start = group.start;
                const count = group.count;
                for (let j = start, jl = start + count; j < jl; j += 3) {
                    handleTriangle(
                        index.getX(j + 0),
                        index.getX(j + 1),
                        index.getX(j + 2)
                    );
                }
            }
            const tmp = new Vector3(), tmp2 = new Vector3();
            const n = new Vector3(), n2 = new Vector3();
            function handleVertex(v) {
                n.fromBufferAttribute(normalAttribute, v);
                n2.copy(n);
                const t = tan1[v];
                // Gram-Schmidt orthogonalize
                tmp.copy(t);
                tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
                // Calculate handedness
                tmp2.crossVectors(n2, t);
                const test = tmp2.dot(tan2[v]);
                const w = (test < 0.0) ? -1 : 1.0;
                tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);
            }
            for (let i = 0, il = groups.length; i < il; ++i) {
                const group = groups[i];
                const start = group.start;
                const count = group.count;
                for (let j = start, jl = start + count; j < jl; j += 3) {
                    handleVertex(index.getX(j + 0));
                    handleVertex(index.getX(j + 1));
                    handleVertex(index.getX(j + 2));
                }
            }
        }
        computeVertexNormals() {
            const index = this.index;
            const positionAttribute = this.getAttribute('position');
            if (positionAttribute !== undefined) {
                let normalAttribute = this.getAttribute('normal');
                if (normalAttribute === undefined) {
                    normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
                    this.setAttribute('normal', normalAttribute);
                } else {
                    // reset existing normals to zero
                    for (let i = 0, il = normalAttribute.count; i < il; i++) {
                        normalAttribute.setXYZ(i, 0, 0, 0);
                    }
                }
                const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
                const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
                const cb = new Vector3(), ab = new Vector3();
                // indexed elements
                if (index) {
                    for (let i = 0, il = index.count; i < il; i += 3) {
                        const vA = index.getX(i + 0);
                        const vB = index.getX(i + 1);
                        const vC = index.getX(i + 2);
                        pA.fromBufferAttribute(positionAttribute, vA);
                        pB.fromBufferAttribute(positionAttribute, vB);
                        pC.fromBufferAttribute(positionAttribute, vC);
                        cb.subVectors(pC, pB);
                        ab.subVectors(pA, pB);
                        cb.cross(ab);
                        nA.fromBufferAttribute(normalAttribute, vA);
                        nB.fromBufferAttribute(normalAttribute, vB);
                        nC.fromBufferAttribute(normalAttribute, vC);
                        nA.add(cb);
                        nB.add(cb);
                        nC.add(cb);
                        normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                        normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                        normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
                    }
                } else {
                    // non-indexed elements (unconnected triangle soup)
                    for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
                        pA.fromBufferAttribute(positionAttribute, i + 0);
                        pB.fromBufferAttribute(positionAttribute, i + 1);
                        pC.fromBufferAttribute(positionAttribute, i + 2);
                        cb.subVectors(pC, pB);
                        ab.subVectors(pA, pB);
                        cb.cross(ab);
                        normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
                        normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
                        normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
                    }
                }
                this.normalizeNormals();
                normalAttribute.needsUpdate = true;
            }
        }
        normalizeNormals() {
            const normals = this.attributes.normal;
            for (let i = 0, il = normals.count; i < il; i++) {
                _vector$8.fromBufferAttribute(normals, i);
                _vector$8.normalize();
                normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
            }
        }
        toNonIndexed() {
            function convertBufferAttribute(attribute, indices) {
                const array = attribute.array;
                const itemSize = attribute.itemSize;
                const normalized = attribute.normalized;
                const array2 = new array.constructor(indices.length * itemSize);
                let index = 0, index2 = 0;
                for (let i = 0, l = indices.length; i < l; i++) {
                    if (attribute.isInterleavedBufferAttribute) {
                        index = indices[i] * attribute.data.stride + attribute.offset;
                    } else {
                        index = indices[i] * itemSize;
                    }
                    for (let j = 0; j < itemSize; j++) {
                        array2[index2++] = array[index++];
                    }
                }
                return new BufferAttribute(array2, itemSize, normalized);
            }
            //
            if (this.index === null) {
                console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
                return this;
            }
            const geometry2 = new BufferGeometry();
            const indices = this.index.array;
            const attributes = this.attributes;
            // attributes
            for (const name in attributes) {
                const attribute = attributes[name];
                const newAttribute = convertBufferAttribute(attribute, indices);
                geometry2.setAttribute(name, newAttribute);
            }
            // morph attributes
            const morphAttributes = this.morphAttributes;
            for (const name in morphAttributes) {
                const morphArray = [];
                const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes
                for (let i = 0, il = morphAttribute.length; i < il; i++) {
                    const attribute = morphAttribute[i];
                    const newAttribute = convertBufferAttribute(attribute, indices);
                    morphArray.push(newAttribute);
                }
                geometry2.morphAttributes[name] = morphArray;
            }
            geometry2.morphTargetsRelative = this.morphTargetsRelative;
            // groups
            const groups = this.groups;
            for (let i = 0, l = groups.length; i < l; i++) {
                const group = groups[i];
                geometry2.addGroup(group.start, group.count, group.materialIndex);
            }
            return geometry2;
        }
        toJSON() {
            const data = {
                metadata: {
                    version: 4.7,
                    type: 'BufferGeometry',
                    generator: 'BufferGeometry.toJSON'
                }
            };
            // standard BufferGeometry serialization
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '') data.name = this.name;
            if (Object.keys(this.userData).length > 0) data.userData = this.userData;
            if (this.parameters !== undefined) {
                const parameters = this.parameters;
                for (const key in parameters) {
                    if (parameters[key] !== undefined) data[key] = parameters[key];
                }
                return data;
            }
            // for simplicity the code assumes attributes are not shared across geometries, see #15811
            data.data = { attributes: {} };
            const index = this.index;
            if (index !== null) {
                data.data.index = {
                    type: index.array.constructor.name,
                    array: Array.prototype.slice.call(index.array)
                };
            }
            const attributes = this.attributes;
            for (const key in attributes) {
                const attribute = attributes[key];
                data.data.attributes[key] = attribute.toJSON(data.data);
            }
            const morphAttributes = {};
            let hasMorphAttributes = false;
            for (const key in this.morphAttributes) {
                const attributeArray = this.morphAttributes[key];
                const array = [];
                for (let i = 0, il = attributeArray.length; i < il; i++) {
                    const attribute = attributeArray[i];
                    array.push(attribute.toJSON(data.data));
                }
                if (array.length > 0) {
                    morphAttributes[key] = array;
                    hasMorphAttributes = true;
                }
            }
            if (hasMorphAttributes) {
                data.data.morphAttributes = morphAttributes;
                data.data.morphTargetsRelative = this.morphTargetsRelative;
            }
            const groups = this.groups;
            if (groups.length > 0) {
                data.data.groups = JSON.parse(JSON.stringify(groups));
            }
            const boundingSphere = this.boundingSphere;
            if (boundingSphere !== null) {
                data.data.boundingSphere = boundingSphere.toJSON();
            }
            return data;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(source) {
            // reset
            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.groups = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            // used for storing cloned, shared data
            const data = {};
            // name
            this.name = source.name;
            // index
            const index = source.index;
            if (index !== null) {
                this.setIndex(index.clone());
            }
            // attributes
            const attributes = source.attributes;
            for (const name in attributes) {
                const attribute = attributes[name];
                this.setAttribute(name, attribute.clone(data));
            }
            // morph attributes
            const morphAttributes = source.morphAttributes;
            for (const name in morphAttributes) {
                const array = [];
                const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes
                for (let i = 0, l = morphAttribute.length; i < l; i++) {
                    array.push(morphAttribute[i].clone(data));
                }
                this.morphAttributes[name] = array;
            }
            this.morphTargetsRelative = source.morphTargetsRelative;
            // groups
            const groups = source.groups;
            for (let i = 0, l = groups.length; i < l; i++) {
                const group = groups[i];
                this.addGroup(group.start, group.count, group.materialIndex);
            }
            // bounding box
            const boundingBox = source.boundingBox;
            if (boundingBox !== null) {
                this.boundingBox = boundingBox.clone();
            }
            // bounding sphere
            const boundingSphere = source.boundingSphere;
            if (boundingSphere !== null) {
                this.boundingSphere = boundingSphere.clone();
            }
            // draw range
            this.drawRange.start = source.drawRange.start;
            this.drawRange.count = source.drawRange.count;
            // user data
            this.userData = source.userData;
            return this;
        }
        dispose() {
            this.dispatchEvent({ type: 'dispose' });
        }
    }
    const _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();
    const _ray$3 = /*@__PURE__*/ new Ray();
    const _sphere$6 = /*@__PURE__*/ new Sphere();
    const _sphereHitAt = /*@__PURE__*/ new Vector3();
    const _vA$1 = /*@__PURE__*/ new Vector3();
    const _vB$1 = /*@__PURE__*/ new Vector3();
    const _vC$1 = /*@__PURE__*/ new Vector3();
    const _tempA = /*@__PURE__*/ new Vector3();
    const _morphA = /*@__PURE__*/ new Vector3();
    const _intersectionPoint = /*@__PURE__*/ new Vector3();
    const _intersectionPointWorld = /*@__PURE__*/ new Vector3();
    class Mesh extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
            super();
            this.isMesh = true;
            this.type = 'Mesh';
            this.geometry = geometry;
            this.material = material;
            this.morphTargetDictionary = undefined;
            this.morphTargetInfluences = undefined;
            this.count = 1;
            this.updateMorphTargets();
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            if (source.morphTargetInfluences !== undefined) {
                this.morphTargetInfluences = source.morphTargetInfluences.slice();
            }
            if (source.morphTargetDictionary !== undefined) {
                this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
            }
            this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
            this.geometry = source.geometry;
            return this;
        }
        updateMorphTargets() {
            const geometry = this.geometry;
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        }
        getVertexPosition(index, target) {
            const geometry = this.geometry;
            const position = geometry.attributes.position;
            const morphPosition = geometry.morphAttributes.position;
            const morphTargetsRelative = geometry.morphTargetsRelative;
            target.fromBufferAttribute(position, index);
            const morphInfluences = this.morphTargetInfluences;
            if (morphPosition && morphInfluences) {
                _morphA.set(0, 0, 0);
                for (let i = 0, il = morphPosition.length; i < il; i++) {
                    const influence = morphInfluences[i];
                    const morphAttribute = morphPosition[i];
                    if (influence === 0) continue;
                    _tempA.fromBufferAttribute(morphAttribute, index);
                    if (morphTargetsRelative) {
                        _morphA.addScaledVector(_tempA, influence);
                    } else {
                        _morphA.addScaledVector(_tempA.sub(target), influence);
                    }
                }
                target.add(_morphA);
            }
            return target;
        }
        raycast(raycaster, intersects) {
            const geometry = this.geometry;
            const material = this.material;
            const matrixWorld = this.matrixWorld;
            if (material === undefined) return;
            // test with bounding sphere in world space
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            _sphere$6.copy(geometry.boundingSphere);
            _sphere$6.applyMatrix4(matrixWorld);
            // check distance from ray origin to bounding sphere
            _ray$3.copy(raycaster.ray).recast(raycaster.near);
            if (_sphere$6.containsPoint(_ray$3.origin) === false) {
                if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
                if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;
            }
            // convert ray to local space of mesh
            _inverseMatrix$3.copy(matrixWorld).invert();
            _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
            // test with bounding box in local space
            if (geometry.boundingBox !== null) {
                if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
            }
            // test for intersections with geometry
            this._computeIntersections(raycaster, intersects, _ray$3);
        }
        _computeIntersections(raycaster, intersects, rayLocalSpace) {
            let intersection;
            const geometry = this.geometry;
            const material = this.material;
            const index = geometry.index;
            const position = geometry.attributes.position;
            const uv = geometry.attributes.uv;
            const uv1 = geometry.attributes.uv1;
            const normal = geometry.attributes.normal;
            const groups = geometry.groups;
            const drawRange = geometry.drawRange;
            if (index !== null) {
                // indexed buffer geometry
                if (Array.isArray(material)) {
                    for (let i = 0, il = groups.length; i < il; i++) {
                        const group = groups[i];
                        const groupMaterial = material[group.materialIndex];
                        const start = Math.max(group.start, drawRange.start);
                        const end = Math.min(index.count, Math.min((group.start + group.count), (drawRange.start + drawRange.count)));
                        for (let j = start, jl = end; j < jl; j += 3) {
                            const a = index.getX(j);
                            const b = index.getX(j + 1);
                            const c = index.getX(j + 2);
                            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                                intersection.face.materialIndex = group.materialIndex;
                                intersects.push(intersection);
                            }
                        }
                    }
                } else {
                    const start = Math.max(0, drawRange.start);
                    const end = Math.min(index.count, (drawRange.start + drawRange.count));
                    for (let i = start, il = end; i < il; i += 3) {
                        const a = index.getX(i);
                        const b = index.getX(i + 1);
                        const c = index.getX(i + 2);
                        intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics
                            intersects.push(intersection);
                        }
                    }
                }
            } else if (position !== undefined) {
                // non-indexed buffer geometry
                if (Array.isArray(material)) {
                    for (let i = 0, il = groups.length; i < il; i++) {
                        const group = groups[i];
                        const groupMaterial = material[group.materialIndex];
                        const start = Math.max(group.start, drawRange.start);
                        const end = Math.min(position.count, Math.min((group.start + group.count), (drawRange.start + drawRange.count)));
                        for (let j = start, jl = end; j < jl; j += 3) {
                            const a = j;
                            const b = j + 1;
                            const c = j + 2;
                            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
                                intersection.face.materialIndex = group.materialIndex;
                                intersects.push(intersection);
                            }
                        }
                    }
                } else {
                    const start = Math.max(0, drawRange.start);
                    const end = Math.min(position.count, (drawRange.start + drawRange.count));
                    for (let i = start, il = end; i < il; i += 3) {
                        const a = i;
                        const b = i + 1;
                        const c = i + 2;
                        intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics
                            intersects.push(intersection);
                        }
                    }
                }
            }
        }
    }
    function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
        let intersect;
        if (material.side === BackSide) {
            intersect = ray.intersectTriangle(pC, pB, pA, true, point);
        } else {
            intersect = ray.intersectTriangle(pA, pB, pC, (material.side === FrontSide), point);
        }
        if (intersect === null) return null;
        _intersectionPointWorld.copy(point);
        _intersectionPointWorld.applyMatrix4(object.matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
        if (distance < raycaster.near || distance > raycaster.far) return null;
        return {
            distance: distance,
            point: _intersectionPointWorld.clone(),
            object: object
        };
    }
    function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {
        object.getVertexPosition(a, _vA$1);
        object.getVertexPosition(b, _vB$1);
        object.getVertexPosition(c, _vC$1);
        const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
        if (intersection) {
            const barycoord = new Vector3();
            Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);
            if (uv) {
                intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());
            }
            if (uv1) {
                intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());
            }
            if (normal) {
                intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());
                if (intersection.normal.dot(ray.direction) > 0) {
                    intersection.normal.multiplyScalar(-1);
                }
            }
            const face = {
                a: a,
                b: b,
                c: c,
                normal: new Vector3(),
                materialIndex: 0
            };
            Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
            intersection.face = face;
            intersection.barycoord = barycoord;
        }
        return intersection;
    }
    class BoxGeometry extends BufferGeometry {
        constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
            super();
            this.type = 'BoxGeometry';
            this.parameters = {
                width: width,
                height: height,
                depth: depth,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                depthSegments: depthSegments
            };
            const scope = this;
            // segments
            widthSegments = Math.floor(widthSegments);
            heightSegments = Math.floor(heightSegments);
            depthSegments = Math.floor(depthSegments);
            // buffers
            const indices = [];
            const vertices = [];
            const normals = [];
            const uvs = [];
            // helper variables
            let numberOfVertices = 0;
            let groupStart = 0;
            // build each side of the box geometry
            buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
            buildPlane('z', 'y', 'x', 1, -1, depth, height, - width, depthSegments, heightSegments, 1); // nx
            buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
            buildPlane('x', 'z', 'y', 1, -1, width, depth, - height, widthSegments, depthSegments, 3); // ny
            buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
            buildPlane('x', 'y', 'z', -1, -1, width, height, - depth, widthSegments, heightSegments, 5); // nz
            // build geometry
            this.setIndex(indices);
            this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
                const segmentWidth = width / gridX;
                const segmentHeight = height / gridY;
                const widthHalf = width / 2;
                const heightHalf = height / 2;
                const depthHalf = depth / 2;
                const gridX1 = gridX + 1;
                const gridY1 = gridY + 1;
                let vertexCounter = 0;
                let groupCount = 0;
                const vector = new Vector3();
                // generate vertices, normals and uvs
                for (let iy = 0; iy < gridY1; iy++) {
                    const y = iy * segmentHeight - heightHalf;
                    for (let ix = 0; ix < gridX1; ix++) {
                        const x = ix * segmentWidth - widthHalf;
                        // set values to correct vector component
                        vector[u] = x * udir;
                        vector[v] = y * vdir;
                        vector[w] = depthHalf;
                        // now apply vector to vertex buffer
                        vertices.push(vector.x, vector.y, vector.z);
                        // set values to correct vector component
                        vector[u] = 0;
                        vector[v] = 0;
                        vector[w] = depth > 0 ? 1 : -1;
                        // now apply vector to normal buffer
                        normals.push(vector.x, vector.y, vector.z);
                        // uvs
                        uvs.push(ix / gridX);
                        uvs.push(1 - (iy / gridY));
                        // counters
                        vertexCounter += 1;
                    }
                }
                // indices
                // 1. you need three indices to draw a single face
                // 2. a single segment consists of two faces
                // 3. so we need to generate six (2*3) indices per segment
                for (let iy = 0; iy < gridY; iy++) {
                    for (let ix = 0; ix < gridX; ix++) {
                        const a = numberOfVertices + ix + gridX1 * iy;
                        const b = numberOfVertices + ix + gridX1 * (iy + 1);
                        const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                        const d = numberOfVertices + (ix + 1) + gridX1 * iy;
                        // faces
                        indices.push(a, b, d);
                        indices.push(b, c, d);
                        // increase counter
                        groupCount += 6;
                    }
                }
                // add a group to the geometry. this will ensure multi material support
                scope.addGroup(groupStart, groupCount, materialIndex);
                // calculate new start value for groups
                groupStart += groupCount;
                // update total number of vertices
                numberOfVertices += vertexCounter;
            }
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
        static fromJSON(data) {
            return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
        }
    }
    // Uniform Utilities
    function cloneUniforms(src) {
        const dst = {};
        for (const u in src) {
            dst[u] = {};
            for (const p in src[u]) {
                const property = src[u][p];
                if (property && (property.isColor ||
                    property.isMatrix3 || property.isMatrix4 ||
                    property.isVector2 || property.isVector3 || property.isVector4 ||
                    property.isTexture || property.isQuaternion)) {
                    if (property.isRenderTargetTexture) {
                        console.warn('UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().');
                        dst[u][p] = null;
                    } else {
                        dst[u][p] = property.clone();
                    }
                } else if (Array.isArray(property)) {
                    dst[u][p] = property.slice();
                } else {
                    dst[u][p] = property;
                }
            }
        }
        return dst;
    }
    function mergeUniforms(uniforms) {
        const merged = {};
        for (let u = 0; u < uniforms.length; u++) {
            const tmp = cloneUniforms(uniforms[u]);
            for (const p in tmp) {
                merged[p] = tmp[p];
            }
        }
        return merged;
    }
    function cloneUniformsGroups(src) {
        const dst = [];
        for (let u = 0; u < src.length; u++) {
            dst.push(src[u].clone());
        }
        return dst;
    }
    function getUnlitUniformColorSpace(renderer) {
        const currentRenderTarget = renderer.getRenderTarget();
        if (currentRenderTarget === null) {
            // https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
            return renderer.outputColorSpace;
        }
        // https://github.com/mrdoob/three.js/issues/27868
        if (currentRenderTarget.isXRRenderTarget === true) {
            return currentRenderTarget.texture.colorSpace;
        }
        return ColorManagement.workingColorSpace;
    }
    // Legacy
    const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
    var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    class ShaderMaterial extends Material {
        constructor(parameters) {
            super();
            this.isShaderMaterial = true;
            this.type = 'ShaderMaterial';
            this.defines = {};
            this.uniforms = {};
            this.uniformsGroups = [];
            this.vertexShader = default_vertex;
            this.fragmentShader = default_fragment;
            this.linewidth = 1;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.fog = false;
            this.lights = false;
            this.clipping = false;
            this.forceSinglePass = true;
            this.extensions = {
                clipCullDistance: false, // set to use vertex shader clipping
                multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
            };
            this.defaultAttributeValues = {
                'color': [1, 1, 1],
                'uv': [0, 0],
                'uv1': [0, 0]
            };
            this.index0AttributeName = undefined;
            this.uniformsNeedUpdate = false;
            this.glslVersion = null;
            if (parameters !== undefined) {
                this.setValues(parameters);
            }
        }
        copy(source) {
            super.copy(source);
            this.fragmentShader = source.fragmentShader;
            this.vertexShader = source.vertexShader;
            this.uniforms = cloneUniforms(source.uniforms);
            this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
            this.defines = Object.assign({}, source.defines);
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.fog = source.fog;
            this.lights = source.lights;
            this.clipping = source.clipping;
            this.extensions = Object.assign({}, source.extensions);
            this.glslVersion = source.glslVersion;
            return this;
        }
        toJSON(meta) {
            const data = super.toJSON(meta);
            data.glslVersion = this.glslVersion;
            data.uniforms = {};
            for (const name in this.uniforms) {
                const uniform = this.uniforms[name];
                const value = uniform.value;
                if (value && value.isTexture) {
                    data.uniforms[name] = {
                        type: 't',
                        value: value.toJSON(meta).uuid
                    };
                } else if (value && value.isColor) {
                    data.uniforms[name] = {
                        type: 'c',
                        value: value.getHex()
                    };
                } else if (value && value.isVector2) {
                    data.uniforms[name] = {
                        type: 'v2',
                        value: value.toArray()
                    };
                } else if (value && value.isVector3) {
                    data.uniforms[name] = {
                        type: 'v3',
                        value: value.toArray()
                    };
                } else if (value && value.isVector4) {
                    data.uniforms[name] = {
                        type: 'v4',
                        value: value.toArray()
                    };
                } else if (value && value.isMatrix3) {
                    data.uniforms[name] = {
                        type: 'm3',
                        value: value.toArray()
                    };
                } else if (value && value.isMatrix4) {
                    data.uniforms[name] = {
                        type: 'm4',
                        value: value.toArray()
                    };
                } else {
                    data.uniforms[name] = {
                        value: value
                    };
                    // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
                }
            }
            if (Object.keys(this.defines).length > 0) data.defines = this.defines;
            data.vertexShader = this.vertexShader;
            data.fragmentShader = this.fragmentShader;
            data.lights = this.lights;
            data.clipping = this.clipping;
            const extensions = {};
            for (const key in this.extensions) {
                if (this.extensions[key] === true) extensions[key] = true;
            }
            if (Object.keys(extensions).length > 0) data.extensions = extensions;
            return data;
        }
    }
    class Camera extends Object3D {
        constructor() {
            super();
            this.isCamera = true;
            this.type = 'Camera';
            this.matrixWorldInverse = new Matrix4();
            this.projectionMatrix = new Matrix4();
            this.projectionMatrixInverse = new Matrix4();
            this.coordinateSystem = WebGLCoordinateSystem;
            this._reversedDepth = false;
        }
        get reversedDepth() {
            return this._reversedDepth;
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.matrixWorldInverse.copy(source.matrixWorldInverse);
            this.projectionMatrix.copy(source.projectionMatrix);
            this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
            this.coordinateSystem = source.coordinateSystem;
            return this;
        }
        getWorldDirection(target) {
            return super.getWorldDirection(target).negate();
        }
        updateMatrixWorld(force) {
            super.updateMatrixWorld(force);
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(updateParents, updateChildren) {
            super.updateWorldMatrix(updateParents, updateChildren);
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const _v3$1 = /*@__PURE__*/ new Vector3();
    const _minTarget = /*@__PURE__*/ new Vector2();
    const _maxTarget = /*@__PURE__*/ new Vector2();
    class PerspectiveCamera extends Camera {
        constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
            super();
            this.isPerspectiveCamera = true;
            this.type = 'PerspectiveCamera';
            this.fov = fov;
            this.zoom = 1;
            this.near = near;
            this.far = far;
            this.focus = 10;
            this.aspect = aspect;
            this.view = null;
            this.filmGauge = 35;
            this.filmOffset = 0;
            this.updateProjectionMatrix();
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.fov = source.fov;
            this.zoom = source.zoom;
            this.near = source.near;
            this.far = source.far;
            this.focus = source.focus;
            this.aspect = source.aspect;
            this.view = source.view === null ? null : Object.assign({}, source.view);
            this.filmGauge = source.filmGauge;
            this.filmOffset = source.filmOffset;
            return this;
        }
        setFocalLength(focalLength) {
            const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
            this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
            this.updateProjectionMatrix();
        }
        getFocalLength() {
            const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
            return 0.5 * this.getFilmHeight() / vExtentSlope;
        }
        getEffectiveFOV() {
            return RAD2DEG * 2 * Math.atan(
                Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
            // film not completely covered in portrait format (aspect < 1)
            return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
            // film not completely covered in landscape format (aspect > 1)
            return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(distance, minTarget, maxTarget) {
            _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
            minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(- distance / _v3$1.z);
            _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
            maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(- distance / _v3$1.z);
        }
        getViewSize(distance, target) {
            this.getViewBounds(distance, _minTarget, _maxTarget);
            return target.subVectors(_maxTarget, _minTarget);
        }
        setViewOffset(fullWidth, fullHeight, x, y, width, height) {
            this.aspect = fullWidth / fullHeight;
            if (this.view === null) {
                this.view = {
                    enabled: true,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                };
            }
            this.view.enabled = true;
            this.view.fullWidth = fullWidth;
            this.view.fullHeight = fullHeight;
            this.view.offsetX = x;
            this.view.offsetY = y;
            this.view.width = width;
            this.view.height = height;
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
            if (this.view !== null) {
                this.view.enabled = false;
            }
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
            const near = this.near;
            let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
            let height = 2 * top;
            let width = this.aspect * height;
            let left = -0.5 * width;
            const view = this.view;
            if (this.view !== null && this.view.enabled) {
                const fullWidth = view.fullWidth,
                    fullHeight = view.fullHeight;
                left += view.offsetX * width / fullWidth;
                top -= view.offsetY * height / fullHeight;
                width *= view.width / fullWidth;
                height *= view.height / fullHeight;
            }
            const skew = this.filmOffset;
            if (skew !== 0) left += near * skew / this.getFilmWidth();
            this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem, this.reversedDepth);
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
            const data = super.toJSON(meta);
            data.object.fov = this.fov;
            data.object.zoom = this.zoom;
            data.object.near = this.near;
            data.object.far = this.far;
            data.object.focus = this.focus;
            data.object.aspect = this.aspect;
            if (this.view !== null) data.object.view = Object.assign({}, this.view);
            data.object.filmGauge = this.filmGauge;
            data.object.filmOffset = this.filmOffset;
            return data;
        }
    }
    const fov = -90; // negative fov is not an error
    const aspect = 1;
    class CubeCamera extends Object3D {
        constructor(near, far, renderTarget) {
            super();
            this.type = 'CubeCamera';
            this.renderTarget = renderTarget;
            this.coordinateSystem = null;
            this.activeMipmapLevel = 0;
            const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
            cameraPX.layers = this.layers;
            this.add(cameraPX);
            const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
            cameraNX.layers = this.layers;
            this.add(cameraNX);
            const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
            cameraPY.layers = this.layers;
            this.add(cameraPY);
            const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
            cameraNY.layers = this.layers;
            this.add(cameraNY);
            const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
            cameraPZ.layers = this.layers;
            this.add(cameraPZ);
            const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
            cameraNZ.layers = this.layers;
            this.add(cameraNZ);
        }
        updateCoordinateSystem() {
            const coordinateSystem = this.coordinateSystem;
            const cameras = this.children.concat();
            const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
            for (const camera of cameras) this.remove(camera);
            if (coordinateSystem === WebGLCoordinateSystem) {
                cameraPX.up.set(0, 1, 0);
                cameraPX.lookAt(1, 0, 0);
                cameraNX.up.set(0, 1, 0);
                cameraNX.lookAt(-1, 0, 0);
                cameraPY.up.set(0, 0, -1);
                cameraPY.lookAt(0, 1, 0);
                cameraNY.up.set(0, 0, 1);
                cameraNY.lookAt(0, -1, 0);
                cameraPZ.up.set(0, 1, 0);
                cameraPZ.lookAt(0, 0, 1);
                cameraNZ.up.set(0, 1, 0);
                cameraNZ.lookAt(0, 0, -1);
            } else if (coordinateSystem === WebGPUCoordinateSystem) {
                cameraPX.up.set(0, -1, 0);
                cameraPX.lookAt(-1, 0, 0);
                cameraNX.up.set(0, -1, 0);
                cameraNX.lookAt(1, 0, 0);
                cameraPY.up.set(0, 0, 1);
                cameraPY.lookAt(0, 1, 0);
                cameraNY.up.set(0, 0, -1);
                cameraNY.lookAt(0, -1, 0);
                cameraPZ.up.set(0, -1, 0);
                cameraPZ.lookAt(0, 0, 1);
                cameraNZ.up.set(0, -1, 0);
                cameraNZ.lookAt(0, 0, -1);
            } else {
                throw new Error('THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem);
            }
            for (const camera of cameras) {
                this.add(camera);
                camera.updateMatrixWorld();
            }
        }
        update(renderer, scene) {
            if (this.parent === null) this.updateMatrixWorld();
            const { renderTarget, activeMipmapLevel } = this;
            if (this.coordinateSystem !== renderer.coordinateSystem) {
                this.coordinateSystem = renderer.coordinateSystem;
                this.updateCoordinateSystem();
            }
            const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
            const currentRenderTarget = renderer.getRenderTarget();
            const currentActiveCubeFace = renderer.getActiveCubeFace();
            const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
            const currentXrEnabled = renderer.xr.enabled;
            renderer.xr.enabled = false;
            const generateMipmaps = renderTarget.texture.generateMipmaps;
            renderTarget.texture.generateMipmaps = false;
            renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
            renderer.render(scene, cameraPX);
            renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
            renderer.render(scene, cameraNX);
            renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
            renderer.render(scene, cameraPY);
            renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
            renderer.render(scene, cameraNY);
            renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
            renderer.render(scene, cameraPZ);
            // mipmaps are generated during the last call of render()
            // at this point, all sides of the cube render target are defined
            renderTarget.texture.generateMipmaps = generateMipmaps;
            renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
            renderer.render(scene, cameraNZ);
            renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
            renderer.xr.enabled = currentXrEnabled;
            renderTarget.texture.needsPMREMUpdate = true;
        }
    }
    class CubeTexture extends Texture {
        constructor(images = [], mapping = CubeReflectionMapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
            super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
            this.isCubeTexture = true;
            this.flipY = false;
        }
        get images() {
            return this.image;
        }
        set images(value) {
            this.image = value;
        }
    }
    class WebGLCubeRenderTarget extends WebGLRenderTarget {
        constructor(size = 1, options = {}) {
            super(size, size, options);
            this.isWebGLCubeRenderTarget = true;
            const image = { width: size, height: size, depth: 1 };
            const images = [image, image, image, image, image, image];
            this.texture = new CubeTexture(images);
            this._setTextureOptions(options);
            // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
            // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
            // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
            // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
            // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
            // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
            this.texture.isRenderTargetTexture = true;
        }
        fromEquirectangularTexture(renderer, texture) {
            this.texture.type = texture.type;
            this.texture.colorSpace = texture.colorSpace;
            this.texture.generateMipmaps = texture.generateMipmaps;
            this.texture.minFilter = texture.minFilter;
            this.texture.magFilter = texture.magFilter;
            const shader = {
                uniforms: {
                    tEquirect: { value: null },
                },
                vertexShader: /* glsl */`
				varying vec3 vWorldDirection;
				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
				}
				void main() {
					vWorldDirection = transformDirection( position, modelMatrix );
					#include <begin_vertex>
					#include <project_vertex>
				}
			`,
                fragmentShader: /* glsl */`
				uniform sampler2D tEquirect;
				varying vec3 vWorldDirection;
				#include <common>
				void main() {
					vec3 direction = normalize( vWorldDirection );
					vec2 sampleUV = equirectUv( direction );
					gl_FragColor = texture2D( tEquirect, sampleUV );
				}
			`
            };
            const geometry = new BoxGeometry(5, 5, 5);
            const material = new ShaderMaterial({
                name: 'CubemapFromEquirect',
                uniforms: cloneUniforms(shader.uniforms),
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader,
                side: BackSide,
                blending: NoBlending
            });
            material.uniforms.tEquirect.value = texture;
            const mesh = new Mesh(geometry, material);
            const currentMinFilter = texture.minFilter;
            // Avoid blurred poles
            if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
            const camera = new CubeCamera(1, 10, this);
            camera.update(renderer, mesh);
            texture.minFilter = currentMinFilter;
            mesh.geometry.dispose();
            mesh.material.dispose();
            return this;
        }
        clear(renderer, color = true, depth = true, stencil = true) {
            const currentRenderTarget = renderer.getRenderTarget();
            for (let i = 0; i < 6; i++) {
                renderer.setRenderTarget(this, i);
                renderer.clear(color, depth, stencil);
            }
            renderer.setRenderTarget(currentRenderTarget);
        }
    }
    class Group extends Object3D {
        constructor() {
            super();
            this.isGroup = true;
            this.type = 'Group';
        }
    }
    const _moveEvent = { type: 'move' };
    class WebXRController {
        constructor() {
            this._targetRay = null;
            this._grip = null;
            this._hand = null;
        }
        getHandSpace() {
            if (this._hand === null) {
                this._hand = new Group();
                this._hand.matrixAutoUpdate = false;
                this._hand.visible = false;
                this._hand.joints = {};
                this._hand.inputState = { pinching: false };
            }
            return this._hand;
        }
        getTargetRaySpace() {
            if (this._targetRay === null) {
                this._targetRay = new Group();
                this._targetRay.matrixAutoUpdate = false;
                this._targetRay.visible = false;
                this._targetRay.hasLinearVelocity = false;
                this._targetRay.linearVelocity = new Vector3();
                this._targetRay.hasAngularVelocity = false;
                this._targetRay.angularVelocity = new Vector3();
            }
            return this._targetRay;
        }
        getGripSpace() {
            if (this._grip === null) {
                this._grip = new Group();
                this._grip.matrixAutoUpdate = false;
                this._grip.visible = false;
                this._grip.hasLinearVelocity = false;
                this._grip.linearVelocity = new Vector3();
                this._grip.hasAngularVelocity = false;
                this._grip.angularVelocity = new Vector3();
            }
            return this._grip;
        }
        dispatchEvent(event) {
            if (this._targetRay !== null) {
                this._targetRay.dispatchEvent(event);
            }
            if (this._grip !== null) {
                this._grip.dispatchEvent(event);
            }
            if (this._hand !== null) {
                this._hand.dispatchEvent(event);
            }
            return this;
        }
        connect(inputSource) {
            if (inputSource && inputSource.hand) {
                const hand = this._hand;
                if (hand) {
                    for (const inputjoint of inputSource.hand.values()) {
                        // Initialize hand with joints when connected
                        this._getHandJoint(hand, inputjoint);
                    }
                }
            }
            this.dispatchEvent({ type: 'connected', data: inputSource });
            return this;
        }
        disconnect(inputSource) {
            this.dispatchEvent({ type: 'disconnected', data: inputSource });
            if (this._targetRay !== null) {
                this._targetRay.visible = false;
            }
            if (this._grip !== null) {
                this._grip.visible = false;
            }
            if (this._hand !== null) {
                this._hand.visible = false;
            }
            return this;
        }
        update(inputSource, frame, referenceSpace) {
            let inputPose = null;
            let gripPose = null;
            let handPose = null;
            const targetRay = this._targetRay;
            const grip = this._grip;
            const hand = this._hand;
            if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
                if (hand && inputSource.hand) {
                    handPose = true;
                    for (const inputjoint of inputSource.hand.values()) {
                        // Update the joints groups with the XRJoint poses
                        const jointPose = frame.getJointPose(inputjoint, referenceSpace);
                        // The transform of this joint will be updated with the joint pose on each frame
                        const joint = this._getHandJoint(hand, inputjoint);
                        if (jointPose !== null) {
                            joint.matrix.fromArray(jointPose.transform.matrix);
                            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                            joint.matrixWorldNeedsUpdate = true;
                            joint.jointRadius = jointPose.radius;
                        }
                        joint.visible = jointPose !== null;
                    }
                    // Custom events
                    // Check pinchz
                    const indexTip = hand.joints['index-finger-tip'];
                    const thumbTip = hand.joints['thumb-tip'];
                    const distance = indexTip.position.distanceTo(thumbTip.position);
                    const distanceToPinch = 0.02;
                    const threshold = 0.005;
                    if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                        hand.inputState.pinching = false;
                        this.dispatchEvent({
                            type: 'pinchend',
                            handedness: inputSource.handedness,
                            target: this
                        });
                    } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                        hand.inputState.pinching = true;
                        this.dispatchEvent({
                            type: 'pinchstart',
                            handedness: inputSource.handedness,
                            target: this
                        });
                    }
                } else {
                    if (grip !== null && inputSource.gripSpace) {
                        gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                        if (gripPose !== null) {
                            grip.matrix.fromArray(gripPose.transform.matrix);
                            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                            grip.matrixWorldNeedsUpdate = true;
                            if (gripPose.linearVelocity) {
                                grip.hasLinearVelocity = true;
                                grip.linearVelocity.copy(gripPose.linearVelocity);
                            } else {
                                grip.hasLinearVelocity = false;
                            }
                            if (gripPose.angularVelocity) {
                                grip.hasAngularVelocity = true;
                                grip.angularVelocity.copy(gripPose.angularVelocity);
                            } else {
                                grip.hasAngularVelocity = false;
                            }
                        }
                    }
                }
                if (targetRay !== null) {
                    inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                    // Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
                    if (inputPose === null && gripPose !== null) {
                        inputPose = gripPose;
                    }
                    if (inputPose !== null) {
                        targetRay.matrix.fromArray(inputPose.transform.matrix);
                        targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                        targetRay.matrixWorldNeedsUpdate = true;
                        if (inputPose.linearVelocity) {
                            targetRay.hasLinearVelocity = true;
                            targetRay.linearVelocity.copy(inputPose.linearVelocity);
                        } else {
                            targetRay.hasLinearVelocity = false;
                        }
                        if (inputPose.angularVelocity) {
                            targetRay.hasAngularVelocity = true;
                            targetRay.angularVelocity.copy(inputPose.angularVelocity);
                        } else {
                            targetRay.hasAngularVelocity = false;
                        }
                        this.dispatchEvent(_moveEvent);
                    }
                }

            }
            if (targetRay !== null) {
                targetRay.visible = (inputPose !== null);
            }
            if (grip !== null) {
                grip.visible = (gripPose !== null);
            }
            if (hand !== null) {
                hand.visible = (handPose !== null);
            }
            return this;
        }
        _getHandJoint(hand, inputjoint) {
            if (hand.joints[inputjoint.jointName] === undefined) {
                const joint = new Group();
                joint.matrixAutoUpdate = false;
                joint.visible = false;
                hand.joints[inputjoint.jointName] = joint;
                hand.add(joint);
            }
            return hand.joints[inputjoint.jointName];
        }
    }
    class FogExp2 {
        constructor(color, density = 0.00025) {
            this.isFogExp2 = true;
            this.name = '';
            this.color = new Color(color);
            this.density = density;
        }
        clone() {
            return new FogExp2(this.color, this.density);
        }
        toJSON( /* meta */) {
            return {
                type: 'FogExp2',
                name: this.name,
                color: this.color.getHex(),
                density: this.density
            };
        }
    }
    class Fog {
        constructor(color, near = 1, far = 1000) {
            this.isFog = true;
            this.name = '';
            this.color = new Color(color);
            this.near = near;
            this.far = far;
        }
        clone() {
            return new Fog(this.color, this.near, this.far);
        }
        toJSON( /* meta */) {
            return {
                type: 'Fog',
                name: this.name,
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            };
        }
    }
    class Scene extends Object3D {
        constructor() {
            super();
            this.isScene = true;
            this.type = 'Scene';
            this.background = null;
            this.environment = null;
            this.fog = null;
            this.backgroundBlurriness = 0;
            this.backgroundIntensity = 1;
            this.backgroundRotation = new Euler();
            this.environmentIntensity = 1;
            this.environmentRotation = new Euler();
            this.overrideMaterial = null;
            if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
                __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
            }
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            if (source.background !== null) this.background = source.background.clone();
            if (source.environment !== null) this.environment = source.environment.clone();
            if (source.fog !== null) this.fog = source.fog.clone();
            this.backgroundBlurriness = source.backgroundBlurriness;
            this.backgroundIntensity = source.backgroundIntensity;
            this.backgroundRotation.copy(source.backgroundRotation);
            this.environmentIntensity = source.environmentIntensity;
            this.environmentRotation.copy(source.environmentRotation);
            if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            return this;
        }
        toJSON(meta) {
            const data = super.toJSON(meta);
            if (this.fog !== null) data.object.fog = this.fog.toJSON();
            if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
            if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
            data.object.backgroundRotation = this.backgroundRotation.toArray();
            if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;
            data.object.environmentRotation = this.environmentRotation.toArray();
            return data;
        }
    }
    class InterleavedBuffer {
        constructor(array, stride) {
            this.isInterleavedBuffer = true;
            this.array = array;
            this.stride = stride;
            this.count = array !== undefined ? array.length / stride : 0;
            this.usage = StaticDrawUsage;
            this.updateRanges = [];
            this.version = 0;
            this.uuid = generateUUID();
        }
        onUploadCallback() { }
        set needsUpdate(value) {
            if (value === true) this.version++;
        }
        setUsage(value) {
            this.usage = value;
            return this;
        }
        addUpdateRange(start, count) {
            this.updateRanges.push({ start, count });
        }
        clearUpdateRanges() {
            this.updateRanges.length = 0;
        }
        copy(source) {
            this.array = new source.array.constructor(source.array);
            this.count = source.count;
            this.stride = source.stride;
            this.usage = source.usage;
            return this;
        }
        copyAt(index1, interleavedBuffer, index2) {
            index1 *= this.stride;
            index2 *= interleavedBuffer.stride;
            for (let i = 0, l = this.stride; i < l; i++) {
                this.array[index1 + i] = interleavedBuffer.array[index2 + i];
            }
            return this;
        }
        set(value, offset = 0) {
            this.array.set(value, offset);
            return this;
        }
        clone(data) {
            if (data.arrayBuffers === undefined) {
                data.arrayBuffers = {};
            }
            if (this.array.buffer._uuid === undefined) {
                this.array.buffer._uuid = generateUUID();
            }
            if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
                data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
            }
            const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
            const ib = new this.constructor(array, this.stride);
            ib.setUsage(this.usage);
            return ib;
        }
        onUpload(callback) {
            this.onUploadCallback = callback;
            return this;
        }
        toJSON(data) {
            if (data.arrayBuffers === undefined) {
                data.arrayBuffers = {};
            }
            // generate UUID for array buffer if necessary
            if (this.array.buffer._uuid === undefined) {
                this.array.buffer._uuid = generateUUID();
            }
            if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
                data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
            }
            //
            return {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            };
        }
    }
    const _vector$7 = /*@__PURE__*/ new Vector3();
    class InterleavedBufferAttribute {
        constructor(interleavedBuffer, itemSize, offset, normalized = false) {
            this.isInterleavedBufferAttribute = true;
            this.name = '';
            this.data = interleavedBuffer;
            this.itemSize = itemSize;
            this.offset = offset;
            this.normalized = normalized;
        }
        get count() {
            return this.data.count;
        }
        get array() {
            return this.data.array;
        }
        set needsUpdate(value) {
            this.data.needsUpdate = value;
        }
        applyMatrix4(m) {
            for (let i = 0, l = this.data.count; i < l; i++) {
                _vector$7.fromBufferAttribute(this, i);
                _vector$7.applyMatrix4(m);
                this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
            }
            return this;
        }
        applyNormalMatrix(m) {
            for (let i = 0, l = this.count; i < l; i++) {
                _vector$7.fromBufferAttribute(this, i);
                _vector$7.applyNormalMatrix(m);
                this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
            }
            return this;
        }
        transformDirection(m) {
            for (let i = 0, l = this.count; i < l; i++) {
                _vector$7.fromBufferAttribute(this, i);
                _vector$7.transformDirection(m);
                this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
            }
            return this;
        }
        getComponent(index, component) {
            let value = this.array[index * this.data.stride + this.offset + component];
            if (this.normalized) value = denormalize(value, this.array);
            return value;
        }
        setComponent(index, component, value) {
            if (this.normalized) value = normalize$1(value, this.array);
            this.data.array[index * this.data.stride + this.offset + component] = value;
            return this;
        }
        setX(index, x) {
            if (this.normalized) x = normalize$1(x, this.array);
            this.data.array[index * this.data.stride + this.offset] = x;
            return this;
        }
        setY(index, y) {
            if (this.normalized) y = normalize$1(y, this.array);
            this.data.array[index * this.data.stride + this.offset + 1] = y;
            return this;
        }
        setZ(index, z) {
            if (this.normalized) z = normalize$1(z, this.array);
            this.data.array[index * this.data.stride + this.offset + 2] = z;
            return this;
        }
        setW(index, w) {
            if (this.normalized) w = normalize$1(w, this.array);
            this.data.array[index * this.data.stride + this.offset + 3] = w;
            return this;
        }
        getX(index) {
            let x = this.data.array[index * this.data.stride + this.offset];
            if (this.normalized) x = denormalize(x, this.array);
            return x;
        }
        getY(index) {
            let y = this.data.array[index * this.data.stride + this.offset + 1];
            if (this.normalized) y = denormalize(y, this.array);
            return y;
        }
        getZ(index) {
            let z = this.data.array[index * this.data.stride + this.offset + 2];
            if (this.normalized) z = denormalize(z, this.array);
            return z;
        }
        getW(index) {
            let w = this.data.array[index * this.data.stride + this.offset + 3];
            if (this.normalized) w = denormalize(w, this.array);
            return w;
        }
        setXY(index, x, y) {
            index = index * this.data.stride + this.offset;
            if (this.normalized) {
                x = normalize$1(x, this.array);
                y = normalize$1(y, this.array);
            }
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            return this;
        }
        setXYZ(index, x, y, z) {
            index = index * this.data.stride + this.offset;
            if (this.normalized) {
                x = normalize$1(x, this.array);
                y = normalize$1(y, this.array);
                z = normalize$1(z, this.array);
            }
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            return this;
        }
        setXYZW(index, x, y, z, w) {
            index = index * this.data.stride + this.offset;
            if (this.normalized) {
                x = normalize$1(x, this.array);
                y = normalize$1(y, this.array);
                z = normalize$1(z, this.array);
                w = normalize$1(w, this.array);
            }
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            this.data.array[index + 3] = w;
            return this;
        }
        clone(data) {
            if (data === undefined) {
                console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.');
                const array = [];
                for (let i = 0; i < this.count; i++) {
                    const index = i * this.data.stride + this.offset;
                    for (let j = 0; j < this.itemSize; j++) {
                        array.push(this.data.array[index + j]);
                    }
                }
                return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
            } else {
                if (data.interleavedBuffers === undefined) {
                    data.interleavedBuffers = {};
                }
                if (data.interleavedBuffers[this.data.uuid] === undefined) {
                    data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
                }
                return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
            }
        }
        toJSON(data) {
            if (data === undefined) {
                console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.');
                const array = [];
                for (let i = 0; i < this.count; i++) {
                    const index = i * this.data.stride + this.offset;
                    for (let j = 0; j < this.itemSize; j++) {
                        array.push(this.data.array[index + j]);
                    }
                }
                // de-interleave data and save it as an ordinary buffer attribute for now
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: array,
                    normalized: this.normalized
                };
            } else {
                // save as true interleaved attribute
                if (data.interleavedBuffers === undefined) {
                    data.interleavedBuffers = {};
                }
                if (data.interleavedBuffers[this.data.uuid] === undefined) {
                    data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
                }
                return {
                    isInterleavedBufferAttribute: true,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                };
            }
        }
    }
    class SpriteMaterial extends Material {
        constructor(parameters) {
            super();
            this.isSpriteMaterial = true;
            this.type = 'SpriteMaterial';
            this.color = new Color(0xffffff);
            this.map = null;
            this.alphaMap = null;
            this.rotation = 0;
            this.sizeAttenuation = true;
            this.transparent = true;
            this.fog = true;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.map = source.map;
            this.alphaMap = source.alphaMap;
            this.rotation = source.rotation;
            this.sizeAttenuation = source.sizeAttenuation;
            this.fog = source.fog;
            return this;
        }
    }
    let _geometry;
    const _intersectPoint = /*@__PURE__*/ new Vector3();
    const _worldScale = /*@__PURE__*/ new Vector3();
    const _mvPosition = /*@__PURE__*/ new Vector3();
    const _alignedPosition = /*@__PURE__*/ new Vector2();
    const _rotatedPosition = /*@__PURE__*/ new Vector2();
    const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();
    const _vA = /*@__PURE__*/ new Vector3();
    const _vB = /*@__PURE__*/ new Vector3();
    const _vC = /*@__PURE__*/ new Vector3();
    const _uvA = /*@__PURE__*/ new Vector2();
    const _uvB = /*@__PURE__*/ new Vector2();
    const _uvC = /*@__PURE__*/ new Vector2();
    class Sprite extends Object3D {
        constructor(material = new SpriteMaterial()) {
            super();
            this.isSprite = true;
            this.type = 'Sprite';
            if (_geometry === undefined) {
                _geometry = new BufferGeometry();
                const float32Array = new Float32Array([
                    -0.5, -0.5, 0, 0, 0,
                    0.5, -0.5, 0, 1, 0,
                    0.5, 0.5, 0, 1, 1,
                    -0.5, 0.5, 0, 0, 1
                ]);
                const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
                _geometry.setIndex([0, 1, 2, 0, 2, 3]);
                _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
                _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
            }
            this.geometry = _geometry;
            this.material = material;
            this.center = new Vector2(0.5, 0.5);
            this.count = 1;
        }
        raycast(raycaster, intersects) {
            if (raycaster.camera === null) {
                console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
            }
            _worldScale.setFromMatrixScale(this.matrixWorld);
            _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
            this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
            _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
            if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
                _worldScale.multiplyScalar(- _mvPosition.z);
            }
            const rotation = this.material.rotation;
            let sin, cos;
            if (rotation !== 0) {
                cos = Math.cos(rotation);
                sin = Math.sin(rotation);
            }
            const center = this.center;
            transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
            transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
            transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
            _uvA.set(0, 0);
            _uvB.set(1, 0);
            _uvC.set(1, 1);
            // check first triangle
            let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
            if (intersect === null) {
                // check second triangle
                transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                _uvB.set(0, 1);
                intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
                if (intersect === null) {
                    return;
                }
            }
            const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far) return;
            intersects.push({
                distance: distance,
                point: _intersectPoint.clone(),
                uv: Triangle.getInterpolation(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
                face: null,
                object: this
            });
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            if (source.center !== undefined) this.center.copy(source.center);
            this.material = source.material;
            return this;
        }
    }
    function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
        // compute position in camera space
        _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
        // to check if rotation is not zero
        if (sin !== undefined) {
            _rotatedPosition.x = (cos * _alignedPosition.x) - (sin * _alignedPosition.y);
            _rotatedPosition.y = (sin * _alignedPosition.x) + (cos * _alignedPosition.y);
        } else {
            _rotatedPosition.copy(_alignedPosition);
        }

        vertexPosition.copy(mvPosition);
        vertexPosition.x += _rotatedPosition.x;
        vertexPosition.y += _rotatedPosition.y;
        // transform to world space
        vertexPosition.applyMatrix4(_viewWorldMatrix);
    }
    const _v1$2 = /*@__PURE__*/ new Vector3();
    const _v2$1 = /*@__PURE__*/ new Vector3();
    class LOD extends Object3D {
        constructor() {
            super();
            this.isLOD = true;
            this._currentLevel = 0;
            this.type = 'LOD';
            Object.defineProperties(this, {
                levels: {
                    enumerable: true,
                    value: []
                }
            });
            this.autoUpdate = true;
        }
        copy(source) {
            super.copy(source, false);
            const levels = source.levels;
            for (let i = 0, l = levels.length; i < l; i++) {
                const level = levels[i];
                this.addLevel(level.object.clone(), level.distance, level.hysteresis);
            }
            this.autoUpdate = source.autoUpdate;
            return this;
        }
        addLevel(object, distance = 0, hysteresis = 0) {
            distance = Math.abs(distance);
            const levels = this.levels;
            let l;
            for (l = 0; l < levels.length; l++) {
                if (distance < levels[l].distance) {
                    break;
                }
            }
            levels.splice(l, 0, { distance: distance, hysteresis: hysteresis, object: object });
            this.add(object);
            return this;
        }
        removeLevel(distance) {
            const levels = this.levels;
            for (let i = 0; i < levels.length; i++) {
                if (levels[i].distance === distance) {
                    const removedElements = levels.splice(i, 1);
                    this.remove(removedElements[0].object);
                    return true;
                }
            }
            return false;
        }
        getCurrentLevel() {
            return this._currentLevel;
        }
        getObjectForDistance(distance) {
            const levels = this.levels;
            if (levels.length > 0) {
                let i, l;
                for (i = 1, l = levels.length; i < l; i++) {
                    let levelDistance = levels[i].distance;
                    if (levels[i].object.visible) {
                        levelDistance -= levelDistance * levels[i].hysteresis;
                    }
                    if (distance < levelDistance) {
                        break;
                    }
                }
                return levels[i - 1].object;
            }
            return null;
        }
        raycast(raycaster, intersects) {
            const levels = this.levels;
            if (levels.length > 0) {
                _v1$2.setFromMatrixPosition(this.matrixWorld);
                const distance = raycaster.ray.origin.distanceTo(_v1$2);
                this.getObjectForDistance(distance).raycast(raycaster, intersects);
            }
        }
        update(camera) {
            const levels = this.levels;
            if (levels.length > 1) {
                _v1$2.setFromMatrixPosition(camera.matrixWorld);
                _v2$1.setFromMatrixPosition(this.matrixWorld);
                const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
                levels[0].object.visible = true;
                let i, l;
                for (i = 1, l = levels.length; i < l; i++) {
                    let levelDistance = levels[i].distance;
                    if (levels[i].object.visible) {
                        levelDistance -= levelDistance * levels[i].hysteresis;
                    }
                    if (distance >= levelDistance) {
                        levels[i - 1].object.visible = false;
                        levels[i].object.visible = true;
                    } else {
                        break;
                    }
                }
                this._currentLevel = i - 1;
                for (; i < l; i++) {
                    levels[i].object.visible = false;
                }
            }
        }
        toJSON(meta) {
            const data = super.toJSON(meta);
            if (this.autoUpdate === false) data.object.autoUpdate = false;
            data.object.levels = [];
            const levels = this.levels;
            for (let i = 0, l = levels.length; i < l; i++) {
                const level = levels[i];
                data.object.levels.push({
                    object: level.object.uuid,
                    distance: level.distance,
                    hysteresis: level.hysteresis
                });
            }
            return data;
        }
    }
    const _basePosition = /*@__PURE__*/ new Vector3();
    const _skinIndex = /*@__PURE__*/ new Vector4();
    const _skinWeight = /*@__PURE__*/ new Vector4();
    const _vector3 = /*@__PURE__*/ new Vector3();
    const _matrix4 = /*@__PURE__*/ new Matrix4();
    const _vertex = /*@__PURE__*/ new Vector3();
    const _sphere$5 = /*@__PURE__*/ new Sphere();
    const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
    const _ray$2 = /*@__PURE__*/ new Ray();
    class SkinnedMesh extends Mesh {
        constructor(geometry, material) {
            super(geometry, material);
            this.isSkinnedMesh = true;
            this.type = 'SkinnedMesh';
            this.bindMode = AttachedBindMode;
            this.bindMatrix = new Matrix4();
            this.bindMatrixInverse = new Matrix4();
            this.boundingBox = null;
            this.boundingSphere = null;
        }
        computeBoundingBox() {
            const geometry = this.geometry;
            if (this.boundingBox === null) {
                this.boundingBox = new Box3();
            }
            this.boundingBox.makeEmpty();
            const positionAttribute = geometry.getAttribute('position');
            for (let i = 0; i < positionAttribute.count; i++) {
                this.getVertexPosition(i, _vertex);
                this.boundingBox.expandByPoint(_vertex);
            }
        }
        computeBoundingSphere() {
            const geometry = this.geometry;
            if (this.boundingSphere === null) {
                this.boundingSphere = new Sphere();
            }
            this.boundingSphere.makeEmpty();
            const positionAttribute = geometry.getAttribute('position');
            for (let i = 0; i < positionAttribute.count; i++) {
                this.getVertexPosition(i, _vertex);
                this.boundingSphere.expandByPoint(_vertex);
            }
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.bindMode = source.bindMode;
            this.bindMatrix.copy(source.bindMatrix);
            this.bindMatrixInverse.copy(source.bindMatrixInverse);
            this.skeleton = source.skeleton;
            if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
            if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
            return this;
        }
        raycast(raycaster, intersects) {
            const material = this.material;
            const matrixWorld = this.matrixWorld;
            if (material === undefined) return;
            // test with bounding sphere in world space
            if (this.boundingSphere === null) this.computeBoundingSphere();
            _sphere$5.copy(this.boundingSphere);
            _sphere$5.applyMatrix4(matrixWorld);
            if (raycaster.ray.intersectsSphere(_sphere$5) === false) return;
            // convert ray to local space of skinned mesh
            _inverseMatrix$2.copy(matrixWorld).invert();
            _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
            // test with bounding box in local space
            if (this.boundingBox !== null) {
                if (_ray$2.intersectsBox(this.boundingBox) === false) return;
            }
            // test for intersections with geometry
            this._computeIntersections(raycaster, intersects, _ray$2);
        }
        getVertexPosition(index, target) {
            super.getVertexPosition(index, target);
            this.applyBoneTransform(index, target);
            return target;
        }
        bind(skeleton, bindMatrix) {
            this.skeleton = skeleton;
            if (bindMatrix === undefined) {
                this.updateMatrixWorld(true);
                this.skeleton.calculateInverses();
                bindMatrix = this.matrixWorld;
            }
            this.bindMatrix.copy(bindMatrix);
            this.bindMatrixInverse.copy(bindMatrix).invert();
        }
        pose() {
            this.skeleton.pose();
        }
        normalizeSkinWeights() {
            const vector = new Vector4();
            const skinWeight = this.geometry.attributes.skinWeight;
            for (let i = 0, l = skinWeight.count; i < l; i++) {
                vector.fromBufferAttribute(skinWeight, i);
                const scale = 1.0 / vector.manhattanLength();
                if (scale !== Infinity) {
                    vector.multiplyScalar(scale);
                } else {
                    vector.set(1, 0, 0, 0); // do something reasonable
                }
                skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
            }
        }
        updateMatrixWorld(force) {
            super.updateMatrixWorld(force);
            if (this.bindMode === AttachedBindMode) {
                this.bindMatrixInverse.copy(this.matrixWorld).invert();
            } else if (this.bindMode === DetachedBindMode) {
                this.bindMatrixInverse.copy(this.bindMatrix).invert();
            } else {
                console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
            }
        }
        applyBoneTransform(index, target) {
            const skeleton = this.skeleton;
            const geometry = this.geometry;
            _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
            _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
            _basePosition.copy(target).applyMatrix4(this.bindMatrix);
            target.set(0, 0, 0);
            for (let i = 0; i < 4; i++) {
                const weight = _skinWeight.getComponent(i);
                if (weight !== 0) {
                    const boneIndex = _skinIndex.getComponent(i);
                    _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
                    target.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
                }
            }
            return target.applyMatrix4(this.bindMatrixInverse);
        }
    }
    class Bone extends Object3D {
        constructor() {
            super();
            this.isBone = true;
            this.type = 'Bone';
        }
    }
    class DataTexture extends Texture {
        constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {
            super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
            this.isDataTexture = true;
            this.image = { data: data, width: width, height: height };
            this.generateMipmaps = false;
            this.flipY = false;
            this.unpackAlignment = 1;
        }
    }
    const _offsetMatrix = /*@__PURE__*/ new Matrix4();
    const _identityMatrix = /*@__PURE__*/ new Matrix4();
    class Skeleton {
        constructor(bones = [], boneInverses = []) {
            this.uuid = generateUUID();
            this.bones = bones.slice(0);
            this.boneInverses = boneInverses;
            this.boneMatrices = null;
            this.boneTexture = null;
            this.init();
        }
        init() {
            const bones = this.bones;
            const boneInverses = this.boneInverses;
            this.boneMatrices = new Float32Array(bones.length * 16);
            // calculate inverse bone matrices if necessary
            if (boneInverses.length === 0) {
                this.calculateInverses();
            } else {
                // handle special case
                if (bones.length !== boneInverses.length) {
                    console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
                    this.boneInverses = [];
                    for (let i = 0, il = this.bones.length; i < il; i++) {
                        this.boneInverses.push(new Matrix4());
                    }
                }
            }
        }
        calculateInverses() {
            this.boneInverses.length = 0;
            for (let i = 0, il = this.bones.length; i < il; i++) {
                const inverse = new Matrix4();
                if (this.bones[i]) {
                    inverse.copy(this.bones[i].matrixWorld).invert();
                }
                this.boneInverses.push(inverse);
            }
        }
        pose() {
            // recover the bind-time world matrices
            for (let i = 0, il = this.bones.length; i < il; i++) {
                const bone = this.bones[i];
                if (bone) {
                    bone.matrixWorld.copy(this.boneInverses[i]).invert();
                }
            }
            // compute the local matrices, positions, rotations and scales
            for (let i = 0, il = this.bones.length; i < il; i++) {
                const bone = this.bones[i];
                if (bone) {
                    if (bone.parent && bone.parent.isBone) {
                        bone.matrix.copy(bone.parent.matrixWorld).invert();
                        bone.matrix.multiply(bone.matrixWorld);
                    } else {
                        bone.matrix.copy(bone.matrixWorld);
                    }
                    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
                }
            }
        }
        update() {
            const bones = this.bones;
            const boneInverses = this.boneInverses;
            const boneMatrices = this.boneMatrices;
            const boneTexture = this.boneTexture;
            // flatten bone matrices to array
            for (let i = 0, il = bones.length; i < il; i++) {
                // compute the offset between the current and the original transform
                const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
                _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
                _offsetMatrix.toArray(boneMatrices, i * 16);
            }
            if (boneTexture !== null) {
                boneTexture.needsUpdate = true;
            }
        }
        clone() {
            return new Skeleton(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
            // layout (1 matrix = 4 pixels)
            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
            let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix
            size = Math.ceil(size / 4) * 4;
            size = Math.max(size, 4);
            const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
            boneMatrices.set(this.boneMatrices); // copy current values
            const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            boneTexture.needsUpdate = true;
            this.boneMatrices = boneMatrices;
            this.boneTexture = boneTexture;
            return this;
        }
        getBoneByName(name) {
            for (let i = 0, il = this.bones.length; i < il; i++) {
                const bone = this.bones[i];
                if (bone.name === name) {
                    return bone;
                }
            }
            return undefined;
        }
        dispose() {
            if (this.boneTexture !== null) {
                this.boneTexture.dispose();
                this.boneTexture = null;
            }
        }
        fromJSON(json, bones) {
            this.uuid = json.uuid;
            for (let i = 0, l = json.bones.length; i < l; i++) {
                const uuid = json.bones[i];
                let bone = bones[uuid];
                if (bone === undefined) {
                    console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
                    bone = new Bone();
                }
                this.bones.push(bone);
                this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
            }
            this.init();
            return this;
        }
        toJSON() {
            const data = {
                metadata: {
                    version: 4.7,
                    type: 'Skeleton',
                    generator: 'Skeleton.toJSON'
                },
                bones: [],
                boneInverses: []
            };
            data.uuid = this.uuid;
            const bones = this.bones;
            const boneInverses = this.boneInverses;
            for (let i = 0, l = bones.length; i < l; i++) {
                const bone = bones[i];
                data.bones.push(bone.uuid);
                const boneInverse = boneInverses[i];
                data.boneInverses.push(boneInverse.toArray());
            }
            return data;
        }
    }
    class InstancedBufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized, meshPerAttribute = 1) {
            super(array, itemSize, normalized);
            this.isInstancedBufferAttribute = true;
            this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
            super.copy(source);
            this.meshPerAttribute = source.meshPerAttribute;
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.meshPerAttribute = this.meshPerAttribute;
            data.isInstancedBufferAttribute = true;
            return data;
        }
    }
    const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
    const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();
    const _instanceIntersects = [];
    const _box3 = /*@__PURE__*/ new Box3();
    const _identity = /*@__PURE__*/ new Matrix4();
    const _mesh$1 = /*@__PURE__*/ new Mesh();
    const _sphere$4 = /*@__PURE__*/ new Sphere();
    class InstancedMesh extends Mesh {
        constructor(geometry, material, count) {
            super(geometry, material);
            this.isInstancedMesh = true;
            this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
            this.instanceColor = null;
            this.morphTexture = null;
            this.count = count;
            this.boundingBox = null;
            this.boundingSphere = null;
            for (let i = 0; i < count; i++) {
                this.setMatrixAt(i, _identity);
            }
        }
        computeBoundingBox() {
            const geometry = this.geometry;
            const count = this.count;
            if (this.boundingBox === null) {
                this.boundingBox = new Box3();
            }
            if (geometry.boundingBox === null) {
                geometry.computeBoundingBox();
            }
            this.boundingBox.makeEmpty();
            for (let i = 0; i < count; i++) {
                this.getMatrixAt(i, _instanceLocalMatrix);
                _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
                this.boundingBox.union(_box3);
            }
        }
        computeBoundingSphere() {
            const geometry = this.geometry;
            const count = this.count;
            if (this.boundingSphere === null) {
                this.boundingSphere = new Sphere();
            }
            if (geometry.boundingSphere === null) {
                geometry.computeBoundingSphere();
            }
            this.boundingSphere.makeEmpty();
            for (let i = 0; i < count; i++) {
                this.getMatrixAt(i, _instanceLocalMatrix);
                _sphere$4.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
                this.boundingSphere.union(_sphere$4);
            }
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.instanceMatrix.copy(source.instanceMatrix);
            if (source.morphTexture !== null) this.morphTexture = source.morphTexture.clone();
            if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
            this.count = source.count;
            if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
            if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
            return this;
        }
        getColorAt(index, color) {
            color.fromArray(this.instanceColor.array, index * 3);
        }
        getMatrixAt(index, matrix) {
            matrix.fromArray(this.instanceMatrix.array, index * 16);
        }
        getMorphAt(index, object) {
            const objectInfluences = object.morphTargetInfluences;
            const array = this.morphTexture.source.data.data;
            const len = objectInfluences.length + 1; // All influences + the baseInfluenceSum
            const dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning
            for (let i = 0; i < objectInfluences.length; i++) {
                objectInfluences[i] = array[dataIndex + i];
            }
        }
        raycast(raycaster, intersects) {
            const matrixWorld = this.matrixWorld;
            const raycastTimes = this.count;
            _mesh$1.geometry = this.geometry;
            _mesh$1.material = this.material;
            if (_mesh$1.material === undefined) return;
            // test with bounding sphere first
            if (this.boundingSphere === null) this.computeBoundingSphere();
            _sphere$4.copy(this.boundingSphere);
            _sphere$4.applyMatrix4(matrixWorld);
            if (raycaster.ray.intersectsSphere(_sphere$4) === false) return;
            // now test each instance
            for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
                // calculate the world matrix for each instance
                this.getMatrixAt(instanceId, _instanceLocalMatrix);
                _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
                // the mesh represents this single instance
                _mesh$1.matrixWorld = _instanceWorldMatrix;
                _mesh$1.raycast(raycaster, _instanceIntersects);
                // process the result of raycast
                for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
                    const intersect = _instanceIntersects[i];
                    intersect.instanceId = instanceId;
                    intersect.object = this;
                    intersects.push(intersect);
                }
                _instanceIntersects.length = 0;
            }
        }
        setColorAt(index, color) {
            if (this.instanceColor === null) {
                this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3);
            }
            color.toArray(this.instanceColor.array, index * 3);
        }
        setMatrixAt(index, matrix) {
            matrix.toArray(this.instanceMatrix.array, index * 16);
        }
        setMorphAt(index, object) {
            const objectInfluences = object.morphTargetInfluences;
            const len = objectInfluences.length + 1; // morphBaseInfluence + all influences
            if (this.morphTexture === null) {
                this.morphTexture = new DataTexture(new Float32Array(len * this.count), len, this.count, RedFormat, FloatType);
            }
            const array = this.morphTexture.source.data.data;
            let morphInfluencesSum = 0;
            for (let i = 0; i < objectInfluences.length; i++) {
                morphInfluencesSum += objectInfluences[i];
            }
            const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
            const dataIndex = len * index;
            array[dataIndex] = morphBaseInfluence;
            array.set(objectInfluences, dataIndex + 1);
        }
        updateMorphTargets() {
        }
        dispose() {
            this.dispatchEvent({ type: 'dispose' });
            if (this.morphTexture !== null) {
                this.morphTexture.dispose();
                this.morphTexture = null;
            }
        }
    }
    const _vector1 = /*@__PURE__*/ new Vector3();
    const _vector2 = /*@__PURE__*/ new Vector3();
    const _normalMatrix = /*@__PURE__*/ new Matrix3();
    class Plane {
        constructor(normal = new Vector3(1, 0, 0), constant = 0) {
            this.isPlane = true;
            this.normal = normal;
            this.constant = constant;
        }
        set(normal, constant) {
            this.normal.copy(normal);
            this.constant = constant;
            return this;
        }
        setComponents(x, y, z, w) {
            this.normal.set(x, y, z);
            this.constant = w;
            return this;
        }
        setFromNormalAndCoplanarPoint(normal, point) {
            this.normal.copy(normal);
            this.constant = - point.dot(this.normal);
            return this;
        }
        setFromCoplanarPoints(a, b, c) {
            const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
            // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
            this.setFromNormalAndCoplanarPoint(normal, a);
            return this;
        }
        copy(plane) {
            this.normal.copy(plane.normal);
            this.constant = plane.constant;
            return this;
        }
        normalize() {
            // Note: will lead to a divide by zero if the plane is invalid.
            const inverseNormalLength = 1.0 / this.normal.length();
            this.normal.multiplyScalar(inverseNormalLength);
            this.constant *= inverseNormalLength;
            return this;
        }
        negate() {
            this.constant *= -1;
            this.normal.negate();
            return this;
        }
        distanceToPoint(point) {
            return this.normal.dot(point) + this.constant;
        }
        distanceToSphere(sphere) {
            return this.distanceToPoint(sphere.center) - sphere.radius;
        }
        projectPoint(point, target) {
            return target.copy(point).addScaledVector(this.normal, - this.distanceToPoint(point));
        }
        intersectLine(line, target) {
            const direction = line.delta(_vector1);
            const denominator = this.normal.dot(direction);
            if (denominator === 0) {
                // line is coplanar, return origin
                if (this.distanceToPoint(line.start) === 0) {
                    return target.copy(line.start);
                }
                // Unsure if this is the correct method to handle this case.
                return null;
            }
            const t = - (line.start.dot(this.normal) + this.constant) / denominator;
            if (t < 0 || t > 1) {
                return null;
            }
            return target.copy(line.start).addScaledVector(direction, t);
        }
        intersectsLine(line) {
            // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
            const startSign = this.distanceToPoint(line.start);
            const endSign = this.distanceToPoint(line.end);
            return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
        }
        intersectsBox(box) {
            return box.intersectsPlane(this);
        }
        intersectsSphere(sphere) {
            return sphere.intersectsPlane(this);
        }
        coplanarPoint(target) {
            return target.copy(this.normal).multiplyScalar(- this.constant);
        }
        applyMatrix4(matrix, optionalNormalMatrix) {
            const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
            const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
            const normal = this.normal.applyMatrix3(normalMatrix).normalize();
            this.constant = - referencePoint.dot(normal);
            return this;
        }
        translate(offset) {
            this.constant -= offset.dot(this.normal);
            return this;
        }
        equals(plane) {
            return plane.normal.equals(this.normal) && (plane.constant === this.constant);
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const _sphere$3 = /*@__PURE__*/ new Sphere();
    const _defaultSpriteCenter = /*@__PURE__*/ new Vector2(0.5, 0.5);
    const _vector$6 = /*@__PURE__*/ new Vector3();
    class Frustum {
        constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
            this.planes = [p0, p1, p2, p3, p4, p5];
        }
        set(p0, p1, p2, p3, p4, p5) {
            const planes = this.planes;
            planes[0].copy(p0);
            planes[1].copy(p1);
            planes[2].copy(p2);
            planes[3].copy(p3);
            planes[4].copy(p4);
            planes[5].copy(p5);
            return this;
        }
        copy(frustum) {
            const planes = this.planes;
            for (let i = 0; i < 6; i++) {
                planes[i].copy(frustum.planes[i]);
            }
            return this;
        }
        setFromProjectionMatrix(m, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {
            const planes = this.planes;
            const me = m.elements;
            const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
            const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
            const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
            const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
            planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
            planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
            planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
            planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
            if (reversedDepth) {
                planes[4].setComponents(me2, me6, me10, me14).normalize(); // far
                planes[5].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize(); // near
            } else {
                planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize(); // far
                if (coordinateSystem === WebGLCoordinateSystem) {
                    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize(); // near
                } else if (coordinateSystem === WebGPUCoordinateSystem) {
                    planes[5].setComponents(me2, me6, me10, me14).normalize(); // near
                } else {
                    throw new Error('THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem);
                }
            }
            return this;
        }
        intersectsObject(object) {
            if (object.boundingSphere !== undefined) {
                if (object.boundingSphere === null) object.computeBoundingSphere();
                _sphere$3.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
            } else {
                const geometry = object.geometry;
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                _sphere$3.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
            }
            return this.intersectsSphere(_sphere$3);
        }
        intersectsSprite(sprite) {
            _sphere$3.center.set(0, 0, 0);
            const offset = _defaultSpriteCenter.distanceTo(sprite.center);
            _sphere$3.radius = 0.7071067811865476 + offset;
            _sphere$3.applyMatrix4(sprite.matrixWorld);
            return this.intersectsSphere(_sphere$3);
        }
        intersectsSphere(sphere) {
            const planes = this.planes;
            const center = sphere.center;
            const negRadius = - sphere.radius;
            for (let i = 0; i < 6; i++) {
                const distance = planes[i].distanceToPoint(center);
                if (distance < negRadius) {
                    return false;
                }
            }
            return true;
        }
        intersectsBox(box) {
            const planes = this.planes;
            for (let i = 0; i < 6; i++) {
                const plane = planes[i];
                // corner at max distance
                _vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                _vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                _vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                if (plane.distanceToPoint(_vector$6) < 0) {
                    return false;
                }
            }
            return true;
        }
        containsPoint(point) {
            const planes = this.planes;
            for (let i = 0; i < 6; i++) {
                if (planes[i].distanceToPoint(point) < 0) {
                    return false;
                }
            }
            return true;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const _projScreenMatrix$2 = /*@__PURE__*/ new Matrix4();
    const _frustum$1 = /*@__PURE__*/ new Frustum();
    class FrustumArray {
        constructor() {
            this.coordinateSystem = WebGLCoordinateSystem;
        }
        intersectsObject(object, cameraArray) {
            if (!cameraArray.isArrayCamera || cameraArray.cameras.length === 0) {
                return false;
            }
            for (let i = 0; i < cameraArray.cameras.length; i++) {
                const camera = cameraArray.cameras[i];
                _projScreenMatrix$2.multiplyMatrices(
                    camera.projectionMatrix,
                    camera.matrixWorldInverse
                );
                _frustum$1.setFromProjectionMatrix(
                    _projScreenMatrix$2,
                    camera.coordinateSystem,
                    camera.reversedDepth
                );
                if (_frustum$1.intersectsObject(object)) {
                    return true; // Object is visible in at least one camera
                }
            }
            return false; // Not visible in any camera
        }
        intersectsSprite(sprite, cameraArray) {
            if (!cameraArray || !cameraArray.cameras || cameraArray.cameras.length === 0) {
                return false;
            }
            for (let i = 0; i < cameraArray.cameras.length; i++) {
                const camera = cameraArray.cameras[i];
                _projScreenMatrix$2.multiplyMatrices(
                    camera.projectionMatrix,
                    camera.matrixWorldInverse
                );
                _frustum$1.setFromProjectionMatrix(
                    _projScreenMatrix$2,
                    camera.coordinateSystem,
                    camera.reversedDepth
                );
                if (_frustum$1.intersectsSprite(sprite)) {
                    return true; // Sprite is visible in at least one camera
                }
            }
            return false; // Not visible in any camera
        }
        intersectsSphere(sphere, cameraArray) {
            if (!cameraArray || !cameraArray.cameras || cameraArray.cameras.length === 0) {
                return false;
            }
            for (let i = 0; i < cameraArray.cameras.length; i++) {
                const camera = cameraArray.cameras[i];
                _projScreenMatrix$2.multiplyMatrices(
                    camera.projectionMatrix,
                    camera.matrixWorldInverse
                );
                _frustum$1.setFromProjectionMatrix(
                    _projScreenMatrix$2,
                    camera.coordinateSystem,
                    camera.reversedDepth
                );
                if (_frustum$1.intersectsSphere(sphere)) {
                    return true; // Sphere is visible in at least one camera
                }
            }
            return false; // Not visible in any camera
        }
        intersectsBox(box, cameraArray) {
            if (!cameraArray || !cameraArray.cameras || cameraArray.cameras.length === 0) {
                return false;
            }
            for (let i = 0; i < cameraArray.cameras.length; i++) {
                const camera = cameraArray.cameras[i];
                _projScreenMatrix$2.multiplyMatrices(
                    camera.projectionMatrix,
                    camera.matrixWorldInverse
                );
                _frustum$1.setFromProjectionMatrix(
                    _projScreenMatrix$2,
                    camera.coordinateSystem,
                    camera.reversedDepth
                );
                if (_frustum$1.intersectsBox(box)) {
                    return true; // Box is visible in at least one camera
                }
            }
            return false; // Not visible in any camera
        }
        containsPoint(point, cameraArray) {
            if (!cameraArray || !cameraArray.cameras || cameraArray.cameras.length === 0) {
                return false;
            }
            for (let i = 0; i < cameraArray.cameras.length; i++) {
                const camera = cameraArray.cameras[i];
                _projScreenMatrix$2.multiplyMatrices(
                    camera.projectionMatrix,
                    camera.matrixWorldInverse
                );
                _frustum$1.setFromProjectionMatrix(
                    _projScreenMatrix$2,
                    camera.coordinateSystem,
                    camera.reversedDepth
                );
                if (_frustum$1.containsPoint(point)) {
                    return true; // Point is visible in at least one camera
                }
            }
            return false; // Not visible in any camera
        }
        clone() {
            return new FrustumArray();
        }
    }
    function ascIdSort(a, b) {
        return a - b;
    }
    function sortOpaque(a, b) {
        return a.z - b.z;
    }
    function sortTransparent(a, b) {
        return b.z - a.z;
    }
    class MultiDrawRenderList {
        constructor() {
            this.index = 0;
            this.pool = [];
            this.list = [];
        }
        push(start, count, z, index) {
            const pool = this.pool;
            const list = this.list;
            if (this.index >= pool.length) {
                pool.push({
                    start: -1,
                    count: -1,
                    z: -1,
                    index: -1,
                });
            }
            const item = pool[this.index];
            list.push(item);
            this.index++;
            item.start = start;
            item.count = count;
            item.z = z;
            item.index = index;
        }
        reset() {
            this.list.length = 0;
            this.index = 0;
        }
    }
    const _matrix$1 = /*@__PURE__*/ new Matrix4();
    const _whiteColor = /*@__PURE__*/ new Color(1, 1, 1);
    const _frustum = /*@__PURE__*/ new Frustum();
    const _frustumArray = /*@__PURE__*/ new FrustumArray();
    const _box$1 = /*@__PURE__*/ new Box3();
    const _sphere$2 = /*@__PURE__*/ new Sphere();
    const _vector$5 = /*@__PURE__*/ new Vector3();
    const _forward$1 = /*@__PURE__*/ new Vector3();
    const _temp = /*@__PURE__*/ new Vector3();
    const _renderList = /*@__PURE__*/ new MultiDrawRenderList();
    const _mesh = /*@__PURE__*/ new Mesh();
    const _batchIntersects = [];
    // copies data from attribute "src" into "target" starting at "targetOffset"
    function copyAttributeData(src, target, targetOffset = 0) {
        const itemSize = target.itemSize;
        if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {
            // use the component getters and setters if the array data cannot
            // be copied directly
            const vertexCount = src.count;
            for (let i = 0; i < vertexCount; i++) {
                for (let c = 0; c < itemSize; c++) {
                    target.setComponent(i + targetOffset, c, src.getComponent(i, c));
                }
            }
        } else {
            // faster copy approach using typed array set function
            target.array.set(src.array, targetOffset * itemSize);
        }
        target.needsUpdate = true;
    }
    // safely copies array contents to a potentially smaller array
    function copyArrayContents(src, target) {
        if (src.constructor !== target.constructor) {
            // if arrays are of a different type (eg due to index size increasing) then data must be per-element copied
            const len = Math.min(src.length, target.length);
            for (let i = 0; i < len; i++) {
                target[i] = src[i];
            }
        } else {
            // if the arrays use the same data layout we can use a fast block copy
            const len = Math.min(src.length, target.length);
            target.set(new src.constructor(src.buffer, 0, len));
        }
    }
    class BatchedMesh extends Mesh {
        constructor(maxInstanceCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material) {
            super(new BufferGeometry(), material);
            this.isBatchedMesh = true;
            this.perObjectFrustumCulled = true;
            this.sortObjects = true;
            this.boundingBox = null;
            this.boundingSphere = null;
            this.customSort = null;
            // stores visible, active, and geometry id per instance and reserved buffer ranges for geometries
            this._instanceInfo = [];
            this._geometryInfo = [];
            // instance, geometry ids that have been set as inactive, and are available to be overwritten
            this._availableInstanceIds = [];
            this._availableGeometryIds = [];
            // used to track where the next point is that geometry should be inserted
            this._nextIndexStart = 0;
            this._nextVertexStart = 0;
            this._geometryCount = 0;
            // flags
            this._visibilityChanged = true;
            this._geometryInitialized = false;
            // cached user options
            this._maxInstanceCount = maxInstanceCount;
            this._maxVertexCount = maxVertexCount;
            this._maxIndexCount = maxIndexCount;
            // buffers for multi draw
            this._multiDrawCounts = new Int32Array(maxInstanceCount);
            this._multiDrawStarts = new Int32Array(maxInstanceCount);
            this._multiDrawCount = 0;
            this._multiDrawInstances = null;
            // Local matrix per geometry by using data texture
            this._matricesTexture = null;
            this._indirectTexture = null;
            this._colorsTexture = null;
            this._initMatricesTexture();
            this._initIndirectTexture();
        }
        get maxInstanceCount() {
            return this._maxInstanceCount;
        }
        get instanceCount() {
            return this._instanceInfo.length - this._availableInstanceIds.length;
        }
        get unusedVertexCount() {
            return this._maxVertexCount - this._nextVertexStart;
        }
        get unusedIndexCount() {
            return this._maxIndexCount - this._nextIndexStart;
        }
        _initMatricesTexture() {
            // layout (1 matrix = 4 pixels)
            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
            //  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)
            //       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)
            //       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)
            //       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)
            let size = Math.sqrt(this._maxInstanceCount * 4); // 4 pixels needed for 1 matrix
            size = Math.ceil(size / 4) * 4;
            size = Math.max(size, 4);
            const matricesArray = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
            const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);
            this._matricesTexture = matricesTexture;
        }
        _initIndirectTexture() {
            let size = Math.sqrt(this._maxInstanceCount);
            size = Math.ceil(size);
            const indirectArray = new Uint32Array(size * size);
            const indirectTexture = new DataTexture(indirectArray, size, size, RedIntegerFormat, UnsignedIntType);
            this._indirectTexture = indirectTexture;
        }
        _initColorsTexture() {
            let size = Math.sqrt(this._maxInstanceCount);
            size = Math.ceil(size);
            // 4 floats per RGBA pixel initialized to white
            const colorsArray = new Float32Array(size * size * 4).fill(1);
            const colorsTexture = new DataTexture(colorsArray, size, size, RGBAFormat, FloatType);
            colorsTexture.colorSpace = ColorManagement.workingColorSpace;
            this._colorsTexture = colorsTexture;
        }
        _initializeGeometry(reference) {
            const geometry = this.geometry;
            const maxVertexCount = this._maxVertexCount;
            const maxIndexCount = this._maxIndexCount;
            if (this._geometryInitialized === false) {
                for (const attributeName in reference.attributes) {
                    const srcAttribute = reference.getAttribute(attributeName);
                    const { array, itemSize, normalized } = srcAttribute;
                    const dstArray = new array.constructor(maxVertexCount * itemSize);
                    const dstAttribute = new BufferAttribute(dstArray, itemSize, normalized);
                    geometry.setAttribute(attributeName, dstAttribute);
                }
                if (reference.getIndex() !== null) {
                    // Reserve last u16 index for primitive restart.
                    const indexArray = maxVertexCount > 65535
                        ? new Uint32Array(maxIndexCount)
                        : new Uint16Array(maxIndexCount);
                    geometry.setIndex(new BufferAttribute(indexArray, 1));
                }
                this._geometryInitialized = true;
            }
        }
        // Make sure the geometry is compatible with the existing combined geometry attributes
        _validateGeometry(geometry) {
            // check to ensure the geometries are using consistent attributes and indices
            const batchGeometry = this.geometry;
            if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {
                throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
            }
            for (const attributeName in batchGeometry.attributes) {
                if (!geometry.hasAttribute(attributeName)) {
                    throw new Error(`THREE.BatchedMesh: Added geometry missing "${attributeName}". All geometries must have consistent attributes.`);
                }
                const srcAttribute = geometry.getAttribute(attributeName);
                const dstAttribute = batchGeometry.getAttribute(attributeName);
                if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {
                    throw new Error('THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.');
                }
            }
        }
        validateInstanceId(instanceId) {
            const instanceInfo = this._instanceInfo;
            if (instanceId < 0 || instanceId >= instanceInfo.length || instanceInfo[instanceId].active === false) {
                throw new Error(`THREE.BatchedMesh: Invalid instanceId ${instanceId}. Instance is either out of range or has been deleted.`);
            }
        }
        validateGeometryId(geometryId) {
            const geometryInfoList = this._geometryInfo;
            if (geometryId < 0 || geometryId >= geometryInfoList.length || geometryInfoList[geometryId].active === false) {
                throw new Error(`THREE.BatchedMesh: Invalid geometryId ${geometryId}. Geometry is either out of range or has been deleted.`);
            }
        }
        setCustomSort(func) {
            this.customSort = func;
            return this;
        }
        computeBoundingBox() {
            if (this.boundingBox === null) {
                this.boundingBox = new Box3();
            }
            const boundingBox = this.boundingBox;
            const instanceInfo = this._instanceInfo;
            boundingBox.makeEmpty();
            for (let i = 0, l = instanceInfo.length; i < l; i++) {
                if (instanceInfo[i].active === false) continue;
                const geometryId = instanceInfo[i].geometryIndex;
                this.getMatrixAt(i, _matrix$1);
                this.getBoundingBoxAt(geometryId, _box$1).applyMatrix4(_matrix$1);
                boundingBox.union(_box$1);
            }
        }
        computeBoundingSphere() {
            if (this.boundingSphere === null) {
                this.boundingSphere = new Sphere();
            }
            const boundingSphere = this.boundingSphere;
            const instanceInfo = this._instanceInfo;
            boundingSphere.makeEmpty();
            for (let i = 0, l = instanceInfo.length; i < l; i++) {
                if (instanceInfo[i].active === false) continue;
                const geometryId = instanceInfo[i].geometryIndex;
                this.getMatrixAt(i, _matrix$1);
                this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
                boundingSphere.union(_sphere$2);
            }
        }
        addInstance(geometryId) {
            const atCapacity = this._instanceInfo.length >= this.maxInstanceCount;
            // ensure we're not over geometry
            if (atCapacity && this._availableInstanceIds.length === 0) {
                throw new Error('THREE.BatchedMesh: Maximum item count reached.');
            }
            const instanceInfo = {
                visible: true,
                active: true,
                geometryIndex: geometryId,
            };
            let drawId = null;
            // Prioritize using previously freed instance ids
            if (this._availableInstanceIds.length > 0) {
                this._availableInstanceIds.sort(ascIdSort);
                drawId = this._availableInstanceIds.shift();
                this._instanceInfo[drawId] = instanceInfo;
            } else {
                drawId = this._instanceInfo.length;
                this._instanceInfo.push(instanceInfo);
            }
            const matricesTexture = this._matricesTexture;
            _matrix$1.identity().toArray(matricesTexture.image.data, drawId * 16);
            matricesTexture.needsUpdate = true;
            const colorsTexture = this._colorsTexture;
            if (colorsTexture) {
                _whiteColor.toArray(colorsTexture.image.data, drawId * 4);
                colorsTexture.needsUpdate = true;
            }
            this._visibilityChanged = true;
            return drawId;
        }
        addGeometry(geometry, reservedVertexCount = -1, reservedIndexCount = -1) {
            this._initializeGeometry(geometry);
            this._validateGeometry(geometry);
            const geometryInfo = {
                // geometry information
                vertexStart: -1,
                vertexCount: -1,
                reservedVertexCount: -1,
                indexStart: -1,
                indexCount: -1,
                reservedIndexCount: -1,
                // draw range information
                start: -1,
                count: -1,
                // state
                boundingBox: null,
                boundingSphere: null,
                active: true,
            };
            const geometryInfoList = this._geometryInfo;
            geometryInfo.vertexStart = this._nextVertexStart;
            geometryInfo.reservedVertexCount = reservedVertexCount === -1 ? geometry.getAttribute('position').count : reservedVertexCount;
            const index = geometry.getIndex();
            const hasIndex = index !== null;
            if (hasIndex) {
                geometryInfo.indexStart = this._nextIndexStart;
                geometryInfo.reservedIndexCount = reservedIndexCount === -1 ? index.count : reservedIndexCount;
            }
            if (
                geometryInfo.indexStart !== -1 &&
                geometryInfo.indexStart + geometryInfo.reservedIndexCount > this._maxIndexCount ||
                geometryInfo.vertexStart + geometryInfo.reservedVertexCount > this._maxVertexCount
            ) {
                throw new Error('THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.');
            }
            // update id
            let geometryId;
            if (this._availableGeometryIds.length > 0) {
                this._availableGeometryIds.sort(ascIdSort);
                geometryId = this._availableGeometryIds.shift();
                geometryInfoList[geometryId] = geometryInfo;

            } else {
                geometryId = this._geometryCount;
                this._geometryCount++;
                geometryInfoList.push(geometryInfo);
            }
            // update the geometry
            this.setGeometryAt(geometryId, geometry);
            // increment the next geometry position
            this._nextIndexStart = geometryInfo.indexStart + geometryInfo.reservedIndexCount;
            this._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;
            return geometryId;
        }
        setGeometryAt(geometryId, geometry) {
            if (geometryId >= this._geometryCount) {
                throw new Error('THREE.BatchedMesh: Maximum geometry count reached.');
            }
            this._validateGeometry(geometry);
            const batchGeometry = this.geometry;
            const hasIndex = batchGeometry.getIndex() !== null;
            const dstIndex = batchGeometry.getIndex();
            const srcIndex = geometry.getIndex();
            const geometryInfo = this._geometryInfo[geometryId];
            if (
                hasIndex &&
                srcIndex.count > geometryInfo.reservedIndexCount ||
                geometry.attributes.position.count > geometryInfo.reservedVertexCount
            ) {
                throw new Error('THREE.BatchedMesh: Reserved space not large enough for provided geometry.');
            }
            // copy geometry buffer data over
            const vertexStart = geometryInfo.vertexStart;
            const reservedVertexCount = geometryInfo.reservedVertexCount;
            geometryInfo.vertexCount = geometry.getAttribute('position').count;
            for (const attributeName in batchGeometry.attributes) {
                // copy attribute data
                const srcAttribute = geometry.getAttribute(attributeName);
                const dstAttribute = batchGeometry.getAttribute(attributeName);
                copyAttributeData(srcAttribute, dstAttribute, vertexStart);
                // fill the rest in with zeroes
                const itemSize = srcAttribute.itemSize;
                for (let i = srcAttribute.count, l = reservedVertexCount; i < l; i++) {
                    const index = vertexStart + i;
                    for (let c = 0; c < itemSize; c++) {
                        dstAttribute.setComponent(index, c, 0);
                    }
                }
                dstAttribute.needsUpdate = true;
                dstAttribute.addUpdateRange(vertexStart * itemSize, reservedVertexCount * itemSize);
            }
            // copy index
            if (hasIndex) {
                const indexStart = geometryInfo.indexStart;
                const reservedIndexCount = geometryInfo.reservedIndexCount;
                geometryInfo.indexCount = geometry.getIndex().count;
                // copy index data over
                for (let i = 0; i < srcIndex.count; i++) {
                    dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i));
                }
                // fill the rest in with zeroes
                for (let i = srcIndex.count, l = reservedIndexCount; i < l; i++) {
                    dstIndex.setX(indexStart + i, vertexStart);
                }
                dstIndex.needsUpdate = true;
                dstIndex.addUpdateRange(indexStart, geometryInfo.reservedIndexCount);
            }
            // update the draw range
            geometryInfo.start = hasIndex ? geometryInfo.indexStart : geometryInfo.vertexStart;
            geometryInfo.count = hasIndex ? geometryInfo.indexCount : geometryInfo.vertexCount;
            // store the bounding boxes
            geometryInfo.boundingBox = null;
            if (geometry.boundingBox !== null) {
                geometryInfo.boundingBox = geometry.boundingBox.clone();
            }
            geometryInfo.boundingSphere = null;
            if (geometry.boundingSphere !== null) {
                geometryInfo.boundingSphere = geometry.boundingSphere.clone();
            }
            this._visibilityChanged = true;
            return geometryId;
        }
        deleteGeometry(geometryId) {
            const geometryInfoList = this._geometryInfo;
            if (geometryId >= geometryInfoList.length || geometryInfoList[geometryId].active === false) {
                return this;
            }
            // delete any instances associated with this geometry
            const instanceInfo = this._instanceInfo;
            for (let i = 0, l = instanceInfo.length; i < l; i++) {
                if (instanceInfo[i].active && instanceInfo[i].geometryIndex === geometryId) {
                    this.deleteInstance(i);
                }
            }
            geometryInfoList[geometryId].active = false;
            this._availableGeometryIds.push(geometryId);
            this._visibilityChanged = true;
            return this;
        }
        deleteInstance(instanceId) {
            this.validateInstanceId(instanceId);
            this._instanceInfo[instanceId].active = false;
            this._availableInstanceIds.push(instanceId);
            this._visibilityChanged = true;
            return this;
        }
        optimize() {
            // track the next indices to copy data to
            let nextVertexStart = 0;
            let nextIndexStart = 0;
            // Iterate over all geometry ranges in order sorted from earliest in the geometry buffer to latest
            // in the geometry buffer. Because draw range objects can be reused there is no guarantee of their order.
            const geometryInfoList = this._geometryInfo;
            const indices = geometryInfoList
                .map((e, i) => i)
                .sort((a, b) => {
                    return geometryInfoList[a].vertexStart - geometryInfoList[b].vertexStart;
                });
            const geometry = this.geometry;
            for (let i = 0, l = geometryInfoList.length; i < l; i++) {
                // if a geometry range is inactive then don't copy anything
                const index = indices[i];
                const geometryInfo = geometryInfoList[index];
                if (geometryInfo.active === false) {
                    continue;
                }
                // if a geometry contains an index buffer then shift it, as well
                if (geometry.index !== null) {
                    if (geometryInfo.indexStart !== nextIndexStart) {
                        const { indexStart, vertexStart, reservedIndexCount } = geometryInfo;
                        const index = geometry.index;
                        const array = index.array;
                        // shift the index pointers based on how the vertex data will shift
                        // adjusting the index must happen first so the original vertex start value is available
                        const elementDelta = nextVertexStart - vertexStart;
                        for (let j = indexStart; j < indexStart + reservedIndexCount; j++) {
                            array[j] = array[j] + elementDelta;
                        }
                        index.array.copyWithin(nextIndexStart, indexStart, indexStart + reservedIndexCount);
                        index.addUpdateRange(nextIndexStart, reservedIndexCount);
                        geometryInfo.indexStart = nextIndexStart;
                    }
                    nextIndexStart += geometryInfo.reservedIndexCount;
                }
                // if a geometry needs to be moved then copy attribute data to overwrite unused space
                if (geometryInfo.vertexStart !== nextVertexStart) {
                    const { vertexStart, reservedVertexCount } = geometryInfo;
                    const attributes = geometry.attributes;
                    for (const key in attributes) {
                        const attribute = attributes[key];
                        const { array, itemSize } = attribute;
                        array.copyWithin(nextVertexStart * itemSize, vertexStart * itemSize, (vertexStart + reservedVertexCount) * itemSize);
                        attribute.addUpdateRange(nextVertexStart * itemSize, reservedVertexCount * itemSize);
                    }
                    geometryInfo.vertexStart = nextVertexStart;
                }
                nextVertexStart += geometryInfo.reservedVertexCount;
                geometryInfo.start = geometry.index ? geometryInfo.indexStart : geometryInfo.vertexStart;
                // step the next geometry points to the shifted position
                this._nextIndexStart = geometry.index ? geometryInfo.indexStart + geometryInfo.reservedIndexCount : 0;
                this._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;
            }
            return this;
        }
        getBoundingBoxAt(geometryId, target) {
            if (geometryId >= this._geometryCount) {
                return null;
            }
            // compute bounding box
            const geometry = this.geometry;
            const geometryInfo = this._geometryInfo[geometryId];
            if (geometryInfo.boundingBox === null) {
                const box = new Box3();
                const index = geometry.index;
                const position = geometry.attributes.position;
                for (let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i++) {
                    let iv = i;
                    if (index) {
                        iv = index.getX(iv);
                    }
                    box.expandByPoint(_vector$5.fromBufferAttribute(position, iv));
                }
                geometryInfo.boundingBox = box;
            }
            target.copy(geometryInfo.boundingBox);
            return target;
        }
        getBoundingSphereAt(geometryId, target) {
            if (geometryId >= this._geometryCount) {
                return null;
            }
            // compute bounding sphere
            const geometry = this.geometry;
            const geometryInfo = this._geometryInfo[geometryId];
            if (geometryInfo.boundingSphere === null) {
                const sphere = new Sphere();
                this.getBoundingBoxAt(geometryId, _box$1);
                _box$1.getCenter(sphere.center);
                const index = geometry.index;
                const position = geometry.attributes.position;
                let maxRadiusSq = 0;
                for (let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i++) {
                    let iv = i;
                    if (index) {
                        iv = index.getX(iv);
                    }
                    _vector$5.fromBufferAttribute(position, iv);
                    maxRadiusSq = Math.max(maxRadiusSq, sphere.center.distanceToSquared(_vector$5));
                }
                sphere.radius = Math.sqrt(maxRadiusSq);
                geometryInfo.boundingSphere = sphere;
            }
            target.copy(geometryInfo.boundingSphere);
            return target;
        }
        setMatrixAt(instanceId, matrix) {
            this.validateInstanceId(instanceId);
            const matricesTexture = this._matricesTexture;
            const matricesArray = this._matricesTexture.image.data;
            matrix.toArray(matricesArray, instanceId * 16);
            matricesTexture.needsUpdate = true;
            return this;
        }
        getMatrixAt(instanceId, matrix) {
            this.validateInstanceId(instanceId);
            return matrix.fromArray(this._matricesTexture.image.data, instanceId * 16);
        }
        setColorAt(instanceId, color) {
            this.validateInstanceId(instanceId);
            if (this._colorsTexture === null) {
                this._initColorsTexture();
            }
            color.toArray(this._colorsTexture.image.data, instanceId * 4);
            this._colorsTexture.needsUpdate = true;
            return this;
        }
        getColorAt(instanceId, color) {
            this.validateInstanceId(instanceId);
            return color.fromArray(this._colorsTexture.image.data, instanceId * 4);
        }
        setVisibleAt(instanceId, visible) {
            this.validateInstanceId(instanceId);
            if (this._instanceInfo[instanceId].visible === visible) {
                return this;
            }
            this._instanceInfo[instanceId].visible = visible;
            this._visibilityChanged = true;
            return this;
        }
        getVisibleAt(instanceId) {
            this.validateInstanceId(instanceId);
            return this._instanceInfo[instanceId].visible;
        }
        setGeometryIdAt(instanceId, geometryId) {
            this.validateInstanceId(instanceId);
            this.validateGeometryId(geometryId);
            this._instanceInfo[instanceId].geometryIndex = geometryId;
            return this;
        }
        getGeometryIdAt(instanceId) {
            this.validateInstanceId(instanceId);
            return this._instanceInfo[instanceId].geometryIndex;
        }
        getGeometryRangeAt(geometryId, target = {}) {
            this.validateGeometryId(geometryId);
            const geometryInfo = this._geometryInfo[geometryId];
            target.vertexStart = geometryInfo.vertexStart;
            target.vertexCount = geometryInfo.vertexCount;
            target.reservedVertexCount = geometryInfo.reservedVertexCount;
            target.indexStart = geometryInfo.indexStart;
            target.indexCount = geometryInfo.indexCount;
            target.reservedIndexCount = geometryInfo.reservedIndexCount;
            target.start = geometryInfo.start;
            target.count = geometryInfo.count;
            return target;
        }
        setInstanceCount(maxInstanceCount) {
            // shrink the available instances as much as possible
            const availableInstanceIds = this._availableInstanceIds;
            const instanceInfo = this._instanceInfo;
            availableInstanceIds.sort(ascIdSort);
            while (availableInstanceIds[availableInstanceIds.length - 1] === instanceInfo.length - 1) {
                instanceInfo.pop();
                availableInstanceIds.pop();
            }
            // throw an error if it can't be shrunk to the desired size
            if (maxInstanceCount < instanceInfo.length) {
                throw new Error(`BatchedMesh: Instance ids outside the range ${maxInstanceCount} are being used. Cannot shrink instance count.`);
            }
            // copy the multi draw counts
            const multiDrawCounts = new Int32Array(maxInstanceCount);
            const multiDrawStarts = new Int32Array(maxInstanceCount);
            copyArrayContents(this._multiDrawCounts, multiDrawCounts);
            copyArrayContents(this._multiDrawStarts, multiDrawStarts);
            this._multiDrawCounts = multiDrawCounts;
            this._multiDrawStarts = multiDrawStarts;
            this._maxInstanceCount = maxInstanceCount;
            // update texture data for instance sampling
            const indirectTexture = this._indirectTexture;
            const matricesTexture = this._matricesTexture;
            const colorsTexture = this._colorsTexture;
            indirectTexture.dispose();
            this._initIndirectTexture();
            copyArrayContents(indirectTexture.image.data, this._indirectTexture.image.data);
            matricesTexture.dispose();
            this._initMatricesTexture();
            copyArrayContents(matricesTexture.image.data, this._matricesTexture.image.data);
            if (colorsTexture) {
                colorsTexture.dispose();
                this._initColorsTexture();
                copyArrayContents(colorsTexture.image.data, this._colorsTexture.image.data);
            }
        }
        setGeometrySize(maxVertexCount, maxIndexCount) {
            // Check if we can shrink to the requested vertex attribute size
            const validRanges = [...this._geometryInfo].filter(info => info.active);
            const requiredVertexLength = Math.max(...validRanges.map(range => range.vertexStart + range.reservedVertexCount));
            if (requiredVertexLength > maxVertexCount) {
                throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${maxIndexCount}. Cannot shrink further.`);
            }
            // Check if we can shrink to the requested index attribute size
            if (this.geometry.index) {
                const requiredIndexLength = Math.max(...validRanges.map(range => range.indexStart + range.reservedIndexCount));
                if (requiredIndexLength > maxIndexCount) {
                    throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${maxIndexCount}. Cannot shrink further.`);
                }
            }
            //
            // dispose of the previous geometry
            const oldGeometry = this.geometry;
            oldGeometry.dispose();
            // recreate the geometry needed based on the previous variant
            this._maxVertexCount = maxVertexCount;
            this._maxIndexCount = maxIndexCount;
            if (this._geometryInitialized) {
                this._geometryInitialized = false;
                this.geometry = new BufferGeometry();
                this._initializeGeometry(oldGeometry);
            }
            // copy data from the previous geometry
            const geometry = this.geometry;
            if (oldGeometry.index) {
                copyArrayContents(oldGeometry.index.array, geometry.index.array);
            }
            for (const key in oldGeometry.attributes) {
                copyArrayContents(oldGeometry.attributes[key].array, geometry.attributes[key].array);
            }
        }
        raycast(raycaster, intersects) {
            const instanceInfo = this._instanceInfo;
            const geometryInfoList = this._geometryInfo;
            const matrixWorld = this.matrixWorld;
            const batchGeometry = this.geometry;
            // iterate over each geometry
            _mesh.material = this.material;
            _mesh.geometry.index = batchGeometry.index;
            _mesh.geometry.attributes = batchGeometry.attributes;
            if (_mesh.geometry.boundingBox === null) {
                _mesh.geometry.boundingBox = new Box3();
            }
            if (_mesh.geometry.boundingSphere === null) {
                _mesh.geometry.boundingSphere = new Sphere();
            }
            for (let i = 0, l = instanceInfo.length; i < l; i++) {
                if (!instanceInfo[i].visible || !instanceInfo[i].active) {
                    continue;
                }
                const geometryId = instanceInfo[i].geometryIndex;
                const geometryInfo = geometryInfoList[geometryId];
                _mesh.geometry.setDrawRange(geometryInfo.start, geometryInfo.count);
                // get the intersects
                this.getMatrixAt(i, _mesh.matrixWorld).premultiply(matrixWorld);
                this.getBoundingBoxAt(geometryId, _mesh.geometry.boundingBox);
                this.getBoundingSphereAt(geometryId, _mesh.geometry.boundingSphere);
                _mesh.raycast(raycaster, _batchIntersects);
                // add batch id to the intersects
                for (let j = 0, l = _batchIntersects.length; j < l; j++) {
                    const intersect = _batchIntersects[j];
                    intersect.object = this;
                    intersect.batchId = i;
                    intersects.push(intersect);
                }
                _batchIntersects.length = 0;
            }
            _mesh.material = null;
            _mesh.geometry.index = null;
            _mesh.geometry.attributes = {};
            _mesh.geometry.setDrawRange(0, Infinity);
        }
        copy(source) {
            super.copy(source);
            this.geometry = source.geometry.clone();
            this.perObjectFrustumCulled = source.perObjectFrustumCulled;
            this.sortObjects = source.sortObjects;
            this.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;
            this.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;
            this._geometryInfo = source._geometryInfo.map(info => ({
                ...info,
                boundingBox: info.boundingBox !== null ? info.boundingBox.clone() : null,
                boundingSphere: info.boundingSphere !== null ? info.boundingSphere.clone() : null,
            }));
            this._instanceInfo = source._instanceInfo.map(info => ({ ...info }));
            this._availableInstanceIds = source._availableInstanceIds.slice();
            this._availableGeometryIds = source._availableGeometryIds.slice();
            this._nextIndexStart = source._nextIndexStart;
            this._nextVertexStart = source._nextVertexStart;
            this._geometryCount = source._geometryCount;
            this._maxInstanceCount = source._maxInstanceCount;
            this._maxVertexCount = source._maxVertexCount;
            this._maxIndexCount = source._maxIndexCount;
            this._geometryInitialized = source._geometryInitialized;
            this._multiDrawCounts = source._multiDrawCounts.slice();
            this._multiDrawStarts = source._multiDrawStarts.slice();
            this._indirectTexture = source._indirectTexture.clone();
            this._indirectTexture.image.data = this._indirectTexture.image.data.slice();
            this._matricesTexture = source._matricesTexture.clone();
            this._matricesTexture.image.data = this._matricesTexture.image.data.slice();
            if (this._colorsTexture !== null) {
                this._colorsTexture = source._colorsTexture.clone();
                this._colorsTexture.image.data = this._colorsTexture.image.data.slice();
            }
            return this;
        }
        dispose() {
            // Assuming the geometry is not shared with other meshes
            this.geometry.dispose();
            this._matricesTexture.dispose();
            this._matricesTexture = null;
            this._indirectTexture.dispose();
            this._indirectTexture = null;
            if (this._colorsTexture !== null) {
                this._colorsTexture.dispose();
                this._colorsTexture = null;
            }
        }
        onBeforeRender(renderer, scene, camera, geometry, material/*, _group*/) {
            // if visibility has not changed and frustum culling and object sorting is not required
            // then skip iterating over all items
            if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) {
                return;
            }
            // the indexed version of the multi draw function requires specifying the start
            // offset in bytes.
            const index = geometry.getIndex();
            const bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;
            const instanceInfo = this._instanceInfo;
            const multiDrawStarts = this._multiDrawStarts;
            const multiDrawCounts = this._multiDrawCounts;
            const geometryInfoList = this._geometryInfo;
            const perObjectFrustumCulled = this.perObjectFrustumCulled;
            const indirectTexture = this._indirectTexture;
            const indirectArray = indirectTexture.image.data;
            const frustum = camera.isArrayCamera ? _frustumArray : _frustum;
            // prepare the frustum in the local frame
            if (perObjectFrustumCulled && !camera.isArrayCamera) {
                _matrix$1
                    .multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse)
                    .multiply(this.matrixWorld);
                _frustum.setFromProjectionMatrix(
                    _matrix$1,
                    camera.coordinateSystem,
                    camera.reversedDepth
                );
            }
            let multiDrawCount = 0;
            if (this.sortObjects) {
                // get the camera position in the local frame
                _matrix$1.copy(this.matrixWorld).invert();
                _vector$5.setFromMatrixPosition(camera.matrixWorld).applyMatrix4(_matrix$1);
                _forward$1.set(0, 0, -1).transformDirection(camera.matrixWorld).transformDirection(_matrix$1);
                for (let i = 0, l = instanceInfo.length; i < l; i++) {
                    if (instanceInfo[i].visible && instanceInfo[i].active) {
                        const geometryId = instanceInfo[i].geometryIndex;
                        // get the bounds in world space
                        this.getMatrixAt(i, _matrix$1);
                        this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
                        // determine whether the batched geometry is within the frustum
                        let culled = false;
                        if (perObjectFrustumCulled) {
                            culled = !frustum.intersectsSphere(_sphere$2, camera);
                        }
                        if (!culled) {
                            // get the distance from camera used for sorting
                            const geometryInfo = geometryInfoList[geometryId];
                            const z = _temp.subVectors(_sphere$2.center, _vector$5).dot(_forward$1);
                            _renderList.push(geometryInfo.start, geometryInfo.count, z, i);
                        }
                    }
                }
                // Sort the draw ranges and prep for rendering
                const list = _renderList.list;
                const customSort = this.customSort;
                if (customSort === null) {
                    list.sort(material.transparent ? sortTransparent : sortOpaque);
                } else {
                    customSort.call(this, list, camera);
                }
                for (let i = 0, l = list.length; i < l; i++) {
                    const item = list[i];
                    multiDrawStarts[multiDrawCount] = item.start * bytesPerElement;
                    multiDrawCounts[multiDrawCount] = item.count;
                    indirectArray[multiDrawCount] = item.index;
                    multiDrawCount++;
                }
                _renderList.reset();
            } else {
                for (let i = 0, l = instanceInfo.length; i < l; i++) {
                    if (instanceInfo[i].visible && instanceInfo[i].active) {
                        const geometryId = instanceInfo[i].geometryIndex;
                        // determine whether the batched geometry is within the frustum
                        let culled = false;
                        if (perObjectFrustumCulled) {
                            // get the bounds in world space
                            this.getMatrixAt(i, _matrix$1);
                            this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
                            culled = !frustum.intersectsSphere(_sphere$2, camera);
                        }
                        if (!culled) {
                            const geometryInfo = geometryInfoList[geometryId];
                            multiDrawStarts[multiDrawCount] = geometryInfo.start * bytesPerElement;
                            multiDrawCounts[multiDrawCount] = geometryInfo.count;
                            indirectArray[multiDrawCount] = i;
                            multiDrawCount++;
                        }
                    }
                }
            }
            indirectTexture.needsUpdate = true;
            this._multiDrawCount = multiDrawCount;
            this._visibilityChanged = false;
        }
        onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial/* , group */) {
            this.onBeforeRender(renderer, null, shadowCamera, geometry, depthMaterial);
        }
    }
    class LineBasicMaterial extends Material {
        constructor(parameters) {
            super();
            this.isLineBasicMaterial = true;
            this.type = 'LineBasicMaterial';
            this.color = new Color(0xffffff);
            this.map = null;
            this.linewidth = 1;
            this.linecap = 'round';
            this.linejoin = 'round';
            this.fog = true;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.map = source.map;
            this.linewidth = source.linewidth;
            this.linecap = source.linecap;
            this.linejoin = source.linejoin;
            this.fog = source.fog;
            return this;
        }
    }
    const _vStart = /*@__PURE__*/ new Vector3();
    const _vEnd = /*@__PURE__*/ new Vector3();
    const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
    const _ray$1 = /*@__PURE__*/ new Ray();
    const _sphere$1 = /*@__PURE__*/ new Sphere();
    const _intersectPointOnRay = /*@__PURE__*/ new Vector3();
    const _intersectPointOnSegment = /*@__PURE__*/ new Vector3();
    class Line extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
            super();
            this.isLine = true;
            this.type = 'Line';
            this.geometry = geometry;
            this.material = material;
            this.morphTargetDictionary = undefined;
            this.morphTargetInfluences = undefined;
            this.updateMorphTargets();
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
            this.geometry = source.geometry;
            return this;
        }
        computeLineDistances() {
            const geometry = this.geometry;
            // we assume non-indexed geometry
            if (geometry.index === null) {
                const positionAttribute = geometry.attributes.position;
                const lineDistances = [0];
                for (let i = 1, l = positionAttribute.count; i < l; i++) {
                    _vStart.fromBufferAttribute(positionAttribute, i - 1);
                    _vEnd.fromBufferAttribute(positionAttribute, i);
                    lineDistances[i] = lineDistances[i - 1];
                    lineDistances[i] += _vStart.distanceTo(_vEnd);
                }
                geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
            } else {
                console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
            }
            return this;
        }
        raycast(raycaster, intersects) {
            const geometry = this.geometry;
            const matrixWorld = this.matrixWorld;
            const threshold = raycaster.params.Line.threshold;
            const drawRange = geometry.drawRange;
            // Checking boundingSphere distance to ray
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            _sphere$1.copy(geometry.boundingSphere);
            _sphere$1.applyMatrix4(matrixWorld);
            _sphere$1.radius += threshold;
            if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
            //
            _inverseMatrix$1.copy(matrixWorld).invert();
            _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
            const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
            const localThresholdSq = localThreshold * localThreshold;
            const step = this.isLineSegments ? 2 : 1;
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(index.count, (drawRange.start + drawRange.count));
                for (let i = start, l = end - 1; i < l; i += step) {
                    const a = index.getX(i);
                    const b = index.getX(i + 1);
                    const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b, i);
                    if (intersect) {
                        intersects.push(intersect);
                    }
                }
                if (this.isLineLoop) {
                    const a = index.getX(end - 1);
                    const b = index.getX(start);
                    const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b, end - 1);
                    if (intersect) {
                        intersects.push(intersect);
                    }
                }
            } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(positionAttribute.count, (drawRange.start + drawRange.count));
                for (let i = start, l = end - 1; i < l; i += step) {
                    const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, i, i + 1, i);
                    if (intersect) {
                        intersects.push(intersect);
                    }
                }
                if (this.isLineLoop) {
                    const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, end - 1, start, end - 1);
                    if (intersect) {
                        intersects.push(intersect);
                    }
                }
            }
        }
        updateMorphTargets() {
            const geometry = this.geometry;
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        }
    }
    function checkIntersection(object, raycaster, ray, thresholdSq, a, b, i) {
        const positionAttribute = object.geometry.attributes.position;
        _vStart.fromBufferAttribute(positionAttribute, a);
        _vEnd.fromBufferAttribute(positionAttribute, b);
        const distSq = ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);
        if (distSq > thresholdSq) return;
        _intersectPointOnRay.applyMatrix4(object.matrixWorld); // Move back to world space for distance calculation
        const distance = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
        if (distance < raycaster.near || distance > raycaster.far) return;
        return {
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: object
        };
    }
    const _start = /*@__PURE__*/ new Vector3();
    const _end = /*@__PURE__*/ new Vector3();
    class LineSegments extends Line {
        constructor(geometry, material) {
            super(geometry, material);
            this.isLineSegments = true;
            this.type = 'LineSegments';
        }
        computeLineDistances() {
            const geometry = this.geometry;
            // we assume non-indexed geometry
            if (geometry.index === null) {
                const positionAttribute = geometry.attributes.position;
                const lineDistances = [];
                for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
                    _start.fromBufferAttribute(positionAttribute, i);
                    _end.fromBufferAttribute(positionAttribute, i + 1);
                    lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];
                    lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
                }
                geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
            } else {
                console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
            }
            return this;
        }
    }
    class LineLoop extends Line {
        constructor(geometry, material) {
            super(geometry, material);
            this.isLineLoop = true;
            this.type = 'LineLoop';
        }
    }
    class PointsMaterial extends Material {
        constructor(parameters) {
            super();
            this.isPointsMaterial = true;
            this.type = 'PointsMaterial';
            this.color = new Color(0xffffff);
            this.map = null;
            this.alphaMap = null;
            this.size = 1;
            this.sizeAttenuation = true;
            this.fog = true;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.map = source.map;
            this.alphaMap = source.alphaMap;
            this.size = source.size;
            this.sizeAttenuation = source.sizeAttenuation;
            this.fog = source.fog;
            return this;
        }
    }
    const _inverseMatrix = /*@__PURE__*/ new Matrix4();
    const _ray = /*@__PURE__*/ new Ray();
    const _sphere = /*@__PURE__*/ new Sphere();
    const _position$2 = /*@__PURE__*/ new Vector3();
    class Points extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
            super();
            this.isPoints = true;
            this.type = 'Points';
            this.geometry = geometry;
            this.material = material;
            this.morphTargetDictionary = undefined;
            this.morphTargetInfluences = undefined;
            this.updateMorphTargets();
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
            this.geometry = source.geometry;
            return this;
        }
        raycast(raycaster, intersects) {
            const geometry = this.geometry;
            const matrixWorld = this.matrixWorld;
            const threshold = raycaster.params.Points.threshold;
            const drawRange = geometry.drawRange;
            // Checking boundingSphere distance to ray
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            _sphere.copy(geometry.boundingSphere);
            _sphere.applyMatrix4(matrixWorld);
            _sphere.radius += threshold;
            if (raycaster.ray.intersectsSphere(_sphere) === false) return;
            //
            _inverseMatrix.copy(matrixWorld).invert();
            _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
            const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
            const localThresholdSq = localThreshold * localThreshold;
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(index.count, (drawRange.start + drawRange.count));
                for (let i = start, il = end; i < il; i++) {
                    const a = index.getX(i);
                    _position$2.fromBufferAttribute(positionAttribute, a);
                    testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
                }
            } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(positionAttribute.count, (drawRange.start + drawRange.count));
                for (let i = start, l = end; i < l; i++) {
                    _position$2.fromBufferAttribute(positionAttribute, i);
                    testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
                }
            }
        }
        updateMorphTargets() {
            const geometry = this.geometry;
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        }
    }
    function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
        const rayPointDistanceSq = _ray.distanceSqToPoint(point);
        if (rayPointDistanceSq < localThresholdSq) {
            const intersectPoint = new Vector3();
            _ray.closestPointToPoint(point, intersectPoint);
            intersectPoint.applyMatrix4(matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far) return;
            intersects.push({
                distance: distance,
                distanceToRay: Math.sqrt(rayPointDistanceSq),
                point: intersectPoint,
                index: index,
                face: null,
                faceIndex: null,
                barycoord: null,
                object: object
            });
        }
    }
    class VideoTexture extends Texture {
        constructor(video, mapping, wrapS, wrapT, magFilter = LinearFilter, minFilter = LinearFilter, format, type, anisotropy) {
            super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            this.isVideoTexture = true;
            this.generateMipmaps = false;
            this._requestVideoFrameCallbackId = 0;
            const scope = this;
            function updateVideo() {
                scope.needsUpdate = true;
                scope._requestVideoFrameCallbackId = video.requestVideoFrameCallback(updateVideo);
            }
            if ('requestVideoFrameCallback' in video) {
                this._requestVideoFrameCallbackId = video.requestVideoFrameCallback(updateVideo);
            }
        }
        clone() {
            return new this.constructor(this.image).copy(this);
        }
        update() {
            const video = this.image;
            const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;
            if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
                this.needsUpdate = true;
            }
        }
        dispose() {
            if (this._requestVideoFrameCallbackId !== 0) {
                this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId);
            }
            super.dispose();
        }
    }
    class VideoFrameTexture extends VideoTexture {
        constructor(mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
            super({}, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            this.isVideoFrameTexture = true;
        }
        update() { }
        clone() {
            return new this.constructor().copy(this); // restoring Texture.clone()
        }
        setFrame(frame) {
            this.image = frame;
            this.needsUpdate = true;
        }
    }
    class FramebufferTexture extends Texture {
        constructor(width, height) {
            super({ width, height });
            this.isFramebufferTexture = true;
            this.magFilter = NearestFilter;
            this.minFilter = NearestFilter;
            this.generateMipmaps = false;
            this.needsUpdate = true;
        }
    }
    class CompressedTexture extends Texture {
        constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace) {
            super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
            this.isCompressedTexture = true;
            this.image = { width: width, height: height };
            this.mipmaps = mipmaps;
            this.flipY = false;
            this.generateMipmaps = false;
        }
    }
    class CompressedArrayTexture extends CompressedTexture {
        constructor(mipmaps, width, height, depth, format, type) {
            super(mipmaps, width, height, format, type);
            this.isCompressedArrayTexture = true;
            this.image.depth = depth;
            this.wrapR = ClampToEdgeWrapping;
            this.layerUpdates = new Set();
        }
        addLayerUpdate(layerIndex) {
            this.layerUpdates.add(layerIndex);
        }
        clearLayerUpdates() {
            this.layerUpdates.clear();
        }
    }
    class CompressedCubeTexture extends CompressedTexture {
        constructor(images, format, type) {
            super(undefined, images[0].width, images[0].height, format, type, CubeReflectionMapping);
            this.isCompressedCubeTexture = true;
            this.isCubeTexture = true;
            this.image = images;
        }
    }
    class CanvasTexture extends Texture {
        constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
            super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            this.isCanvasTexture = true;
            this.needsUpdate = true;
        }
    }
    class DepthTexture extends Texture {
        constructor(width, height, type = UnsignedIntType, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, format = DepthFormat, depth = 1) {
            if (format !== DepthFormat && format !== DepthStencilFormat) {
                throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
            }
            const image = { width: width, height: height, depth: depth };
            super(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            this.isDepthTexture = true;
            this.flipY = false;
            this.generateMipmaps = false;
            this.compareFunction = null;
        }

        copy(source) {
            super.copy(source);
            this.source = new Source(Object.assign({}, source.image)); // see #30540
            this.compareFunction = source.compareFunction;
            return this;
        }
        toJSON(meta) {
            const data = super.toJSON(meta);
            if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
            return data;
        }
    }
    class CapsuleGeometry extends BufferGeometry {
        constructor(radius = 1, height = 1, capSegments = 4, radialSegments = 8, heightSegments = 1) {
            super();
            this.type = 'CapsuleGeometry';
            this.parameters = {
                radius: radius,
                height: height,
                capSegments: capSegments,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
            };
            height = Math.max(0, height);
            capSegments = Math.max(1, Math.floor(capSegments));
            radialSegments = Math.max(3, Math.floor(radialSegments));
            heightSegments = Math.max(1, Math.floor(heightSegments));
            // buffers
            const indices = [];
            const vertices = [];
            const normals = [];
            const uvs = [];
            // helper variables
            const halfHeight = height / 2;
            const capArcLength = (Math.PI / 2) * radius;
            const cylinderPartLength = height;
            const totalArcLength = 2 * capArcLength + cylinderPartLength;
            const numVerticalSegments = capSegments * 2 + heightSegments;
            const verticesPerRow = radialSegments + 1;
            const normal = new Vector3();
            const vertex = new Vector3();
            // generate vertices, normals, and uvs
            for (let iy = 0; iy <= numVerticalSegments; iy++) {
                let currentArcLength = 0;
                let profileY = 0;
                let profileRadius = 0;
                let normalYComponent = 0;
                if (iy <= capSegments) {
                    // bottom cap
                    const segmentProgress = iy / capSegments;
                    const angle = (segmentProgress * Math.PI) / 2;
                    profileY = - halfHeight - radius * Math.cos(angle);
                    profileRadius = radius * Math.sin(angle);
                    normalYComponent = - radius * Math.cos(angle);
                    currentArcLength = segmentProgress * capArcLength;
                } else if (iy <= capSegments + heightSegments) {
                    // middle section
                    const segmentProgress = (iy - capSegments) / heightSegments;
                    profileY = - halfHeight + segmentProgress * height;
                    profileRadius = radius;
                    normalYComponent = 0;
                    currentArcLength = capArcLength + segmentProgress * cylinderPartLength;
                } else {
                    // top cap
                    const segmentProgress =
                        (iy - capSegments - heightSegments) / capSegments;
                    const angle = (segmentProgress * Math.PI) / 2;
                    profileY = halfHeight + radius * Math.sin(angle);
                    profileRadius = radius * Math.cos(angle);
                    normalYComponent = radius * Math.sin(angle);
                    currentArcLength =
                        capArcLength + cylinderPartLength + segmentProgress * capArcLength;
                }
                const v = Math.max(0, Math.min(1, currentArcLength / totalArcLength));

                // special case for the poles
                let uOffset = 0;
                if (iy === 0) {
                    uOffset = 0.5 / radialSegments;
                } else if (iy === numVerticalSegments) {
                    uOffset = -0.5 / radialSegments;
                }
                for (let ix = 0; ix <= radialSegments; ix++) {
                    const u = ix / radialSegments;
                    const theta = u * Math.PI * 2;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    // vertex
                    vertex.x = - profileRadius * cosTheta;
                    vertex.y = profileY;
                    vertex.z = profileRadius * sinTheta;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal
                    normal.set(
                        - profileRadius * cosTheta,
                        normalYComponent,
                        profileRadius * sinTheta
                    );
                    normal.normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    // uv
                    uvs.push(u + uOffset, v);
                }
                if (iy > 0) {
                    const prevIndexRow = (iy - 1) * verticesPerRow;
                    for (let ix = 0; ix < radialSegments; ix++) {
                        const i1 = prevIndexRow + ix;
                        const i2 = prevIndexRow + ix + 1;
                        const i3 = iy * verticesPerRow + ix;
                        const i4 = iy * verticesPerRow + ix + 1;
                        indices.push(i1, i2, i3);
                        indices.push(i2, i4, i3);
                    }
                }
            }
            // build geometry
            this.setIndex(indices);
            this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
        static fromJSON(data) {
            return new CapsuleGeometry(data.radius, data.height, data.capSegments, data.radialSegments, data.heightSegments);
        }
    }
    class CircleGeometry extends BufferGeometry {
        constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {
            super();
            this.type = 'CircleGeometry';
            this.parameters = {
                radius: radius,
                segments: segments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            segments = Math.max(3, segments);
            // buffers
            const indices = [];
            const vertices = [];
            const normals = [];
            const uvs = [];
            // helper variables
            const vertex = new Vector3();
            const uv = new Vector2();
            // center point
            vertices.push(0, 0, 0);
            normals.push(0, 0, 1);
            uvs.push(0.5, 0.5);
            for (let s = 0, i = 3; s <= segments; s++, i += 3) {
                const segment = thetaStart + s / segments * thetaLength;
                // vertex
                vertex.x = radius * Math.cos(segment);
                vertex.y = radius * Math.sin(segment);
                vertices.push(vertex.x, vertex.y, vertex.z);
                // normal
                normals.push(0, 0, 1);
                // uvs
                uv.x = (vertices[i] / radius + 1) / 2;
                uv.y = (vertices[i + 1] / radius + 1) / 2;
                uvs.push(uv.x, uv.y);
            }
            // indices
            for (let i = 1; i <= segments; i++) {
                indices.push(i, i + 1, 0);
            }
            // build geometry
            this.setIndex(indices);
            this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
        static fromJSON(data) {
            return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
        }
    }
    class CylinderGeometry extends BufferGeometry {
        constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
            super();
            this.type = 'CylinderGeometry';
            this.parameters = {
                radiusTop: radiusTop,
                radiusBottom: radiusBottom,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            const scope = this;
            radialSegments = Math.floor(radialSegments);
            heightSegments = Math.floor(heightSegments);
            // buffers
            const indices = [];
            const vertices = [];
            const normals = [];
            const uvs = [];
            // helper variables
            let index = 0;
            const indexArray = [];
            const halfHeight = height / 2;
            let groupStart = 0;
            // generate geometry
            generateTorso();
            if (openEnded === false) {
                if (radiusTop > 0) generateCap(true);
                if (radiusBottom > 0) generateCap(false);
            }
            // build geometry
            this.setIndex(indices);
            this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            function generateTorso() {
                const normal = new Vector3();
                const vertex = new Vector3();
                let groupCount = 0;
                // this will be used to calculate the normal
                const slope = (radiusBottom - radiusTop) / height;
                // generate vertices, normals and uvs
                for (let y = 0; y <= heightSegments; y++) {
                    const indexRow = [];
                    const v = y / heightSegments;
                    // calculate the radius of the current row
                    const radius = v * (radiusBottom - radiusTop) + radiusTop;
                    for (let x = 0; x <= radialSegments; x++) {
                        const u = x / radialSegments;
                        const theta = u * thetaLength + thetaStart;
                        const sinTheta = Math.sin(theta);
                        const cosTheta = Math.cos(theta);
                        // vertex
                        vertex.x = radius * sinTheta;
                        vertex.y = - v * height + halfHeight;
                        vertex.z = radius * cosTheta;
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        // normal
                        normal.set(sinTheta, slope, cosTheta).normalize();
                        normals.push(normal.x, normal.y, normal.z);
                        // uv
                        uvs.push(u, 1 - v);
                        // save index of vertex in respective row
                        indexRow.push(index++);
                    }
                    // now save vertices of the row in our index array
                    indexArray.push(indexRow);
                }
                // generate indices
                for (let x = 0; x < radialSegments; x++) {
                    for (let y = 0; y < heightSegments; y++) {
                        // we use the index array to access the correct indices
                        const a = indexArray[y][x];
                        const b = indexArray[y + 1][x];
                        const c = indexArray[y + 1][x + 1];
                        const d = indexArray[y][x + 1];
                        // faces
                        if (radiusTop > 0 || y !== 0) {
                            indices.push(a, b, d);
                            groupCount += 3;
                        }
                        if (radiusBottom > 0 || y !== heightSegments - 1) {
                            indices.push(b, c, d);
                            groupCount += 3;
                        }
                    }
                }
                // add a group to the geometry. this will ensure multi material support
                scope.addGroup(groupStart, groupCount, 0);
                // calculate new start value for groups
                groupStart += groupCount;
            }
            function generateCap(top) {
                // save the index of the first center vertex
                const centerIndexStart = index;
                const uv = new Vector2();
                const vertex = new Vector3();
                let groupCount = 0;
                const radius = (top === true) ? radiusTop : radiusBottom;
                const sign = (top === true) ? 1 : -1;
                // first we generate the center vertex data of the cap.
                // because the geometry needs one set of uvs per face,
                // we must generate a center vertex per face/segment
                for (let x = 1; x <= radialSegments; x++) {
                    // vertex
                    vertices.push(0, halfHeight * sign, 0);
                    // normal
                    normals.push(0, sign, 0);
                    // uv
                    uvs.push(0.5, 0.5);
                    // increase index
                    index++;
                }
                // save the index of the last center vertex
                const centerIndexEnd = index;
                // now we generate the surrounding vertices, normals and uvs
                for (let x = 0; x <= radialSegments; x++) {
                    const u = x / radialSegments;
                    const theta = u * thetaLength + thetaStart;
                    const cosTheta = Math.cos(theta);
                    const sinTheta = Math.sin(theta);
                    // vertex
                    vertex.x = radius * sinTheta;
                    vertex.y = halfHeight * sign;
                    vertex.z = radius * cosTheta;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal
                    normals.push(0, sign, 0);
                    // uv
                    uv.x = (cosTheta * 0.5) + 0.5;
                    uv.y = (sinTheta * 0.5 * sign) + 0.5;
                    uvs.push(uv.x, uv.y);
                    // increase index
                    index++;
                }
                // generate indices
                for (let x = 0; x < radialSegments; x++) {
                    const c = centerIndexStart + x;
                    const i = centerIndexEnd + x;
                    if (top === true) {
                        // face top
                        indices.push(i, i + 1, c);
                    } else {
                        // face bottom
                        indices.push(i + 1, i, c);
                    }
                    groupCount += 3;
                }
                // add a group to the geometry. this will ensure multi material support
                scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
                // calculate new start value for groups
                groupStart += groupCount;
            }
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
        static fromJSON(data) {
            return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
        }
    }
    class ConeGeometry extends CylinderGeometry {
        constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
            super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
            this.type = 'ConeGeometry';
            this.parameters = {
                radius: radius,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
        }
        static fromJSON(data) {
            return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
        }
    }
    class PolyhedronGeometry extends BufferGeometry {
        constructor(vertices = [], indices = [], radius = 1, detail = 0) {
            super();
            this.type = 'PolyhedronGeometry';
            this.parameters = {
                vertices: vertices,
                indices: indices,
                radius: radius,
                detail: detail
            };
            // default buffer data
            const vertexBuffer = [];
            const uvBuffer = [];
            // the subdivision creates the vertex buffer data
            subdivide(detail);
            // all vertices should lie on a conceptual sphere with a given radius
            applyRadius(radius);
            // finally, create the uv data
            generateUVs();
            // build non-indexed geometry
            this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
            this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
            if (detail === 0) {
                this.computeVertexNormals(); // flat normals
            } else {
                this.normalizeNormals(); // smooth normals
            }
            // helper functions
            function subdivide(detail) {
                const a = new Vector3();
                const b = new Vector3();
                const c = new Vector3();
                // iterate over all faces and apply a subdivision with the given detail value
                for (let i = 0; i < indices.length; i += 3) {
                    // get the vertices of the face
                    getVertexByIndex(indices[i + 0], a);
                    getVertexByIndex(indices[i + 1], b);
                    getVertexByIndex(indices[i + 2], c);
                    // perform subdivision
                    subdivideFace(a, b, c, detail);
                }
            }
            function subdivideFace(a, b, c, detail) {
                const cols = detail + 1;
                // we use this multidimensional array as a data structure for creating the subdivision
                const v = [];
                // construct all of the vertices for this subdivision
                for (let i = 0; i <= cols; i++) {
                    v[i] = [];
                    const aj = a.clone().lerp(c, i / cols);
                    const bj = b.clone().lerp(c, i / cols);
                    const rows = cols - i;
                    for (let j = 0; j <= rows; j++) {
                        if (j === 0 && i === cols) {
                            v[i][j] = aj;
                        } else {
                            v[i][j] = aj.clone().lerp(bj, j / rows);
                        }
                    }
                }
                // construct all of the faces
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < 2 * (cols - i) - 1; j++) {
                        const k = Math.floor(j / 2);
                        if (j % 2 === 0) {
                            pushVertex(v[i][k + 1]);
                            pushVertex(v[i + 1][k]);
                            pushVertex(v[i][k]);
                        } else {
                            pushVertex(v[i][k + 1]);
                            pushVertex(v[i + 1][k + 1]);
                            pushVertex(v[i + 1][k]);
                        }
                    }
                }
            }
            function applyRadius(radius) {
                const vertex = new Vector3();
                // iterate over the entire buffer and apply the radius to each vertex
                for (let i = 0; i < vertexBuffer.length; i += 3) {
                    vertex.x = vertexBuffer[i + 0];
                    vertex.y = vertexBuffer[i + 1];
                    vertex.z = vertexBuffer[i + 2];
                    vertex.normalize().multiplyScalar(radius);
                    vertexBuffer[i + 0] = vertex.x;
                    vertexBuffer[i + 1] = vertex.y;
                    vertexBuffer[i + 2] = vertex.z;
                }
            }
            function generateUVs() {
                const vertex = new Vector3();
                for (let i = 0; i < vertexBuffer.length; i += 3) {
                    vertex.x = vertexBuffer[i + 0];
                    vertex.y = vertexBuffer[i + 1];
                    vertex.z = vertexBuffer[i + 2];
                    const u = azimuth(vertex) / 2 / Math.PI + 0.5;
                    const v = inclination(vertex) / Math.PI + 0.5;
                    uvBuffer.push(u, 1 - v);
                }
                correctUVs();
                correctSeam();
            }
            function correctSeam() {
                // handle case when face straddles the seam, see #3269
                for (let i = 0; i < uvBuffer.length; i += 6) {
                    // uv data of a single face
                    const x0 = uvBuffer[i + 0];
                    const x1 = uvBuffer[i + 2];
                    const x2 = uvBuffer[i + 4];
                    const max = Math.max(x0, x1, x2);
                    const min = Math.min(x0, x1, x2);
                    // 0.9 is somewhat arbitrary
                    if (max > 0.9 && min < 0.1) {
                        if (x0 < 0.2) uvBuffer[i + 0] += 1;
                        if (x1 < 0.2) uvBuffer[i + 2] += 1;
                        if (x2 < 0.2) uvBuffer[i + 4] += 1;
                    }
                }
            }
            function pushVertex(vertex) {
                vertexBuffer.push(vertex.x, vertex.y, vertex.z);
            }
            function getVertexByIndex(index, vertex) {
                const stride = index * 3;
                vertex.x = vertices[stride + 0];
                vertex.y = vertices[stride + 1];
                vertex.z = vertices[stride + 2];
            }
            function correctUVs() {
                const a = new Vector3();
                const b = new Vector3();
                const c = new Vector3();
                const centroid = new Vector3();
                const uvA = new Vector2();
                const uvB = new Vector2();
                const uvC = new Vector2();
                for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
                    a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                    b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                    c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
                    uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                    uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                    uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                    centroid.copy(a).add(b).add(c).divideScalar(3);
                    const azi = azimuth(centroid);
                    correctUV(uvA, j + 0, a, azi);
                    correctUV(uvB, j + 2, b, azi);
                    correctUV(uvC, j + 4, c, azi);
                }
            }
            function correctUV(uv, stride, vector, azimuth) {
                if ((azimuth < 0) && (uv.x === 1)) {
                    uvBuffer[stride] = uv.x - 1;
                }
                if ((vector.x === 0) && (vector.z === 0)) {
                    uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
                }
            }
            // Angle around the Y axis, counter-clockwise when looking from above.
            function azimuth(vector) {
                return Math.atan2(vector.z, - vector.x);
            }

            // Angle above the XZ plane.
            function inclination(vector) {
                return Math.atan2(- vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
            }
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
        static fromJSON(data) {
            return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
        }
    }
    class DodecahedronGeometry extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
            const t = (1 + Math.sqrt(5)) / 2;
            const r = 1 / t;
            const vertices = [
                // (±1, ±1, ±1)
                -1, -1, -1, -1, -1, 1,
                -1, 1, -1, -1, 1, 1,
                1, -1, -1, 1, -1, 1,
                1, 1, -1, 1, 1, 1,
                // (0, ±1/φ, ±φ)
                0, - r, - t, 0, - r, t,
                0, r, - t, 0, r, t,
                // (±1/φ, ±φ, 0)
                - r, - t, 0, - r, t, 0,
                r, - t, 0, r, t, 0,
                // (±φ, 0, ±1/φ)
                - t, 0, - r, t, 0, - r,
                - t, 0, r, t, 0, r
            ];
            const indices = [
                3, 11, 7, 3, 7, 15, 3, 15, 13,
                7, 19, 17, 7, 17, 6, 7, 6, 15,
                17, 4, 8, 17, 8, 10, 17, 10, 6,
                8, 0, 16, 8, 16, 2, 8, 2, 10,
                0, 12, 1, 0, 1, 18, 0, 18, 16,
                6, 10, 2, 6, 2, 13, 6, 13, 15,
                2, 16, 18, 2, 18, 3, 2, 3, 13,
                18, 1, 9, 18, 9, 11, 18, 11, 3,
                4, 14, 12, 4, 12, 0, 4, 0, 8,
                11, 9, 5, 11, 5, 19, 11, 19, 7,
                19, 5, 14, 19, 14, 4, 19, 4, 17,
                1, 12, 14, 1, 14, 5, 1, 5, 9
            ];
            super(vertices, indices, radius, detail);
            this.type = 'DodecahedronGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
        }
        static fromJSON(data) {
            return new DodecahedronGeometry(data.radius, data.detail);
        }
    }
    const _v0 = /*@__PURE__*/ new Vector3();
    const _v1$1 = /*@__PURE__*/ new Vector3();
    const _normal = /*@__PURE__*/ new Vector3();
    const _triangle = /*@__PURE__*/ new Triangle();
    class EdgesGeometry extends BufferGeometry {
        constructor(geometry = null, thresholdAngle = 1) {
            super();
            this.type = 'EdgesGeometry';
            this.parameters = {
                geometry: geometry,
                thresholdAngle: thresholdAngle
            };
            if (geometry !== null) {
                const precisionPoints = 4;
                const precision = Math.pow(10, precisionPoints);
                const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
                const indexAttr = geometry.getIndex();
                const positionAttr = geometry.getAttribute('position');
                const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
                const indexArr = [0, 0, 0];
                const vertKeys = ['a', 'b', 'c'];
                const hashes = new Array(3);
                const edgeData = {};
                const vertices = [];
                for (let i = 0; i < indexCount; i += 3) {
                    if (indexAttr) {
                        indexArr[0] = indexAttr.getX(i);
                        indexArr[1] = indexAttr.getX(i + 1);
                        indexArr[2] = indexAttr.getX(i + 2);
                    } else {
                        indexArr[0] = i;
                        indexArr[1] = i + 1;
                        indexArr[2] = i + 2;
                    }
                    const { a, b, c } = _triangle;
                    a.fromBufferAttribute(positionAttr, indexArr[0]);
                    b.fromBufferAttribute(positionAttr, indexArr[1]);
                    c.fromBufferAttribute(positionAttr, indexArr[2]);
                    _triangle.getNormal(_normal);
                    // create hashes for the edge from the vertices
                    hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
                    hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
                    hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
                    // skip degenerate triangles
                    if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
                        continue;
                    }
                    // iterate over every edge
                    for (let j = 0; j < 3; j++) {
                        // get the first and next vertex making up the edge
                        const jNext = (j + 1) % 3;
                        const vecHash0 = hashes[j];
                        const vecHash1 = hashes[jNext];
                        const v0 = _triangle[vertKeys[j]];
                        const v1 = _triangle[vertKeys[jNext]];
                        const hash = `${vecHash0}_${vecHash1}`;
                        const reverseHash = `${vecHash1}_${vecHash0}`;
                        if (reverseHash in edgeData && edgeData[reverseHash]) {
                            // if we found a sibling edge add it into the vertex array if
                            // it meets the angle threshold and delete the edge from the map.
                            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                                vertices.push(v0.x, v0.y, v0.z);
                                vertices.push(v1.x, v1.y, v1.z);
                            }
                            edgeData[reverseHash] = null;
                        } else if (!(hash in edgeData)) {
                            // if we've already got an edge here then skip adding a new one
                            edgeData[hash] = {
                                index0: indexArr[j],
                                index1: indexArr[jNext],
                                normal: _normal.clone(),
                            };
                        }
                    }
                }
                // iterate over all remaining, unmatched edges and add them to the vertex array
                for (const key in edgeData) {
                    if (edgeData[key]) {
                        const { index0, index1 } = edgeData[key];
                        _v0.fromBufferAttribute(positionAttr, index0);
                        _v1$1.fromBufferAttribute(positionAttr, index1);
                        vertices.push(_v0.x, _v0.y, _v0.z);
                        vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
                    }
                }
                this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            }
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
    }
    class Curve {
        constructor() {
            this.type = 'Curve';
            this.arcLengthDivisions = 200;
            this.needsUpdate = false;
            this.cacheArcLengths = null;
        }
        getPoint( /* t, optionalTarget */) {
            console.warn('THREE.Curve: .getPoint() not implemented.');
        }
        getPointAt(u, optionalTarget) {
            const t = this.getUtoTmapping(u);
            return this.getPoint(t, optionalTarget);
        }
        getPoints(divisions = 5) {
            const points = [];
            for (let d = 0; d <= divisions; d++) {
                points.push(this.getPoint(d / divisions));
            }
            return points;
        }
        // Get sequence of points using getPointAt( u )
        getSpacedPoints(divisions = 5) {
            const points = [];
            for (let d = 0; d <= divisions; d++) {
                points.push(this.getPointAt(d / divisions));
            }
            return points;
        }
        getLength() {
            const lengths = this.getLengths();
            return lengths[lengths.length - 1];
        }
        getLengths(divisions = this.arcLengthDivisions) {
            if (this.cacheArcLengths &&
                (this.cacheArcLengths.length === divisions + 1) &&
                !this.needsUpdate) {
                return this.cacheArcLengths;
            }
            this.needsUpdate = false;
            const cache = [];
            let current, last = this.getPoint(0);
            let sum = 0;
            cache.push(0);
            for (let p = 1; p <= divisions; p++) {
                current = this.getPoint(p / divisions);
                sum += current.distanceTo(last);
                cache.push(sum);
                last = current;
            }
            this.cacheArcLengths = cache;
            return cache; // { sums: cache, sum: sum }; Sum is in the last element.
        }
        updateArcLengths() {
            this.needsUpdate = true;
            this.getLengths();
        }
        getUtoTmapping(u, distance = null) {
            const arcLengths = this.getLengths();
            let i = 0;
            const il = arcLengths.length;
            let targetArcLength; // The targeted u distance value to get
            if (distance) {
                targetArcLength = distance;
            } else {
                targetArcLength = u * arcLengths[il - 1];
            }
            // binary search for the index with largest value smaller than target u distance
            let low = 0, high = il - 1, comparison;
            while (low <= high) {
                i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
                comparison = arcLengths[i] - targetArcLength;
                if (comparison < 0) {
                    low = i + 1;
                } else if (comparison > 0) {
                    high = i - 1;
                } else {
                    high = i;
                    break;
                    // DONE
                }
            }
            i = high;
            if (arcLengths[i] === targetArcLength) {
                return i / (il - 1);
            }
            // we could get finer grain at lengths, or use simple interpolation between two points
            const lengthBefore = arcLengths[i];
            const lengthAfter = arcLengths[i + 1];
            const segmentLength = lengthAfter - lengthBefore;
            // determine where we are between the 'before' and 'after' points
            const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
            // add that fractional amount to t
            const t = (i + segmentFraction) / (il - 1);
            return t;
        }
        getTangent(t, optionalTarget) {
            const delta = 0.0001;
            let t1 = t - delta;
            let t2 = t + delta;
            // Capping in case of danger
            if (t1 < 0) t1 = 0;
            if (t2 > 1) t2 = 1;
            const pt1 = this.getPoint(t1);
            const pt2 = this.getPoint(t2);
            const tangent = optionalTarget || ((pt1.isVector2) ? new Vector2() : new Vector3());
            tangent.copy(pt2).sub(pt1).normalize();
            return tangent;
        }
        getTangentAt(u, optionalTarget) {
            const t = this.getUtoTmapping(u);
            return this.getTangent(t, optionalTarget);
        }
        computeFrenetFrames(segments, closed = false) {
            // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
            const normal = new Vector3();
            const tangents = [];
            const normals = [];
            const binormals = [];
            const vec = new Vector3();
            const mat = new Matrix4();
            // compute the tangent vectors for each segment on the curve
            for (let i = 0; i <= segments; i++) {
                const u = i / segments;
                tangents[i] = this.getTangentAt(u, new Vector3());
            }
            // select an initial normal vector perpendicular to the first tangent vector,
            // and in the direction of the minimum tangent xyz component
            normals[0] = new Vector3();
            binormals[0] = new Vector3();
            let min = Number.MAX_VALUE;
            const tx = Math.abs(tangents[0].x);
            const ty = Math.abs(tangents[0].y);
            const tz = Math.abs(tangents[0].z);
            if (tx <= min) {
                min = tx;
                normal.set(1, 0, 0);
            }
            if (ty <= min) {
                min = ty;
                normal.set(0, 1, 0);
            }
            if (tz <= min) {
                normal.set(0, 0, 1);
            }
            vec.crossVectors(tangents[0], normal).normalize();
            normals[0].crossVectors(tangents[0], vec);
            binormals[0].crossVectors(tangents[0], normals[0]);

            // compute the slowly-varying normal and binormal vectors for each segment on the curve
            for (let i = 1; i <= segments; i++) {
                normals[i] = normals[i - 1].clone();
                binormals[i] = binormals[i - 1].clone();
                vec.crossVectors(tangents[i - 1], tangents[i]);
                if (vec.length() > Number.EPSILON) {
                    vec.normalize();
                    const theta = Math.acos(clamp$1(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors
                    normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
                }
                binormals[i].crossVectors(tangents[i], normals[i]);
            }
            // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
            if (closed === true) {
                let theta = Math.acos(clamp$1(normals[0].dot(normals[segments]), -1, 1));
                theta /= segments;
                if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
                    theta = - theta;
                }
                for (let i = 1; i <= segments; i++) {
                    // twist a little...
                    normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                    binormals[i].crossVectors(tangents[i], normals[i]);
                }
            }
            return {
                tangents: tangents,
                normals: normals,
                binormals: binormals
            };
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(source) {
            this.arcLengthDivisions = source.arcLengthDivisions;
            return this;
        }
        toJSON() {
            const data = {
                metadata: {
                    version: 4.7,
                    type: 'Curve',
                    generator: 'Curve.toJSON'
                }
            };
            data.arcLengthDivisions = this.arcLengthDivisions;
            data.type = this.type;
            return data;
        }
        fromJSON(json) {
            this.arcLengthDivisions = json.arcLengthDivisions;
            return this;
        }
    }
    class EllipseCurve extends Curve {
        constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
            super();
            this.isEllipseCurve = true;
            this.type = 'EllipseCurve';
            this.aX = aX;
            this.aY = aY;
            this.xRadius = xRadius;
            this.yRadius = yRadius;
            this.aStartAngle = aStartAngle;
            this.aEndAngle = aEndAngle;
            this.aClockwise = aClockwise;
            this.aRotation = aRotation;
        }
        getPoint(t, optionalTarget = new Vector2()) {
            const point = optionalTarget;
            const twoPi = Math.PI * 2;
            let deltaAngle = this.aEndAngle - this.aStartAngle;
            const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
            // ensures that deltaAngle is 0 .. 2 PI
            while (deltaAngle < 0) deltaAngle += twoPi;
            while (deltaAngle > twoPi) deltaAngle -= twoPi;
            if (deltaAngle < Number.EPSILON) {
                if (samePoints) {
                    deltaAngle = 0;
                } else {
                    deltaAngle = twoPi;
                }
            }
            if (this.aClockwise === true && !samePoints) {
                if (deltaAngle === twoPi) {
                    deltaAngle = - twoPi;
                } else {
                    deltaAngle = deltaAngle - twoPi;
                }
            }
            const angle = this.aStartAngle + t * deltaAngle;
            let x = this.aX + this.xRadius * Math.cos(angle);
            let y = this.aY + this.yRadius * Math.sin(angle);
            if (this.aRotation !== 0) {
                const cos = Math.cos(this.aRotation);
                const sin = Math.sin(this.aRotation);
                const tx = x - this.aX;
                const ty = y - this.aY;
                // Rotate the point about the center of the ellipse.
                x = tx * cos - ty * sin + this.aX;
                y = tx * sin + ty * cos + this.aY;
            }
            return point.set(x, y);
        }
        copy(source) {
            super.copy(source);
            this.aX = source.aX;
            this.aY = source.aY;
            this.xRadius = source.xRadius;
            this.yRadius = source.yRadius;
            this.aStartAngle = source.aStartAngle;
            this.aEndAngle = source.aEndAngle;
            this.aClockwise = source.aClockwise;
            this.aRotation = source.aRotation;
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.aX = this.aX;
            data.aY = this.aY;
            data.xRadius = this.xRadius;
            data.yRadius = this.yRadius;
            data.aStartAngle = this.aStartAngle;
            data.aEndAngle = this.aEndAngle;
            data.aClockwise = this.aClockwise;
            data.aRotation = this.aRotation;
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.aX = json.aX;
            this.aY = json.aY;
            this.xRadius = json.xRadius;
            this.yRadius = json.yRadius;
            this.aStartAngle = json.aStartAngle;
            this.aEndAngle = json.aEndAngle;
            this.aClockwise = json.aClockwise;
            this.aRotation = json.aRotation;
            return this;
        }
    }
    class ArcCurve extends EllipseCurve {
        constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
            this.isArcCurve = true;
            this.type = 'ArcCurve';
        }
    }
    function CubicPoly() {

        /*
        Based on an optimized c++ solution in
        - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
        - http://ideone.com/NoEbVM
        This CubicPoly class could be used for reusing some variables and calculations,
        but for three.js curve use, it could be possible inlined and flatten into a single function call
        which can be placed in CurveUtils.
        */
        let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
        /*
         * Compute coefficients for a cubic polynomial
         *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
         * such that
         *   p(0) = x0, p(1) = x1
         *  and
         *   p'(0) = t0, p'(1) = t1.
         */
        function init(x0, x1, t0, t1) {
            c0 = x0;
            c1 = t0;
            c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
            c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }
        return {
            initCatmullRom: function (x0, x1, x2, x3, tension) {
                init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
            },
            initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
                // compute tangents when parameterized in [t1,t2]
                let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
                let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
                // rescale tangents for parametrization in [0,1]
                t1 *= dt1;
                t2 *= dt1;
                init(x1, x2, t1, t2);
            },
            calc: function (t) {
                const t2 = t * t;
                const t3 = t2 * t;
                return c0 + c1 * t + c2 * t2 + c3 * t3;
            }
        };
    }
    //
    const tmp = /*@__PURE__*/ new Vector3();
    const px = /*@__PURE__*/ new CubicPoly();
    const py = /*@__PURE__*/ new CubicPoly();
    const pz = /*@__PURE__*/ new CubicPoly();
    class CatmullRomCurve3 extends Curve {
        constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {
            super();
            this.isCatmullRomCurve3 = true;
            this.type = 'CatmullRomCurve3';
            this.points = points;
            this.closed = closed;
            this.curveType = curveType;
            this.tension = tension;
        }
        getPoint(t, optionalTarget = new Vector3()) {
            const point = optionalTarget;
            const points = this.points;
            const l = points.length;
            const p = (l - (this.closed ? 0 : 1)) * t;
            let intPoint = Math.floor(p);
            let weight = p - intPoint;
            if (this.closed) {
                intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
            } else if (weight === 0 && intPoint === l - 1) {
                intPoint = l - 2;
                weight = 1;
            }
            let p0, p3; // 4 points (p1 & p2 defined below)
            if (this.closed || intPoint > 0) {
                p0 = points[(intPoint - 1) % l];
            } else {
                // extrapolate first point
                tmp.subVectors(points[0], points[1]).add(points[0]);
                p0 = tmp;
            }
            const p1 = points[intPoint % l];
            const p2 = points[(intPoint + 1) % l];
            if (this.closed || intPoint + 2 < l) {
                p3 = points[(intPoint + 2) % l];
            } else {
                // extrapolate last point
                tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
                p3 = tmp;
            }
            if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
                // init Centripetal / Chordal Catmull-Rom
                const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
                let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
                let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
                let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
                // safety check for repeated points
                if (dt1 < 1e-4) dt1 = 1.0;
                if (dt0 < 1e-4) dt0 = dt1;
                if (dt2 < 1e-4) dt2 = dt1;
                px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
                py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
                pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
            } else if (this.curveType === 'catmullrom') {
                px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
                py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
                pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
            }
            point.set(
                px.calc(weight),
                py.calc(weight),
                pz.calc(weight)
            );
            return point;
        }
        copy(source) {
            super.copy(source);
            this.points = [];
            for (let i = 0, l = source.points.length; i < l; i++) {
                const point = source.points[i];
                this.points.push(point.clone());
            }
            this.closed = source.closed;
            this.curveType = source.curveType;
            this.tension = source.tension;
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.points = [];
            for (let i = 0, l = this.points.length; i < l; i++) {
                const point = this.points[i];
                data.points.push(point.toArray());
            }
            data.closed = this.closed;
            data.curveType = this.curveType;
            data.tension = this.tension;
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.points = [];
            for (let i = 0, l = json.points.length; i < l; i++) {
                const point = json.points[i];
                this.points.push(new Vector3().fromArray(point));
            }
            this.closed = json.closed;
            this.curveType = json.curveType;
            this.tension = json.tension;
            return this;
        }
    }
    // Bezier Curves formulas obtained from: https://en.wikipedia.org/wiki/B%C3%A9zier_curve
    function CatmullRom(t, p0, p1, p2, p3) {
        const v0 = (p2 - p0) * 0.5;
        const v1 = (p3 - p1) * 0.5;
        const t2 = t * t;
        const t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    //
    function QuadraticBezierP0(t, p) {
        const k = 1 - t;
        return k * k * p;
    }
    function QuadraticBezierP1(t, p) {
        return 2 * (1 - t) * t * p;
    }
    function QuadraticBezierP2(t, p) {
        return t * t * p;
    }
    function QuadraticBezier(t, p0, p1, p2) {
        return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) +
            QuadraticBezierP2(t, p2);
    }
    //
    function CubicBezierP0(t, p) {
        const k = 1 - t;
        return k * k * k * p;
    }
    function CubicBezierP1(t, p) {
        const k = 1 - t;
        return 3 * k * k * t * p;
    }
    function CubicBezierP2(t, p) {
        return 3 * (1 - t) * t * t * p;
    }
    function CubicBezierP3(t, p) {
        return t * t * t * p;
    }
    function CubicBezier(t, p0, p1, p2, p3) {
        return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) +
            CubicBezierP3(t, p3);
    }
    class CubicBezierCurve extends Curve {
        constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
            super();
            this.isCubicBezierCurve = true;
            this.type = 'CubicBezierCurve';
            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;
            this.v3 = v3;
        }
        getPoint(t, optionalTarget = new Vector2()) {
            const point = optionalTarget;
            const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
            point.set(
                CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
                CubicBezier(t, v0.y, v1.y, v2.y, v3.y)
            );
            return point;
        }
        copy(source) {
            super.copy(source);
            this.v0.copy(source.v0);
            this.v1.copy(source.v1);
            this.v2.copy(source.v2);
            this.v3.copy(source.v3);
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.v0 = this.v0.toArray();
            data.v1 = this.v1.toArray();
            data.v2 = this.v2.toArray();
            data.v3 = this.v3.toArray();
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.v0.fromArray(json.v0);
            this.v1.fromArray(json.v1);
            this.v2.fromArray(json.v2);
            this.v3.fromArray(json.v3);
            return this;
        }
    }
    class CubicBezierCurve3 extends Curve {
        constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
            super();
            this.isCubicBezierCurve3 = true;
            this.type = 'CubicBezierCurve3';
            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;
            this.v3 = v3;
        }
        getPoint(t, optionalTarget = new Vector3()) {
            const point = optionalTarget;
            const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
            point.set(
                CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
                CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
                CubicBezier(t, v0.z, v1.z, v2.z, v3.z)
            );
            return point;
        }
        copy(source) {
            super.copy(source);
            this.v0.copy(source.v0);
            this.v1.copy(source.v1);
            this.v2.copy(source.v2);
            this.v3.copy(source.v3);
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.v0 = this.v0.toArray();
            data.v1 = this.v1.toArray();
            data.v2 = this.v2.toArray();
            data.v3 = this.v3.toArray();
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.v0.fromArray(json.v0);
            this.v1.fromArray(json.v1);
            this.v2.fromArray(json.v2);
            this.v3.fromArray(json.v3);
            return this;
        }
    }
    class LineCurve extends Curve {
        constructor(v1 = new Vector2(), v2 = new Vector2()) {
            super();
            this.isLineCurve = true;
            this.type = 'LineCurve';
            this.v1 = v1;
            this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector2()) {
            const point = optionalTarget;
            if (t === 1) {
                point.copy(this.v2);
            } else {
                point.copy(this.v2).sub(this.v1);
                point.multiplyScalar(t).add(this.v1);
            }
            return point;
        }
        // Line curve is linear, so we can overwrite default getPointAt
        getPointAt(u, optionalTarget) {
            return this.getPoint(u, optionalTarget);
        }
        getTangent(t, optionalTarget = new Vector2()) {
            return optionalTarget.subVectors(this.v2, this.v1).normalize();
        }
        getTangentAt(u, optionalTarget) {
            return this.getTangent(u, optionalTarget);
        }
        copy(source) {
            super.copy(source);
            this.v1.copy(source.v1);
            this.v2.copy(source.v2);
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.v1 = this.v1.toArray();
            data.v2 = this.v2.toArray();
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.v1.fromArray(json.v1);
            this.v2.fromArray(json.v2);
            return this;
        }
    }
    class LineCurve3 extends Curve {
        constructor(v1 = new Vector3(), v2 = new Vector3()) {
            super();
            this.isLineCurve3 = true;
            this.type = 'LineCurve3';
            this.v1 = v1;
            this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector3()) {
            const point = optionalTarget;
            if (t === 1) {
                point.copy(this.v2);
            } else {
                point.copy(this.v2).sub(this.v1);
                point.multiplyScalar(t).add(this.v1);
            }
            return point;
        }
        // Line curve is linear, so we can overwrite default getPointAt
        getPointAt(u, optionalTarget) {
            return this.getPoint(u, optionalTarget);
        }
        getTangent(t, optionalTarget = new Vector3()) {
            return optionalTarget.subVectors(this.v2, this.v1).normalize();
        }
        getTangentAt(u, optionalTarget) {
            return this.getTangent(u, optionalTarget);
        }
        copy(source) {
            super.copy(source);
            this.v1.copy(source.v1);
            this.v2.copy(source.v2);
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.v1 = this.v1.toArray();
            data.v2 = this.v2.toArray();
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.v1.fromArray(json.v1);
            this.v2.fromArray(json.v2);
            return this;
        }
    }
    class QuadraticBezierCurve extends Curve {
        constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
            super();
            this.isQuadraticBezierCurve = true;
            this.type = 'QuadraticBezierCurve';
            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector2()) {
            const point = optionalTarget;
            const v0 = this.v0, v1 = this.v1, v2 = this.v2;
            point.set(
                QuadraticBezier(t, v0.x, v1.x, v2.x),
                QuadraticBezier(t, v0.y, v1.y, v2.y)
            );
            return point;
        }
        copy(source) {
            super.copy(source);
            this.v0.copy(source.v0);
            this.v1.copy(source.v1);
            this.v2.copy(source.v2);
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.v0 = this.v0.toArray();
            data.v1 = this.v1.toArray();
            data.v2 = this.v2.toArray();
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.v0.fromArray(json.v0);
            this.v1.fromArray(json.v1);
            this.v2.fromArray(json.v2);
            return this;
        }
    }
    class QuadraticBezierCurve3 extends Curve {
        constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
            super();
            this.isQuadraticBezierCurve3 = true;
            this.type = 'QuadraticBezierCurve3';
            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector3()) {
            const point = optionalTarget;
            const v0 = this.v0, v1 = this.v1, v2 = this.v2;
            point.set(
                QuadraticBezier(t, v0.x, v1.x, v2.x),
                QuadraticBezier(t, v0.y, v1.y, v2.y),
                QuadraticBezier(t, v0.z, v1.z, v2.z)
            );
            return point;
        }
        copy(source) {
            super.copy(source);
            this.v0.copy(source.v0);
            this.v1.copy(source.v1);
            this.v2.copy(source.v2);
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.v0 = this.v0.toArray();
            data.v1 = this.v1.toArray();
            data.v2 = this.v2.toArray();
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.v0.fromArray(json.v0);
            this.v1.fromArray(json.v1);
            this.v2.fromArray(json.v2);
            return this;
        }
    }
    class SplineCurve extends Curve {
        constructor(points = []) {
            super();
            this.isSplineCurve = true;
            this.type = 'SplineCurve';
            this.points = points;
        }
        getPoint(t, optionalTarget = new Vector2()) {
            const point = optionalTarget;
            const points = this.points;
            const p = (points.length - 1) * t;
            const intPoint = Math.floor(p);
            const weight = p - intPoint;
            const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
            const p1 = points[intPoint];
            const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
            const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
            point.set(
                CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),
                CatmullRom(weight, p0.y, p1.y, p2.y, p3.y)
            );
            return point;
        }
        copy(source) {
            super.copy(source);
            this.points = [];
            for (let i = 0, l = source.points.length; i < l; i++) {
                const point = source.points[i];
                this.points.push(point.clone());
            }
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.points = [];
            for (let i = 0, l = this.points.length; i < l; i++) {
                const point = this.points[i];
                data.points.push(point.toArray());
            }
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.points = [];
            for (let i = 0, l = json.points.length; i < l; i++) {
                const point = json.points[i];
                this.points.push(new Vector2().fromArray(point));
            }
            return this;
        }
    }
    var Curves = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ArcCurve: ArcCurve,
        CatmullRomCurve3: CatmullRomCurve3,
        CubicBezierCurve: CubicBezierCurve,
        CubicBezierCurve3: CubicBezierCurve3,
        EllipseCurve: EllipseCurve,
        LineCurve: LineCurve,
        LineCurve3: LineCurve3,
        QuadraticBezierCurve: QuadraticBezierCurve,
        QuadraticBezierCurve3: QuadraticBezierCurve3,
        SplineCurve: SplineCurve
    });
    class CurvePath extends Curve {
        constructor() {
            super();
            this.type = 'CurvePath';
            this.curves = [];
            this.autoClose = false;
        }
        add(curve) {
            this.curves.push(curve);
        }
        closePath() {
            // Add a line curve if start and end of lines are not connected
            const startPoint = this.curves[0].getPoint(0);
            const endPoint = this.curves[this.curves.length - 1].getPoint(1);
            if (!startPoint.equals(endPoint)) {
                const lineType = (startPoint.isVector2 === true) ? 'LineCurve' : 'LineCurve3';
                this.curves.push(new Curves[lineType](endPoint, startPoint));
            }
            return this;
        }
        getPoint(t, optionalTarget) {
            // To get accurate point with reference to
            // entire path distance at time t,
            // following has to be done:
            // 1. Length of each sub path have to be known
            // 2. Locate and identify type of curve
            // 3. Get t for the curve
            // 4. Return curve.getPointAt(t')
            const d = t * this.getLength();
            const curveLengths = this.getCurveLengths();
            let i = 0;
            // To think about boundaries points.
            while (i < curveLengths.length) {
                if (curveLengths[i] >= d) {
                    const diff = curveLengths[i] - d;
                    const curve = this.curves[i];
                    const segmentLength = curve.getLength();
                    const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                    return curve.getPointAt(u, optionalTarget);
                }
                i++;
            }
            return null;
            // loop where sum != 0, sum > d , sum+1 <d
        }
        getLength() {
            // We cannot use the default THREE.Curve getPoint() with getLength() because in
            // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
            // getPoint() depends on getLength
            const lens = this.getCurveLengths();
            return lens[lens.length - 1];
        }
        updateArcLengths() {
            // cacheLengths must be recalculated.
            this.needsUpdate = true;
            this.cacheLengths = null;
            this.getCurveLengths();
        }
        getCurveLengths() {
            // Compute lengths and cache them
            // We cannot overwrite getLengths() because UtoT mapping uses it.
            // We use cache values if curves and cache array are same length
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
                return this.cacheLengths;
            }
            // Get length of sub-curve
            // Push sums into cached array
            const lengths = [];
            let sums = 0;
            for (let i = 0, l = this.curves.length; i < l; i++) {
                sums += this.curves[i].getLength();
                lengths.push(sums);
            }
            this.cacheLengths = lengths;
            return lengths;
        }
        getSpacedPoints(divisions = 40) {
            const points = [];
            for (let i = 0; i <= divisions; i++) {
                points.push(this.getPoint(i / divisions));
            }
            if (this.autoClose) {
                points.push(points[0]);
            }
            return points;
        }
        getPoints(divisions = 12) {
            const points = [];
            let last;
            for (let i = 0, curves = this.curves; i < curves.length; i++) {
                const curve = curves[i];
                const resolution = curve.isEllipseCurve ? divisions * 2
                    : (curve.isLineCurve || curve.isLineCurve3) ? 1
                        : curve.isSplineCurve ? divisions * curve.points.length
                            : divisions;
                const pts = curve.getPoints(resolution);
                for (let j = 0; j < pts.length; j++) {
                    const point = pts[j];
                    if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates
                    points.push(point);
                    last = point;
                }
            }
            if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                points.push(points[0]);
            }
            return points;
        }
        copy(source) {
            super.copy(source);
            this.curves = [];
            for (let i = 0, l = source.curves.length; i < l; i++) {
                const curve = source.curves[i];
                this.curves.push(curve.clone());
            }
            this.autoClose = source.autoClose;
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.autoClose = this.autoClose;
            data.curves = [];
            for (let i = 0, l = this.curves.length; i < l; i++) {
                const curve = this.curves[i];
                data.curves.push(curve.toJSON());
            }
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.autoClose = json.autoClose;
            this.curves = [];
            for (let i = 0, l = json.curves.length; i < l; i++) {
                const curve = json.curves[i];
                this.curves.push(new Curves[curve.type]().fromJSON(curve));
            }
            return this;
        }
    }
    class Path extends CurvePath {
        constructor(points) {
            super();
            this.type = 'Path';
            this.currentPoint = new Vector2();
            if (points) {
                this.setFromPoints(points);
            }
        }
        setFromPoints(points) {
            this.moveTo(points[0].x, points[0].y);
            for (let i = 1, l = points.length; i < l; i++) {
                this.lineTo(points[i].x, points[i].y);
            }
            return this;
        }
        moveTo(x, y) {
            this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
            return this;
        }
        lineTo(x, y) {
            const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
            this.curves.push(curve);
            this.currentPoint.set(x, y);
            return this;
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
            const curve = new QuadraticBezierCurve(
                this.currentPoint.clone(),
                new Vector2(aCPx, aCPy),
                new Vector2(aX, aY)
            );
            this.curves.push(curve);
            this.currentPoint.set(aX, aY);
            return this;
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            const curve = new CubicBezierCurve(
                this.currentPoint.clone(),
                new Vector2(aCP1x, aCP1y),
                new Vector2(aCP2x, aCP2y),
                new Vector2(aX, aY)
            );
            this.curves.push(curve);
            this.currentPoint.set(aX, aY);
            return this;
        }
        splineThru(pts) {
            const npts = [this.currentPoint.clone()].concat(pts);
            const curve = new SplineCurve(npts);
            this.curves.push(curve);
            this.currentPoint.copy(pts[pts.length - 1]);
            return this;
        }
        arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            const x0 = this.currentPoint.x;
            const y0 = this.currentPoint.y;
            this.absarc(aX + x0, aY + y0, aRadius,
                aStartAngle, aEndAngle, aClockwise);
            return this;
        }
        absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
            return this;
        }
        ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            const x0 = this.currentPoint.x;
            const y0 = this.currentPoint.y;
            this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
            return this;
        }
        absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
            if (this.curves.length > 0) {
                // if a previous curve is present, attempt to join
                const firstPoint = curve.getPoint(0);
                if (!firstPoint.equals(this.currentPoint)) {
                    this.lineTo(firstPoint.x, firstPoint.y);
                }
            }
            this.curves.push(curve);
            const lastPoint = curve.getPoint(1);
            this.currentPoint.copy(lastPoint);
            return this;
        }
        copy(source) {
            super.copy(source);
            this.currentPoint.copy(source.currentPoint);
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.currentPoint = this.currentPoint.toArray();
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.currentPoint.fromArray(json.currentPoint);
            return this;
        }
    }
    class Shape extends Path {
        constructor(points) {
            super(points);
            this.uuid = generateUUID();
            this.type = 'Shape';
            this.holes = [];
        }
        getPointsHoles(divisions) {
            const holesPts = [];
            for (let i = 0, l = this.holes.length; i < l; i++) {
                holesPts[i] = this.holes[i].getPoints(divisions);
            }
            return holesPts;
        }
        // get points of shape and holes (keypoints based on segments parameter)
        extractPoints(divisions) {
            return {
                shape: this.getPoints(divisions),
                holes: this.getPointsHoles(divisions)
            };
        }
        copy(source) {
            super.copy(source);
            this.holes = [];
            for (let i = 0, l = source.holes.length; i < l; i++) {
                const hole = source.holes[i];
                this.holes.push(hole.clone());
            }
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.uuid = this.uuid;
            data.holes = [];
            for (let i = 0, l = this.holes.length; i < l; i++) {
                const hole = this.holes[i];
                data.holes.push(hole.toJSON());
            }
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.uuid = json.uuid;
            this.holes = [];
            for (let i = 0, l = json.holes.length; i < l; i++) {
                const hole = json.holes[i];
                this.holes.push(new Path().fromJSON(hole));
            }
            return this;
        }
    }
    /* eslint-disable */
    // copy of mapbox/earcut version 3.0.1
    // https://github.com/mapbox/earcut/tree/v3.0.1
    function earcut(data, holeIndices, dim = 2) {
        const hasHoles = holeIndices && holeIndices.length;
        const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        let outerNode = linkedList(data, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) return triangles;
        let minX, minY, invSize;
        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = Infinity;
            minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;
            for (let i = dim; i < outerLen; i += dim) {
                const x = data[i];
                const y = data[i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
    }
    // create a circular doubly linked list from polygon points in the specified winding order
    function linkedList(data, start, end, dim, clockwise) {
        let last;
        if (clockwise === (signedArea(data, start, end, dim) > 0)) {
            for (let i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);
        } else {
            for (let i = end - dim; i >= start; i -= dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);
        }
        if (last && equals$1(last, last.next)) {
            removeNode(last);
            last = last.next;
        }
        return last;
    }
    // eliminate colinear or duplicate points
    function filterPoints(start, end) {
        if (!start) return start;
        if (!end) end = start;
        let p = start,
            again;
        do {
            again = false;
            if (!p.steiner && (equals$1(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next) break;
                again = true;
            } else {
                p = p.next;
            }
        } while (again || p !== end);
        return end;
    }
    // main ear slicing loop which triangulates a polygon (given as a linked list)
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear) return;
        // interlink polygon nodes in z-order
        if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
        let stop = ear;
        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
            const prev = ear.prev;
            const next = ear.next;
            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                triangles.push(prev.i, ear.i, next.i); // cut off the triangle
                removeNode(ear);
                // skipping the next vertex leads to less sliver triangles
                ear = next.next;
                stop = next.next;
                continue;
            }
            ear = next;
            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                    // if this didn't work, try curing all small self-intersections locally
                } else if (pass === 1) {
                    ear = cureLocalIntersections(filterPoints(ear), triangles);
                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                    // as a last resort, try splitting the remaining polygon into two
                } else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }
                break;
            }
        }
    }
    // check whether a polygon node forms a valid ear with adjacent nodes
    function isEar(ear) {
        const a = ear.prev,
            b = ear,
            c = ear.next;
        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
        // now make sure we don't have other points inside the potential ear
        const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
        // triangle bbox
        const x0 = Math.min(ax, bx, cx),
            y0 = Math.min(ay, by, cy),
            x1 = Math.max(ax, bx, cx),
            y1 = Math.max(ay, by, cy);
        let p = c.next;
        while (p !== a) {
            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
                pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) return false;
            p = p.next;
        }
        return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
        const a = ear.prev,
            b = ear,
            c = ear.next;
        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
        const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
        // triangle bbox
        const x0 = Math.min(ax, bx, cx),
            y0 = Math.min(ay, by, cy),
            x1 = Math.max(ax, bx, cx),
            y1 = Math.max(ay, by, cy);
        // z-order range for the current triangle bbox;
        const minZ = zOrder(x0, y0, minX, minY, invSize),
            maxZ = zOrder(x1, y1, minX, minY, invSize);
        let p = ear.prevZ,
            n = ear.nextZ;
        // look for points inside the triangle in both directions
        while (p && p.z >= minZ && n && n.z <= maxZ) {
            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
                pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
            if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
                pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
            n = n.nextZ;
        }
        // look for remaining points in decreasing z-order
        while (p && p.z >= minZ) {
            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
                pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
        }
        // look for remaining points in increasing z-order
        while (n && n.z <= maxZ) {
            if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
                pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
            n = n.nextZ;
        }
        return true;
    }
    // go through all polygon nodes and cure small local self-intersections
    function cureLocalIntersections(start, triangles) {
        let p = start;
        do {
            const a = p.prev,
                b = p.next.next;
            if (!equals$1(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                triangles.push(a.i, p.i, b.i);
                // remove two nodes involved
                removeNode(p);
                removeNode(p.next);
                p = start = b;
            }
            p = p.next;
        } while (p !== start);
        return filterPoints(p);
    }
    // try splitting polygon into two and triangulate them independently
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        // look for a valid diagonal that divides the polygon into two
        let a = start;
        do {
            let b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    let c = splitPolygon(a, b);
                    // filter colinear points around the cuts
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);
                    // run earcut on each half
                    earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                    earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }
    // link every hole into the outer loop, producing a single-ring polygon without holes
    function eliminateHoles(data, holeIndices, outerNode, dim) {
        const queue = [];
        for (let i = 0, len = holeIndices.length; i < len; i++) {
            const start = holeIndices[i] * dim;
            const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            const list = linkedList(data, start, end, dim, false);
            if (list === list.next) list.steiner = true;
            queue.push(getLeftmost(list));
        }
        queue.sort(compareXYSlope);
        // process holes from left to right
        for (let i = 0; i < queue.length; i++) {
            outerNode = eliminateHole(queue[i], outerNode);
        }
        return outerNode;
    }
    function compareXYSlope(a, b) {
        let result = a.x - b.x;
        // when the left-most point of 2 holes meet at a vertex, sort the holes counterclockwise so that when we find
        // the bridge to the outer shell is always the point that they meet at.
        if (result === 0) {
            result = a.y - b.y;
            if (result === 0) {
                const aSlope = (a.next.y - a.y) / (a.next.x - a.x);
                const bSlope = (b.next.y - b.y) / (b.next.x - b.x);
                result = aSlope - bSlope;
            }
        }
        return result;
    }
    // find a bridge between vertices that connects hole with an outer ring and and link it
    function eliminateHole(hole, outerNode) {
        const bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
            return outerNode;
        }
        const bridgeReverse = splitPolygon(bridge, hole);
        // filter collinear points around the cuts
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
    }
    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    function findHoleBridge(hole, outerNode) {
        let p = outerNode;
        const hx = hole.x;
        const hy = hole.y;
        let qx = -Infinity;
        let m;
        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        // unless they intersect at a vertex, then choose the vertex
        if (equals(hole, p)) return p;
        do {
            if (equals(hole, p.next)) return p.next;
            else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    m = p.x < p.next.x ? p : p.next;
                    if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
                }
            }
            p = p.next;
        } while (p !== outerNode);
        if (!m) return null;
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
        const stop = m;
        const mx = m.x;
        const my = m.y;
        let tanMin = Infinity;
        p = m;
        do {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                const tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                if (locallyInside(p, hole) &&
                    (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.next;
        } while (p !== stop);
        return m;
    }
    // whether sector in vertex m contains sector in vertex p in the same coordinates
    function sectorContainsSector(m, p) {
        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    }
    // interlink polygon nodes in z-order
    function indexCurve(start, minX, minY, invSize) {
        let p = start;
        do {
            if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
    }
    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    function sortLinked(list) {
        let numMerges;
        let inSize = 1;
        do {
            let p = list;
            let e;
            list = null;
            let tail = null;
            numMerges = 0;
            while (p) {
                numMerges++;
                let q = p;
                let pSize = 0;
                for (let i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q) break;
                }
                let qSize = inSize;
                while (pSize > 0 || (qSize > 0 && q)) {
                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    if (tail) tail.nextZ = e;
                    else list = e;
                    e.prevZ = tail;
                    tail = e;
                }
                p = q;
            }
            tail.nextZ = null;
            inSize *= 2;
        } while (numMerges > 1);
        return list;
    }
    // z-order of a point given coords and inverse of the longer side of data bbox
    function zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = (x - minX) * invSize | 0;
        y = (y - minY) * invSize | 0;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
        return x | (y << 1);
    }
    // find the leftmost node of a polygon ring
    function getLeftmost(start) {
        let p = start,
            leftmost = start;
        do {
            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
            p = p.next;
        } while (p !== start);
        return leftmost;
    }
    // check if a point lies within a convex triangle
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
            (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
            (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    // check if a point lies within a convex triangle but false if its equal to the first point of the triangle
    function pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {
        return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);
    }
    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
            (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
                (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
                equals$1(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
    }
    // signed area of a triangle
    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    // check if two points are equal
    function equals$1(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    // check if two segments intersect
    function intersects(p1, q1, p2, q2) {
        const o1 = sign$1(area(p1, q1, p2));
        const o2 = sign$1(area(p1, q1, q2));
        const o3 = sign$1(area(p2, q2, p1));
        const o4 = sign$1(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4) return true; // general case
        if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
        if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
        if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
        if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
        return false;
    }
    // for collinear points p, q, r, check if point q lies on segment pr
    function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign$1(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    // check if a polygon diagonal intersects any polygon segments
    function intersectsPolygon(a, b) {
        let p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
            p = p.next;
        } while (p !== a);
        return false;
    }
    // check if a polygon diagonal is locally inside the polygon
    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ?
            area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
            area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    // check if the middle point of a polygon diagonal is inside the polygon
    function middleInside(a, b) {
        let p = a;
        let inside = false;
        const px = (a.x + b.x) / 2;
        const py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                inside = !inside;
            p = p.next;
        } while (p !== a);
        return inside;
    }
    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    function splitPolygon(a, b) {
        const a2 = createNode(a.i, a.x, a.y),
            b2 = createNode(b.i, b.x, b.y),
            an = a.next,
            bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
    }
    // create a node and optionally link it with previous one (in a circular doubly linked list)
    function insertNode(i, x, y, last) {
        const p = createNode(i, x, y);
        if (!last) {
            p.prev = p;
            p.next = p;
        } else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }
    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ) p.prevZ.nextZ = p.nextZ;
        if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }
    function createNode(i, x, y) {
        return {
            i, // vertex index in coordinates array
            x, y, // vertex coordinates
            prev: null, // previous and next vertex nodes in a polygon ring
            next: null,
            z: 0, // z-order curve value
            prevZ: null, // previous and next nodes in z-order
            nextZ: null,
            steiner: false // indicates whether this is a steiner point
        };
    }
    function signedArea(data, start, end, dim) {
        let sum = 0;
        for (let i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }
    class Earcut {
        static triangulate(data, holeIndices, dim = 2) {
            return earcut(data, holeIndices, dim);
        }
    }
    class ShapeUtils {
        static area(contour) {
            const n = contour.length;
            let a = 0.0;
            for (let p = n - 1, q = 0; q < n; p = q++) {
                a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
            }
            return a * 0.5;
        }
        static isClockWise(pts) {
            return ShapeUtils.area(pts) < 0;
        }
        static triangulateShape(contour, holes) {
            const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
            const holeIndices = []; // array of hole indices
            const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
            removeDupEndPts(contour);
            addContour(vertices, contour);
            //
            let holeIndex = contour.length;
            holes.forEach(removeDupEndPts);
            for (let i = 0; i < holes.length; i++) {
                holeIndices.push(holeIndex);
                holeIndex += holes[i].length;
                addContour(vertices, holes[i]);
            }
            //
            const triangles = Earcut.triangulate(vertices, holeIndices);
            //
            for (let i = 0; i < triangles.length; i += 3) {
                faces.push(triangles.slice(i, i + 3));
            }
            return faces;
        }
    }
    function removeDupEndPts(points) {
        const l = points.length;
        if (l > 2 && points[l - 1].equals(points[0])) {
            points.pop();
        }
    }
    function addContour(vertices, contour) {
        for (let i = 0; i < contour.length; i++) {
            vertices.push(contour[i].x);
            vertices.push(contour[i].y);
        }
    }
    class ExtrudeGeometry extends BufferGeometry {
        constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
            super();
            this.type = 'ExtrudeGeometry';
            this.parameters = {
                shapes: shapes,
                options: options
            };
            shapes = Array.isArray(shapes) ? shapes : [shapes];
            const scope = this;
            const verticesArray = [];
            const uvArray = [];
            for (let i = 0, l = shapes.length; i < l; i++) {
                const shape = shapes[i];
                addShape(shape);
            }
            // build geometry
            this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
            this.computeVertexNormals();
            // functions
            function addShape(shape) {
                const placeholder = [];
                // options
                const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
                const steps = options.steps !== undefined ? options.steps : 1;
                const depth = options.depth !== undefined ? options.depth : 1;
                let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
                let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
                let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
                let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
                let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
                const extrudePath = options.extrudePath;
                const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
                //
                let extrudePts, extrudeByPath = false;
                let splineTube, binormal, normal, position2;
                if (extrudePath) {
                    extrudePts = extrudePath.getSpacedPoints(steps);
                    extrudeByPath = true;
                    bevelEnabled = false; // bevels not supported for path extrusion
                    // SETUP TNB variables
                    // TODO1 - have a .isClosed in spline?
                    splineTube = extrudePath.computeFrenetFrames(steps, false);
                    // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
                    binormal = new Vector3();
                    normal = new Vector3();
                    position2 = new Vector3();
                }
                // Safeguards if bevels are not enabled
                if (!bevelEnabled) {
                    bevelSegments = 0;
                    bevelThickness = 0;
                    bevelSize = 0;
                    bevelOffset = 0;
                }
                // Variables initialization
                const shapePoints = shape.extractPoints(curveSegments);
                let vertices = shapePoints.shape;
                const holes = shapePoints.holes;
                const reverse = !ShapeUtils.isClockWise(vertices);
                if (reverse) {
                    vertices = vertices.reverse();
                    // Maybe we should also check if holes are in the opposite direction, just to be safe ...
                    for (let h = 0, hl = holes.length; h < hl; h++) {
                        const ahole = holes[h];
                        if (ShapeUtils.isClockWise(ahole)) {
                            holes[h] = ahole.reverse();
                        }
                    }
                }
                function mergeOverlappingPoints(points) {
                    const THRESHOLD = 1e-10;
                    const THRESHOLD_SQ = THRESHOLD * THRESHOLD;
                    let prevPos = points[0];
                    for (let i = 1; i <= points.length; i++) {
                        const currentIndex = i % points.length;
                        const currentPos = points[currentIndex];
                        const dx = currentPos.x - prevPos.x;
                        const dy = currentPos.y - prevPos.y;
                        const distSq = dx * dx + dy * dy;
                        const scalingFactorSqrt = Math.max(
                            Math.abs(currentPos.x),
                            Math.abs(currentPos.y),
                            Math.abs(prevPos.x),
                            Math.abs(prevPos.y)
                        );
                        const thresholdSqScaled = THRESHOLD_SQ * scalingFactorSqrt * scalingFactorSqrt;
                        if (distSq <= thresholdSqScaled) {
                            points.splice(currentIndex, 1);
                            i--;
                            continue;
                        }
                        prevPos = currentPos;
                    }
                }
                mergeOverlappingPoints(vertices);
                holes.forEach(mergeOverlappingPoints);
                const numHoles = holes.length;
                /* Vertices */
                const contour = vertices; // vertices has all points but contour has only points of circumference
                for (let h = 0; h < numHoles; h++) {
                    const ahole = holes[h];
                    vertices = vertices.concat(ahole);
                }

                function scalePt2(pt, vec, size) {
                    if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
                    return pt.clone().addScaledVector(vec, size);
                }
                const vlen = vertices.length;

                // Find directions for point movement

                function getBevelVec(inPt, inPrev, inNext) {
                    // computes for inPt the corresponding point inPt' on a new contour
                    //   shifted by 1 unit (length of normalized vector) to the left
                    // if we walk along contour clockwise, this new contour is outside the old one
                    //
                    // inPt' is the intersection of the two lines parallel to the two
                    //  adjacent edges of inPt at a distance of 1 unit on the left side.
                    let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
                    // good reading for geometry algorithms (here: line-line intersection)
                    // http://geomalgorithms.com/a05-_intersect-1.html
                    const v_prev_x = inPt.x - inPrev.x,
                        v_prev_y = inPt.y - inPrev.y;
                    const v_next_x = inNext.x - inPt.x,
                        v_next_y = inNext.y - inPt.y;
                    const v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
                    // check for collinear edges
                    const collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
                    if (Math.abs(collinear0) > Number.EPSILON) {
                        // not collinear
                        // length of vectors for normalizing
                        const v_prev_len = Math.sqrt(v_prev_lensq);
                        const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                        // shift adjacent points by unit vectors to the left
                        const ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
                        const ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
                        const ptNextShift_x = (inNext.x - v_next_y / v_next_len);
                        const ptNextShift_y = (inNext.y + v_next_x / v_next_len);
                        // scaling factor for v_prev to intersection point
                        const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
                            (ptNextShift_y - ptPrevShift_y) * v_next_x) /
                            (v_prev_x * v_next_y - v_prev_y * v_next_x);
                        // vector from inPt to intersection point
                        v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
                        v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
                        // Don't normalize!, otherwise sharp corners become ugly
                        //  but prevent crazy spikes
                        const v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
                        if (v_trans_lensq <= 2) {
                            return new Vector2(v_trans_x, v_trans_y);
                        } else {
                            shrink_by = Math.sqrt(v_trans_lensq / 2);
                        }
                    } else {
                        // handle special case of collinear edges
                        let direction_eq = false; // assumes: opposite
                        if (v_prev_x > Number.EPSILON) {
                            if (v_next_x > Number.EPSILON) {
                                direction_eq = true;
                            }
                        } else {
                            if (v_prev_x < - Number.EPSILON) {
                                if (v_next_x < - Number.EPSILON) {
                                    direction_eq = true;
                                }
                            } else {
                                if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                                    direction_eq = true;
                                }
                            }
                        }
                        if (direction_eq) {
                            // console.log("Warning: lines are a straight sequence");
                            v_trans_x = - v_prev_y;
                            v_trans_y = v_prev_x;
                            shrink_by = Math.sqrt(v_prev_lensq);
                        } else {
                            // console.log("Warning: lines are a straight spike");
                            v_trans_x = v_prev_x;
                            v_trans_y = v_prev_y;
                            shrink_by = Math.sqrt(v_prev_lensq / 2);
                        }
                    }
                    return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
                }

                const contourMovements = [];
                for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                    if (j === il) j = 0;
                    if (k === il) k = 0;
                    //  (j)---(i)---(k)
                    // console.log('i,j,k', i, j , k)
                    contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
                }
                const holesMovements = [];
                let oneHoleMovements, verticesMovements = contourMovements.concat();
                for (let h = 0, hl = numHoles; h < hl; h++) {
                    const ahole = holes[h];
                    oneHoleMovements = [];
                    for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                        if (j === il) j = 0;
                        if (k === il) k = 0;
                        //  (j)---(i)---(k)
                        oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
                    }
                    holesMovements.push(oneHoleMovements);
                    verticesMovements = verticesMovements.concat(oneHoleMovements);
                }
                let faces;
                if (bevelSegments === 0) {
                    faces = ShapeUtils.triangulateShape(contour, holes);
                } else {
                    const contractedContourVertices = [];
                    const expandedHoleVertices = [];
                    // Loop bevelSegments, 1 for the front, 1 for the back
                    for (let b = 0; b < bevelSegments; b++) {
                        //for ( b = bevelSegments; b > 0; b -- ) {
                        const t = b / bevelSegments;
                        const z = bevelThickness * Math.cos(t * Math.PI / 2);
                        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                        // contract shape
                        for (let i = 0, il = contour.length; i < il; i++) {
                            const vert = scalePt2(contour[i], contourMovements[i], bs);
                            v(vert.x, vert.y, - z);
                            if (t === 0) contractedContourVertices.push(vert);
                        }
                        // expand holes
                        for (let h = 0, hl = numHoles; h < hl; h++) {
                            const ahole = holes[h];
                            oneHoleMovements = holesMovements[h];
                            const oneHoleVertices = [];
                            for (let i = 0, il = ahole.length; i < il; i++) {
                                const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                                v(vert.x, vert.y, - z);
                                if (t === 0) oneHoleVertices.push(vert);
                            }
                            if (t === 0) expandedHoleVertices.push(oneHoleVertices);
                        }
                    }
                    faces = ShapeUtils.triangulateShape(contractedContourVertices, expandedHoleVertices);
                }
                const flen = faces.length;
                const bs = bevelSize + bevelOffset;
                // Back facing vertices
                for (let i = 0; i < vlen; i++) {
                    const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                    if (!extrudeByPath) {
                        v(vert.x, vert.y, 0);
                    } else {
                        // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
                        normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                        binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                        position2.copy(extrudePts[0]).add(normal).add(binormal);
                        v(position2.x, position2.y, position2.z);
                    }
                }
                // Add stepped vertices...
                // Including front facing vertices
                for (let s = 1; s <= steps; s++) {
                    for (let i = 0; i < vlen; i++) {
                        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                        if (!extrudeByPath) {
                            v(vert.x, vert.y, depth / steps * s);
                        } else {
                            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
                            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                            position2.copy(extrudePts[s]).add(normal).add(binormal);
                            v(position2.x, position2.y, position2.z);
                        }
                    }
                }

                // Add bevel segments planes
                //for ( b = 1; b <= bevelSegments; b ++ ) {
                for (let b = bevelSegments - 1; b >= 0; b--) {
                    const t = b / bevelSegments;
                    const z = bevelThickness * Math.cos(t * Math.PI / 2);
                    const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                    // contract shape
                    for (let i = 0, il = contour.length; i < il; i++) {
                        const vert = scalePt2(contour[i], contourMovements[i], bs);
                        v(vert.x, vert.y, depth + z);
                    }
                    // expand holes
                    for (let h = 0, hl = holes.length; h < hl; h++) {
                        const ahole = holes[h];
                        oneHoleMovements = holesMovements[h];
                        for (let i = 0, il = ahole.length; i < il; i++) {
                            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                            if (!extrudeByPath) {
                                v(vert.x, vert.y, depth + z);
                            } else {
                                v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                            }
                        }
                    }
                }
                /* Faces */
                // Top and bottom faces
                buildLidFaces();
                // Sides faces
                buildSideFaces();

                /////  Internal functions
                function buildLidFaces() {
                    const start = verticesArray.length / 3;
                    if (bevelEnabled) {
                        let layer = 0; // steps + 1
                        let offset = vlen * layer;
                        // Bottom faces
                        for (let i = 0; i < flen; i++) {
                            const face = faces[i];
                            f3(face[2] + offset, face[1] + offset, face[0] + offset);
                        }
                        layer = steps + bevelSegments * 2;
                        offset = vlen * layer;
                        // Top faces
                        for (let i = 0; i < flen; i++) {
                            const face = faces[i];
                            f3(face[0] + offset, face[1] + offset, face[2] + offset);
                        }
                    } else {
                        // Bottom faces
                        for (let i = 0; i < flen; i++) {
                            const face = faces[i];
                            f3(face[2], face[1], face[0]);
                        }
                        // Top faces
                        for (let i = 0; i < flen; i++) {
                            const face = faces[i];
                            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                        }
                    }
                    scope.addGroup(start, verticesArray.length / 3 - start, 0);
                }
                // Create faces for the z-sides of the shape
                function buildSideFaces() {
                    const start = verticesArray.length / 3;
                    let layeroffset = 0;
                    sidewalls(contour, layeroffset);
                    layeroffset += contour.length;
                    for (let h = 0, hl = holes.length; h < hl; h++) {
                        const ahole = holes[h];
                        sidewalls(ahole, layeroffset);
                        //, true
                        layeroffset += ahole.length;
                    }

                    scope.addGroup(start, verticesArray.length / 3 - start, 1);

                }
                function sidewalls(contour, layeroffset) {
                    let i = contour.length;
                    while (--i >= 0) {
                        const j = i;
                        let k = i - 1;
                        if (k < 0) k = contour.length - 1;
                        //console.log('b', i,j, i-1, k,vertices.length);
                        for (let s = 0, sl = (steps + bevelSegments * 2); s < sl; s++) {
                            const slen1 = vlen * s;
                            const slen2 = vlen * (s + 1);
                            const a = layeroffset + j + slen1,
                                b = layeroffset + k + slen1,
                                c = layeroffset + k + slen2,
                                d = layeroffset + j + slen2;
                            f4(a, b, c, d);
                        }
                    }
                }
                function v(x, y, z) {
                    placeholder.push(x);
                    placeholder.push(y);
                    placeholder.push(z);
                }

                function f3(a, b, c) {
                    addVertex(a);
                    addVertex(b);
                    addVertex(c);
                    const nextIndex = verticesArray.length / 3;
                    const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                    addUV(uvs[0]);
                    addUV(uvs[1]);
                    addUV(uvs[2]);
                }
                function f4(a, b, c, d) {
                    addVertex(a);
                    addVertex(b);
                    addVertex(d);
                    addVertex(b);
                    addVertex(c);
                    addVertex(d);

                    const nextIndex = verticesArray.length / 3;
                    const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                    addUV(uvs[0]);
                    addUV(uvs[1]);
                    addUV(uvs[3]);
                    addUV(uvs[1]);
                    addUV(uvs[2]);
                    addUV(uvs[3]);
                }
                function addVertex(index) {
                    verticesArray.push(placeholder[index * 3 + 0]);
                    verticesArray.push(placeholder[index * 3 + 1]);
                    verticesArray.push(placeholder[index * 3 + 2]);
                }

                function addUV(vector2) {
                    uvArray.push(vector2.x);
                    uvArray.push(vector2.y);
                }
            }
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            const shapes = this.parameters.shapes;
            const options = this.parameters.options;
            return toJSON$1(shapes, options, data);
        }
        static fromJSON(data, shapes) {
            const geometryShapes = [];
            for (let j = 0, jl = data.shapes.length; j < jl; j++) {
                const shape = shapes[data.shapes[j]];
                geometryShapes.push(shape);
            }
            const extrudePath = data.options.extrudePath;
            if (extrudePath !== undefined) {
                data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
            }
            return new ExtrudeGeometry(geometryShapes, data.options);
        }
    }
    const WorldUVGenerator = {
        generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
            const a_x = vertices[indexA * 3];
            const a_y = vertices[indexA * 3 + 1];
            const b_x = vertices[indexB * 3];
            const b_y = vertices[indexB * 3 + 1];
            const c_x = vertices[indexC * 3];
            const c_y = vertices[indexC * 3 + 1];
            return [
                new Vector2(a_x, a_y),
                new Vector2(b_x, b_y),
                new Vector2(c_x, c_y)
            ];
        },
        generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
            const a_x = vertices[indexA * 3];
            const a_y = vertices[indexA * 3 + 1];
            const a_z = vertices[indexA * 3 + 2];
            const b_x = vertices[indexB * 3];
            const b_y = vertices[indexB * 3 + 1];
            const b_z = vertices[indexB * 3 + 2];
            const c_x = vertices[indexC * 3];
            const c_y = vertices[indexC * 3 + 1];
            const c_z = vertices[indexC * 3 + 2];
            const d_x = vertices[indexD * 3];
            const d_y = vertices[indexD * 3 + 1];
            const d_z = vertices[indexD * 3 + 2];
            if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
                return [
                    new Vector2(a_x, 1 - a_z),
                    new Vector2(b_x, 1 - b_z),
                    new Vector2(c_x, 1 - c_z),
                    new Vector2(d_x, 1 - d_z)
                ];
            } else {
                return [
                    new Vector2(a_y, 1 - a_z),
                    new Vector2(b_y, 1 - b_z),
                    new Vector2(c_y, 1 - c_z),
                    new Vector2(d_y, 1 - d_z)
                ];
            }
        }
    };
    function toJSON$1(shapes, options, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
            for (let i = 0, l = shapes.length; i < l; i++) {
                const shape = shapes[i];
                data.shapes.push(shape.uuid);
            }
        } else {
            data.shapes.push(shapes.uuid);
        }
        data.options = Object.assign({}, options);
        if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
        return data;
    }
    class IcosahedronGeometry extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
            const t = (1 + Math.sqrt(5)) / 2;
            const vertices = [
                -1, t, 0, 1, t, 0, -1, - t, 0, 1, - t, 0,
                0, -1, t, 0, 1, t, 0, -1, - t, 0, 1, - t,
                t, 0, -1, t, 0, 1, - t, 0, -1, - t, 0, 1
            ];
            const indices = [
                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
                1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
                3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
                4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
            ];
            super(vertices, indices, radius, detail);
            this.type = 'IcosahedronGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
        }
        static fromJSON(data) {
            return new IcosahedronGeometry(data.radius, data.detail);
        }
    }
    class LatheGeometry extends BufferGeometry {
        constructor(points = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
            super();
            this.type = 'LatheGeometry';
            this.parameters = {
                points: points,
                segments: segments,
                phiStart: phiStart,
                phiLength: phiLength
            };
            segments = Math.floor(segments);
            // clamp phiLength so it's in range of [ 0, 2PI ]
            phiLength = clamp$1(phiLength, 0, Math.PI * 2);
            // buffers
            const indices = [];
            const vertices = [];
            const uvs = [];
            const initNormals = [];
            const normals = [];
            // helper variables
            const inverseSegments = 1.0 / segments;
            const vertex = new Vector3();
            const uv = new Vector2();
            const normal = new Vector3();
            const curNormal = new Vector3();
            const prevNormal = new Vector3();
            let dx = 0;
            let dy = 0;
            // pre-compute normals for initial "meridian"
            for (let j = 0; j <= (points.length - 1); j++) {
                switch (j) {
                    case 0:				// special handling for 1st vertex on path
                        dx = points[j + 1].x - points[j].x;
                        dy = points[j + 1].y - points[j].y;
                        normal.x = dy * 1.0;
                        normal.y = - dx;
                        normal.z = dy * 0.0;
                        prevNormal.copy(normal);
                        normal.normalize();
                        initNormals.push(normal.x, normal.y, normal.z);
                        break;
                    case (points.length - 1):	// special handling for last Vertex on path
                        initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
                        break;
                    default:			// default handling for all vertices in between
                        dx = points[j + 1].x - points[j].x;
                        dy = points[j + 1].y - points[j].y;
                        normal.x = dy * 1.0;
                        normal.y = - dx;
                        normal.z = dy * 0.0;
                        curNormal.copy(normal);
                        normal.x += prevNormal.x;
                        normal.y += prevNormal.y;
                        normal.z += prevNormal.z;
                        normal.normalize();
                        initNormals.push(normal.x, normal.y, normal.z);
                        prevNormal.copy(curNormal);
                }
            }
            // generate vertices, uvs and normals
            for (let i = 0; i <= segments; i++) {
                const phi = phiStart + i * inverseSegments * phiLength;
                const sin = Math.sin(phi);
                const cos = Math.cos(phi);
                for (let j = 0; j <= (points.length - 1); j++) {
                    // vertex
                    vertex.x = points[j].x * sin;
                    vertex.y = points[j].y;
                    vertex.z = points[j].x * cos;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // uv
                    uv.x = i / segments;
                    uv.y = j / (points.length - 1);
                    uvs.push(uv.x, uv.y);
                    // normal
                    const x = initNormals[3 * j + 0] * sin;
                    const y = initNormals[3 * j + 1];
                    const z = initNormals[3 * j + 0] * cos;
                    normals.push(x, y, z);
                }
            }
            // indices
            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < (points.length - 1); j++) {
                    const base = j + i * points.length;
                    const a = base;
                    const b = base + points.length;
                    const c = base + points.length + 1;
                    const d = base + 1;
                    // faces
                    indices.push(a, b, d);
                    indices.push(c, d, b);
                }
            }
            // build geometry
            this.setIndex(indices);
            this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
        static fromJSON(data) {
            return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
        }
    }
    class OctahedronGeometry extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
            const vertices = [
                1, 0, 0, -1, 0, 0, 0, 1, 0,
                0, -1, 0, 0, 0, 1, 0, 0, -1
            ];
            const indices = [
                0, 2, 4, 0, 4, 3, 0, 3, 5,
                0, 5, 2, 1, 2, 5, 1, 5, 3,
                1, 3, 4, 1, 4, 2
            ];
            super(vertices, indices, radius, detail);
            this.type = 'OctahedronGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
        }
        static fromJSON(data) {
            return new OctahedronGeometry(data.radius, data.detail);
        }
    }
    class PlaneGeometry extends BufferGeometry {
        constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
            super();
            this.type = 'PlaneGeometry';
            this.parameters = {
                width: width,
                height: height,
                widthSegments: widthSegments,
                heightSegments: heightSegments
            };
            const width_half = width / 2;
            const height_half = height / 2;
            const gridX = Math.floor(widthSegments);
            const gridY = Math.floor(heightSegments);
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            const segment_width = width / gridX;
            const segment_height = height / gridY;
            //
            const indices = [];
            const vertices = [];
            const normals = [];
            const uvs = [];
            for (let iy = 0; iy < gridY1; iy++) {
                const y = iy * segment_height - height_half;
                for (let ix = 0; ix < gridX1; ix++) {
                    const x = ix * segment_width - width_half;
                    vertices.push(x, - y, 0);
                    normals.push(0, 0, 1);
                    uvs.push(ix / gridX);
                    uvs.push(1 - (iy / gridY));
                }
            }
            for (let iy = 0; iy < gridY; iy++) {
                for (let ix = 0; ix < gridX; ix++) {
                    const a = ix + gridX1 * iy;
                    const b = ix + gridX1 * (iy + 1);
                    const c = (ix + 1) + gridX1 * (iy + 1);
                    const d = (ix + 1) + gridX1 * iy;
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
            this.setIndex(indices);
            this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
        static fromJSON(data) {
            return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
        }
    }
    class RingGeometry extends BufferGeometry {
        constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
            super();
            this.type = 'RingGeometry';
            this.parameters = {
                innerRadius: innerRadius,
                outerRadius: outerRadius,
                thetaSegments: thetaSegments,
                phiSegments: phiSegments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            thetaSegments = Math.max(3, thetaSegments);
            phiSegments = Math.max(1, phiSegments);
            // buffers
            const indices = [];
            const vertices = [];
            const normals = [];
            const uvs = [];
            // some helper variables
            let radius = innerRadius;
            const radiusStep = ((outerRadius - innerRadius) / phiSegments);
            const vertex = new Vector3();
            const uv = new Vector2();
            // generate vertices, normals and uvs
            for (let j = 0; j <= phiSegments; j++) {
                for (let i = 0; i <= thetaSegments; i++) {
                    // values are generate from the inside of the ring to the outside
                    const segment = thetaStart + i / thetaSegments * thetaLength;
                    // vertex
                    vertex.x = radius * Math.cos(segment);
                    vertex.y = radius * Math.sin(segment);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal
                    normals.push(0, 0, 1);
                    // uv
                    uv.x = (vertex.x / outerRadius + 1) / 2;
                    uv.y = (vertex.y / outerRadius + 1) / 2;
                    uvs.push(uv.x, uv.y);
                }
                // increase the radius for next row of vertices
                radius += radiusStep;
            }
            // indices
            for (let j = 0; j < phiSegments; j++) {
                const thetaSegmentLevel = j * (thetaSegments + 1);
                for (let i = 0; i < thetaSegments; i++) {
                    const segment = i + thetaSegmentLevel;
                    const a = segment;
                    const b = segment + thetaSegments + 1;
                    const c = segment + thetaSegments + 2;
                    const d = segment + 1;
                    // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
            // build geometry
            this.setIndex(indices);
            this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
        static fromJSON(data) {
            return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
        }
    }
    class ShapeGeometry extends BufferGeometry {
        constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
            super();
            this.type = 'ShapeGeometry';
            this.parameters = {
                shapes: shapes,
                curveSegments: curveSegments
            };
            // buffers
            const indices = [];
            const vertices = [];
            const normals = [];
            const uvs = [];
            // helper variables
            let groupStart = 0;
            let groupCount = 0;
            // allow single and array values for "shapes" parameter
            if (Array.isArray(shapes) === false) {
                addShape(shapes);
            } else {
                for (let i = 0; i < shapes.length; i++) {
                    addShape(shapes[i]);
                    this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support
                    groupStart += groupCount;
                    groupCount = 0;
                }
            }
            // build geometry
            this.setIndex(indices);
            this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

            // helper functions
            function addShape(shape) {
                const indexOffset = vertices.length / 3;
                const points = shape.extractPoints(curveSegments);
                let shapeVertices = points.shape;
                const shapeHoles = points.holes;
                // check direction of vertices
                if (ShapeUtils.isClockWise(shapeVertices) === false) {
                    shapeVertices = shapeVertices.reverse();
                }
                for (let i = 0, l = shapeHoles.length; i < l; i++) {
                    const shapeHole = shapeHoles[i];
                    if (ShapeUtils.isClockWise(shapeHole) === true) {
                        shapeHoles[i] = shapeHole.reverse();
                    }
                }
                const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
                // join vertices of inner and outer paths to a single array
                for (let i = 0, l = shapeHoles.length; i < l; i++) {
                    const shapeHole = shapeHoles[i];
                    shapeVertices = shapeVertices.concat(shapeHole);
                }
                // vertices, normals, uvs
                for (let i = 0, l = shapeVertices.length; i < l; i++) {
                    const vertex = shapeVertices[i];
                    vertices.push(vertex.x, vertex.y, 0);
                    normals.push(0, 0, 1);
                    uvs.push(vertex.x, vertex.y); // world uvs
                }
                // indices
                for (let i = 0, l = faces.length; i < l; i++) {
                    const face = faces[i];
                    const a = face[0] + indexOffset;
                    const b = face[1] + indexOffset;
                    const c = face[2] + indexOffset;
                    indices.push(a, b, c);
                    groupCount += 3;
                }
            }
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            const shapes = this.parameters.shapes;
            return toJSON(shapes, data);
        }
        static fromJSON(data, shapes) {
            const geometryShapes = [];
            for (let j = 0, jl = data.shapes.length; j < jl; j++) {
                const shape = shapes[data.shapes[j]];
                geometryShapes.push(shape);
            }
            return new ShapeGeometry(geometryShapes, data.curveSegments);
        }
    }
    function toJSON(shapes, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
            for (let i = 0, l = shapes.length; i < l; i++) {
                const shape = shapes[i];
                data.shapes.push(shape.uuid);
            }
        } else {
            data.shapes.push(shapes.uuid);
        }
        return data;
    }
    class SphereGeometry extends BufferGeometry {
        constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
            super();
            this.type = 'SphereGeometry';
            this.parameters = {
                radius: radius,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                phiStart: phiStart,
                phiLength: phiLength,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            widthSegments = Math.max(3, Math.floor(widthSegments));
            heightSegments = Math.max(2, Math.floor(heightSegments));
            const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
            let index = 0;
            const grid = [];
            const vertex = new Vector3();
            const normal = new Vector3();
            // buffers
            const indices = [];
            const vertices = [];
            const normals = [];
            const uvs = [];
            // generate vertices, normals and uvs
            for (let iy = 0; iy <= heightSegments; iy++) {
                const verticesRow = [];
                const v = iy / heightSegments;
                // special case for the poles
                let uOffset = 0;
                if (iy === 0 && thetaStart === 0) {
                    uOffset = 0.5 / widthSegments;
                } else if (iy === heightSegments && thetaEnd === Math.PI) {
                    uOffset = -0.5 / widthSegments;
                }
                for (let ix = 0; ix <= widthSegments; ix++) {
                    const u = ix / widthSegments;
                    // vertex
                    vertex.x = - radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                    vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal
                    normal.copy(vertex).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    // uv
                    uvs.push(u + uOffset, 1 - v);
                    verticesRow.push(index++);
                }
                grid.push(verticesRow);
            }
            // indices
            for (let iy = 0; iy < heightSegments; iy++) {
                for (let ix = 0; ix < widthSegments; ix++) {
                    const a = grid[iy][ix + 1];
                    const b = grid[iy][ix];
                    const c = grid[iy + 1][ix];
                    const d = grid[iy + 1][ix + 1];
                    if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
                    if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
                }
            }
            // build geometry
            this.setIndex(indices);
            this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
        static fromJSON(data) {
            return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
        }
    }
    class TetrahedronGeometry extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
            const vertices = [
                1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1
            ];
            const indices = [
                2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
            ];
            super(vertices, indices, radius, detail);
            this.type = 'TetrahedronGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
        }
        static fromJSON(data) {
            return new TetrahedronGeometry(data.radius, data.detail);
        }
    }
    class TorusGeometry extends BufferGeometry {
        constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {
            super();
            this.type = 'TorusGeometry';
            this.parameters = {
                radius: radius,
                tube: tube,
                radialSegments: radialSegments,
                tubularSegments: tubularSegments,
                arc: arc
            };
            radialSegments = Math.floor(radialSegments);
            tubularSegments = Math.floor(tubularSegments);
            // buffers
            const indices = [];
            const vertices = [];
            const normals = [];
            const uvs = [];
            // helper variables
            const center = new Vector3();
            const vertex = new Vector3();
            const normal = new Vector3();
            // generate vertices, normals and uvs
            for (let j = 0; j <= radialSegments; j++) {
                for (let i = 0; i <= tubularSegments; i++) {
                    const u = i / tubularSegments * arc;
                    const v = j / radialSegments * Math.PI * 2;
                    // vertex
                    vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                    vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                    vertex.z = tube * Math.sin(v);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal
                    center.x = radius * Math.cos(u);
                    center.y = radius * Math.sin(u);
                    normal.subVectors(vertex, center).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    // uv
                    uvs.push(i / tubularSegments);
                    uvs.push(j / radialSegments);
                }
            }
            // generate indices
            for (let j = 1; j <= radialSegments; j++) {
                for (let i = 1; i <= tubularSegments; i++) {
                    // indices
                    const a = (tubularSegments + 1) * j + i - 1;
                    const b = (tubularSegments + 1) * (j - 1) + i - 1;
                    const c = (tubularSegments + 1) * (j - 1) + i;
                    const d = (tubularSegments + 1) * j + i;
                    // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
            // build geometry
            this.setIndex(indices);
            this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
        static fromJSON(data) {
            return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
        }
    }
    class TorusKnotGeometry extends BufferGeometry {
        constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
            super();
            this.type = 'TorusKnotGeometry';
            this.parameters = {
                radius: radius,
                tube: tube,
                tubularSegments: tubularSegments,
                radialSegments: radialSegments,
                p: p,
                q: q
            };
            tubularSegments = Math.floor(tubularSegments);
            radialSegments = Math.floor(radialSegments);
            // buffers
            const indices = [];
            const vertices = [];
            const normals = [];
            const uvs = [];
            // helper variables
            const vertex = new Vector3();
            const normal = new Vector3();
            const P1 = new Vector3();
            const P2 = new Vector3();
            const B = new Vector3();
            const T = new Vector3();
            const N = new Vector3();
            // generate vertices, normals and uvs
            for (let i = 0; i <= tubularSegments; ++i) {
                // the radian "u" is used to calculate the position on the torus curve of the current tubular segment
                const u = i / tubularSegments * p * Math.PI * 2;
                // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
                // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
                calculatePositionOnCurve(u, p, q, radius, P1);
                calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
                // calculate orthonormal basis
                T.subVectors(P2, P1);
                N.addVectors(P2, P1);
                B.crossVectors(T, N);
                N.crossVectors(B, T);
                // normalize B, N. T can be ignored, we don't use it
                B.normalize();
                N.normalize();
                for (let j = 0; j <= radialSegments; ++j) {
                    // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
                    // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
                    const v = j / radialSegments * Math.PI * 2;
                    const cx = - tube * Math.cos(v);
                    const cy = tube * Math.sin(v);
                    // now calculate the final vertex position.
                    // first we orient the extrusion with our basis vectors, then we add it to the current position on the curve
                    vertex.x = P1.x + (cx * N.x + cy * B.x);
                    vertex.y = P1.y + (cx * N.y + cy * B.y);
                    vertex.z = P1.z + (cx * N.z + cy * B.z);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
                    normal.subVectors(vertex, P1).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    // uv
                    uvs.push(i / tubularSegments);
                    uvs.push(j / radialSegments);
                }
            }
            // generate indices
            for (let j = 1; j <= tubularSegments; j++) {
                for (let i = 1; i <= radialSegments; i++) {
                    // indices
                    const a = (radialSegments + 1) * (j - 1) + (i - 1);
                    const b = (radialSegments + 1) * j + (i - 1);
                    const c = (radialSegments + 1) * j + i;
                    const d = (radialSegments + 1) * (j - 1) + i;
                    // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
            // build geometry
            this.setIndex(indices);
            this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            // this function calculates the current position on the torus curve
            function calculatePositionOnCurve(u, p, q, radius, position) {
                const cu = Math.cos(u);
                const su = Math.sin(u);
                const quOverP = q / p * u;
                const cs = Math.cos(quOverP);
                position.x = radius * (2 + cs) * 0.5 * cu;
                position.y = radius * (2 + cs) * su * 0.5;
                position.z = radius * Math.sin(quOverP) * 0.5;
            }
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
        static fromJSON(data) {
            return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
        }
    }
    class TubeGeometry extends BufferGeometry {
        constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
            super();
            this.type = 'TubeGeometry';
            this.parameters = {
                path: path,
                tubularSegments: tubularSegments,
                radius: radius,
                radialSegments: radialSegments,
                closed: closed
            };
            const frames = path.computeFrenetFrames(tubularSegments, closed);
            // expose internals
            this.tangents = frames.tangents;
            this.normals = frames.normals;
            this.binormals = frames.binormals;
            // helper variables
            const vertex = new Vector3();
            const normal = new Vector3();
            const uv = new Vector2();
            let P = new Vector3();
            // buffer
            const vertices = [];
            const normals = [];
            const uvs = [];
            const indices = [];
            // create buffer data
            generateBufferData();
            // build geometry
            this.setIndex(indices);
            this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            // functions
            function generateBufferData() {
                for (let i = 0; i < tubularSegments; i++) {
                    generateSegment(i);
                }
                // if the geometry is not closed, generate the last row of vertices and normals
                // at the regular position on the given path
                //
                // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
                generateSegment((closed === false) ? tubularSegments : 0);
                // uvs are generated in a separate function.
                // this makes it easy compute correct values for closed geometries
                generateUVs();
                // finally create faces
                generateIndices();
            }
            function generateSegment(i) {
                // we use getPointAt to sample evenly distributed points from the given path
                P = path.getPointAt(i / tubularSegments, P);
                // retrieve corresponding normal and binormal
                const N = frames.normals[i];
                const B = frames.binormals[i];
                // generate normals and vertices for the current segment
                for (let j = 0; j <= radialSegments; j++) {
                    const v = j / radialSegments * Math.PI * 2;
                    const sin = Math.sin(v);
                    const cos = - Math.cos(v);
                    // normal
                    normal.x = (cos * N.x + sin * B.x);
                    normal.y = (cos * N.y + sin * B.y);
                    normal.z = (cos * N.z + sin * B.z);
                    normal.normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    // vertex
                    vertex.x = P.x + radius * normal.x;
                    vertex.y = P.y + radius * normal.y;
                    vertex.z = P.z + radius * normal.z;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }
            }
            function generateIndices() {
                for (let j = 1; j <= tubularSegments; j++) {
                    for (let i = 1; i <= radialSegments; i++) {
                        const a = (radialSegments + 1) * (j - 1) + (i - 1);
                        const b = (radialSegments + 1) * j + (i - 1);
                        const c = (radialSegments + 1) * j + i;
                        const d = (radialSegments + 1) * (j - 1) + i;
                        // faces
                        indices.push(a, b, d);
                        indices.push(b, c, d);
                    }
                }
            }
            function generateUVs() {
                for (let i = 0; i <= tubularSegments; i++) {
                    for (let j = 0; j <= radialSegments; j++) {
                        uv.x = i / tubularSegments;
                        uv.y = j / radialSegments;
                        uvs.push(uv.x, uv.y);
                    }
                }
            }
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.path = this.parameters.path.toJSON();
            return data;
        }
        static fromJSON(data) {
            // This only works for built-in curves (e.g. CatmullRomCurve3).
            // User defined curves or instances of CurvePath will not be deserialized.
            return new TubeGeometry(
                new Curves[data.path.type]().fromJSON(data.path),
                data.tubularSegments,
                data.radius,
                data.radialSegments,
                data.closed
            );
        }
    }
    class WireframeGeometry extends BufferGeometry {
        constructor(geometry = null) {
            super();
            this.type = 'WireframeGeometry';
            this.parameters = {
                geometry: geometry
            };
            if (geometry !== null) {
                // buffer
                const vertices = [];
                const edges = new Set();
                // helper variables
                const start = new Vector3();
                const end = new Vector3();
                if (geometry.index !== null) {
                    // indexed BufferGeometry
                    const position = geometry.attributes.position;
                    const indices = geometry.index;
                    let groups = geometry.groups;
                    if (groups.length === 0) {
                        groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
                    }
                    // create a data structure that contains all edges without duplicates
                    for (let o = 0, ol = groups.length; o < ol; ++o) {
                        const group = groups[o];
                        const groupStart = group.start;
                        const groupCount = group.count;
                        for (let i = groupStart, l = (groupStart + groupCount); i < l; i += 3) {
                            for (let j = 0; j < 3; j++) {
                                const index1 = indices.getX(i + j);
                                const index2 = indices.getX(i + (j + 1) % 3);
                                start.fromBufferAttribute(position, index1);
                                end.fromBufferAttribute(position, index2);
                                if (isUniqueEdge(start, end, edges) === true) {
                                    vertices.push(start.x, start.y, start.z);
                                    vertices.push(end.x, end.y, end.z);
                                }
                            }
                        }
                    }
                } else {
                    // non-indexed BufferGeometry
                    const position = geometry.attributes.position;
                    for (let i = 0, l = (position.count / 3); i < l; i++) {
                        for (let j = 0; j < 3; j++) {
                            // three edges per triangle, an edge is represented as (index1, index2)
                            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
                            const index1 = 3 * i + j;
                            const index2 = 3 * i + ((j + 1) % 3);
                            start.fromBufferAttribute(position, index1);
                            end.fromBufferAttribute(position, index2);
                            if (isUniqueEdge(start, end, edges) === true) {
                                vertices.push(start.x, start.y, start.z);
                                vertices.push(end.x, end.y, end.z);
                            }
                        }
                    }
                }
                // build geometry
                this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            }
        }
        copy(source) {
            super.copy(source);
            this.parameters = Object.assign({}, source.parameters);
            return this;
        }
    }
    function isUniqueEdge(start, end, edges) {
        const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
        const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge
        if (edges.has(hash1) === true || edges.has(hash2) === true) {
            return false;
        } else {
            edges.add(hash1);
            edges.add(hash2);
            return true;
        }
    }
    var Geometries$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BoxGeometry: BoxGeometry,
        CapsuleGeometry: CapsuleGeometry,
        CircleGeometry: CircleGeometry,
        ConeGeometry: ConeGeometry,
        CylinderGeometry: CylinderGeometry,
        DodecahedronGeometry: DodecahedronGeometry,
        EdgesGeometry: EdgesGeometry,
        ExtrudeGeometry: ExtrudeGeometry,
        IcosahedronGeometry: IcosahedronGeometry,
        LatheGeometry: LatheGeometry,
        OctahedronGeometry: OctahedronGeometry,
        PlaneGeometry: PlaneGeometry,
        PolyhedronGeometry: PolyhedronGeometry,
        RingGeometry: RingGeometry,
        ShapeGeometry: ShapeGeometry,
        SphereGeometry: SphereGeometry,
        TetrahedronGeometry: TetrahedronGeometry,
        TorusGeometry: TorusGeometry,
        TorusKnotGeometry: TorusKnotGeometry,
        TubeGeometry: TubeGeometry,
        WireframeGeometry: WireframeGeometry
    });
    class ShadowMaterial extends Material {
        constructor(parameters) {
            super();
            this.isShadowMaterial = true;
            this.type = 'ShadowMaterial';
            this.color = new Color(0x000000);
            this.transparent = true;
            this.fog = true;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.fog = source.fog;
            return this;
        }
    }
    class RawShaderMaterial extends ShaderMaterial {
        constructor(parameters) {
            super(parameters);
            this.isRawShaderMaterial = true;
            this.type = 'RawShaderMaterial';
        }
    }
    class MeshStandardMaterial extends Material {
        constructor(parameters) {
            super();
            this.isMeshStandardMaterial = true;
            this.type = 'MeshStandardMaterial';
            this.defines = { 'STANDARD': '' };
            this.color = new Color(0xffffff); // diffuse
            this.roughness = 1.0;
            this.metalness = 0.0;
            this.map = null;
            this.lightMap = null;
            this.lightMapIntensity = 1.0;
            this.aoMap = null;
            this.aoMapIntensity = 1.0;
            this.emissive = new Color(0x000000);
            this.emissiveIntensity = 1.0;
            this.emissiveMap = null;
            this.bumpMap = null;
            this.bumpScale = 1;
            this.normalMap = null;
            this.normalMapType = TangentSpaceNormalMap;
            this.normalScale = new Vector2(1, 1);
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.roughnessMap = null;
            this.metalnessMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.envMapRotation = new Euler();
            this.envMapIntensity = 1.0;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';
            this.flatShading = false;
            this.fog = true;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.defines = { 'STANDARD': '' };
            this.color.copy(source.color);
            this.roughness = source.roughness;
            this.metalness = source.metalness;
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;
            this.bumpMap = source.bumpMap;
            this.bumpScale = source.bumpScale;
            this.normalMap = source.normalMap;
            this.normalMapType = source.normalMapType;
            this.normalScale.copy(source.normalScale);
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.roughnessMap = source.roughnessMap;
            this.metalnessMap = source.metalnessMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.envMapRotation.copy(source.envMapRotation);
            this.envMapIntensity = source.envMapIntensity;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.flatShading = source.flatShading;
            this.fog = source.fog;
            return this;
        }
    }
    class MeshPhysicalMaterial extends MeshStandardMaterial {
        constructor(parameters) {
            super();
            this.isMeshPhysicalMaterial = true;
            this.defines = {
                'STANDARD': '',
                'PHYSICAL': ''
            };
            this.type = 'MeshPhysicalMaterial';
            this.anisotropyRotation = 0;
            this.anisotropyMap = null;
            this.clearcoatMap = null;
            this.clearcoatRoughness = 0.0;
            this.clearcoatRoughnessMap = null;
            this.clearcoatNormalScale = new Vector2(1, 1);
            this.clearcoatNormalMap = null;
            this.ior = 1.5;
            Object.defineProperty(this, 'reflectivity', {
                get: function () {
                    return (clamp$1(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1));
                },
                set: function (reflectivity) {
                    this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
                }
            });
            this.iridescenceMap = null;
            this.iridescenceIOR = 1.3;
            this.iridescenceThicknessRange = [100, 400];
            this.iridescenceThicknessMap = null;
            this.sheenColor = new Color(0x000000);
            this.sheenColorMap = null;
            this.sheenRoughness = 1.0;
            this.sheenRoughnessMap = null;
            this.transmissionMap = null;
            this.thickness = 0;
            this.thicknessMap = null;
            this.attenuationDistance = Infinity;
            this.attenuationColor = new Color(1, 1, 1);
            this.specularIntensity = 1.0;
            this.specularIntensityMap = null;
            this.specularColor = new Color(1, 1, 1);
            this.specularColorMap = null;
            this._anisotropy = 0;
            this._clearcoat = 0;
            this._dispersion = 0;
            this._iridescence = 0;
            this._sheen = 0.0;
            this._transmission = 0;
            this.setValues(parameters);
        }
        get anisotropy() {
            return this._anisotropy;
        }
        set anisotropy(value) {
            if (this._anisotropy > 0 !== value > 0) {
                this.version++;
            }
            this._anisotropy = value;
        }
        get clearcoat() {
            return this._clearcoat;
        }
        set clearcoat(value) {
            if (this._clearcoat > 0 !== value > 0) {
                this.version++;
            }
            this._clearcoat = value;
        }
        get iridescence() {
            return this._iridescence;
        }
        set iridescence(value) {
            if (this._iridescence > 0 !== value > 0) {
                this.version++;
            }
            this._iridescence = value;
        }
        get dispersion() {
            return this._dispersion;
        }
        set dispersion(value) {
            if (this._dispersion > 0 !== value > 0) {
                this.version++;
            }
            this._dispersion = value;
        }
        get sheen() {
            return this._sheen;
        }
        set sheen(value) {
            if (this._sheen > 0 !== value > 0) {
                this.version++;
            }
            this._sheen = value;
        }
        get transmission() {
            return this._transmission;
        }
        set transmission(value) {
            if (this._transmission > 0 !== value > 0) {
                this.version++;
            }
            this._transmission = value;
        }
        copy(source) {
            super.copy(source);
            this.defines = {
                'STANDARD': '',
                'PHYSICAL': ''
            };
            this.anisotropy = source.anisotropy;
            this.anisotropyRotation = source.anisotropyRotation;
            this.anisotropyMap = source.anisotropyMap;
            this.clearcoat = source.clearcoat;
            this.clearcoatMap = source.clearcoatMap;
            this.clearcoatRoughness = source.clearcoatRoughness;
            this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
            this.clearcoatNormalMap = source.clearcoatNormalMap;
            this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
            this.dispersion = source.dispersion;
            this.ior = source.ior;
            this.iridescence = source.iridescence;
            this.iridescenceMap = source.iridescenceMap;
            this.iridescenceIOR = source.iridescenceIOR;
            this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
            this.iridescenceThicknessMap = source.iridescenceThicknessMap;
            this.sheen = source.sheen;
            this.sheenColor.copy(source.sheenColor);
            this.sheenColorMap = source.sheenColorMap;
            this.sheenRoughness = source.sheenRoughness;
            this.sheenRoughnessMap = source.sheenRoughnessMap;
            this.transmission = source.transmission;
            this.transmissionMap = source.transmissionMap;
            this.thickness = source.thickness;
            this.thicknessMap = source.thicknessMap;
            this.attenuationDistance = source.attenuationDistance;
            this.attenuationColor.copy(source.attenuationColor);
            this.specularIntensity = source.specularIntensity;
            this.specularIntensityMap = source.specularIntensityMap;
            this.specularColor.copy(source.specularColor);
            this.specularColorMap = source.specularColorMap;
            return this;
        }
    }
    class MeshPhongMaterial extends Material {
        constructor(parameters) {
            super();
            this.isMeshPhongMaterial = true;
            this.type = 'MeshPhongMaterial';
            this.color = new Color(0xffffff); // diffuse
            this.specular = new Color(0x111111);
            this.shininess = 30;
            this.map = null;
            this.lightMap = null;
            this.lightMapIntensity = 1.0;
            this.aoMap = null;
            this.aoMapIntensity = 1.0;
            this.emissive = new Color(0x000000);
            this.emissiveIntensity = 1.0;
            this.emissiveMap = null;
            this.bumpMap = null;
            this.bumpScale = 1;
            this.normalMap = null;
            this.normalMapType = TangentSpaceNormalMap;
            this.normalScale = new Vector2(1, 1);
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.specularMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.envMapRotation = new Euler();
            this.combine = MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = 0.98;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';
            this.flatShading = false;
            this.fog = true;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.specular.copy(source.specular);
            this.shininess = source.shininess;
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;
            this.bumpMap = source.bumpMap;
            this.bumpScale = source.bumpScale;
            this.normalMap = source.normalMap;
            this.normalMapType = source.normalMapType;
            this.normalScale.copy(source.normalScale);
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.specularMap = source.specularMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.envMapRotation.copy(source.envMapRotation);
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.flatShading = source.flatShading;
            this.fog = source.fog;
            return this;
        }
    }
    class MeshToonMaterial extends Material {
        constructor(parameters) {
            super();
            this.isMeshToonMaterial = true;
            this.defines = { 'TOON': '' };
            this.type = 'MeshToonMaterial';
            this.color = new Color(0xffffff);
            this.map = null;
            this.gradientMap = null;
            this.lightMap = null;
            this.lightMapIntensity = 1.0;
            this.aoMap = null;
            this.aoMapIntensity = 1.0;
            this.emissive = new Color(0x000000);
            this.emissiveIntensity = 1.0;
            this.emissiveMap = null;
            this.bumpMap = null;
            this.bumpScale = 1;
            this.normalMap = null;
            this.normalMapType = TangentSpaceNormalMap;
            this.normalScale = new Vector2(1, 1);
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.alphaMap = null;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';
            this.fog = true;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.map = source.map;
            this.gradientMap = source.gradientMap;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;
            this.bumpMap = source.bumpMap;
            this.bumpScale = source.bumpScale;
            this.normalMap = source.normalMap;
            this.normalMapType = source.normalMapType;
            this.normalScale.copy(source.normalScale);
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.alphaMap = source.alphaMap;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.fog = source.fog;
            return this;
        }
    }
    class MeshNormalMaterial extends Material {
        constructor(parameters) {
            super();
            this.isMeshNormalMaterial = true;
            this.type = 'MeshNormalMaterial';
            this.bumpMap = null;
            this.bumpScale = 1;
            this.normalMap = null;
            this.normalMapType = TangentSpaceNormalMap;
            this.normalScale = new Vector2(1, 1);
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.flatShading = false;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.bumpMap = source.bumpMap;
            this.bumpScale = source.bumpScale;
            this.normalMap = source.normalMap;
            this.normalMapType = source.normalMapType;
            this.normalScale.copy(source.normalScale);
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.flatShading = source.flatShading;
            return this;
        }
    }
    class MeshLambertMaterial extends Material {
        constructor(parameters) {
            super();
            this.isMeshLambertMaterial = true;
            this.type = 'MeshLambertMaterial';
            this.color = new Color(0xffffff); // diffuse
            this.map = null;
            this.lightMap = null;
            this.lightMapIntensity = 1.0;
            this.aoMap = null;
            this.aoMapIntensity = 1.0;
            this.emissive = new Color(0x000000);
            this.emissiveIntensity = 1.0;
            this.emissiveMap = null;
            this.bumpMap = null;
            this.bumpScale = 1;
            this.normalMap = null;
            this.normalMapType = TangentSpaceNormalMap;
            this.normalScale = new Vector2(1, 1);
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.specularMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.envMapRotation = new Euler();
            this.combine = MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = 0.98;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';
            this.flatShading = false;
            this.fog = true;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;
            this.bumpMap = source.bumpMap;
            this.bumpScale = source.bumpScale;
            this.normalMap = source.normalMap;
            this.normalMapType = source.normalMapType;
            this.normalScale.copy(source.normalScale);
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.specularMap = source.specularMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.envMapRotation.copy(source.envMapRotation);
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.flatShading = source.flatShading;
            this.fog = source.fog;
            return this;
        }
    }
    class MeshDepthMaterial extends Material {
        constructor(parameters) {
            super();
            this.isMeshDepthMaterial = true;
            this.type = 'MeshDepthMaterial';
            this.depthPacking = BasicDepthPacking;
            this.map = null;
            this.alphaMap = null;
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.depthPacking = source.depthPacking;
            this.map = source.map;
            this.alphaMap = source.alphaMap;
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            return this;
        }
    }
    class MeshDistanceMaterial extends Material {
        constructor(parameters) {
            super();
            this.isMeshDistanceMaterial = true;
            this.type = 'MeshDistanceMaterial';
            this.map = null;
            this.alphaMap = null;
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.map = source.map;
            this.alphaMap = source.alphaMap;
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            return this;
        }
    }
    class MeshMatcapMaterial extends Material {
        constructor(parameters) {
            super();
            this.isMeshMatcapMaterial = true;
            this.defines = { 'MATCAP': '' };
            this.type = 'MeshMatcapMaterial';
            this.color = new Color(0xffffff); // diffuse
            this.matcap = null;
            this.map = null;
            this.bumpMap = null;
            this.bumpScale = 1;
            this.normalMap = null;
            this.normalMapType = TangentSpaceNormalMap;
            this.normalScale = new Vector2(1, 1);
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.alphaMap = null;
            this.flatShading = false;
            this.fog = true;
            this.setValues(parameters);
        }

        copy(source) {
            super.copy(source);
            this.defines = { 'MATCAP': '' };
            this.color.copy(source.color);
            this.matcap = source.matcap;
            this.map = source.map;
            this.bumpMap = source.bumpMap;
            this.bumpScale = source.bumpScale;
            this.normalMap = source.normalMap;
            this.normalMapType = source.normalMapType;
            this.normalScale.copy(source.normalScale);
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.alphaMap = source.alphaMap;
            this.flatShading = source.flatShading;
            this.fog = source.fog;
            return this;
        }
    }
    class LineDashedMaterial extends LineBasicMaterial {
        constructor(parameters) {
            super();
            this.isLineDashedMaterial = true;
            this.type = 'LineDashedMaterial';
            this.scale = 1;
            this.dashSize = 3;
            this.gapSize = 1;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.scale = source.scale;
            this.dashSize = source.dashSize;
            this.gapSize = source.gapSize;
            return this;
        }
    }
    function convertArray(array, type) {
        if (!array || array.constructor === type) return array;
        if (typeof type.BYTES_PER_ELEMENT === 'number') {
            return new type(array); // create typed array
        }
        return Array.prototype.slice.call(array); // create Array
    }
    function isTypedArray(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
    }
    function getKeyframeOrder(times) {
        function compareTime(i, j) {
            return times[i] - times[j];
        }
        const n = times.length;
        const result = new Array(n);
        for (let i = 0; i !== n; ++i) result[i] = i;
        result.sort(compareTime);
        return result;
    }
    function sortedArray(values, stride, order) {
        const nValues = values.length;
        const result = new values.constructor(nValues);
        for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
            const srcOffset = order[i] * stride;
            for (let j = 0; j !== stride; ++j) {
                result[dstOffset++] = values[srcOffset + j];
            }
        }
        return result;
    }
    function flattenJSON(jsonKeys, times, values, valuePropertyName) {
        let i = 1, key = jsonKeys[0];
        while (key !== undefined && key[valuePropertyName] === undefined) {
            key = jsonKeys[i++];
        }
        if (key === undefined) return; // no data
        let value = key[valuePropertyName];
        if (value === undefined) return; // no data
        if (Array.isArray(value)) {
            do {
                value = key[valuePropertyName];
                if (value !== undefined) {
                    times.push(key.time);
                    values.push(...value); // push all elements
                }
                key = jsonKeys[i++];
            } while (key !== undefined);
        } else if (value.toArray !== undefined) {
            // ...assume THREE.Math-ish
            do {
                value = key[valuePropertyName];
                if (value !== undefined) {
                    times.push(key.time);
                    value.toArray(values, values.length);
                }
                key = jsonKeys[i++];
            } while (key !== undefined);
        } else {
            // otherwise push as-is
            do {
                value = key[valuePropertyName];
                if (value !== undefined) {
                    times.push(key.time);
                    values.push(value);
                }
                key = jsonKeys[i++];
            } while (key !== undefined);
        }
    }
    function subclip(sourceClip, name, startFrame, endFrame, fps = 30) {
        const clip = sourceClip.clone();
        clip.name = name;
        const tracks = [];
        for (let i = 0; i < clip.tracks.length; ++i) {
            const track = clip.tracks[i];
            const valueSize = track.getValueSize();
            const times = [];
            const values = [];
            for (let j = 0; j < track.times.length; ++j) {
                const frame = track.times[j] * fps;
                if (frame < startFrame || frame >= endFrame) continue;
                times.push(track.times[j]);
                for (let k = 0; k < valueSize; ++k) {
                    values.push(track.values[j * valueSize + k]);
                }
            }
            if (times.length === 0) continue;
            track.times = convertArray(times, track.times.constructor);
            track.values = convertArray(values, track.values.constructor);
            tracks.push(track);
        }
        clip.tracks = tracks;
        // find minimum .times value across all tracks in the trimmed clip
        let minStartTime = Infinity;
        for (let i = 0; i < clip.tracks.length; ++i) {
            if (minStartTime > clip.tracks[i].times[0]) {
                minStartTime = clip.tracks[i].times[0];
            }
        }
        // shift all tracks such that clip begins at t=0
        for (let i = 0; i < clip.tracks.length; ++i) {
            clip.tracks[i].shift(-1 * minStartTime);
        }
        clip.resetDuration();
        return clip;
    }
    function makeClipAdditive(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
        if (fps <= 0) fps = 30;
        const numTracks = referenceClip.tracks.length;
        const referenceTime = referenceFrame / fps;
        // Make each track's values relative to the values at the reference frame
        for (let i = 0; i < numTracks; ++i) {
            const referenceTrack = referenceClip.tracks[i];
            const referenceTrackType = referenceTrack.ValueTypeName;
            // Skip this track if it's non-numeric
            if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;
            // Find the track in the target clip whose name and type matches the reference track
            const targetTrack = targetClip.tracks.find(function (track) {
                return track.name === referenceTrack.name
                    && track.ValueTypeName === referenceTrackType;
            });
            if (targetTrack === undefined) continue;
            let referenceOffset = 0;
            const referenceValueSize = referenceTrack.getValueSize();
            if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
                referenceOffset = referenceValueSize / 3;
            }
            let targetOffset = 0;
            const targetValueSize = targetTrack.getValueSize();
            if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
                targetOffset = targetValueSize / 3;
            }
            const lastIndex = referenceTrack.times.length - 1;
            let referenceValue;
            // Find the value to subtract out of the track
            if (referenceTime <= referenceTrack.times[0]) {
                // Reference frame is earlier than the first keyframe, so just use the first keyframe
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                referenceValue = referenceTrack.values.slice(startIndex, endIndex);
            } else if (referenceTime >= referenceTrack.times[lastIndex]) {
                // Reference frame is after the last keyframe, so just use the last keyframe
                const startIndex = lastIndex * referenceValueSize + referenceOffset;
                const endIndex = startIndex + referenceValueSize - referenceOffset;
                referenceValue = referenceTrack.values.slice(startIndex, endIndex);
            } else {
                // Interpolate to the reference value
                const interpolant = referenceTrack.createInterpolant();
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                interpolant.evaluate(referenceTime);
                referenceValue = interpolant.resultBuffer.slice(startIndex, endIndex);
            }
            // Conjugate the quaternion
            if (referenceTrackType === 'quaternion') {
                const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
                referenceQuat.toArray(referenceValue);
            }
            // Subtract the reference value from all of the track values
            const numTimes = targetTrack.times.length;
            for (let j = 0; j < numTimes; ++j) {
                const valueStart = j * targetValueSize + targetOffset;
                if (referenceTrackType === 'quaternion') {
                    // Multiply the conjugate for quaternion track types
                    Quaternion.multiplyQuaternionsFlat(
                        targetTrack.values,
                        valueStart,
                        referenceValue,
                        0,
                        targetTrack.values,
                        valueStart
                    );
                } else {
                    const valueEnd = targetValueSize - targetOffset * 2;
                    // Subtract each value for all other numeric track types
                    for (let k = 0; k < valueEnd; ++k) {
                        targetTrack.values[valueStart + k] -= referenceValue[k];
                    }
                }
            }
        }
        targetClip.blendMode = AdditiveAnimationBlendMode;
        return targetClip;
    }
    class AnimationUtils {
        static convertArray(array, type) {
            return convertArray(array, type);
        }
        static isTypedArray(object) {
            return isTypedArray(object);
        }
        static getKeyframeOrder(times) {
            return getKeyframeOrder(times);
        }
        static sortedArray(values, stride, order) {
            return sortedArray(values, stride, order);
        }
        static flattenJSON(jsonKeys, times, values, valuePropertyName) {
            flattenJSON(jsonKeys, times, values, valuePropertyName);
        }
        static subclip(sourceClip, name, startFrame, endFrame, fps = 30) {
            return subclip(sourceClip, name, startFrame, endFrame, fps);
        }
        static makeClipAdditive(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
            return makeClipAdditive(targetClip, referenceFrame, referenceClip, fps);
        }
    }
    class Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            this.parameterPositions = parameterPositions;
            this._cachedIndex = 0;
            this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
            this.sampleValues = sampleValues;
            this.valueSize = sampleSize;
            this.settings = null;
            this.DefaultSettings_ = {};
        }
        evaluate(t) {
            const pp = this.parameterPositions;
            let i1 = this._cachedIndex,
                t1 = pp[i1],
                t0 = pp[i1 - 1];
            validate_interval: {
                seek: {
                    let right;
                    linear_scan: {
                        //- See http://jsperf.com/comparison-to-undefined/3
                        //- slower code:
                        //-
                        //- 				if ( t >= t1 || t1 === undefined ) {
                        forward_scan: if (!(t < t1)) {
                            for (let giveUpAt = i1 + 2; ;) {
                                if (t1 === undefined) {
                                    if (t < t0) break forward_scan;
                                    // after end
                                    i1 = pp.length;
                                    this._cachedIndex = i1;
                                    return this.copySampleValue_(i1 - 1);
                                }
                                if (i1 === giveUpAt) break; // this loop
                                t0 = t1;
                                t1 = pp[++i1];
                                if (t < t1) {
                                    // we have arrived at the sought interval
                                    break seek;
                                }
                            }
                            // prepare binary search on the right side of the index
                            right = pp.length;
                            break linear_scan;
                        }
                        //- slower code:
                        //-					if ( t < t0 || t0 === undefined ) {
                        if (!(t >= t0)) {
                            // looping?
                            const t1global = pp[1];
                            if (t < t1global) {
                                i1 = 2; // + 1, using the scan for the details
                                t0 = t1global;
                            }
                            // linear reverse scan
                            for (let giveUpAt = i1 - 2; ;) {
                                if (t0 === undefined) {
                                    // before start
                                    this._cachedIndex = 0;
                                    return this.copySampleValue_(0);
                                }
                                if (i1 === giveUpAt) break; // this loop
                                t1 = t0;
                                t0 = pp[--i1 - 1];
                                if (t >= t0) {
                                    // we have arrived at the sought interval
                                    break seek;
                                }
                            }
                            // prepare binary search on the left side of the index
                            right = i1;
                            i1 = 0;
                            break linear_scan;
                        }
                        // the interval is valid
                        break validate_interval;
                    } // linear scan
                    // binary search
                    while (i1 < right) {
                        const mid = (i1 + right) >>> 1;
                        if (t < pp[mid]) {
                            right = mid;
                        } else {
                            i1 = mid + 1;
                        }
                    }
                    t1 = pp[i1];
                    t0 = pp[i1 - 1];
                    // check boundary cases, again
                    if (t0 === undefined) {
                        this._cachedIndex = 0;
                        return this.copySampleValue_(0);
                    }
                    if (t1 === undefined) {
                        i1 = pp.length;
                        this._cachedIndex = i1;
                        return this.copySampleValue_(i1 - 1);
                    }
                } // seek
                this._cachedIndex = i1;
                this.intervalChanged_(i1, t0, t1);
            } // validate_interval
            return this.interpolate_(i1, t0, t, t1);
        }
        getSettings_() {
            return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(index) {
            // copies a sample value to the result buffer
            const result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                offset = index * stride;
            for (let i = 0; i !== stride; ++i) {
                result[i] = values[offset + i];
            }
            return result;
        }
        interpolate_( /* i1, t0, t, t1 */) {
            throw new Error('call to abstract method');
            // implementations shall return this.resultBuffer
        }
        intervalChanged_( /* i1, t0, t1 */) {
            // empty
        }
    }
    class CubicInterpolant extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            super(parameterPositions, sampleValues, sampleSize, resultBuffer);
            this._weightPrev = -0;
            this._offsetPrev = -0;
            this._weightNext = -0;
            this._offsetNext = -0;
            this.DefaultSettings_ = {
                endingStart: ZeroCurvatureEnding,
                endingEnd: ZeroCurvatureEnding
            };
        }
        intervalChanged_(i1, t0, t1) {
            const pp = this.parameterPositions;
            let iPrev = i1 - 2,
                iNext = i1 + 1,
                tPrev = pp[iPrev],
                tNext = pp[iNext];
            if (tPrev === undefined) {
                switch (this.getSettings_().endingStart) {
                    case ZeroSlopeEnding:
                        // f'(t0) = 0
                        iPrev = i1;
                        tPrev = 2 * t0 - t1;
                        break;
                    case WrapAroundEnding:
                        // use the other end of the curve
                        iPrev = pp.length - 2;
                        tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                        break;
                    default: // ZeroCurvatureEnding
                        // f''(t0) = 0 a.k.a. Natural Spline
                        iPrev = i1;
                        tPrev = t1;
                }
            }
            if (tNext === undefined) {
                switch (this.getSettings_().endingEnd) {
                    case ZeroSlopeEnding:
                        // f'(tN) = 0
                        iNext = i1;
                        tNext = 2 * t1 - t0;
                        break;
                    case WrapAroundEnding:
                        // use the other end of the curve
                        iNext = 1;
                        tNext = t1 + pp[1] - pp[0];
                        break;
                    default: // ZeroCurvatureEnding
                        // f''(tN) = 0, a.k.a. Natural Spline
                        iNext = i1 - 1;
                        tNext = t0;
                }
            }
            const halfDt = (t1 - t0) * 0.5,
                stride = this.valueSize;
            this._weightPrev = halfDt / (t0 - tPrev);
            this._weightNext = halfDt / (tNext - t1);
            this._offsetPrev = iPrev * stride;
            this._offsetNext = iNext * stride;
        }
        interpolate_(i1, t0, t, t1) {
            const result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                o1 = i1 * stride, o0 = o1 - stride,
                oP = this._offsetPrev, oN = this._offsetNext,
                wP = this._weightPrev, wN = this._weightNext,
                p = (t - t0) / (t1 - t0),
                pp = p * p,
                ppp = pp * p;
            // evaluate polynomials
            const sP = - wP * ppp + 2 * wP * pp - wP * p;
            const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
            const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
            const sN = wN * ppp - wN * pp;
            // combine data linearly
            for (let i = 0; i !== stride; ++i) {
                result[i] =
                    sP * values[oP + i] +
                    s0 * values[o0 + i] +
                    s1 * values[o1 + i] +
                    sN * values[oN + i];
            }
            return result;
        }
    }
    class LinearInterpolant extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t, t1) {
            const result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                offset1 = i1 * stride,
                offset0 = offset1 - stride,
                weight1 = (t - t0) / (t1 - t0),
                weight0 = 1 - weight1;
            for (let i = 0; i !== stride; ++i) {
                result[i] =
                    values[offset0 + i] * weight0 +
                    values[offset1 + i] * weight1;
            }
            return result;
        }
    }
    class DiscreteInterpolant extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1 /*, t0, t, t1 */) {
            return this.copySampleValue_(i1 - 1);
        }
    }
    class KeyframeTrack {
        constructor(name, times, values, interpolation) {
            if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
            if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
            this.name = name;
            this.times = convertArray(times, this.TimeBufferType);
            this.values = convertArray(values, this.ValueBufferType);
            this.setInterpolation(interpolation || this.DefaultInterpolation);
        }
        static toJSON(track) {
            const trackType = track.constructor;
            let json;
            // derived classes can define a static toJSON method
            if (trackType.toJSON !== this.toJSON) {
                json = trackType.toJSON(track);
            } else {
                // by default, we assume the data can be serialized as-is
                json = {
                    'name': track.name,
                    'times': convertArray(track.times, Array),
                    'values': convertArray(track.values, Array)
                };
                const interpolation = track.getInterpolation();
                if (interpolation !== track.DefaultInterpolation) {
                    json.interpolation = interpolation;
                }
            }
            json.type = track.ValueTypeName; // mandatory
            return json;
        }
        InterpolantFactoryMethodDiscrete(result) {
            return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodLinear(result) {
            return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodSmooth(result) {
            return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        setInterpolation(interpolation) {
            let factoryMethod;
            switch (interpolation) {
                case InterpolateDiscrete:
                    factoryMethod = this.InterpolantFactoryMethodDiscrete;
                    break;
                case InterpolateLinear:
                    factoryMethod = this.InterpolantFactoryMethodLinear;
                    break;
                case InterpolateSmooth:
                    factoryMethod = this.InterpolantFactoryMethodSmooth;
                    break;
            }
            if (factoryMethod === undefined) {
                const message = 'unsupported interpolation for ' +
                    this.ValueTypeName + ' keyframe track named ' + this.name;
                if (this.createInterpolant === undefined) {
                    // fall back to default, unless the default itself is messed up
                    if (interpolation !== this.DefaultInterpolation) {
                        this.setInterpolation(this.DefaultInterpolation);
                    } else {
                        throw new Error(message); // fatal, in this case
                    }
                }
                console.warn('THREE.KeyframeTrack:', message);
                return this;
            }
            this.createInterpolant = factoryMethod;
            return this;
        }
        getInterpolation() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return InterpolateDiscrete;
                case this.InterpolantFactoryMethodLinear:
                    return InterpolateLinear;
                case this.InterpolantFactoryMethodSmooth:
                    return InterpolateSmooth;
            }
        }
        getValueSize() {
            return this.values.length / this.times.length;
        }
        shift(timeOffset) {
            if (timeOffset !== 0.0) {
                const times = this.times;
                for (let i = 0, n = times.length; i !== n; ++i) {
                    times[i] += timeOffset;
                }
            }
            return this;
        }
        scale(timeScale) {
            if (timeScale !== 1.0) {
                const times = this.times;
                for (let i = 0, n = times.length; i !== n; ++i) {
                    times[i] *= timeScale;
                }
            }
            return this;
        }
        trim(startTime, endTime) {
            const times = this.times,
                nKeys = times.length;
            let from = 0,
                to = nKeys - 1;
            while (from !== nKeys && times[from] < startTime) {
                ++from;
            }
            while (to !== -1 && times[to] > endTime) {
                --to;
            }
            ++to; // inclusive -> exclusive bound
            if (from !== 0 || to !== nKeys) {
                // empty tracks are forbidden, so keep at least one keyframe
                if (from >= to) {
                    to = Math.max(to, 1);
                    from = to - 1;
                }
                const stride = this.getValueSize();
                this.times = times.slice(from, to);
                this.values = this.values.slice(from * stride, to * stride);
            }
            return this;
        }
        validate() {
            let valid = true;
            const valueSize = this.getValueSize();
            if (valueSize - Math.floor(valueSize) !== 0) {
                console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
                valid = false;
            }
            const times = this.times,
                values = this.values,
                nKeys = times.length;
            if (nKeys === 0) {
                console.error('THREE.KeyframeTrack: Track is empty.', this);
                valid = false;
            }
            let prevTime = null;
            for (let i = 0; i !== nKeys; i++) {
                const currTime = times[i];
                if (typeof currTime === 'number' && isNaN(currTime)) {
                    console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
                    valid = false;
                    break;
                }
                if (prevTime !== null && prevTime > currTime) {
                    console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
                    valid = false;
                    break;
                }
                prevTime = currTime;
            }
            if (values !== undefined) {
                if (isTypedArray(values)) {
                    for (let i = 0, n = values.length; i !== n; ++i) {
                        const value = values[i];
                        if (isNaN(value)) {
                            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
                            valid = false;
                            break;
                        }
                    }
                }
            }
            return valid;
        }
        optimize() {
            // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
            // times or values may be shared with other tracks, so overwriting is unsafe
            const times = this.times.slice(),
                values = this.values.slice(),
                stride = this.getValueSize(),
                smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
                lastIndex = times.length - 1;
            let writeIndex = 1;
            for (let i = 1; i < lastIndex; ++i) {
                let keep = false;
                const time = times[i];
                const timeNext = times[i + 1];
                // remove adjacent keyframes scheduled at the same time
                if (time !== timeNext && (i !== 1 || time !== times[0])) {
                    if (!smoothInterpolation) {
                        // remove unnecessary keyframes same as their neighbors
                        const offset = i * stride,
                            offsetP = offset - stride,
                            offsetN = offset + stride;
                        for (let j = 0; j !== stride; ++j) {
                            const value = values[offset + j];
                            if (value !== values[offsetP + j] ||
                                value !== values[offsetN + j]) {
                                keep = true;
                                break;
                            }
                        }
                    } else {
                        keep = true;
                    }
                }
                // in-place compaction
                if (keep) {
                    if (i !== writeIndex) {
                        times[writeIndex] = times[i];
                        const readOffset = i * stride,
                            writeOffset = writeIndex * stride;
                        for (let j = 0; j !== stride; ++j) {
                            values[writeOffset + j] = values[readOffset + j];
                        }
                    }
                    ++writeIndex;
                }
            }
            // flush last keyframe (compaction looks ahead)
            if (lastIndex > 0) {
                times[writeIndex] = times[lastIndex];
                for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
                    values[writeOffset + j] = values[readOffset + j];
                }
                ++writeIndex;
            }
            if (writeIndex !== times.length) {
                this.times = times.slice(0, writeIndex);
                this.values = values.slice(0, writeIndex * stride);
            } else {
                this.times = times;
                this.values = values;
            }
            return this;
        }
        clone() {
            const times = this.times.slice();
            const values = this.values.slice();
            const TypedKeyframeTrack = this.constructor;
            const track = new TypedKeyframeTrack(this.name, times, values);
            // Interpolant argument to constructor is not saved, so copy the factory method directly.
            track.createInterpolant = this.createInterpolant;
            return track;
        }
    }
    KeyframeTrack.prototype.ValueTypeName = '';
    KeyframeTrack.prototype.TimeBufferType = Float32Array;
    KeyframeTrack.prototype.ValueBufferType = Float32Array;
    KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
    class BooleanKeyframeTrack extends KeyframeTrack {
        constructor(name, times, values) {
            super(name, times, values);
        }
    }
    BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
    BooleanKeyframeTrack.prototype.ValueBufferType = Array;
    BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
    class ColorKeyframeTrack extends KeyframeTrack {
        constructor(name, times, values, interpolation) {
            super(name, times, values, interpolation);
        }
    }
    ColorKeyframeTrack.prototype.ValueTypeName = 'color';
    class NumberKeyframeTrack extends KeyframeTrack {
        constructor(name, times, values, interpolation) {
            super(name, times, values, interpolation);
        }
    }
    NumberKeyframeTrack.prototype.ValueTypeName = 'number';
    class QuaternionLinearInterpolant extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t, t1) {
            const result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                alpha = (t - t0) / (t1 - t0);
            let offset = i1 * stride;
            for (let end = offset + stride; offset !== end; offset += 4) {
                Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
            }
            return result;
        }
    }
    class QuaternionKeyframeTrack extends KeyframeTrack {
        constructor(name, times, values, interpolation) {
            super(name, times, values, interpolation);
        }
        InterpolantFactoryMethodLinear(result) {
            return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
    }
    QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
    // ValueBufferType is inherited
    // DefaultInterpolation is inherited;
    QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
    class StringKeyframeTrack extends KeyframeTrack {
        constructor(name, times, values) {
            super(name, times, values);
        }
    }
    StringKeyframeTrack.prototype.ValueTypeName = 'string';
    StringKeyframeTrack.prototype.ValueBufferType = Array;
    StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
    StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
    StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
    class VectorKeyframeTrack extends KeyframeTrack {
        constructor(name, times, values, interpolation) {
            super(name, times, values, interpolation);
        }
    }
    VectorKeyframeTrack.prototype.ValueTypeName = 'vector';
    class AnimationClip {
        constructor(name = '', duration = -1, tracks = [], blendMode = NormalAnimationBlendMode) {
            this.name = name;
            this.tracks = tracks;
            this.duration = duration;
            this.blendMode = blendMode;
            this.uuid = generateUUID();
            // this means it should figure out its duration by scanning the tracks
            if (this.duration < 0) {
                this.resetDuration();
            }
        }
        static parse(json) {
            const tracks = [],
                jsonTracks = json.tracks,
                frameTime = 1.0 / (json.fps || 1.0);
            for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
                tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
            }
            const clip = new this(json.name, json.duration, tracks, json.blendMode);
            clip.uuid = json.uuid;
            return clip;
        }
        static toJSON(clip) {
            const tracks = [],
                clipTracks = clip.tracks;
            const json = {
                'name': clip.name,
                'duration': clip.duration,
                'tracks': tracks,
                'uuid': clip.uuid,
                'blendMode': clip.blendMode
            };
            for (let i = 0, n = clipTracks.length; i !== n; ++i) {
                tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
            }
            return json;
        }
        static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
            const numMorphTargets = morphTargetSequence.length;
            const tracks = [];
            for (let i = 0; i < numMorphTargets; i++) {
                let times = [];
                let values = [];
                times.push(
                    (i + numMorphTargets - 1) % numMorphTargets,
                    i,
                    (i + 1) % numMorphTargets);
                values.push(0, 1, 0);
                const order = getKeyframeOrder(times);
                times = sortedArray(times, 1, order);
                values = sortedArray(values, 1, order);
                // if there is a key at the first frame, duplicate it as the
                // last frame as well for perfect loop.
                if (!noLoop && times[0] === 0) {
                    times.push(numMorphTargets);
                    values.push(values[0]);
                }
                tracks.push(
                    new NumberKeyframeTrack(
                        '.morphTargetInfluences[' + morphTargetSequence[i].name + ']',
                        times, values
                    ).scale(1.0 / fps));
            }
            return new this(name, -1, tracks);
        }
        static findByName(objectOrClipArray, name) {
            let clipArray = objectOrClipArray;
            if (!Array.isArray(objectOrClipArray)) {
                const o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
            }
            for (let i = 0; i < clipArray.length; i++) {
                if (clipArray[i].name === name) {
                    return clipArray[i];
                }
            }
            return null;
        }
        static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
            const animationToMorphTargets = {};
            // tested with https://regex101.com/ on trick sequences
            // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
            const pattern = /^([\w-]*?)([\d]+)$/;
            // sort morph target names into animation groups based
            // patterns like Walk_001, Walk_002, Run_001, Run_002
            for (let i = 0, il = morphTargets.length; i < il; i++) {
                const morphTarget = morphTargets[i];
                const parts = morphTarget.name.match(pattern);
                if (parts && parts.length > 1) {
                    const name = parts[1];
                    let animationMorphTargets = animationToMorphTargets[name];
                    if (!animationMorphTargets) {
                        animationToMorphTargets[name] = animationMorphTargets = [];
                    }
                    animationMorphTargets.push(morphTarget);
                }
            }
            const clips = [];
            for (const name in animationToMorphTargets) {
                clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
            }
            return clips;
        }
        static parseAnimation(animation, bones) {
            console.warn('THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185');
            if (!animation) {
                console.error('THREE.AnimationClip: No animation in JSONLoader data.');
                return null;
            }
            const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
                // only return track if there are actually keys.
                if (animationKeys.length !== 0) {
                    const times = [];
                    const values = [];
                    flattenJSON(animationKeys, times, values, propertyName);
                    // empty keys are filtered out, so check again
                    if (times.length !== 0) {
                        destTracks.push(new trackType(trackName, times, values));
                    }
                }
            };
            const tracks = [];
            const clipName = animation.name || 'default';
            const fps = animation.fps || 30;
            const blendMode = animation.blendMode;
            // automatic length determination in AnimationClip.
            let duration = animation.length || -1;
            const hierarchyTracks = animation.hierarchy || [];
            for (let h = 0; h < hierarchyTracks.length; h++) {
                const animationKeys = hierarchyTracks[h].keys;
                // skip empty tracks
                if (!animationKeys || animationKeys.length === 0) continue;
                // process morph targets
                if (animationKeys[0].morphTargets) {
                    // figure out all morph targets used in this track
                    const morphTargetNames = {};
                    let k;
                    for (k = 0; k < animationKeys.length; k++) {
                        if (animationKeys[k].morphTargets) {
                            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
                                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                            }
                        }
                    }
                    // create a track for each morph target with all zero
                    // morphTargetInfluences except for the keys in which
                    // the morphTarget is named.
                    for (const morphTargetName in morphTargetNames) {
                        const times = [];
                        const values = [];
                        for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                            const animationKey = animationKeys[k];
                            times.push(animationKey.time);
                            values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);
                        }
                        tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                    }
                    duration = morphTargetNames.length * fps;
                } else {
                    // ...assume skeletal animation
                    const boneName = '.bones[' + bones[h].name + ']';
                    addNonemptyTrack(
                        VectorKeyframeTrack, boneName + '.position',
                        animationKeys, 'pos', tracks);
                    addNonemptyTrack(
                        QuaternionKeyframeTrack, boneName + '.quaternion',
                        animationKeys, 'rot', tracks);
                    addNonemptyTrack(
                        VectorKeyframeTrack, boneName + '.scale',
                        animationKeys, 'scl', tracks);
                }
            }
            if (tracks.length === 0) {
                return null;
            }
            const clip = new this(clipName, duration, tracks, blendMode);
            return clip;
        }
        resetDuration() {
            const tracks = this.tracks;
            let duration = 0;
            for (let i = 0, n = tracks.length; i !== n; ++i) {
                const track = this.tracks[i];
                duration = Math.max(duration, track.times[track.times.length - 1]);
            }
            this.duration = duration;
            return this;
        }
        trim() {
            for (let i = 0; i < this.tracks.length; i++) {
                this.tracks[i].trim(0, this.duration);
            }
            return this;
        }
        validate() {
            let valid = true;
            for (let i = 0; i < this.tracks.length; i++) {
                valid = valid && this.tracks[i].validate();
            }
            return valid;
        }
        optimize() {
            for (let i = 0; i < this.tracks.length; i++) {
                this.tracks[i].optimize();
            }
            return this;
        }
        clone() {
            const tracks = [];
            for (let i = 0; i < this.tracks.length; i++) {
                tracks.push(this.tracks[i].clone());
            }
            return new this.constructor(this.name, this.duration, tracks, this.blendMode);
        }
        toJSON() {
            return this.constructor.toJSON(this);
        }
    }
    function getTrackTypeForValueTypeName(typeName) {
        switch (typeName.toLowerCase()) {
            case 'scalar':
            case 'double':
            case 'float':
            case 'number':
            case 'integer':
                return NumberKeyframeTrack;
            case 'vector':
            case 'vector2':
            case 'vector3':
            case 'vector4':
                return VectorKeyframeTrack;
            case 'color':
                return ColorKeyframeTrack;
            case 'quaternion':
                return QuaternionKeyframeTrack;
            case 'bool':
            case 'boolean':
                return BooleanKeyframeTrack;
            case 'string':
                return StringKeyframeTrack;
        }
        throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
    }
    function parseKeyframeTrack(json) {
        if (json.type === undefined) {
            throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
        }
        const trackType = getTrackTypeForValueTypeName(json.type);
        if (json.times === undefined) {
            const times = [], values = [];
            flattenJSON(json.keys, times, values, 'value');
            json.times = times;
            json.values = values;
        }
        // derived classes can define a static parse method
        if (trackType.parse !== undefined) {
            return trackType.parse(json);
        } else {
            // by default, we assume a constructor compatible with the base
            return new trackType(json.name, json.times, json.values, json.interpolation);
        }
    }
    const Cache = {
        enabled: false,
        files: {},
        add: function (key, file) {
            if (this.enabled === false) return;
            // console.log( 'THREE.Cache', 'Adding key:', key );
            this.files[key] = file;
        },
        get: function (key) {
            if (this.enabled === false) return;
            // console.log( 'THREE.Cache', 'Checking key:', key );
            return this.files[key];
        },
        remove: function (key) {
            delete this.files[key];
        },
        clear: function () {
            this.files = {};
        }
    };
    class LoadingManager {
        constructor(onLoad, onProgress, onError) {
            const scope = this;
            let isLoading = false;
            let itemsLoaded = 0;
            let itemsTotal = 0;
            let urlModifier = undefined;
            const handlers = [];
            // Refer to #5689 for the reason why we don't set .onStart
            // in the constructor
            this.onStart = undefined;
            this.onLoad = onLoad;
            this.onProgress = onProgress;
            this.onError = onError;
            this.abortController = new AbortController();
            this.itemStart = function (url) {
                itemsTotal++;
                if (isLoading === false) {
                    if (scope.onStart !== undefined) {
                        scope.onStart(url, itemsLoaded, itemsTotal);
                    }
                }
                isLoading = true;
            };
            this.itemEnd = function (url) {
                itemsLoaded++;
                if (scope.onProgress !== undefined) {
                    scope.onProgress(url, itemsLoaded, itemsTotal);
                }
                if (itemsLoaded === itemsTotal) {
                    isLoading = false;
                    if (scope.onLoad !== undefined) {
                        scope.onLoad();
                    }
                }
            };
            this.itemError = function (url) {
                if (scope.onError !== undefined) {
                    scope.onError(url);
                }
            };
            this.resolveURL = function (url) {
                if (urlModifier) {
                    return urlModifier(url);
                }
                return url;
            };
            this.setURLModifier = function (transform) {
                urlModifier = transform;
                return this;
            };
            this.addHandler = function (regex, loader) {
                handlers.push(regex, loader);
                return this;
            };
            this.removeHandler = function (regex) {
                const index = handlers.indexOf(regex);
                if (index !== -1) {
                    handlers.splice(index, 2);
                }
                return this;
            };
            this.getHandler = function (file) {
                for (let i = 0, l = handlers.length; i < l; i += 2) {
                    const regex = handlers[i];
                    const loader = handlers[i + 1];
                    if (regex.global) regex.lastIndex = 0; // see #17920
                    if (regex.test(file)) {
                        return loader;
                    }
                }
                return null;
            };
            this.abort = function () {
                this.abortController.abort();
                this.abortController = new AbortController();
                return this;
            };
        }
    }
    const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();
    class Loader {
        constructor(manager) {
            this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
            this.crossOrigin = 'anonymous';
            this.withCredentials = false;
            this.path = '';
            this.resourcePath = '';
            this.requestHeader = {};
        }
        load( /* url, onLoad, onProgress, onError */) { }
        loadAsync(url, onProgress) {
            const scope = this;
            return new Promise(function (resolve, reject) {
                scope.load(url, resolve, onProgress, reject);
            });
        }
        parse( /* data */) { }
        setCrossOrigin(crossOrigin) {
            this.crossOrigin = crossOrigin;
            return this;
        }
        setWithCredentials(value) {
            this.withCredentials = value;
            return this;
        }
        setPath(path) {
            this.path = path;
            return this;
        }
        setResourcePath(resourcePath) {
            this.resourcePath = resourcePath;
            return this;
        }
        setRequestHeader(requestHeader) {
            this.requestHeader = requestHeader;
            return this;
        }
        abort() {
            return this;
        }
    }

    Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';
    const loading = {};
    class HttpError extends Error {
        constructor(message, response) {
            super(message);
            this.response = response;
        }
    }
    class FileLoader extends Loader {
        constructor(manager) {
            super(manager);
            this.mimeType = '';
            this.responseType = '';
            this._abortController = new AbortController();
        }
        load(url, onLoad, onProgress, onError) {
            if (url === undefined) url = '';
            if (this.path !== undefined) url = this.path + url;
            url = this.manager.resolveURL(url);
            const cached = Cache.get(`file:${url}`);
            if (cached !== undefined) {
                this.manager.itemStart(url);
                setTimeout(() => {
                    if (onLoad) onLoad(cached);
                    this.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            // Check if request is duplicate
            if (loading[url] !== undefined) {
                loading[url].push({
                    onLoad: onLoad,
                    onProgress: onProgress,
                    onError: onError
                });
                return;
            }
            // Initialise array for duplicate requests
            loading[url] = [];
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError,
            });
            // create request
            const req = new Request(url, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? 'include' : 'same-origin',
                signal: (typeof AbortSignal.any === 'function') ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal
            });
            // record states ( avoid data race )
            const mimeType = this.mimeType;
            const responseType = this.responseType;
            // start the fetch
            fetch(req)
                .then(response => {
                    if (response.status === 200 || response.status === 0) {
                        // Some browsers return HTTP Status 0 when using non-http protocol
                        // e.g. 'file://' or 'data://'. Handle as success.
                        if (response.status === 0) {
                            console.warn('THREE.FileLoader: HTTP Status 0 received.');
                        }
                        // Workaround: Checking if response.body === undefined for Alipay browser #23548
                        if (typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined) {
                            return response;
                        }
                        const callbacks = loading[url];
                        const reader = response.body.getReader();
                        // Nginx needs X-File-Size check
                        // https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content
                        const contentLength = response.headers.get('X-File-Size') || response.headers.get('Content-Length');
                        const total = contentLength ? parseInt(contentLength) : 0;
                        const lengthComputable = total !== 0;
                        let loaded = 0;
                        // periodically read data into the new stream tracking while download progress
                        const stream = new ReadableStream({
                            start(controller) {
                                readData();
                                function readData() {
                                    reader.read().then(({ done, value }) => {
                                        if (done) {
                                            controller.close();
                                        } else {
                                            loaded += value.byteLength;
                                            const event = new ProgressEvent('progress', { lengthComputable, loaded, total });
                                            for (let i = 0, il = callbacks.length; i < il; i++) {
                                                const callback = callbacks[i];
                                                if (callback.onProgress) callback.onProgress(event);
                                            }
                                            controller.enqueue(value);
                                            readData();
                                        }
                                    }, (e) => {
                                        controller.error(e);
                                    });
                                }
                            }
                        });
                        return new Response(stream);
                    } else {
                        throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
                    }
                })
                .then(response => {
                    switch (responseType) {
                        case 'arraybuffer':
                            return response.arrayBuffer();
                        case 'blob':
                            return response.blob();
                        case 'document':
                            return response.text()
                                .then(text => {
                                    const parser = new DOMParser();
                                    return parser.parseFromString(text, mimeType);
                                });
                        case 'json':
                            return response.json();
                        default:
                            if (mimeType === '') {
                                return response.text();
                            } else {
                                // sniff encoding
                                const re = /charset="?([^;"\s]*)"?/i;
                                const exec = re.exec(mimeType);
                                const label = exec && exec[1] ? exec[1].toLowerCase() : undefined;
                                const decoder = new TextDecoder(label);
                                return response.arrayBuffer().then(ab => decoder.decode(ab));
                            }
                    }
                })
                .then(data => {
                    // Add to cache only on HTTP success, so that we do not cache
                    // error response bodies as proper responses to requests.
                    Cache.add(`file:${url}`, data);
                    const callbacks = loading[url];
                    delete loading[url];
                    for (let i = 0, il = callbacks.length; i < il; i++) {
                        const callback = callbacks[i];
                        if (callback.onLoad) callback.onLoad(data);
                    }
                })
                .catch(err => {
                    // Abort errors and other errors are handled the same
                    const callbacks = loading[url];
                    if (callbacks === undefined) {
                        // When onLoad was called and url was deleted in `loading`
                        this.manager.itemError(url);
                        throw err;
                    }
                    delete loading[url];
                    for (let i = 0, il = callbacks.length; i < il; i++) {
                        const callback = callbacks[i];
                        if (callback.onError) callback.onError(err);
                    }
                    this.manager.itemError(url);
                })
                .finally(() => {
                    this.manager.itemEnd(url);
                });
            this.manager.itemStart(url);
        }
        setResponseType(value) {
            this.responseType = value;
            return this;
        }
        setMimeType(value) {
            this.mimeType = value;
            return this;
        }
        abort() {
            this._abortController.abort();
            this._abortController = new AbortController();
            return this;
        }
    }
    class AnimationLoader extends Loader {
        constructor(manager) {
            super(manager);
        }
        load(url, onLoad, onProgress, onError) {
            const scope = this;
            const loader = new FileLoader(this.manager);
            loader.setPath(this.path);
            loader.setRequestHeader(this.requestHeader);
            loader.setWithCredentials(this.withCredentials);
            loader.load(url, function (text) {
                try {
                    onLoad(scope.parse(JSON.parse(text)));
                } catch (e) {
                    if (onError) {
                        onError(e);
                    } else {
                        console.error(e);
                    }
                    scope.manager.itemError(url);
                }
            }, onProgress, onError);
        }
        parse(json) {
            const animations = [];
            for (let i = 0; i < json.length; i++) {
                const clip = AnimationClip.parse(json[i]);
                animations.push(clip);
            }
            return animations;
        }
    }
    class CompressedTextureLoader extends Loader {
        constructor(manager) {
            super(manager);
        }
        load(url, onLoad, onProgress, onError) {
            const scope = this;
            const images = [];
            const texture = new CompressedTexture();
            const loader = new FileLoader(this.manager);
            loader.setPath(this.path);
            loader.setResponseType('arraybuffer');
            loader.setRequestHeader(this.requestHeader);
            loader.setWithCredentials(scope.withCredentials);
            let loaded = 0;
            function loadTexture(i) {
                loader.load(url[i], function (buffer) {
                    const texDatas = scope.parse(buffer, true);
                    images[i] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };
                    loaded += 1;
                    if (loaded === 6) {
                        if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
                        texture.image = images;
                        texture.format = texDatas.format;
                        texture.needsUpdate = true;
                        if (onLoad) onLoad(texture);
                    }
                }, onProgress, onError);
            }
            if (Array.isArray(url)) {
                for (let i = 0, il = url.length; i < il; ++i) {
                    loadTexture(i);
                }
            } else {
                // compressed cubemap texture stored in a single DDS file
                loader.load(url, function (buffer) {
                    const texDatas = scope.parse(buffer, true);
                    if (texDatas.isCubemap) {
                        const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                        for (let f = 0; f < faces; f++) {
                            images[f] = { mipmaps: [] };
                            for (let i = 0; i < texDatas.mipmapCount; i++) {
                                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                                images[f].format = texDatas.format;
                                images[f].width = texDatas.width;
                                images[f].height = texDatas.height;
                            }
                        }
                        texture.image = images;
                    } else {
                        texture.image.width = texDatas.width;
                        texture.image.height = texDatas.height;
                        texture.mipmaps = texDatas.mipmaps;
                    }
                    if (texDatas.mipmapCount === 1) {
                        texture.minFilter = LinearFilter;
                    }
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }, onProgress, onError);
            }
            return texture;
        }
    }
    const _loading = new WeakMap();
    class ImageLoader extends Loader {
        constructor(manager) {
            super(manager);
        }
        load(url, onLoad, onProgress, onError) {
            if (this.path !== undefined) url = this.path + url;
            url = this.manager.resolveURL(url);
            const scope = this;
            const cached = Cache.get(`image:${url}`);
            if (cached !== undefined) {
                if (cached.complete === true) {
                    scope.manager.itemStart(url);
                    setTimeout(function () {
                        if (onLoad) onLoad(cached);
                        scope.manager.itemEnd(url);
                    }, 0);
                } else {
                    let arr = _loading.get(cached);
                    if (arr === undefined) {
                        arr = [];
                        _loading.set(cached, arr);
                    }
                    arr.push({ onLoad, onError });
                }
                return cached;
            }
            const image = createElementNS('img');
            function onImageLoad() {
                removeEventListeners();
                if (onLoad) onLoad(this);
                //
                const callbacks = _loading.get(this) || [];
                for (let i = 0; i < callbacks.length; i++) {
                    const callback = callbacks[i];
                    if (callback.onLoad) callback.onLoad(this);
                }
                _loading.delete(this);
                scope.manager.itemEnd(url);
            }
            function onImageError(event) {
                removeEventListeners();
                if (onError) onError(event);
                Cache.remove(`image:${url}`);
                //
                const callbacks = _loading.get(this) || [];
                for (let i = 0; i < callbacks.length; i++) {
                    const callback = callbacks[i];
                    if (callback.onError) callback.onError(event);
                }
                _loading.delete(this);

                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            }
            function removeEventListeners() {
                image.removeEventListener('load', onImageLoad, false);
                image.removeEventListener('error', onImageError, false);
            }
            image.addEventListener('load', onImageLoad, false);
            image.addEventListener('error', onImageError, false);
            if (url.slice(0, 5) !== 'data:') {
                if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
            }
            Cache.add(`image:${url}`, image);
            scope.manager.itemStart(url);
            image.src = url;
            return image;
        }
    }
    class CubeTextureLoader extends Loader {
        constructor(manager) {
            super(manager);
        }
        load(urls, onLoad, onProgress, onError) {
            const texture = new CubeTexture();
            texture.colorSpace = SRGBColorSpace;
            const loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);
            let loaded = 0;
            function loadTexture(i) {
                loader.load(urls[i], function (image) {
                    texture.images[i] = image;
                    loaded++;
                    if (loaded === 6) {
                        texture.needsUpdate = true;
                        if (onLoad) onLoad(texture);
                    }
                }, undefined, onError);
            }
            for (let i = 0; i < urls.length; ++i) {
                loadTexture(i);
            }
            return texture;
        }
    }
    class DataTextureLoader extends Loader {
        constructor(manager) {
            super(manager);
        }
        load(url, onLoad, onProgress, onError) {
            const scope = this;
            const texture = new DataTexture();
            const loader = new FileLoader(this.manager);
            loader.setResponseType('arraybuffer');
            loader.setRequestHeader(this.requestHeader);
            loader.setPath(this.path);
            loader.setWithCredentials(scope.withCredentials);
            loader.load(url, function (buffer) {
                let texData;
                try {
                    texData = scope.parse(buffer);
                } catch (error) {
                    if (onError !== undefined) {
                        onError(error);
                    } else {
                        console.error(error);
                        return;
                    }
                }
                if (texData.image !== undefined) {
                    texture.image = texData.image;
                } else if (texData.data !== undefined) {
                    texture.image.width = texData.width;
                    texture.image.height = texData.height;
                    texture.image.data = texData.data;
                }
                texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
                texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
                texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
                texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
                texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
                if (texData.colorSpace !== undefined) {
                    texture.colorSpace = texData.colorSpace;
                }
                if (texData.flipY !== undefined) {
                    texture.flipY = texData.flipY;
                }
                if (texData.format !== undefined) {
                    texture.format = texData.format;
                }
                if (texData.type !== undefined) {
                    texture.type = texData.type;
                }
                if (texData.mipmaps !== undefined) {
                    texture.mipmaps = texData.mipmaps;
                    texture.minFilter = LinearMipmapLinearFilter; // presumably...
                }
                if (texData.mipmapCount === 1) {
                    texture.minFilter = LinearFilter;
                }
                if (texData.generateMipmaps !== undefined) {
                    texture.generateMipmaps = texData.generateMipmaps;
                }
                texture.needsUpdate = true;
                if (onLoad) onLoad(texture, texData);
            }, onProgress, onError);

            return texture;
        }
    }
    class TextureLoader extends Loader {
        constructor(manager) {
            super(manager);
        }
        load(url, onLoad, onProgress, onError) {
            const texture = new Texture();
            const loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);
            loader.load(url, function (image) {
                texture.image = image;
                texture.needsUpdate = true;
                if (onLoad !== undefined) {
                    onLoad(texture);
                }
            }, onProgress, onError);
            return texture;
        }
    }
    class Light extends Object3D {
        constructor(color, intensity = 1) {
            super();
            this.isLight = true;
            this.type = 'Light';
            this.color = new Color(color);
            this.intensity = intensity;
        }
        dispose() {
            // Empty here in base class; some subclasses override.
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.color.copy(source.color);
            this.intensity = source.intensity;
            return this;
        }
        toJSON(meta) {
            const data = super.toJSON(meta);
            data.object.color = this.color.getHex();
            data.object.intensity = this.intensity;
            if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
            if (this.distance !== undefined) data.object.distance = this.distance;
            if (this.angle !== undefined) data.object.angle = this.angle;
            if (this.decay !== undefined) data.object.decay = this.decay;
            if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
            if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
            if (this.target !== undefined) data.object.target = this.target.uuid;
            return data;
        }
    }
    class HemisphereLight extends Light {
        constructor(skyColor, groundColor, intensity) {
            super(skyColor, intensity);
            this.isHemisphereLight = true;
            this.type = 'HemisphereLight';
            this.position.copy(Object3D.DEFAULT_UP);
            this.updateMatrix();
            this.groundColor = new Color(groundColor);
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.groundColor.copy(source.groundColor);
            return this;
        }
    }
    const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
    const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
    const _lookTarget$1 = /*@__PURE__*/ new Vector3();
    class LightShadow {
        constructor(camera) {
            this.camera = camera;
            this.intensity = 1;
            this.bias = 0;
            this.normalBias = 0;
            this.radius = 1;
            this.blurSamples = 8;
            this.mapSize = new Vector2(512, 512);
            this.mapType = UnsignedByteType;
            this.map = null;
            this.mapPass = null;
            this.matrix = new Matrix4();
            this.autoUpdate = true;
            this.needsUpdate = false;
            this._frustum = new Frustum();
            this._frameExtents = new Vector2(1, 1);
            this._viewportCount = 1;
            this._viewports = [
                new Vector4(0, 0, 1, 1)
            ];
        }
        getViewportCount() {
            return this._viewportCount;
        }
        getFrustum() {
            return this._frustum;
        }
        updateMatrices(light) {
            const shadowCamera = this.camera;
            const shadowMatrix = this.matrix;
            _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
            shadowCamera.position.copy(_lightPositionWorld$1);
            _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
            shadowCamera.lookAt(_lookTarget$1);
            shadowCamera.updateMatrixWorld();
            _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
            this._frustum.setFromProjectionMatrix(_projScreenMatrix$1, shadowCamera.coordinateSystem, shadowCamera.reversedDepth);
            if (shadowCamera.reversedDepth) {
                shadowMatrix.set(
                    0.5, 0.0, 0.0, 0.5,
                    0.0, 0.5, 0.0, 0.5,
                    0.0, 0.0, 1.0, 0.0,
                    0.0, 0.0, 0.0, 1.0
                );
            } else {
                shadowMatrix.set(
                    0.5, 0.0, 0.0, 0.5,
                    0.0, 0.5, 0.0, 0.5,
                    0.0, 0.0, 0.5, 0.5,
                    0.0, 0.0, 0.0, 1.0
                );
            }
            shadowMatrix.multiply(_projScreenMatrix$1);
        }
        getViewport(viewportIndex) {
            return this._viewports[viewportIndex];
        }
        getFrameExtents() {
            return this._frameExtents;
        }
        dispose() {
            if (this.map) {
                this.map.dispose();
            }
            if (this.mapPass) {
                this.mapPass.dispose();
            }
        }
        copy(source) {
            this.camera = source.camera.clone();
            this.intensity = source.intensity;
            this.bias = source.bias;
            this.radius = source.radius;
            this.autoUpdate = source.autoUpdate;
            this.needsUpdate = source.needsUpdate;
            this.normalBias = source.normalBias;
            this.blurSamples = source.blurSamples;
            this.mapSize.copy(source.mapSize);
            return this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        toJSON() {
            const object = {};
            if (this.intensity !== 1) object.intensity = this.intensity;
            if (this.bias !== 0) object.bias = this.bias;
            if (this.normalBias !== 0) object.normalBias = this.normalBias;
            if (this.radius !== 1) object.radius = this.radius;
            if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
            object.camera = this.camera.toJSON(false).object;
            delete object.camera.matrix;
            return object;
        }
    }
    class SpotLightShadow extends LightShadow {
        constructor() {
            super(new PerspectiveCamera(50, 1, 0.5, 500));
            this.isSpotLightShadow = true;
            this.focus = 1;
            this.aspect = 1;
        }
        updateMatrices(light) {
            const camera = this.camera;
            const fov = RAD2DEG * 2 * light.angle * this.focus;
            const aspect = (this.mapSize.width / this.mapSize.height) * this.aspect;
            const far = light.distance || camera.far;
            if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
                camera.fov = fov;
                camera.aspect = aspect;
                camera.far = far;
                camera.updateProjectionMatrix();
            }
            super.updateMatrices(light);
        }
        copy(source) {
            super.copy(source);
            this.focus = source.focus;
            return this;
        }
    }
    class SpotLight extends Light {
        constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
            super(color, intensity);
            this.isSpotLight = true;
            this.type = 'SpotLight';
            this.position.copy(Object3D.DEFAULT_UP);
            this.updateMatrix();
            this.target = new Object3D();
            this.distance = distance;
            this.angle = angle;
            this.penumbra = penumbra;
            this.decay = decay;
            this.map = null;
            this.shadow = new SpotLightShadow();
        }
        get power() {
            // compute the light's luminous power (in lumens) from its intensity (in candela)
            // by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
            return this.intensity * Math.PI;
        }
        set power(power) {
            // set the light's intensity (in candela) from the desired luminous power (in lumens)
            this.intensity = power / Math.PI;
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.distance = source.distance;
            this.angle = source.angle;
            this.penumbra = source.penumbra;
            this.decay = source.decay;
            this.target = source.target.clone();
            this.shadow = source.shadow.clone();
            return this;
        }
    }
    const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
    const _lightPositionWorld = /*@__PURE__*/ new Vector3();
    const _lookTarget = /*@__PURE__*/ new Vector3();
    class PointLightShadow extends LightShadow {
        constructor() {
            super(new PerspectiveCamera(90, 1, 0.5, 500));
            this.isPointLightShadow = true;
            this._frameExtents = new Vector2(4, 2);
            this._viewportCount = 6;
            this._viewports = [
                // These viewports map a cube-map onto a 2D texture with the
                // following orientation:
                //
                //  xzXZ
                //   y Y
                //
                // X - Positive x direction
                // x - Negative x direction
                // Y - Positive y direction
                // y - Negative y direction
                // Z - Positive z direction
                // z - Negative z direction
                // positive X
                new Vector4(2, 1, 1, 1),
                // negative X
                new Vector4(0, 1, 1, 1),
                // positive Z
                new Vector4(3, 1, 1, 1),
                // negative Z
                new Vector4(1, 1, 1, 1),
                // positive Y
                new Vector4(3, 0, 1, 1),
                // negative Y
                new Vector4(1, 0, 1, 1)
            ];
            this._cubeDirections = [
                new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1),
                new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)
            ];
            this._cubeUps = [
                new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0),
                new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)
            ];
        }
        updateMatrices(light, viewportIndex = 0) {
            const camera = this.camera;
            const shadowMatrix = this.matrix;
            const far = light.distance || camera.far;
            if (far !== camera.far) {
                camera.far = far;
                camera.updateProjectionMatrix();
            }
            _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
            camera.position.copy(_lightPositionWorld);
            _lookTarget.copy(camera.position);
            _lookTarget.add(this._cubeDirections[viewportIndex]);
            camera.up.copy(this._cubeUps[viewportIndex]);
            camera.lookAt(_lookTarget);
            camera.updateMatrixWorld();
            shadowMatrix.makeTranslation(- _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z);
            _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            this._frustum.setFromProjectionMatrix(_projScreenMatrix, camera.coordinateSystem, camera.reversedDepth);
        }
    }
    class PointLight extends Light {
        constructor(color, intensity, distance = 0, decay = 2) {
            super(color, intensity);
            this.isPointLight = true;
            this.type = 'PointLight';
            this.distance = distance;
            this.decay = decay;
            this.shadow = new PointLightShadow();
        }
        get power() {
            // compute the light's luminous power (in lumens) from its intensity (in candela)
            // for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
            return this.intensity * 4 * Math.PI;
        }
        set power(power) {
            // set the light's intensity (in candela) from the desired luminous power (in lumens)
            this.intensity = power / (4 * Math.PI);
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.distance = source.distance;
            this.decay = source.decay;
            this.shadow = source.shadow.clone();
            return this;
        }
    }
    class OrthographicCamera extends Camera {
        constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
            super();
            this.isOrthographicCamera = true;
            this.type = 'OrthographicCamera';
            this.zoom = 1;
            this.view = null;
            this.left = left;
            this.right = right;
            this.top = top;
            this.bottom = bottom;
            this.near = near;
            this.far = far;
            this.updateProjectionMatrix();
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.left = source.left;
            this.right = source.right;
            this.top = source.top;
            this.bottom = source.bottom;
            this.near = source.near;
            this.far = source.far;
            this.zoom = source.zoom;
            this.view = source.view === null ? null : Object.assign({}, source.view);
            return this;
        }
        setViewOffset(fullWidth, fullHeight, x, y, width, height) {
            if (this.view === null) {
                this.view = {
                    enabled: true,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                };
            }
            this.view.enabled = true;
            this.view.fullWidth = fullWidth;
            this.view.fullHeight = fullHeight;
            this.view.offsetX = x;
            this.view.offsetY = y;
            this.view.width = width;
            this.view.height = height;
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
            if (this.view !== null) {
                this.view.enabled = false;
            }
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
            const dx = (this.right - this.left) / (2 * this.zoom);
            const dy = (this.top - this.bottom) / (2 * this.zoom);
            const cx = (this.right + this.left) / 2;
            const cy = (this.top + this.bottom) / 2;
            let left = cx - dx;
            let right = cx + dx;
            let top = cy + dy;
            let bottom = cy - dy;
            if (this.view !== null && this.view.enabled) {
                const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
                const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                left += scaleW * this.view.offsetX;
                right = left + scaleW * this.view.width;
                top -= scaleH * this.view.offsetY;
                bottom = top - scaleH * this.view.height;
            }
            this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem, this.reversedDepth);
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
            const data = super.toJSON(meta);
            data.object.zoom = this.zoom;
            data.object.left = this.left;
            data.object.right = this.right;
            data.object.top = this.top;
            data.object.bottom = this.bottom;
            data.object.near = this.near;
            data.object.far = this.far;
            if (this.view !== null) data.object.view = Object.assign({}, this.view);
            return data;
        }
    }
    class DirectionalLightShadow extends LightShadow {
        constructor() {
            super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
            this.isDirectionalLightShadow = true;
        }
    }
    class DirectionalLight extends Light {
        constructor(color, intensity) {
            super(color, intensity);
            this.isDirectionalLight = true;
            this.type = 'DirectionalLight';
            this.position.copy(Object3D.DEFAULT_UP);
            this.updateMatrix();
            this.target = new Object3D();
            this.shadow = new DirectionalLightShadow();
        }
        dispose() {
            this.shadow.dispose();
        }
        copy(source) {
            super.copy(source);
            this.target = source.target.clone();
            this.shadow = source.shadow.clone();
            return this;
        }
    }
    class AmbientLight extends Light {
        constructor(color, intensity) {
            super(color, intensity);
            this.isAmbientLight = true;
            this.type = 'AmbientLight';
        }
    }
    class RectAreaLight extends Light {
        constructor(color, intensity, width = 10, height = 10) {
            super(color, intensity);
            this.isRectAreaLight = true;
            this.type = 'RectAreaLight';
            this.width = width;
            this.height = height;
        }
        get power() {
            // compute the light's luminous power (in lumens) from its intensity (in nits)
            return this.intensity * this.width * this.height * Math.PI;
        }
        set power(power) {
            // set the light's intensity (in nits) from the desired luminous power (in lumens)
            this.intensity = power / (this.width * this.height * Math.PI);
        }
        copy(source) {
            super.copy(source);
            this.width = source.width;
            this.height = source.height;
            return this;
        }
        toJSON(meta) {
            const data = super.toJSON(meta);
            data.object.width = this.width;
            data.object.height = this.height;
            return data;
        }
    }
    class SphericalHarmonics3 {
        constructor() {
            this.isSphericalHarmonics3 = true;
            this.coefficients = [];
            for (let i = 0; i < 9; i++) {
                this.coefficients.push(new Vector3());
            }
        }
        set(coefficients) {
            for (let i = 0; i < 9; i++) {
                this.coefficients[i].copy(coefficients[i]);
            }
            return this;
        }
        zero() {
            for (let i = 0; i < 9; i++) {
                this.coefficients[i].set(0, 0, 0);
            }
            return this;
        }
        getAt(normal, target) {
            // normal is assumed to be unit length
            const x = normal.x, y = normal.y, z = normal.z;
            const coeff = this.coefficients;
            // band 0
            target.copy(coeff[0]).multiplyScalar(0.282095);
            // band 1
            target.addScaledVector(coeff[1], 0.488603 * y);
            target.addScaledVector(coeff[2], 0.488603 * z);
            target.addScaledVector(coeff[3], 0.488603 * x);
            // band 2
            target.addScaledVector(coeff[4], 1.092548 * (x * y));
            target.addScaledVector(coeff[5], 1.092548 * (y * z));
            target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
            target.addScaledVector(coeff[7], 1.092548 * (x * z));
            target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
            return target;
        }
        getIrradianceAt(normal, target) {
            // normal is assumed to be unit length
            const x = normal.x, y = normal.y, z = normal.z;
            const coeff = this.coefficients;
            // band 0
            target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095
            // band 1
            target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603
            target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
            target.addScaledVector(coeff[3], 2.0 * 0.511664 * x);
            // band 2
            target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548
            target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
            target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3
            target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
            target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274
            return target;
        }
        add(sh) {
            for (let i = 0; i < 9; i++) {
                this.coefficients[i].add(sh.coefficients[i]);
            }
            return this;
        }
        addScaledSH(sh, s) {
            for (let i = 0; i < 9; i++) {
                this.coefficients[i].addScaledVector(sh.coefficients[i], s);
            }
            return this;
        }
        scale(s) {
            for (let i = 0; i < 9; i++) {
                this.coefficients[i].multiplyScalar(s);
            }
            return this;
        }
        lerp(sh, alpha) {
            for (let i = 0; i < 9; i++) {
                this.coefficients[i].lerp(sh.coefficients[i], alpha);
            }
            return this;
        }
        equals(sh) {
            for (let i = 0; i < 9; i++) {
                if (!this.coefficients[i].equals(sh.coefficients[i])) {
                    return false;
                }
            }
            return true;
        }
        copy(sh) {
            return this.set(sh.coefficients);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        fromArray(array, offset = 0) {
            const coefficients = this.coefficients;
            for (let i = 0; i < 9; i++) {
                coefficients[i].fromArray(array, offset + (i * 3));
            }
            return this;
        }
        toArray(array = [], offset = 0) {
            const coefficients = this.coefficients;
            for (let i = 0; i < 9; i++) {
                coefficients[i].toArray(array, offset + (i * 3));
            }
            return array;
        }
        static getBasisAt(normal, shBasis) {
            // normal is assumed to be unit length
            const x = normal.x, y = normal.y, z = normal.z;
            // band 0
            shBasis[0] = 0.282095;
            // band 1
            shBasis[1] = 0.488603 * y;
            shBasis[2] = 0.488603 * z;
            shBasis[3] = 0.488603 * x;
            // band 2
            shBasis[4] = 1.092548 * x * y;
            shBasis[5] = 1.092548 * y * z;
            shBasis[6] = 0.315392 * (3 * z * z - 1);
            shBasis[7] = 1.092548 * x * z;
            shBasis[8] = 0.546274 * (x * x - y * y);
        }
    }
    class LightProbe extends Light {
        constructor(sh = new SphericalHarmonics3(), intensity = 1) {
            super(undefined, intensity);
            this.isLightProbe = true;
            this.sh = sh;
        }
        copy(source) {
            super.copy(source);
            this.sh.copy(source.sh);
            return this;
        }
        fromJSON(json) {
            this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
            this.sh.fromArray(json.sh);
            return this;
        }
        toJSON(meta) {
            const data = super.toJSON(meta);
            data.object.sh = this.sh.toArray();
            return data;
        }
    }
    class MaterialLoader extends Loader {
        constructor(manager) {
            super(manager);
            this.textures = {};
        }
        load(url, onLoad, onProgress, onError) {
            const scope = this;
            const loader = new FileLoader(scope.manager);
            loader.setPath(scope.path);
            loader.setRequestHeader(scope.requestHeader);
            loader.setWithCredentials(scope.withCredentials);
            loader.load(url, function (text) {
                try {
                    onLoad(scope.parse(JSON.parse(text)));
                } catch (e) {
                    if (onError) {
                        onError(e);
                    } else {
                        console.error(e);
                    }
                    scope.manager.itemError(url);
                }
            }, onProgress, onError);
        }
        parse(json) {
            const textures = this.textures;
            function getTexture(name) {
                if (textures[name] === undefined) {
                    console.warn('THREE.MaterialLoader: Undefined texture', name);
                }
                return textures[name];
            }
            const material = this.createMaterialFromType(json.type);
            if (json.uuid !== undefined) material.uuid = json.uuid;
            if (json.name !== undefined) material.name = json.name;
            if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
            if (json.roughness !== undefined) material.roughness = json.roughness;
            if (json.metalness !== undefined) material.metalness = json.metalness;
            if (json.sheen !== undefined) material.sheen = json.sheen;
            if (json.sheenColor !== undefined) material.sheenColor = new Color().setHex(json.sheenColor);
            if (json.sheenRoughness !== undefined) material.sheenRoughness = json.sheenRoughness;
            if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
            if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
            if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;
            if (json.specularColor !== undefined && material.specularColor !== undefined) material.specularColor.setHex(json.specularColor);
            if (json.shininess !== undefined) material.shininess = json.shininess;
            if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
            if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
            if (json.dispersion !== undefined) material.dispersion = json.dispersion;
            if (json.iridescence !== undefined) material.iridescence = json.iridescence;
            if (json.iridescenceIOR !== undefined) material.iridescenceIOR = json.iridescenceIOR;
            if (json.iridescenceThicknessRange !== undefined) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
            if (json.transmission !== undefined) material.transmission = json.transmission;
            if (json.thickness !== undefined) material.thickness = json.thickness;
            if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
            if (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);
            if (json.anisotropy !== undefined) material.anisotropy = json.anisotropy;
            if (json.anisotropyRotation !== undefined) material.anisotropyRotation = json.anisotropyRotation;
            if (json.fog !== undefined) material.fog = json.fog;
            if (json.flatShading !== undefined) material.flatShading = json.flatShading;
            if (json.blending !== undefined) material.blending = json.blending;
            if (json.combine !== undefined) material.combine = json.combine;
            if (json.side !== undefined) material.side = json.side;
            if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
            if (json.opacity !== undefined) material.opacity = json.opacity;
            if (json.transparent !== undefined) material.transparent = json.transparent;
            if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
            if (json.alphaHash !== undefined) material.alphaHash = json.alphaHash;
            if (json.depthFunc !== undefined) material.depthFunc = json.depthFunc;
            if (json.depthTest !== undefined) material.depthTest = json.depthTest;
            if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
            if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
            if (json.blendSrc !== undefined) material.blendSrc = json.blendSrc;
            if (json.blendDst !== undefined) material.blendDst = json.blendDst;
            if (json.blendEquation !== undefined) material.blendEquation = json.blendEquation;
            if (json.blendSrcAlpha !== undefined) material.blendSrcAlpha = json.blendSrcAlpha;
            if (json.blendDstAlpha !== undefined) material.blendDstAlpha = json.blendDstAlpha;
            if (json.blendEquationAlpha !== undefined) material.blendEquationAlpha = json.blendEquationAlpha;
            if (json.blendColor !== undefined && material.blendColor !== undefined) material.blendColor.setHex(json.blendColor);
            if (json.blendAlpha !== undefined) material.blendAlpha = json.blendAlpha;
            if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
            if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
            if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
            if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
            if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
            if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
            if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
            if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
            if (json.wireframe !== undefined) material.wireframe = json.wireframe;
            if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
            if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
            if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
            if (json.rotation !== undefined) material.rotation = json.rotation;
            if (json.linewidth !== undefined) material.linewidth = json.linewidth;
            if (json.dashSize !== undefined) material.dashSize = json.dashSize;
            if (json.gapSize !== undefined) material.gapSize = json.gapSize;
            if (json.scale !== undefined) material.scale = json.scale;
            if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
            if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
            if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
            if (json.dithering !== undefined) material.dithering = json.dithering;
            if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
            if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
            if (json.forceSinglePass !== undefined) material.forceSinglePass = json.forceSinglePass;
            if (json.visible !== undefined) material.visible = json.visible;
            if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
            if (json.userData !== undefined) material.userData = json.userData;
            if (json.vertexColors !== undefined) {
                if (typeof json.vertexColors === 'number') {
                    material.vertexColors = (json.vertexColors > 0) ? true : false;
                } else {
                    material.vertexColors = json.vertexColors;
                }
            }
            // Shader Material
            if (json.uniforms !== undefined) {
                for (const name in json.uniforms) {
                    const uniform = json.uniforms[name];
                    material.uniforms[name] = {};
                    switch (uniform.type) {
                        case 't':
                            material.uniforms[name].value = getTexture(uniform.value);
                            break;
                        case 'c':
                            material.uniforms[name].value = new Color().setHex(uniform.value);
                            break;
                        case 'v2':
                            material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                            break;
                        case 'v3':
                            material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                            break;
                        case 'v4':
                            material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                            break;
                        case 'm3':
                            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                            break;
                        case 'm4':
                            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                            break;
                        default:
                            material.uniforms[name].value = uniform.value;
                    }
                }
            }
            if (json.defines !== undefined) material.defines = json.defines;
            if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
            if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
            if (json.glslVersion !== undefined) material.glslVersion = json.glslVersion;
            if (json.extensions !== undefined) {
                for (const key in json.extensions) {
                    material.extensions[key] = json.extensions[key];
                }
            }
            if (json.lights !== undefined) material.lights = json.lights;
            if (json.clipping !== undefined) material.clipping = json.clipping;
            // for PointsMaterial
            if (json.size !== undefined) material.size = json.size;
            if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
            // maps
            if (json.map !== undefined) material.map = getTexture(json.map);
            if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
            if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
            if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
            if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
            if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
            if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
            if (json.normalScale !== undefined) {
                let normalScale = json.normalScale;
                if (Array.isArray(normalScale) === false) {
                    // Blender exporter used to export a scalar. See #7459
                    normalScale = [normalScale, normalScale];
                }
                material.normalScale = new Vector2().fromArray(normalScale);
            }
            if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
            if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
            if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
            if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
            if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
            if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
            if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
            if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
            if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);
            if (json.specularColorMap !== undefined) material.specularColorMap = getTexture(json.specularColorMap);
            if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
            if (json.envMapRotation !== undefined) material.envMapRotation.fromArray(json.envMapRotation);
            if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
            if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
            if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
            if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
            if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
            if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
            if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
            if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
            if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
            if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
            if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
            if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
            if (json.iridescenceMap !== undefined) material.iridescenceMap = getTexture(json.iridescenceMap);
            if (json.iridescenceThicknessMap !== undefined) material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);
            if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
            if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
            if (json.anisotropyMap !== undefined) material.anisotropyMap = getTexture(json.anisotropyMap);
            if (json.sheenColorMap !== undefined) material.sheenColorMap = getTexture(json.sheenColorMap);
            if (json.sheenRoughnessMap !== undefined) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
            return material;
        }
        setTextures(value) {
            this.textures = value;
            return this;
        }
        createMaterialFromType(type) {
            return MaterialLoader.createMaterialFromType(type);
        }
        static createMaterialFromType(type) {
            const materialLib = {
                ShadowMaterial,
                SpriteMaterial,
                RawShaderMaterial,
                ShaderMaterial,
                PointsMaterial,
                MeshPhysicalMaterial,
                MeshStandardMaterial,
                MeshPhongMaterial,
                MeshToonMaterial,
                MeshNormalMaterial,
                MeshLambertMaterial,
                MeshDepthMaterial,
                MeshDistanceMaterial,
                MeshBasicMaterial,
                MeshMatcapMaterial,
                LineDashedMaterial,
                LineBasicMaterial,
                Material
            };
            return new materialLib[type]();
        }
    }
    class LoaderUtils {
        static extractUrlBase(url) {
            const index = url.lastIndexOf('/');
            if (index === -1) return './';
            return url.slice(0, index + 1);
        }
        static resolveURL(url, path) {
            // Invalid URL
            if (typeof url !== 'string' || url === '') return '';
            // Host Relative URL
            if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
                path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
            }
            // Absolute URL http://,https://,//
            if (/^(https?:)?\/\//i.test(url)) return url;
            // Data URI
            if (/^data:.*,.*$/i.test(url)) return url;
            // Blob URL
            if (/^blob:.*$/i.test(url)) return url;
            // Relative URL
            return path + url;
        }
    }
    class InstancedBufferGeometry extends BufferGeometry {
        constructor() {
            super();
            this.isInstancedBufferGeometry = true;
            this.type = 'InstancedBufferGeometry';
            this.instanceCount = Infinity;
        }
        copy(source) {
            super.copy(source);
            this.instanceCount = source.instanceCount;
            return this;
        }
        toJSON() {
            const data = super.toJSON();
            data.instanceCount = this.instanceCount;
            data.isInstancedBufferGeometry = true;
            return data;
        }
    }
    class BufferGeometryLoader extends Loader {
        constructor(manager) {
            super(manager);
        }
        load(url, onLoad, onProgress, onError) {
            const scope = this;
            const loader = new FileLoader(scope.manager);
            loader.setPath(scope.path);
            loader.setRequestHeader(scope.requestHeader);
            loader.setWithCredentials(scope.withCredentials);
            loader.load(url, function (text) {
                try {
                    onLoad(scope.parse(JSON.parse(text)));
                } catch (e) {
                    if (onError) {
                        onError(e);
                    } else {
                        console.error(e);
                    }
                    scope.manager.itemError(url);
                }
            }, onProgress, onError);
        }
        parse(json) {
            const interleavedBufferMap = {};
            const arrayBufferMap = {};
            function getInterleavedBuffer(json, uuid) {
                if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
                const interleavedBuffers = json.interleavedBuffers;
                const interleavedBuffer = interleavedBuffers[uuid];
                const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
                const array = getTypedArray(interleavedBuffer.type, buffer);
                const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
                ib.uuid = interleavedBuffer.uuid;
                interleavedBufferMap[uuid] = ib;
                return ib;
            }
            function getArrayBuffer(json, uuid) {
                if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
                const arrayBuffers = json.arrayBuffers;
                const arrayBuffer = arrayBuffers[uuid];
                const ab = new Uint32Array(arrayBuffer).buffer;
                arrayBufferMap[uuid] = ab;
                return ab;
            }
            const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
            const index = json.data.index;
            if (index !== undefined) {
                const typedArray = getTypedArray(index.type, index.array);
                geometry.setIndex(new BufferAttribute(typedArray, 1));
            }
            const attributes = json.data.attributes;
            for (const key in attributes) {
                const attribute = attributes[key];
                let bufferAttribute;
                if (attribute.isInterleavedBufferAttribute) {
                    const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                    bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                    const typedArray = getTypedArray(attribute.type, attribute.array);
                    const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
                    bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
                if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);
                geometry.setAttribute(key, bufferAttribute);
            }
            const morphAttributes = json.data.morphAttributes;
            if (morphAttributes) {
                for (const key in morphAttributes) {
                    const attributeArray = morphAttributes[key];
                    const array = [];
                    for (let i = 0, il = attributeArray.length; i < il; i++) {
                        const attribute = attributeArray[i];
                        let bufferAttribute;
                        if (attribute.isInterleavedBufferAttribute) {
                            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                        } else {
                            const typedArray = getTypedArray(attribute.type, attribute.array);
                            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
                        }
                        if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
                        array.push(bufferAttribute);
                    }
                    geometry.morphAttributes[key] = array;
                }
            }
            const morphTargetsRelative = json.data.morphTargetsRelative;
            if (morphTargetsRelative) {
                geometry.morphTargetsRelative = true;
            }
            const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
            if (groups !== undefined) {
                for (let i = 0, n = groups.length; i !== n; ++i) {
                    const group = groups[i];
                    geometry.addGroup(group.start, group.count, group.materialIndex);
                }
            }
            const boundingSphere = json.data.boundingSphere;
            if (boundingSphere !== undefined) {
                geometry.boundingSphere = new Sphere().fromJSON(boundingSphere);
            }
            if (json.name) geometry.name = json.name;
            if (json.userData) geometry.userData = json.userData;
            return geometry;
        }
    }
    class ObjectLoader extends Loader {
        constructor(manager) {
            super(manager);
        }
        load(url, onLoad, onProgress, onError) {
            const scope = this;
            const path = (this.path === '') ? LoaderUtils.extractUrlBase(url) : this.path;
            this.resourcePath = this.resourcePath || path;
            const loader = new FileLoader(this.manager);
            loader.setPath(this.path);
            loader.setRequestHeader(this.requestHeader);
            loader.setWithCredentials(this.withCredentials);
            loader.load(url, function (text) {
                let json = null;
                try {
                    json = JSON.parse(text);
                } catch (error) {
                    if (onError !== undefined) onError(error);
                    console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
                    return;
                }
                const metadata = json.metadata;
                if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                    if (onError !== undefined) onError(new Error('THREE.ObjectLoader: Can\'t load ' + url));
                    console.error('THREE.ObjectLoader: Can\'t load ' + url);
                    return;
                }
                scope.parse(json, onLoad);
            }, onProgress, onError);
        }
        async loadAsync(url, onProgress) {
            const scope = this;
            const path = (this.path === '') ? LoaderUtils.extractUrlBase(url) : this.path;
            this.resourcePath = this.resourcePath || path;
            const loader = new FileLoader(this.manager);
            loader.setPath(this.path);
            loader.setRequestHeader(this.requestHeader);
            loader.setWithCredentials(this.withCredentials);
            const text = await loader.loadAsync(url, onProgress);
            const json = JSON.parse(text);
            const metadata = json.metadata;
            if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                throw new Error('THREE.ObjectLoader: Can\'t load ' + url);
            }
            return await scope.parseAsync(json);
        }
        parse(json, onLoad) {
            const animations = this.parseAnimations(json.animations);
            const shapes = this.parseShapes(json.shapes);
            const geometries = this.parseGeometries(json.geometries, shapes);
            const images = this.parseImages(json.images, function () {
                if (onLoad !== undefined) onLoad(object);
            });
            const textures = this.parseTextures(json.textures, images);
            const materials = this.parseMaterials(json.materials, textures);
            const object = this.parseObject(json.object, geometries, materials, textures, animations);
            const skeletons = this.parseSkeletons(json.skeletons, object);
            this.bindSkeletons(object, skeletons);
            this.bindLightTargets(object);
            //
            if (onLoad !== undefined) {
                let hasImages = false;
                for (const uuid in images) {
                    if (images[uuid].data instanceof HTMLImageElement) {
                        hasImages = true;
                        break;
                    }
                }
                if (hasImages === false) onLoad(object);
            }
            return object;
        }
        async parseAsync(json) {
            const animations = this.parseAnimations(json.animations);
            const shapes = this.parseShapes(json.shapes);
            const geometries = this.parseGeometries(json.geometries, shapes);
            const images = await this.parseImagesAsync(json.images);
            const textures = this.parseTextures(json.textures, images);
            const materials = this.parseMaterials(json.materials, textures);
            const object = this.parseObject(json.object, geometries, materials, textures, animations);
            const skeletons = this.parseSkeletons(json.skeletons, object);
            this.bindSkeletons(object, skeletons);
            this.bindLightTargets(object);
            return object;
        }
        // internals
        parseShapes(json) {
            const shapes = {};
            if (json !== undefined) {
                for (let i = 0, l = json.length; i < l; i++) {
                    const shape = new Shape().fromJSON(json[i]);
                    shapes[shape.uuid] = shape;
                }
            }
            return shapes;
        }
        parseSkeletons(json, object) {
            const skeletons = {};
            const bones = {};
            // generate bone lookup table
            object.traverse(function (child) {
                if (child.isBone) bones[child.uuid] = child;
            });
            // create skeletons
            if (json !== undefined) {
                for (let i = 0, l = json.length; i < l; i++) {
                    const skeleton = new Skeleton().fromJSON(json[i], bones);
                    skeletons[skeleton.uuid] = skeleton;
                }
            }
            return skeletons;
        }
        parseGeometries(json, shapes) {
            const geometries = {};
            if (json !== undefined) {
                const bufferGeometryLoader = new BufferGeometryLoader();
                for (let i = 0, l = json.length; i < l; i++) {
                    let geometry;
                    const data = json[i];
                    switch (data.type) {
                        case 'BufferGeometry':
                        case 'InstancedBufferGeometry':
                            geometry = bufferGeometryLoader.parse(data);
                            break;
                        default:
                            if (data.type in Geometries$1) {
                                geometry = Geometries$1[data.type].fromJSON(data, shapes);
                            } else {
                                console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
                            }
                    }
                    geometry.uuid = data.uuid;
                    if (data.name !== undefined) geometry.name = data.name;
                    if (data.userData !== undefined) geometry.userData = data.userData;
                    geometries[data.uuid] = geometry;
                }
            }
            return geometries;
        }
        parseMaterials(json, textures) {
            const cache = {}; // MultiMaterial
            const materials = {};
            if (json !== undefined) {
                const loader = new MaterialLoader();
                loader.setTextures(textures);
                for (let i = 0, l = json.length; i < l; i++) {
                    const data = json[i];
                    if (cache[data.uuid] === undefined) {
                        cache[data.uuid] = loader.parse(data);
                    }
                    materials[data.uuid] = cache[data.uuid];
                }
            }
            return materials;
        }
        parseAnimations(json) {
            const animations = {};
            if (json !== undefined) {
                for (let i = 0; i < json.length; i++) {
                    const data = json[i];
                    const clip = AnimationClip.parse(data);
                    animations[clip.uuid] = clip;
                }
            }
            return animations;
        }
        parseImages(json, onLoad) {
            const scope = this;
            const images = {};
            let loader;
            function loadImage(url) {
                scope.manager.itemStart(url);
                return loader.load(url, function () {
                    scope.manager.itemEnd(url);
                }, undefined, function () {
                    scope.manager.itemError(url);
                    scope.manager.itemEnd(url);
                });
            }
            function deserializeImage(image) {
                if (typeof image === 'string') {
                    const url = image;
                    const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                    return loadImage(path);
                } else {
                    if (image.data) {
                        return {
                            data: getTypedArray(image.type, image.data),
                            width: image.width,
                            height: image.height
                        };
                    } else {
                        return null;
                    }
                }
            }
            if (json !== undefined && json.length > 0) {
                const manager = new LoadingManager(onLoad);
                loader = new ImageLoader(manager);
                loader.setCrossOrigin(this.crossOrigin);
                for (let i = 0, il = json.length; i < il; i++) {
                    const image = json[i];
                    const url = image.url;
                    if (Array.isArray(url)) {
                        // load array of images e.g CubeTexture
                        const imageArray = [];
                        for (let j = 0, jl = url.length; j < jl; j++) {
                            const currentUrl = url[j];
                            const deserializedImage = deserializeImage(currentUrl);
                            if (deserializedImage !== null) {
                                if (deserializedImage instanceof HTMLImageElement) {
                                    imageArray.push(deserializedImage);
                                } else {
                                    // special case: handle array of data textures for cube textures
                                    imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                                }
                            }
                        }
                        images[image.uuid] = new Source(imageArray);
                    } else {
                        // load single image
                        const deserializedImage = deserializeImage(image.url);
                        images[image.uuid] = new Source(deserializedImage);

                    }
                }
            }
            return images;
        }
        async parseImagesAsync(json) {
            const scope = this;
            const images = {};
            let loader;
            async function deserializeImage(image) {
                if (typeof image === 'string') {
                    const url = image;
                    const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                    return await loader.loadAsync(path);
                } else {
                    if (image.data) {
                        return {
                            data: getTypedArray(image.type, image.data),
                            width: image.width,
                            height: image.height
                        };
                    } else {
                        return null;
                    }
                }
            }
            if (json !== undefined && json.length > 0) {
                loader = new ImageLoader(this.manager);
                loader.setCrossOrigin(this.crossOrigin);
                for (let i = 0, il = json.length; i < il; i++) {
                    const image = json[i];
                    const url = image.url;
                    if (Array.isArray(url)) {
                        // load array of images e.g CubeTexture
                        const imageArray = [];
                        for (let j = 0, jl = url.length; j < jl; j++) {
                            const currentUrl = url[j];
                            const deserializedImage = await deserializeImage(currentUrl);
                            if (deserializedImage !== null) {
                                if (deserializedImage instanceof HTMLImageElement) {
                                    imageArray.push(deserializedImage);
                                } else {
                                    // special case: handle array of data textures for cube textures
                                    imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                                }
                            }
                        }
                        images[image.uuid] = new Source(imageArray);
                    } else {
                        // load single image
                        const deserializedImage = await deserializeImage(image.url);
                        images[image.uuid] = new Source(deserializedImage);
                    }
                }
            }
            return images;
        }
        parseTextures(json, images) {
            function parseConstant(value, type) {
                if (typeof value === 'number') return value;
                console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
                return type[value];
            }
            const textures = {};
            if (json !== undefined) {
                for (let i = 0, l = json.length; i < l; i++) {
                    const data = json[i];
                    if (data.image === undefined) {
                        console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
                    }
                    if (images[data.image] === undefined) {
                        console.warn('THREE.ObjectLoader: Undefined image', data.image);
                    }
                    const source = images[data.image];
                    const image = source.data;
                    let texture;
                    if (Array.isArray(image)) {
                        texture = new CubeTexture();
                        if (image.length === 6) texture.needsUpdate = true;
                    } else {
                        if (image && image.data) {
                            texture = new DataTexture();
                        } else {
                            texture = new Texture();
                        }
                        if (image) texture.needsUpdate = true; // textures can have undefined image data
                    }
                    texture.source = source;
                    texture.uuid = data.uuid;
                    if (data.name !== undefined) texture.name = data.name;
                    if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
                    if (data.channel !== undefined) texture.channel = data.channel;
                    if (data.offset !== undefined) texture.offset.fromArray(data.offset);
                    if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
                    if (data.center !== undefined) texture.center.fromArray(data.center);
                    if (data.rotation !== undefined) texture.rotation = data.rotation;
                    if (data.wrap !== undefined) {
                        texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                        texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
                    }
                    if (data.format !== undefined) texture.format = data.format;
                    if (data.internalFormat !== undefined) texture.internalFormat = data.internalFormat;
                    if (data.type !== undefined) texture.type = data.type;
                    if (data.colorSpace !== undefined) texture.colorSpace = data.colorSpace;
                    if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
                    if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
                    if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
                    if (data.flipY !== undefined) texture.flipY = data.flipY;
                    if (data.generateMipmaps !== undefined) texture.generateMipmaps = data.generateMipmaps;
                    if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
                    if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
                    if (data.compareFunction !== undefined) texture.compareFunction = data.compareFunction;
                    if (data.userData !== undefined) texture.userData = data.userData;
                    textures[data.uuid] = texture;
                }
            }
            return textures;
        }
        parseObject(data, geometries, materials, textures, animations) {
            let object;
            function getGeometry(name) {
                if (geometries[name] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined geometry', name);
                }
                return geometries[name];
            }
            function getMaterial(name) {
                if (name === undefined) return undefined;
                if (Array.isArray(name)) {
                    const array = [];
                    for (let i = 0, l = name.length; i < l; i++) {
                        const uuid = name[i];
                        if (materials[uuid] === undefined) {
                            console.warn('THREE.ObjectLoader: Undefined material', uuid);
                        }
                        array.push(materials[uuid]);
                    }
                    return array;
                }
                if (materials[name] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined material', name);
                }
                return materials[name];
            }
            function getTexture(uuid) {
                if (textures[uuid] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined texture', uuid);
                }
                return textures[uuid];
            }
            let geometry, material;
            switch (data.type) {
                case 'Scene':
                    object = new Scene();
                    if (data.background !== undefined) {
                        if (Number.isInteger(data.background)) {
                            object.background = new Color(data.background);
                        } else {
                            object.background = getTexture(data.background);
                        }
                    }
                    if (data.environment !== undefined) {
                        object.environment = getTexture(data.environment);
                    }
                    if (data.fog !== undefined) {
                        if (data.fog.type === 'Fog') {
                            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                        } else if (data.fog.type === 'FogExp2') {
                            object.fog = new FogExp2(data.fog.color, data.fog.density);
                        }
                        if (data.fog.name !== '') {
                            object.fog.name = data.fog.name;
                        }
                    }
                    if (data.backgroundBlurriness !== undefined) object.backgroundBlurriness = data.backgroundBlurriness;
                    if (data.backgroundIntensity !== undefined) object.backgroundIntensity = data.backgroundIntensity;
                    if (data.backgroundRotation !== undefined) object.backgroundRotation.fromArray(data.backgroundRotation);
                    if (data.environmentIntensity !== undefined) object.environmentIntensity = data.environmentIntensity;
                    if (data.environmentRotation !== undefined) object.environmentRotation.fromArray(data.environmentRotation);
                    break;
                case 'PerspectiveCamera':
                    object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                    if (data.focus !== undefined) object.focus = data.focus;
                    if (data.zoom !== undefined) object.zoom = data.zoom;
                    if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                    if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                    if (data.view !== undefined) object.view = Object.assign({}, data.view);
                    break;
                case 'OrthographicCamera':
                    object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                    if (data.zoom !== undefined) object.zoom = data.zoom;
                    if (data.view !== undefined) object.view = Object.assign({}, data.view);
                    break;
                case 'AmbientLight':
                    object = new AmbientLight(data.color, data.intensity);
                    break;
                case 'DirectionalLight':
                    object = new DirectionalLight(data.color, data.intensity);
                    object.target = data.target || '';
                    break;
                case 'PointLight':
                    object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                    break;
                case 'RectAreaLight':
                    object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                    break;
                case 'SpotLight':
                    object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                    object.target = data.target || '';
                    break;
                case 'HemisphereLight':
                    object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                    break;
                case 'LightProbe':
                    object = new LightProbe().fromJSON(data);
                    break;
                case 'SkinnedMesh':
                    geometry = getGeometry(data.geometry);
                    material = getMaterial(data.material);
                    object = new SkinnedMesh(geometry, material);
                    if (data.bindMode !== undefined) object.bindMode = data.bindMode;
                    if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
                    if (data.skeleton !== undefined) object.skeleton = data.skeleton;
                    break;
                case 'Mesh':
                    geometry = getGeometry(data.geometry);
                    material = getMaterial(data.material);
                    object = new Mesh(geometry, material);
                    break;
                case 'InstancedMesh':
                    geometry = getGeometry(data.geometry);
                    material = getMaterial(data.material);
                    const count = data.count;
                    const instanceMatrix = data.instanceMatrix;
                    const instanceColor = data.instanceColor;
                    object = new InstancedMesh(geometry, material, count);
                    object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
                    if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
                    break;
                case 'BatchedMesh':
                    geometry = getGeometry(data.geometry);
                    material = getMaterial(data.material);
                    object = new BatchedMesh(data.maxInstanceCount, data.maxVertexCount, data.maxIndexCount, material);
                    object.geometry = geometry;
                    object.perObjectFrustumCulled = data.perObjectFrustumCulled;
                    object.sortObjects = data.sortObjects;
                    object._drawRanges = data.drawRanges;
                    object._reservedRanges = data.reservedRanges;
                    object._geometryInfo = data.geometryInfo.map(info => {
                        let box = null;
                        let sphere = null;
                        if (info.boundingBox !== undefined) {
                            box = new Box3().fromJSON(info.boundingBox);
                        }
                        if (info.boundingSphere !== undefined) {
                            sphere = new Sphere().fromJSON(info.boundingSphere);
                        }
                        return {
                            ...info,
                            boundingBox: box,
                            boundingSphere: sphere
                        };
                    });
                    object._instanceInfo = data.instanceInfo;
                    object._availableInstanceIds = data._availableInstanceIds;
                    object._availableGeometryIds = data._availableGeometryIds;
                    object._nextIndexStart = data.nextIndexStart;
                    object._nextVertexStart = data.nextVertexStart;
                    object._geometryCount = data.geometryCount;
                    object._maxInstanceCount = data.maxInstanceCount;
                    object._maxVertexCount = data.maxVertexCount;
                    object._maxIndexCount = data.maxIndexCount;
                    object._geometryInitialized = data.geometryInitialized;
                    object._matricesTexture = getTexture(data.matricesTexture.uuid);
                    object._indirectTexture = getTexture(data.indirectTexture.uuid);
                    if (data.colorsTexture !== undefined) {
                        object._colorsTexture = getTexture(data.colorsTexture.uuid);
                    }
                    if (data.boundingSphere !== undefined) {
                        object.boundingSphere = new Sphere().fromJSON(data.boundingSphere);
                    }
                    if (data.boundingBox !== undefined) {
                        object.boundingBox = new Box3().fromJSON(data.boundingBox);
                    }
                    break;
                case 'LOD':
                    object = new LOD();
                    break;
                case 'Line':
                    object = new Line(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'LineLoop':
                    object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'LineSegments':
                    object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'PointCloud':
                case 'Points':
                    object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'Sprite':
                    object = new Sprite(getMaterial(data.material));
                    break;
                case 'Group':
                    object = new Group();
                    break;
                case 'Bone':
                    object = new Bone();
                    break;
                default:
                    object = new Object3D();
            }
            object.uuid = data.uuid;
            if (data.name !== undefined) object.name = data.name;
            if (data.matrix !== undefined) {
                object.matrix.fromArray(data.matrix);
                if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
                if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
            } else {
                if (data.position !== undefined) object.position.fromArray(data.position);
                if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
                if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
                if (data.scale !== undefined) object.scale.fromArray(data.scale);
            }
            if (data.up !== undefined) object.up.fromArray(data.up);
            if (data.castShadow !== undefined) object.castShadow = data.castShadow;
            if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
            if (data.shadow) {
                if (data.shadow.intensity !== undefined) object.shadow.intensity = data.shadow.intensity;
                if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
                if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
                if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
                if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
                if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
            }
            if (data.visible !== undefined) object.visible = data.visible;
            if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
            if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
            if (data.userData !== undefined) object.userData = data.userData;
            if (data.layers !== undefined) object.layers.mask = data.layers;
            if (data.children !== undefined) {
                const children = data.children;
                for (let i = 0; i < children.length; i++) {
                    object.add(this.parseObject(children[i], geometries, materials, textures, animations));
                }
            }
            if (data.animations !== undefined) {
                const objectAnimations = data.animations;
                for (let i = 0; i < objectAnimations.length; i++) {
                    const uuid = objectAnimations[i];
                    object.animations.push(animations[uuid]);
                }
            }
            if (data.type === 'LOD') {
                if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
                const levels = data.levels;
                for (let l = 0; l < levels.length; l++) {
                    const level = levels[l];
                    const child = object.getObjectByProperty('uuid', level.object);
                    if (child !== undefined) {
                        object.addLevel(child, level.distance, level.hysteresis);
                    }
                }
            }
            return object;
        }
        bindSkeletons(object, skeletons) {
            if (Object.keys(skeletons).length === 0) return;
            object.traverse(function (child) {
                if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
                    const skeleton = skeletons[child.skeleton];
                    if (skeleton === undefined) {
                        console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
                    } else {
                        child.bind(skeleton, child.bindMatrix);
                    }
                }
            });
        }
        bindLightTargets(object) {
            object.traverse(function (child) {
                if (child.isDirectionalLight || child.isSpotLight) {
                    const uuid = child.target;
                    const target = object.getObjectByProperty('uuid', uuid);
                    if (target !== undefined) {
                        child.target = target;
                    } else {
                        child.target = new Object3D();
                    }
                }
            });
        }
    }
    const TEXTURE_MAPPING = {
        UVMapping: UVMapping,
        CubeReflectionMapping: CubeReflectionMapping,
        CubeRefractionMapping: CubeRefractionMapping,
        EquirectangularReflectionMapping: EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: EquirectangularRefractionMapping,
        CubeUVReflectionMapping: CubeUVReflectionMapping
    };
    const TEXTURE_WRAPPING = {
        RepeatWrapping: RepeatWrapping,
        ClampToEdgeWrapping: ClampToEdgeWrapping,
        MirroredRepeatWrapping: MirroredRepeatWrapping
    };
    const TEXTURE_FILTER = {
        NearestFilter: NearestFilter,
        NearestMipmapNearestFilter: NearestMipmapNearestFilter,
        NearestMipmapLinearFilter: NearestMipmapLinearFilter,
        LinearFilter: LinearFilter,
        LinearMipmapNearestFilter: LinearMipmapNearestFilter,
        LinearMipmapLinearFilter: LinearMipmapLinearFilter
    };
    const _errorMap = new WeakMap();
    class ImageBitmapLoader extends Loader {
        constructor(manager) {
            super(manager);
            this.isImageBitmapLoader = true;
            if (typeof createImageBitmap === 'undefined') {
                console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
            }
            if (typeof fetch === 'undefined') {
                console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
            }
            this.options = { premultiplyAlpha: 'none' };
            this._abortController = new AbortController();
        }
        setOptions(options) {
            this.options = options;
            return this;
        }
        load(url, onLoad, onProgress, onError) {
            if (url === undefined) url = '';
            if (this.path !== undefined) url = this.path + url;
            url = this.manager.resolveURL(url);
            const scope = this;
            const cached = Cache.get(`image-bitmap:${url}`);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                // If cached is a promise, wait for it to resolve
                if (cached.then) {
                    cached.then(imageBitmap => {
                        // check if there is an error for the cached promise
                        if (_errorMap.has(cached) === true) {
                            if (onError) onError(_errorMap.get(cached));
                            scope.manager.itemError(url);
                            scope.manager.itemEnd(url);
                        } else {
                            if (onLoad) onLoad(imageBitmap);
                            scope.manager.itemEnd(url);
                            return imageBitmap;
                        }
                    });
                    return;
                }
                // If cached is not a promise (i.e., it's already an imageBitmap)
                setTimeout(function () {
                    if (onLoad) onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            const fetchOptions = {};
            fetchOptions.credentials = (this.crossOrigin === 'anonymous') ? 'same-origin' : 'include';
            fetchOptions.headers = this.requestHeader;
            fetchOptions.signal = (typeof AbortSignal.any === 'function') ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal;
            const promise = fetch(url, fetchOptions).then(function (res) {
                return res.blob();
            }).then(function (blob) {
                return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: 'none' }));
            }).then(function (imageBitmap) {
                Cache.add(`image-bitmap:${url}`, imageBitmap);
                if (onLoad) onLoad(imageBitmap);
                scope.manager.itemEnd(url);
                return imageBitmap;
            }).catch(function (e) {
                if (onError) onError(e);
                _errorMap.set(promise, e);
                Cache.remove(`image-bitmap:${url}`);
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            });
            Cache.add(`image-bitmap:${url}`, promise);
            scope.manager.itemStart(url);
        }
        abort() {
            this._abortController.abort();
            this._abortController = new AbortController();
            return this;
        }
    }
    let _context;
    class AudioContext {
        static getContext() {
            if (_context === undefined) {
                _context = new (window.AudioContext || window.webkitAudioContext)();
            }
            return _context;
        }
        static setContext(value) {
            _context = value;
        }
    }
    class AudioLoader extends Loader {
        constructor(manager) {
            super(manager);
        }
        load(url, onLoad, onProgress, onError) {
            const scope = this;
            const loader = new FileLoader(this.manager);
            loader.setResponseType('arraybuffer');
            loader.setPath(this.path);
            loader.setRequestHeader(this.requestHeader);
            loader.setWithCredentials(this.withCredentials);
            loader.load(url, function (buffer) {
                try {
                    // Create a copy of the buffer. The `decodeAudioData` method
                    // detaches the buffer when complete, preventing reuse.
                    const bufferCopy = buffer.slice(0);
                    const context = AudioContext.getContext();
                    context.decodeAudioData(bufferCopy, function (audioBuffer) {
                        onLoad(audioBuffer);
                    }).catch(handleError);
                } catch (e) {
                    handleError(e);
                }
            }, onProgress, onError);
            function handleError(e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }
    }
    const _eyeRight = /*@__PURE__*/ new Matrix4();
    const _eyeLeft = /*@__PURE__*/ new Matrix4();
    const _projectionMatrix = /*@__PURE__*/ new Matrix4();
    class StereoCamera {
        constructor() {
            this.type = 'StereoCamera';
            this.aspect = 1;
            this.eyeSep = 0.064;
            this.cameraL = new PerspectiveCamera();
            this.cameraL.layers.enable(1);
            this.cameraL.matrixAutoUpdate = false;
            this.cameraR = new PerspectiveCamera();
            this.cameraR.layers.enable(2);
            this.cameraR.matrixAutoUpdate = false;
            this._cache = {
                focus: null,
                fov: null,
                aspect: null,
                near: null,
                far: null,
                zoom: null,
                eyeSep: null
            };
        }
        update(camera) {
            const cache = this._cache;
            const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
                cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
                cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
            if (needsUpdate) {
                cache.focus = camera.focus;
                cache.fov = camera.fov;
                cache.aspect = camera.aspect * this.aspect;
                cache.near = camera.near;
                cache.far = camera.far;
                cache.zoom = camera.zoom;
                cache.eyeSep = this.eyeSep;
                // Off-axis stereoscopic effect based on
                // http://paulbourke.net/stereographics/stereorender/
                _projectionMatrix.copy(camera.projectionMatrix);
                const eyeSepHalf = cache.eyeSep / 2;
                const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
                const ymax = (cache.near * Math.tan(DEG2RAD * cache.fov * 0.5)) / cache.zoom;
                let xmin, xmax;
                // translate xOffset
                _eyeLeft.elements[12] = - eyeSepHalf;
                _eyeRight.elements[12] = eyeSepHalf;
                // for left eye
                xmin = - ymax * cache.aspect + eyeSepOnProjection;
                xmax = ymax * cache.aspect + eyeSepOnProjection;
                _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
                _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                this.cameraL.projectionMatrix.copy(_projectionMatrix);
                // for right eye
                xmin = - ymax * cache.aspect - eyeSepOnProjection;
                xmax = ymax * cache.aspect - eyeSepOnProjection;
                _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
                _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                this.cameraR.projectionMatrix.copy(_projectionMatrix);
            }
            this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
            this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
        }
    }
    class ArrayCamera extends PerspectiveCamera {
        constructor(array = []) {
            super();
            this.isArrayCamera = true;
            this.isMultiViewCamera = false;
            this.cameras = array;
        }
    }
    class Clock {
        constructor(autoStart = true) {
            this.autoStart = autoStart;
            this.startTime = 0;
            this.oldTime = 0;
            this.elapsedTime = 0;
            this.running = false;
        }
        start() {
            this.startTime = performance.now();
            this.oldTime = this.startTime;
            this.elapsedTime = 0;
            this.running = true;
        }
        stop() {
            this.getElapsedTime();
            this.running = false;
            this.autoStart = false;
        }
        getElapsedTime() {
            this.getDelta();
            return this.elapsedTime;
        }
        getDelta() {
            let diff = 0;
            if (this.autoStart && !this.running) {
                this.start();
                return 0;
            }
            if (this.running) {
                const newTime = performance.now();
                diff = (newTime - this.oldTime) / 1000;
                this.oldTime = newTime;
                this.elapsedTime += diff;
            }
            return diff;
        }
    }
    const _position$1 = /*@__PURE__*/ new Vector3();
    const _quaternion$1 = /*@__PURE__*/ new Quaternion();
    const _scale$1 = /*@__PURE__*/ new Vector3();
    const _forward = /*@__PURE__*/ new Vector3();
    const _up = /*@__PURE__*/ new Vector3();
    class AudioListener extends Object3D {
        constructor() {
            super();
            this.type = 'AudioListener';
            this.context = AudioContext.getContext();
            this.gain = this.context.createGain();
            this.gain.connect(this.context.destination);
            this.filter = null;
            this.timeDelta = 0;
            // private
            this._clock = new Clock();
        }
        getInput() {
            return this.gain;
        }
        removeFilter() {
            if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
                this.gain.connect(this.context.destination);
                this.filter = null;
            }
            return this;
        }
        getFilter() {
            return this.filter;
        }
        setFilter(value) {
            if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
            } else {
                this.gain.disconnect(this.context.destination);
            }
            this.filter = value;
            this.gain.connect(this.filter);
            this.filter.connect(this.context.destination);
            return this;
        }
        getMasterVolume() {
            return this.gain.gain.value;
        }
        setMasterVolume(value) {
            this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
            return this;
        }
        updateMatrixWorld(force) {
            super.updateMatrixWorld(force);
            const listener = this.context.listener;
            this.timeDelta = this._clock.getDelta();
            this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
            // the initial forward and up directions must be orthogonal
            _forward.set(0, 0, -1).applyQuaternion(_quaternion$1);
            _up.set(0, 1, 0).applyQuaternion(_quaternion$1);
            if (listener.positionX) {
                // code path for Chrome (see #14393)
                const endTime = this.context.currentTime + this.timeDelta;
                listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
                listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
                listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
                listener.forwardX.linearRampToValueAtTime(_forward.x, endTime);
                listener.forwardY.linearRampToValueAtTime(_forward.y, endTime);
                listener.forwardZ.linearRampToValueAtTime(_forward.z, endTime);
                listener.upX.linearRampToValueAtTime(_up.x, endTime);
                listener.upY.linearRampToValueAtTime(_up.y, endTime);
                listener.upZ.linearRampToValueAtTime(_up.z, endTime);
            } else {
                listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
                listener.setOrientation(_forward.x, _forward.y, _forward.z, _up.x, _up.y, _up.z);
            }
        }
    }
    class Audio extends Object3D {
        constructor(listener) {
            super();
            this.type = 'Audio';
            this.listener = listener;
            this.context = listener.context;
            this.gain = this.context.createGain();
            this.gain.connect(listener.getInput());
            this.autoplay = false;
            this.buffer = null;
            this.detune = 0;
            this.loop = false;
            this.loopStart = 0;
            this.loopEnd = 0;
            this.offset = 0;
            this.duration = undefined;
            this.playbackRate = 1;
            this.isPlaying = false;
            this.hasPlaybackControl = true;
            this.source = null;
            this.sourceType = 'empty';
            this._startedAt = 0;
            this._progress = 0;
            this._connected = false;
            this.filters = [];
        }
        getOutput() {
            return this.gain;
        }
        setNodeSource(audioNode) {
            this.hasPlaybackControl = false;
            this.sourceType = 'audioNode';
            this.source = audioNode;
            this.connect();
            return this;
        }
        setMediaElementSource(mediaElement) {
            this.hasPlaybackControl = false;
            this.sourceType = 'mediaNode';
            this.source = this.context.createMediaElementSource(mediaElement);
            this.connect();
            return this;
        }
        setMediaStreamSource(mediaStream) {
            this.hasPlaybackControl = false;
            this.sourceType = 'mediaStreamNode';
            this.source = this.context.createMediaStreamSource(mediaStream);
            this.connect();
            return this;
        }
        setBuffer(audioBuffer) {
            this.buffer = audioBuffer;
            this.sourceType = 'buffer';
            if (this.autoplay) this.play();
            return this;
        }
        play(delay = 0) {
            if (this.isPlaying === true) {
                console.warn('THREE.Audio: Audio is already playing.');
                return;
            }
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this._startedAt = this.context.currentTime + delay;
            const source = this.context.createBufferSource();
            source.buffer = this.buffer;
            source.loop = this.loop;
            source.loopStart = this.loopStart;
            source.loopEnd = this.loopEnd;
            source.onended = this.onEnded.bind(this);
            source.start(this._startedAt, this._progress + this.offset, this.duration);
            this.isPlaying = true;
            this.source = source;
            this.setDetune(this.detune);
            this.setPlaybackRate(this.playbackRate);
            return this.connect();
        }
        pause() {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            if (this.isPlaying === true) {
                // update current progress
                this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
                if (this.loop === true) {
                    // ensure _progress does not exceed duration with looped audios
                    this._progress = this._progress % (this.duration || this.buffer.duration);
                }
                this.source.stop();
                this.source.onended = null;
                this.isPlaying = false;
            }
            return this;
        }
        stop(delay = 0) {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this._progress = 0;
            if (this.source !== null) {
                this.source.stop(this.context.currentTime + delay);
                this.source.onended = null;
            }
            this.isPlaying = false;
            return this;
        }
        connect() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (let i = 1, l = this.filters.length; i < l; i++) {
                    this.filters[i - 1].connect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].connect(this.getOutput());
            } else {
                this.source.connect(this.getOutput());
            }
            this._connected = true;
            return this;
        }
        disconnect() {
            if (this._connected === false) {
                return;
            }
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let i = 1, l = this.filters.length; i < l; i++) {
                    this.filters[i - 1].disconnect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
            } else {
                this.source.disconnect(this.getOutput());
            }
            this._connected = false;
            return this;
        }
        getFilters() {
            return this.filters;
        }
        setFilters(value) {
            if (!value) value = [];
            if (this._connected === true) {
                this.disconnect();
                this.filters = value.slice();
                this.connect();
            } else {
                this.filters = value.slice();
            }
            return this;
        }
        setDetune(value) {
            this.detune = value;
            if (this.isPlaying === true && this.source.detune !== undefined) {
                this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
            }
            return this;
        }
        getDetune() {
            return this.detune;
        }
        getFilter() {
            return this.getFilters()[0];
        }
        setFilter(filter) {
            return this.setFilters(filter ? [filter] : []);
        }
        setPlaybackRate(value) {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.playbackRate = value;
            if (this.isPlaying === true) {
                this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
            }
            return this;
        }
        getPlaybackRate() {
            return this.playbackRate;
        }
        onEnded() {
            this.isPlaying = false;
            this._progress = 0;
        }
        getLoop() {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return false;
            }
            return this.loop;
        }
        setLoop(value) {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.loop = value;
            if (this.isPlaying === true) {
                this.source.loop = this.loop;
            }
            return this;
        }
        setLoopStart(value) {
            this.loopStart = value;
            return this;
        }
        setLoopEnd(value) {
            this.loopEnd = value;
            return this;
        }
        getVolume() {
            return this.gain.gain.value;
        }
        setVolume(value) {
            this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
            return this;
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            if (source.sourceType !== 'buffer') {
                console.warn('THREE.Audio: Audio source type cannot be copied.');
                return this;
            }
            this.autoplay = source.autoplay;
            this.buffer = source.buffer;
            this.detune = source.detune;
            this.loop = source.loop;
            this.loopStart = source.loopStart;
            this.loopEnd = source.loopEnd;
            this.offset = source.offset;
            this.duration = source.duration;
            this.playbackRate = source.playbackRate;
            this.hasPlaybackControl = source.hasPlaybackControl;
            this.sourceType = source.sourceType;
            this.filters = source.filters.slice();
            return this;
        }
        clone(recursive) {
            return new this.constructor(this.listener).copy(this, recursive);
        }
    }
    const _position = /*@__PURE__*/ new Vector3();
    const _quaternion = /*@__PURE__*/ new Quaternion();
    const _scale = /*@__PURE__*/ new Vector3();
    const _orientation = /*@__PURE__*/ new Vector3();
    class PositionalAudio extends Audio {
        constructor(listener) {
            super(listener);
            this.panner = this.context.createPanner();
            this.panner.panningModel = 'HRTF';
            this.panner.connect(this.gain);
        }
        connect() {
            super.connect();
            this.panner.connect(this.gain);
            return this;
        }
        disconnect() {
            super.disconnect();
            this.panner.disconnect(this.gain);
            return this;
        }
        getOutput() {
            return this.panner;
        }
        getRefDistance() {
            return this.panner.refDistance;
        }
        setRefDistance(value) {
            this.panner.refDistance = value;
            return this;
        }
        getRolloffFactor() {
            return this.panner.rolloffFactor;
        }
        setRolloffFactor(value) {
            this.panner.rolloffFactor = value;
            return this;
        }
        getDistanceModel() {
            return this.panner.distanceModel;
        }
        setDistanceModel(value) {
            this.panner.distanceModel = value;
            return this;
        }
        getMaxDistance() {
            return this.panner.maxDistance;
        }
        setMaxDistance(value) {
            this.panner.maxDistance = value;
            return this;
        }
        setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
            this.panner.coneInnerAngle = coneInnerAngle;
            this.panner.coneOuterAngle = coneOuterAngle;
            this.panner.coneOuterGain = coneOuterGain;
            return this;
        }
        updateMatrixWorld(force) {
            super.updateMatrixWorld(force);
            if (this.hasPlaybackControl === true && this.isPlaying === false) return;
            this.matrixWorld.decompose(_position, _quaternion, _scale);
            _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
            const panner = this.panner;
            if (panner.positionX) {
                // code path for Chrome and Firefox (see #14393)
                const endTime = this.context.currentTime + this.listener.timeDelta;
                panner.positionX.linearRampToValueAtTime(_position.x, endTime);
                panner.positionY.linearRampToValueAtTime(_position.y, endTime);
                panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
                panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
                panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
                panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
            } else {
                panner.setPosition(_position.x, _position.y, _position.z);
                panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
            }
        }
    }
    class AudioAnalyser {
        constructor(audio, fftSize = 2048) {
            this.analyser = audio.context.createAnalyser();
            this.analyser.fftSize = fftSize;
            this.data = new Uint8Array(this.analyser.frequencyBinCount);
            audio.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
            this.analyser.getByteFrequencyData(this.data);
            return this.data;
        }
        getAverageFrequency() {
            let value = 0;
            const data = this.getFrequencyData();
            for (let i = 0; i < data.length; i++) {
                value += data[i];
            }
            return value / data.length;
        }
    }
    class PropertyMixer {
        constructor(binding, typeName, valueSize) {
            this.binding = binding;
            this.valueSize = valueSize;
            let mixFunction,
                mixFunctionAdditive,
                setIdentity;
            // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
            //
            // interpolators can use .buffer as their .result
            // the data then goes to 'incoming'
            //
            // 'accu0' and 'accu1' are used frame-interleaved for
            // the cumulative result and are compared to detect
            // changes
            //
            // 'orig' stores the original state of the property
            //
            // 'add' is used for additive cumulative results
            //
            // 'work' is optional and is only present for quaternion types. It is used
            // to store intermediate quaternion multiplication results
            switch (typeName) {
                case 'quaternion':
                    mixFunction = this._slerp;
                    mixFunctionAdditive = this._slerpAdditive;
                    setIdentity = this._setAdditiveIdentityQuaternion;
                    this.buffer = new Float64Array(valueSize * 6);
                    this._workIndex = 5;
                    break;
                case 'string':
                case 'bool':
                    mixFunction = this._select;
                    // Use the regular mix function and for additive on these types,
                    // additive is not relevant for non-numeric types
                    mixFunctionAdditive = this._select;
                    setIdentity = this._setAdditiveIdentityOther;
                    this.buffer = new Array(valueSize * 5);
                    break;
                default:
                    mixFunction = this._lerp;
                    mixFunctionAdditive = this._lerpAdditive;
                    setIdentity = this._setAdditiveIdentityNumeric;
                    this.buffer = new Float64Array(valueSize * 5);
            }
            this._mixBufferRegion = mixFunction;
            this._mixBufferRegionAdditive = mixFunctionAdditive;
            this._setIdentity = setIdentity;
            this._origIndex = 3;
            this._addIndex = 4;
            this.cumulativeWeight = 0;
            this.cumulativeWeightAdditive = 0;
            this.useCount = 0;
            this.referenceCount = 0;
        }
        accumulate(accuIndex, weight) {
            // note: happily accumulating nothing when weight = 0, the caller knows
            // the weight and shouldn't have made the call in the first place
            const buffer = this.buffer,
                stride = this.valueSize,
                offset = accuIndex * stride + stride;
            let currentWeight = this.cumulativeWeight;
            if (currentWeight === 0) {
                // accuN := incoming * weight
                for (let i = 0; i !== stride; ++i) {
                    buffer[offset + i] = buffer[i];
                }
                currentWeight = weight;
            } else {
                // accuN := accuN + incoming * weight
                currentWeight += weight;
                const mix = weight / currentWeight;
                this._mixBufferRegion(buffer, offset, 0, mix, stride);
            }
            this.cumulativeWeight = currentWeight;
        }
        accumulateAdditive(weight) {
            const buffer = this.buffer,
                stride = this.valueSize,
                offset = stride * this._addIndex;
            if (this.cumulativeWeightAdditive === 0) {
                // add = identity
                this._setIdentity();
            }
            // add := add + incoming * weight
            this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
            this.cumulativeWeightAdditive += weight;
        }
        apply(accuIndex) {
            const stride = this.valueSize,
                buffer = this.buffer,
                offset = accuIndex * stride + stride,
                weight = this.cumulativeWeight,
                weightAdditive = this.cumulativeWeightAdditive,
                binding = this.binding;
            this.cumulativeWeight = 0;
            this.cumulativeWeightAdditive = 0;
            if (weight < 1) {
                // accuN := accuN + original * ( 1 - cumulativeWeight )
                const originalValueOffset = stride * this._origIndex;
                this._mixBufferRegion(
                    buffer, offset, originalValueOffset, 1 - weight, stride);
            }
            if (weightAdditive > 0) {
                // accuN := accuN + additive accuN
                this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
            }
            for (let i = stride, e = stride + stride; i !== e; ++i) {
                if (buffer[i] !== buffer[i + stride]) {
                    // value has changed -> update scene graph
                    binding.setValue(buffer, offset);
                    break;
                }
            }
        }

        saveOriginalState() {
            const binding = this.binding;
            const buffer = this.buffer,
                stride = this.valueSize,
                originalValueOffset = stride * this._origIndex;
            binding.getValue(buffer, originalValueOffset);
            // accu[0..1] := orig -- initially detect changes against the original
            for (let i = stride, e = originalValueOffset; i !== e; ++i) {
                buffer[i] = buffer[originalValueOffset + (i % stride)];
            }
            // Add to identity for additive
            this._setIdentity();
            this.cumulativeWeight = 0;
            this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
            const originalValueOffset = this.valueSize * 3;
            this.binding.setValue(this.buffer, originalValueOffset);
        }
        // internals
        _setAdditiveIdentityNumeric() {
            const startIndex = this._addIndex * this.valueSize;
            const endIndex = startIndex + this.valueSize;
            for (let i = startIndex; i < endIndex; i++) {
                this.buffer[i] = 0;
            }
        }
        _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric();
            this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
            const startIndex = this._origIndex * this.valueSize;
            const targetIndex = this._addIndex * this.valueSize;
            for (let i = 0; i < this.valueSize; i++) {
                this.buffer[targetIndex + i] = this.buffer[startIndex + i];
            }
        }

        // mix functions
        _select(buffer, dstOffset, srcOffset, t, stride) {
            if (t >= 0.5) {
                for (let i = 0; i !== stride; ++i) {
                    buffer[dstOffset + i] = buffer[srcOffset + i];
                }
            }
        }
        _slerp(buffer, dstOffset, srcOffset, t) {
            Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        }
        _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
            const workOffset = this._workIndex * stride;
            // Store result in intermediate buffer offset
            Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
            // Slerp to the intermediate result
            Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
        }
        _lerp(buffer, dstOffset, srcOffset, t, stride) {
            const s = 1 - t;
            for (let i = 0; i !== stride; ++i) {
                const j = dstOffset + i;
                buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
            }
        }
        _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
            for (let i = 0; i !== stride; ++i) {
                const j = dstOffset + i;
                buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
            }
        }
    }
    // Characters [].:/ are reserved for track binding syntax.
    const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
    const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');
    // Attempts to allow node names from any language. ES5's `\w` regexp matches
    // only latin characters, and the unicode \p{L} is not yet supported. So
    // instead, we exclude reserved characters and match everything else.
    const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
    const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';
    // Parent directories, delimited by '/' or ':'. Currently unused, but must
    // be matched to parse the rest of the track name.
    const _directoryRe = /*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);
    // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
    const _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);
    // Object on target node, and accessor. May not contain reserved
    // characters. Accessor may contain any character except closing bracket.
    const _objectRe = /*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);
    // Property and accessor. May not contain reserved characters. Accessor may
    // contain any non-bracket characters.
    const _propertyRe = /*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
    const _trackRe = new RegExp(''
        + '^'
        + _directoryRe
        + _nodeRe
        + _objectRe
        + _propertyRe
        + '$'
    );
    const _supportedObjectNames = ['material', 'materials', 'bones', 'map'];
    class Composite {
        constructor(targetGroup, path, optionalParsedPath) {
            const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
            this._targetGroup = targetGroup;
            this._bindings = targetGroup.subscribe_(path, parsedPath);
        }
        getValue(array, offset) {
            this.bind(); // bind all binding
            const firstValidIndex = this._targetGroup.nCachedObjects_,
                binding = this._bindings[firstValidIndex];
            // and only call .getValue on the first
            if (binding !== undefined) binding.getValue(array, offset);
        }
        setValue(array, offset) {
            const bindings = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].setValue(array, offset);
            }
        }
        bind() {
            const bindings = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].bind();
            }
        }
        unbind() {
            const bindings = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].unbind();
            }
        }
    }
    // Note: This class uses a State pattern on a per-method basis:
    // 'bind' sets 'this.getValue' / 'setValue' and shadows the
    // prototype version of these methods with one that represents
    // the bound state. When the property is not found, the methods
    // become no-ops.

    class PropertyBinding {
        constructor(rootNode, path, parsedPath) {
            this.path = path;
            this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
            this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
            this.rootNode = rootNode;
            // initial state of these methods that calls 'bind'
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound;
        }

        static create(root, path, parsedPath) {
            if (!(root && root.isAnimationObjectGroup)) {
                return new PropertyBinding(root, path, parsedPath);
            } else {
                return new PropertyBinding.Composite(root, path, parsedPath);
            }
        }
        static sanitizeNodeName(name) {
            return name.replace(/\s/g, '_').replace(_reservedRe, '');
        }
        static parseTrackName(trackName) {
            const matches = _trackRe.exec(trackName);
            if (matches === null) {
                throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
            }
            const results = {
                // directoryName: matches[ 1 ], // (tschw) currently unused
                nodeName: matches[2],
                objectName: matches[3],
                objectIndex: matches[4],
                propertyName: matches[5], // required
                propertyIndex: matches[6]
            };
            const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
            if (lastDot !== undefined && lastDot !== -1) {
                const objectName = results.nodeName.substring(lastDot + 1);
                // Object names must be checked against an allowlist. Otherwise, there
                // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
                // 'bar' could be the objectName, or part of a nodeName (which can
                // include '.' characters).
                if (_supportedObjectNames.indexOf(objectName) !== -1) {
                    results.nodeName = results.nodeName.substring(0, lastDot);
                    results.objectName = objectName;
                }
            }
            if (results.propertyName === null || results.propertyName.length === 0) {
                throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
            }
            return results;
        }
        static findNode(root, nodeName) {
            if (nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
                return root;
            }
            // search into skeleton bones.
            if (root.skeleton) {
                const bone = root.skeleton.getBoneByName(nodeName);
                if (bone !== undefined) {
                    return bone;
                }
            }
            // search into node subtree.
            if (root.children) {
                const searchNodeSubtree = function (children) {
                    for (let i = 0; i < children.length; i++) {
                        const childNode = children[i];
                        if (childNode.name === nodeName || childNode.uuid === nodeName) {
                            return childNode;
                        }
                        const result = searchNodeSubtree(childNode.children);
                        if (result) return result;
                    }
                    return null;
                };
                const subTreeNode = searchNodeSubtree(root.children);
                if (subTreeNode) {
                    return subTreeNode;
                }
            }
            return null;
        }
        // these are used to "bind" a nonexistent property
        _getValue_unavailable() { }
        _setValue_unavailable() { }
        // Getters
        _getValue_direct(buffer, offset) {
            buffer[offset] = this.targetObject[this.propertyName];
        }
        _getValue_array(buffer, offset) {
            const source = this.resolvedProperty;
            for (let i = 0, n = source.length; i !== n; ++i) {
                buffer[offset++] = source[i];
            }
        }
        _getValue_arrayElement(buffer, offset) {
            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(buffer, offset) {
            this.resolvedProperty.toArray(buffer, offset);
        }
        // Direct
        _setValue_direct(buffer, offset) {
            this.targetObject[this.propertyName] = buffer[offset];
        }
        _setValue_direct_setNeedsUpdate(buffer, offset) {
            this.targetObject[this.propertyName] = buffer[offset];
            this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
            this.targetObject[this.propertyName] = buffer[offset];
            this.targetObject.matrixWorldNeedsUpdate = true;
        }
        // EntireArray
        _setValue_array(buffer, offset) {
            const dest = this.resolvedProperty;
            for (let i = 0, n = dest.length; i !== n; ++i) {
                dest[i] = buffer[offset++];
            }
        }
        _setValue_array_setNeedsUpdate(buffer, offset) {
            const dest = this.resolvedProperty;
            for (let i = 0, n = dest.length; i !== n; ++i) {
                dest[i] = buffer[offset++];
            }
            this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
            const dest = this.resolvedProperty;
            for (let i = 0, n = dest.length; i !== n; ++i) {
                dest[i] = buffer[offset++];
            }
            this.targetObject.matrixWorldNeedsUpdate = true;
        }
        // ArrayElement
        _setValue_arrayElement(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
        }
        _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
            this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
            this.targetObject.matrixWorldNeedsUpdate = true;
        }
        // HasToFromArray
        _setValue_fromArray(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
        }
        _setValue_fromArray_setNeedsUpdate(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
            this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
            this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(targetArray, offset) {
            this.bind();
            this.getValue(targetArray, offset);
        }
        _setValue_unbound(sourceArray, offset) {
            this.bind();
            this.setValue(sourceArray, offset);
        }
        bind() {
            let targetObject = this.node;
            const parsedPath = this.parsedPath;
            const objectName = parsedPath.objectName;
            const propertyName = parsedPath.propertyName;
            let propertyIndex = parsedPath.propertyIndex;
            if (!targetObject) {
                targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
                this.node = targetObject;
            }
            // set fail state so we can just 'return' on error
            this.getValue = this._getValue_unavailable;
            this.setValue = this._setValue_unavailable;
            // ensure there is a value node
            if (!targetObject) {
                console.warn('THREE.PropertyBinding: No target node found for track: ' + this.path + '.');
                return;
            }
            if (objectName) {
                let objectIndex = parsedPath.objectIndex;
                // special cases were we need to reach deeper into the hierarchy to get the face materials....
                switch (objectName) {
                    case 'materials':
                        if (!targetObject.material) {
                            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                            return;
                        }
                        if (!targetObject.material.materials) {
                            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                            return;
                        }
                        targetObject = targetObject.material.materials;
                        break;
                    case 'bones':
                        if (!targetObject.skeleton) {
                            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                            return;
                        }
                        // potential future optimization: skip this if propertyIndex is already an integer
                        // and convert the integer string to a true integer.
                        targetObject = targetObject.skeleton.bones;
                        // support resolving morphTarget names into indices.
                        for (let i = 0; i < targetObject.length; i++) {
                            if (targetObject[i].name === objectIndex) {
                                objectIndex = i;
                                break;
                            }
                        }
                        break;
                    case 'map':
                        if ('map' in targetObject) {
                            targetObject = targetObject.map;
                            break;
                        }
                        if (!targetObject.material) {
                            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                            return;
                        }
                        if (!targetObject.material.map) {
                            console.error('THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this);
                            return;
                        }
                        targetObject = targetObject.material.map;
                        break;
                    default:
                        if (targetObject[objectName] === undefined) {
                            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                            return;
                        }
                        targetObject = targetObject[objectName];
                }

                if (objectIndex !== undefined) {
                    if (targetObject[objectIndex] === undefined) {
                        console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                        return;
                    }
                    targetObject = targetObject[objectIndex];
                }
            }
            // resolve property
            const nodeProperty = targetObject[propertyName];
            if (nodeProperty === undefined) {
                const nodeName = parsedPath.nodeName;
                console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
                    '.' + propertyName + ' but it wasn\'t found.', targetObject);
                return;
            }
            // determine versioning scheme
            let versioning = this.Versioning.None;
            this.targetObject = targetObject;
            if (targetObject.isMaterial === true) {
                versioning = this.Versioning.NeedsUpdate;
            } else if (targetObject.isObject3D === true) {
                versioning = this.Versioning.MatrixWorldNeedsUpdate;
            }
            // determine how the property gets bound
            let bindingType = this.BindingType.Direct;
            if (propertyIndex !== undefined) {
                // access a sub element of the property array (only primitives are supported right now)
                if (propertyName === 'morphTargetInfluences') {
                    // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                    // support resolving morphTarget names into indices.
                    if (!targetObject.geometry) {
                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                        return;
                    }
                    if (!targetObject.geometry.morphAttributes) {
                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                        return;
                    }
                    if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
                        propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                    }
                }
                bindingType = this.BindingType.ArrayElement;
                this.resolvedProperty = nodeProperty;
                this.propertyIndex = propertyIndex;
            } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
                // must use copy for Object3D.Euler/Quaternion
                bindingType = this.BindingType.HasFromToArray;
                this.resolvedProperty = nodeProperty;
            } else if (Array.isArray(nodeProperty)) {
                bindingType = this.BindingType.EntireArray;
                this.resolvedProperty = nodeProperty;
            } else {
                this.propertyName = propertyName;
            }
            // select getter / setter
            this.getValue = this.GetterByBindingType[bindingType];
            this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        }
        unbind() {
            this.node = null;
            // back to the prototype version of getValue / setValue
            // note: avoiding to mutate the shape of 'this' via 'delete'
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound;
        }
    }
    PropertyBinding.Composite = Composite;
    PropertyBinding.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    };
    PropertyBinding.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    };
    PropertyBinding.prototype.GetterByBindingType = [
        PropertyBinding.prototype._getValue_direct,
        PropertyBinding.prototype._getValue_array,
        PropertyBinding.prototype._getValue_arrayElement,
        PropertyBinding.prototype._getValue_toArray,
    ];
    PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
        [
            // Direct
            PropertyBinding.prototype._setValue_direct,
            PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
            PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
        ], [
            // EntireArray
            PropertyBinding.prototype._setValue_array,
            PropertyBinding.prototype._setValue_array_setNeedsUpdate,
            PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,
        ], [
            // ArrayElement
            PropertyBinding.prototype._setValue_arrayElement,
            PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
            PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ], [
            // HasToFromArray
            PropertyBinding.prototype._setValue_fromArray,
            PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
            PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
        ]
    ];
    class AnimationObjectGroup {
        constructor() {
            this.isAnimationObjectGroup = true;
            this.uuid = generateUUID();
            // cached objects followed by the active ones
            this._objects = Array.prototype.slice.call(arguments);
            this.nCachedObjects_ = 0; // threshold
            // note: read by PropertyBinding.Composite
            const indices = {};
            this._indicesByUUID = indices; // for bookkeeping
            for (let i = 0, n = arguments.length; i !== n; ++i) {
                indices[arguments[i].uuid] = i;
            }
            this._paths = []; // inside: string
            this._parsedPaths = []; // inside: { we don't care, here }
            this._bindings = []; // inside: Array< PropertyBinding >
            this._bindingsIndicesByPath = {}; // inside: indices in these arrays
            const scope = this;
            this.stats = {
                objects: {
                    get total() {
                        return scope._objects.length;
                    },
                    get inUse() {
                        return this.total - scope.nCachedObjects_;
                    }
                },
                get bindingsPerObject() {
                    return scope._bindings.length;
                }
            };
        }
        add() {
            const objects = this._objects,
                indicesByUUID = this._indicesByUUID,
                paths = this._paths,
                parsedPaths = this._parsedPaths,
                bindings = this._bindings,
                nBindings = bindings.length;
            let knownObject = undefined,
                nObjects = objects.length,
                nCachedObjects = this.nCachedObjects_;
            for (let i = 0, n = arguments.length; i !== n; ++i) {
                const object = arguments[i],
                    uuid = object.uuid;
                let index = indicesByUUID[uuid];
                if (index === undefined) {
                    // unknown object -> add it to the ACTIVE region
                    index = nObjects++;
                    indicesByUUID[uuid] = index;
                    objects.push(object);
                    // accounting is done, now do the same for all bindings
                    for (let j = 0, m = nBindings; j !== m; ++j) {
                        bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                    }
                } else if (index < nCachedObjects) {
                    knownObject = objects[index];
                    // move existing object to the ACTIVE region
                    const firstActiveIndex = --nCachedObjects,
                        lastCachedObject = objects[firstActiveIndex];
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    indicesByUUID[uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = object;
                    // accounting is done, now do the same for all bindings
                    for (let j = 0, m = nBindings; j !== m; ++j) {
                        const bindingsForPath = bindings[j],
                            lastCached = bindingsForPath[firstActiveIndex];
                        let binding = bindingsForPath[index];
                        bindingsForPath[index] = lastCached;
                        if (binding === undefined) {
                            // since we do not bother to create new bindings
                            // for objects that are cached, the binding may
                            // or may not exist
                            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                        }
                        bindingsForPath[firstActiveIndex] = binding;
                    }
                } else if (objects[index] !== knownObject) {
                    console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' +
                        'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
                } // else the object is already where we want it to be
            } // for arguments
            this.nCachedObjects_ = nCachedObjects;
        }
        remove() {
            const objects = this._objects,
                indicesByUUID = this._indicesByUUID,
                bindings = this._bindings,
                nBindings = bindings.length;
            let nCachedObjects = this.nCachedObjects_;
            for (let i = 0, n = arguments.length; i !== n; ++i) {
                const object = arguments[i],
                    uuid = object.uuid,
                    index = indicesByUUID[uuid];
                if (index !== undefined && index >= nCachedObjects) {
                    // move existing object into the CACHED region
                    const lastCachedIndex = nCachedObjects++,
                        firstActiveObject = objects[lastCachedIndex];
                    indicesByUUID[firstActiveObject.uuid] = index;
                    objects[index] = firstActiveObject;
                    indicesByUUID[uuid] = lastCachedIndex;
                    objects[lastCachedIndex] = object;
                    // accounting is done, now do the same for all bindings
                    for (let j = 0, m = nBindings; j !== m; ++j) {
                        const bindingsForPath = bindings[j],
                            firstActive = bindingsForPath[lastCachedIndex],
                            binding = bindingsForPath[index];
                        bindingsForPath[index] = firstActive;
                        bindingsForPath[lastCachedIndex] = binding;
                    }
                }
            } // for arguments
            this.nCachedObjects_ = nCachedObjects;
        }
        uncache() {
            const objects = this._objects,
                indicesByUUID = this._indicesByUUID,
                bindings = this._bindings,
                nBindings = bindings.length;
            let nCachedObjects = this.nCachedObjects_,
                nObjects = objects.length;
            for (let i = 0, n = arguments.length; i !== n; ++i) {
                const object = arguments[i],
                    uuid = object.uuid,
                    index = indicesByUUID[uuid];
                if (index !== undefined) {
                    delete indicesByUUID[uuid];
                    if (index < nCachedObjects) {
                        // object is cached, shrink the CACHED region
                        const firstActiveIndex = --nCachedObjects,
                            lastCachedObject = objects[firstActiveIndex],
                            lastIndex = --nObjects,
                            lastObject = objects[lastIndex];
                        // last cached object takes this object's place
                        indicesByUUID[lastCachedObject.uuid] = index;
                        objects[index] = lastCachedObject;
                        // last object goes to the activated slot and pop
                        indicesByUUID[lastObject.uuid] = firstActiveIndex;
                        objects[firstActiveIndex] = lastObject;
                        objects.pop();
                        // accounting is done, now do the same for all bindings
                        for (let j = 0, m = nBindings; j !== m; ++j) {
                            const bindingsForPath = bindings[j],
                                lastCached = bindingsForPath[firstActiveIndex],
                                last = bindingsForPath[lastIndex];
                            bindingsForPath[index] = lastCached;
                            bindingsForPath[firstActiveIndex] = last;
                            bindingsForPath.pop();
                        }
                    } else {
                        // object is active, just swap with the last and pop
                        const lastIndex = --nObjects,
                            lastObject = objects[lastIndex];
                        if (lastIndex > 0) {
                            indicesByUUID[lastObject.uuid] = index;
                        }
                        objects[index] = lastObject;
                        objects.pop();
                        // accounting is done, now do the same for all bindings
                        for (let j = 0, m = nBindings; j !== m; ++j) {
                            const bindingsForPath = bindings[j];
                            bindingsForPath[index] = bindingsForPath[lastIndex];
                            bindingsForPath.pop();
                        }
                    } // cached or active
                } // if object is known
            } // for arguments
            this.nCachedObjects_ = nCachedObjects;
        }
        // Internal interface used by befriended PropertyBinding.Composite:
        subscribe_(path, parsedPath) {
            // returns an array of bindings for the given path that is changed
            // according to the contained objects in the group
            const indicesByPath = this._bindingsIndicesByPath;
            let index = indicesByPath[path];
            const bindings = this._bindings;
            if (index !== undefined) return bindings[index];
            const paths = this._paths,
                parsedPaths = this._parsedPaths,
                objects = this._objects,
                nObjects = objects.length,
                nCachedObjects = this.nCachedObjects_,
                bindingsForPath = new Array(nObjects);
            index = bindings.length;
            indicesByPath[path] = index;
            paths.push(path);
            parsedPaths.push(parsedPath);
            bindings.push(bindingsForPath);
            for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
                const object = objects[i];
                bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
            }
            return bindingsForPath;
        }
        unsubscribe_(path) {
            // tells the group to forget about a property path and no longer
            // update the array previously obtained with 'subscribe_'
            const indicesByPath = this._bindingsIndicesByPath,
                index = indicesByPath[path];
            if (index !== undefined) {
                const paths = this._paths,
                    parsedPaths = this._parsedPaths,
                    bindings = this._bindings,
                    lastBindingsIndex = bindings.length - 1,
                    lastBindings = bindings[lastBindingsIndex],
                    lastBindingsPath = path[lastBindingsIndex];
                indicesByPath[lastBindingsPath] = index;
                bindings[index] = lastBindings;
                bindings.pop();
                parsedPaths[index] = parsedPaths[lastBindingsIndex];
                parsedPaths.pop();
                paths[index] = paths[lastBindingsIndex];
                paths.pop();
            }
        }
    }
    class AnimationAction {
        constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
            this._mixer = mixer;
            this._clip = clip;
            this._localRoot = localRoot;
            this.blendMode = blendMode;
            const tracks = clip.tracks,
                nTracks = tracks.length,
                interpolants = new Array(nTracks);
            const interpolantSettings = {
                endingStart: ZeroCurvatureEnding,
                endingEnd: ZeroCurvatureEnding
            };
            for (let i = 0; i !== nTracks; ++i) {
                const interpolant = tracks[i].createInterpolant(null);
                interpolants[i] = interpolant;
                interpolant.settings = interpolantSettings;
            }
            this._interpolantSettings = interpolantSettings;
            this._interpolants = interpolants; // bound by the mixer
            // inside: PropertyMixer (managed by the mixer)
            this._propertyBindings = new Array(nTracks);
            this._cacheIndex = null; // for the memory manager
            this._byClipCacheIndex = null; // for the memory manager
            this._timeScaleInterpolant = null;
            this._weightInterpolant = null;
            this.loop = LoopRepeat;
            this._loopCount = -1;
            // global mixer time when the action is to be started
            // it's set back to 'null' upon start of the action
            this._startTime = null;
            this.time = 0;
            this.timeScale = 1;
            this._effectiveTimeScale = 1;
            this.weight = 1;
            this._effectiveWeight = 1;
            this.repetitions = Infinity;
            this.paused = false;
            this.enabled = true;
            this.clampWhenFinished = false;
            this.zeroSlopeAtStart = true;
            this.zeroSlopeAtEnd = true;
        }
        play() {
            this._mixer._activateAction(this);
            return this;
        }
        stop() {
            this._mixer._deactivateAction(this);
            return this.reset();
        }
        reset() {
            this.paused = false;
            this.enabled = true;
            this.time = 0; // restart clip
            this._loopCount = -1;// forget previous loops
            this._startTime = null;// forget scheduling
            return this.stopFading().stopWarping();
        }
        isRunning() {
            return this.enabled && !this.paused && this.timeScale !== 0 &&
                this._startTime === null && this._mixer._isActiveAction(this);
        }
        isScheduled() {
            return this._mixer._isActiveAction(this);
        }
        startAt(time) {
            this._startTime = time;
            return this;
        }
        setLoop(mode, repetitions) {
            this.loop = mode;
            this.repetitions = repetitions;
            return this;
        }
        setEffectiveWeight(weight) {
            this.weight = weight;
            // note: same logic as when updated at runtime
            this._effectiveWeight = this.enabled ? weight : 0;
            return this.stopFading();
        }
        getEffectiveWeight() {
            return this._effectiveWeight;
        }
        fadeIn(duration) {
            return this._scheduleFading(duration, 0, 1);
        }
        fadeOut(duration) {
            return this._scheduleFading(duration, 1, 0);
        }
        crossFadeFrom(fadeOutAction, duration, warp = false) {
            fadeOutAction.fadeOut(duration);
            this.fadeIn(duration);
            if (warp === true) {
                const fadeInDuration = this._clip.duration,
                    fadeOutDuration = fadeOutAction._clip.duration,
                    startEndRatio = fadeOutDuration / fadeInDuration,
                    endStartRatio = fadeInDuration / fadeOutDuration;
                fadeOutAction.warp(1.0, startEndRatio, duration);
                this.warp(endStartRatio, 1.0, duration);
            }
            return this;
        }
        crossFadeTo(fadeInAction, duration, warp = false) {
            return fadeInAction.crossFadeFrom(this, duration, warp);
        }
        stopFading() {
            const weightInterpolant = this._weightInterpolant;
            if (weightInterpolant !== null) {
                this._weightInterpolant = null;
                this._mixer._takeBackControlInterpolant(weightInterpolant);
            }
            return this;
        }
        setEffectiveTimeScale(timeScale) {
            this.timeScale = timeScale;
            this._effectiveTimeScale = this.paused ? 0 : timeScale;
            return this.stopWarping();
        }
        getEffectiveTimeScale() {
            return this._effectiveTimeScale;
        }
        setDuration(duration) {
            this.timeScale = this._clip.duration / duration;
            return this.stopWarping();
        }
        syncWith(action) {
            this.time = action.time;
            this.timeScale = action.timeScale;
            return this.stopWarping();
        }
        halt(duration) {
            return this.warp(this._effectiveTimeScale, 0, duration);
        }
        warp(startTimeScale, endTimeScale, duration) {
            const mixer = this._mixer,
                now = mixer.time,
                timeScale = this.timeScale;
            let interpolant = this._timeScaleInterpolant;
            if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant();
                this._timeScaleInterpolant = interpolant;
            }
            const times = interpolant.parameterPositions,
                values = interpolant.sampleValues;
            times[0] = now;
            times[1] = now + duration;
            values[0] = startTimeScale / timeScale;
            values[1] = endTimeScale / timeScale;
            return this;
        }
        stopWarping() {
            const timeScaleInterpolant = this._timeScaleInterpolant;
            if (timeScaleInterpolant !== null) {
                this._timeScaleInterpolant = null;
                this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
            }
            return this;
        }
        getMixer() {
            return this._mixer;
        }
        getClip() {
            return this._clip;
        }
        getRoot() {
            return this._localRoot || this._mixer._root;
        }
        // Interna
        _update(time, deltaTime, timeDirection, accuIndex) {
            // called by the mixer
            if (!this.enabled) {
                // call ._updateWeight() to update ._effectiveWeight
                this._updateWeight(time);
                return;
            }
            const startTime = this._startTime;
            if (startTime !== null) {
                // check for scheduled start of action
                const timeRunning = (time - startTime) * timeDirection;
                if (timeRunning < 0 || timeDirection === 0) {
                    deltaTime = 0;
                } else {

                    this._startTime = null; // unschedule
                    deltaTime = timeDirection * timeRunning;
                }
            }
            // apply time scale and advance time
            deltaTime *= this._updateTimeScale(time);
            const clipTime = this._updateTime(deltaTime);
            // note: _updateTime may disable the action resulting in
            // an effective weight of 0
            const weight = this._updateWeight(time);
            if (weight > 0) {
                const interpolants = this._interpolants;
                const propertyMixers = this._propertyBindings;
                switch (this.blendMode) {
                    case AdditiveAnimationBlendMode:
                        for (let j = 0, m = interpolants.length; j !== m; ++j) {
                            interpolants[j].evaluate(clipTime);
                            propertyMixers[j].accumulateAdditive(weight);
                        }
                        break;
                    case NormalAnimationBlendMode:
                    default:
                        for (let j = 0, m = interpolants.length; j !== m; ++j) {
                            interpolants[j].evaluate(clipTime);
                            propertyMixers[j].accumulate(accuIndex, weight);
                        }
                }
            }
        }
        _updateWeight(time) {
            let weight = 0;
            if (this.enabled) {
                weight = this.weight;
                const interpolant = this._weightInterpolant;
                if (interpolant !== null) {
                    const interpolantValue = interpolant.evaluate(time)[0];
                    weight *= interpolantValue;
                    if (time > interpolant.parameterPositions[1]) {
                        this.stopFading();
                        if (interpolantValue === 0) {
                            // faded out, disable
                            this.enabled = false;
                        }
                    }
                }
            }
            this._effectiveWeight = weight;
            return weight;
        }
        _updateTimeScale(time) {
            let timeScale = 0;
            if (!this.paused) {
                timeScale = this.timeScale;
                const interpolant = this._timeScaleInterpolant;
                if (interpolant !== null) {
                    const interpolantValue = interpolant.evaluate(time)[0];
                    timeScale *= interpolantValue;
                    if (time > interpolant.parameterPositions[1]) {
                        this.stopWarping();
                        if (timeScale === 0) {
                            // motion has halted, pause
                            this.paused = true;
                        } else {
                            // warp done - apply final time scale
                            this.timeScale = timeScale;
                        }
                    }
                }
            }
            this._effectiveTimeScale = timeScale;
            return timeScale;
        }
        _updateTime(deltaTime) {
            const duration = this._clip.duration;
            const loop = this.loop;
            let time = this.time + deltaTime;
            let loopCount = this._loopCount;
            const pingPong = (loop === LoopPingPong);
            if (deltaTime === 0) {
                if (loopCount === -1) return time;
                return (pingPong && (loopCount & 1) === 1) ? duration - time : time;
            }
            if (loop === LoopOnce) {
                if (loopCount === -1) {
                    // just started
                    this._loopCount = 0;
                    this._setEndings(true, true, false);
                }
                handle_stop: {
                    if (time >= duration) {
                        time = duration;
                    } else if (time < 0) {
                        time = 0;
                    } else {
                        this.time = time;
                        break handle_stop;
                    }
                    if (this.clampWhenFinished) this.paused = true;
                    else this.enabled = false;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: 'finished', action: this,
                        direction: deltaTime < 0 ? -1 : 1
                    });
                }
            } else { // repetitive Repeat or PingPong
                if (loopCount === -1) {
                    // just started
                    if (deltaTime >= 0) {
                        loopCount = 0;
                        this._setEndings(true, this.repetitions === 0, pingPong);
                    } else {
                        // when looping in reverse direction, the initial
                        // transition through zero counts as a repetition,
                        // so leave loopCount at -1
                        this._setEndings(this.repetitions === 0, true, pingPong);
                    }
                }
                if (time >= duration || time < 0) {
                    // wrap around
                    const loopDelta = Math.floor(time / duration); // signed
                    time -= duration * loopDelta;
                    loopCount += Math.abs(loopDelta);
                    const pending = this.repetitions - loopCount;
                    if (pending <= 0) {
                        // have to stop (switch state, clamp time, fire event)
                        if (this.clampWhenFinished) this.paused = true;
                        else this.enabled = false;
                        time = deltaTime > 0 ? duration : 0;
                        this.time = time;
                        this._mixer.dispatchEvent({
                            type: 'finished', action: this,
                            direction: deltaTime > 0 ? 1 : -1
                        });
                    } else {
                        // keep running
                        if (pending === 1) {
                            // entering the last round
                            const atStart = deltaTime < 0;
                            this._setEndings(atStart, !atStart, pingPong);
                        } else {
                            this._setEndings(false, false, pingPong);
                        }
                        this._loopCount = loopCount;
                        this.time = time;
                        this._mixer.dispatchEvent({
                            type: 'loop', action: this, loopDelta: loopDelta
                        });
                    }
                } else {
                    this.time = time;
                }
                if (pingPong && (loopCount & 1) === 1) {
                    // invert time for the "pong round"
                    return duration - time;
                }
            }
            return time;
        }
        _setEndings(atStart, atEnd, pingPong) {
            const settings = this._interpolantSettings;
            if (pingPong) {
                settings.endingStart = ZeroSlopeEnding;
                settings.endingEnd = ZeroSlopeEnding;
            } else {
                // assuming for LoopOnce atStart == atEnd == true
                if (atStart) {
                    settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
                } else {
                    settings.endingStart = WrapAroundEnding;
                }
                if (atEnd) {
                    settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
                } else {
                    settings.endingEnd = WrapAroundEnding;
                }
            }
        }
        _scheduleFading(duration, weightNow, weightThen) {
            const mixer = this._mixer, now = mixer.time;
            let interpolant = this._weightInterpolant;
            if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant();
                this._weightInterpolant = interpolant;
            }
            const times = interpolant.parameterPositions,
                values = interpolant.sampleValues;
            times[0] = now;
            values[0] = weightNow;
            times[1] = now + duration;
            values[1] = weightThen;
            return this;
        }
    }
    const _controlInterpolantsResultBuffer = new Float32Array(1);
    class AnimationMixer extends EventDispatcher {
        constructor(root) {
            super();
            this._root = root;
            this._initMemoryManager();
            this._accuIndex = 0;
            this.time = 0;
            this.timeScale = 1.0;
        }
        _bindAction(action, prototypeAction) {
            const root = action._localRoot || this._root,
                tracks = action._clip.tracks,
                nTracks = tracks.length,
                bindings = action._propertyBindings,
                interpolants = action._interpolants,
                rootUuid = root.uuid,
                bindingsByRoot = this._bindingsByRootAndName;
            let bindingsByName = bindingsByRoot[rootUuid];
            if (bindingsByName === undefined) {
                bindingsByName = {};
                bindingsByRoot[rootUuid] = bindingsByName;
            }
            for (let i = 0; i !== nTracks; ++i) {
                const track = tracks[i],
                    trackName = track.name;
                let binding = bindingsByName[trackName];
                if (binding !== undefined) {
                    ++binding.referenceCount;
                    bindings[i] = binding;
                } else {
                    binding = bindings[i];
                    if (binding !== undefined) {
                        // existing binding, make sure the cache knows
                        if (binding._cacheIndex === null) {
                            ++binding.referenceCount;
                            this._addInactiveBinding(binding, rootUuid, trackName);
                        }
                        continue;
                    }
                    const path = prototypeAction && prototypeAction.
                        _propertyBindings[i].binding.parsedPath;
                    binding = new PropertyMixer(
                        PropertyBinding.create(root, trackName, path),
                        track.ValueTypeName, track.getValueSize());
                    ++binding.referenceCount;
                    this._addInactiveBinding(binding, rootUuid, trackName);
                    bindings[i] = binding;
                }
                interpolants[i].resultBuffer = binding.buffer;
            }
        }
        _activateAction(action) {
            if (!this._isActiveAction(action)) {
                if (action._cacheIndex === null) {
                    // this action has been forgotten by the cache, but the user
                    // appears to be still using it -> rebind
                    const rootUuid = (action._localRoot || this._root).uuid,
                        clipUuid = action._clip.uuid,
                        actionsForClip = this._actionsByClip[clipUuid];
                    this._bindAction(action,
                        actionsForClip && actionsForClip.knownActions[0]);
                    this._addInactiveAction(action, clipUuid, rootUuid);
                }
                const bindings = action._propertyBindings;
                // increment reference counts / sort out state
                for (let i = 0, n = bindings.length; i !== n; ++i) {
                    const binding = bindings[i];
                    if (binding.useCount++ === 0) {
                        this._lendBinding(binding);
                        binding.saveOriginalState();
                    }
                }
                this._lendAction(action);
            }
        }
        _deactivateAction(action) {
            if (this._isActiveAction(action)) {
                const bindings = action._propertyBindings;
                // decrement reference counts / sort out state
                for (let i = 0, n = bindings.length; i !== n; ++i) {
                    const binding = bindings[i];
                    if (--binding.useCount === 0) {
                        binding.restoreOriginalState();
                        this._takeBackBinding(binding);
                    }
                }
                this._takeBackAction(action);
            }
        }
        // Memory manager
        _initMemoryManager() {
            this._actions = []; // 'nActiveActions' followed by inactive ones
            this._nActiveActions = 0;
            this._actionsByClip = {};
            // inside:
            // {
            // 	knownActions: Array< AnimationAction > - used as prototypes
            // 	actionByRoot: AnimationAction - lookup
            // }

            this._bindings = []; // 'nActiveBindings' followed by inactive ones
            this._nActiveBindings = 0;
            this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

            this._controlInterpolants = []; // same game as above
            this._nActiveControlInterpolants = 0;
            const scope = this;
            this.stats = {
                actions: {
                    get total() {
                        return scope._actions.length;
                    },
                    get inUse() {
                        return scope._nActiveActions;
                    }
                },
                bindings: {
                    get total() {
                        return scope._bindings.length;
                    },
                    get inUse() {
                        return scope._nActiveBindings;
                    }
                },
                controlInterpolants: {
                    get total() {
                        return scope._controlInterpolants.length;
                    },
                    get inUse() {
                        return scope._nActiveControlInterpolants;
                    }
                }
            };
        }
        // Memory management for AnimationAction objects
        _isActiveAction(action) {
            const index = action._cacheIndex;
            return index !== null && index < this._nActiveActions;
        }
        _addInactiveAction(action, clipUuid, rootUuid) {
            const actions = this._actions,
                actionsByClip = this._actionsByClip;
            let actionsForClip = actionsByClip[clipUuid];
            if (actionsForClip === undefined) {
                actionsForClip = {
                    knownActions: [action],
                    actionByRoot: {}
                };
                action._byClipCacheIndex = 0;
                actionsByClip[clipUuid] = actionsForClip;
            } else {
                const knownActions = actionsForClip.knownActions;
                action._byClipCacheIndex = knownActions.length;
                knownActions.push(action);
            }
            action._cacheIndex = actions.length;
            actions.push(action);
            actionsForClip.actionByRoot[rootUuid] = action;
        }
        _removeInactiveAction(action) {
            const actions = this._actions,
                lastInactiveAction = actions[actions.length - 1],
                cacheIndex = action._cacheIndex;
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();
            action._cacheIndex = null;

            const clipUuid = action._clip.uuid,
                actionsByClip = this._actionsByClip,
                actionsForClip = actionsByClip[clipUuid],
                knownActionsForClip = actionsForClip.knownActions,
                lastKnownAction =
                    knownActionsForClip[knownActionsForClip.length - 1],
                byClipCacheIndex = action._byClipCacheIndex;
            lastKnownAction._byClipCacheIndex = byClipCacheIndex;
            knownActionsForClip[byClipCacheIndex] = lastKnownAction;
            knownActionsForClip.pop();
            action._byClipCacheIndex = null;

            const actionByRoot = actionsForClip.actionByRoot,
                rootUuid = (action._localRoot || this._root).uuid;
            delete actionByRoot[rootUuid];
            if (knownActionsForClip.length === 0) {
                delete actionsByClip[clipUuid];
            }
            this._removeInactiveBindingsForAction(action);
        }
        _removeInactiveBindingsForAction(action) {
            const bindings = action._propertyBindings;
            for (let i = 0, n = bindings.length; i !== n; ++i) {
                const binding = bindings[i];
                if (--binding.referenceCount === 0) {
                    this._removeInactiveBinding(binding);
                }
            }
        }
        _lendAction(action) {
            // [ active actions |  inactive actions  ]
            // [  active actions >| inactive actions ]
            //                 s        a
            //                  <-swap->
            //                 a        s
            const actions = this._actions,
                prevIndex = action._cacheIndex,
                lastActiveIndex = this._nActiveActions++,
                firstInactiveAction = actions[lastActiveIndex];
            action._cacheIndex = lastActiveIndex;
            actions[lastActiveIndex] = action;
            firstInactiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = firstInactiveAction;
        }
        _takeBackAction(action) {
            // [  active actions  | inactive actions ]
            // [ active actions |< inactive actions  ]
            //        a        s
            //         <-swap->
            //        s        a
            const actions = this._actions,
                prevIndex = action._cacheIndex,
                firstInactiveIndex = --this._nActiveActions,
                lastActiveAction = actions[firstInactiveIndex];
            action._cacheIndex = firstInactiveIndex;
            actions[firstInactiveIndex] = action;
            lastActiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = lastActiveAction;
        }
        // Memory management for PropertyMixer objects
        _addInactiveBinding(binding, rootUuid, trackName) {
            const bindingsByRoot = this._bindingsByRootAndName,
                bindings = this._bindings;
            let bindingByName = bindingsByRoot[rootUuid];
            if (bindingByName === undefined) {
                bindingByName = {};
                bindingsByRoot[rootUuid] = bindingByName;
            }
            bindingByName[trackName] = binding;
            binding._cacheIndex = bindings.length;
            bindings.push(binding);
        }
        _removeInactiveBinding(binding) {
            const bindings = this._bindings,
                propBinding = binding.binding,
                rootUuid = propBinding.rootNode.uuid,
                trackName = propBinding.path,
                bindingsByRoot = this._bindingsByRootAndName,
                bindingByName = bindingsByRoot[rootUuid],
                lastInactiveBinding = bindings[bindings.length - 1],
                cacheIndex = binding._cacheIndex;
            lastInactiveBinding._cacheIndex = cacheIndex;
            bindings[cacheIndex] = lastInactiveBinding;
            bindings.pop();
            delete bindingByName[trackName];
            if (Object.keys(bindingByName).length === 0) {
                delete bindingsByRoot[rootUuid];
            }
        }
        _lendBinding(binding) {
            const bindings = this._bindings,
                prevIndex = binding._cacheIndex,
                lastActiveIndex = this._nActiveBindings++,
                firstInactiveBinding = bindings[lastActiveIndex];
            binding._cacheIndex = lastActiveIndex;
            bindings[lastActiveIndex] = binding;
            firstInactiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = firstInactiveBinding;
        }
        _takeBackBinding(binding) {
            const bindings = this._bindings,
                prevIndex = binding._cacheIndex,
                firstInactiveIndex = --this._nActiveBindings,
                lastActiveBinding = bindings[firstInactiveIndex];
            binding._cacheIndex = firstInactiveIndex;
            bindings[firstInactiveIndex] = binding;
            lastActiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = lastActiveBinding;
        }

        // Memory management of Interpolants for weight and time scale
        _lendControlInterpolant() {
            const interpolants = this._controlInterpolants,
                lastActiveIndex = this._nActiveControlInterpolants++;
            let interpolant = interpolants[lastActiveIndex];
            if (interpolant === undefined) {
                interpolant = new LinearInterpolant(
                    new Float32Array(2), new Float32Array(2),
                    1, _controlInterpolantsResultBuffer);
                interpolant.__cacheIndex = lastActiveIndex;
                interpolants[lastActiveIndex] = interpolant;
            }
            return interpolant;
        }
        _takeBackControlInterpolant(interpolant) {
            const interpolants = this._controlInterpolants,
                prevIndex = interpolant.__cacheIndex,
                firstInactiveIndex = --this._nActiveControlInterpolants,
                lastActiveInterpolant = interpolants[firstInactiveIndex];
            interpolant.__cacheIndex = firstInactiveIndex;
            interpolants[firstInactiveIndex] = interpolant;
            lastActiveInterpolant.__cacheIndex = prevIndex;
            interpolants[prevIndex] = lastActiveInterpolant;
        }
        clipAction(clip, optionalRoot, blendMode) {
            const root = optionalRoot || this._root,
                rootUuid = root.uuid;
            let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
            const clipUuid = clipObject !== null ? clipObject.uuid : clip;
            const actionsForClip = this._actionsByClip[clipUuid];
            let prototypeAction = null;
            if (blendMode === undefined) {
                if (clipObject !== null) {
                    blendMode = clipObject.blendMode;
                } else {
                    blendMode = NormalAnimationBlendMode;
                }
            }
            if (actionsForClip !== undefined) {
                const existingAction = actionsForClip.actionByRoot[rootUuid];
                if (existingAction !== undefined && existingAction.blendMode === blendMode) {
                    return existingAction;
                }
                // we know the clip, so we don't have to parse all
                // the bindings again but can just copy
                prototypeAction = actionsForClip.knownActions[0];
                // also, take the clip from the prototype action
                if (clipObject === null)
                    clipObject = prototypeAction._clip;
            }
            // clip must be known when specified via string
            if (clipObject === null) return null;
            // allocate all resources required to run it
            const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
            this._bindAction(newAction, prototypeAction);
            // and make the action known to the memory manager
            this._addInactiveAction(newAction, clipUuid, rootUuid);
            return newAction;
        }
        existingAction(clip, optionalRoot) {
            const root = optionalRoot || this._root,
                rootUuid = root.uuid,
                clipObject = typeof clip === 'string' ?
                    AnimationClip.findByName(root, clip) : clip,
                clipUuid = clipObject ? clipObject.uuid : clip,
                actionsForClip = this._actionsByClip[clipUuid];
            if (actionsForClip !== undefined) {
                return actionsForClip.actionByRoot[rootUuid] || null;
            }
            return null;
        }
        stopAllAction() {
            const actions = this._actions,
                nActions = this._nActiveActions;
            for (let i = nActions - 1; i >= 0; --i) {
                actions[i].stop();
            }
            return this;
        }
        update(deltaTime) {
            deltaTime *= this.timeScale;
            const actions = this._actions,
                nActions = this._nActiveActions,
                time = this.time += deltaTime,
                timeDirection = Math.sign(deltaTime),
                accuIndex = this._accuIndex ^= 1;
            // run active actions
            for (let i = 0; i !== nActions; ++i) {
                const action = actions[i];
                action._update(time, deltaTime, timeDirection, accuIndex);
            }
            // update scene graph
            const bindings = this._bindings,
                nBindings = this._nActiveBindings;
            for (let i = 0; i !== nBindings; ++i) {
                bindings[i].apply(accuIndex);
            }
            return this;
        }
        setTime(time) {
            this.time = 0; // Zero out time attribute for AnimationMixer object;
            for (let i = 0; i < this._actions.length; i++) {
                this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
            }
            return this.update(time); // Update used to set exact time. Returns "this" AnimationMixer object.
        }
        getRoot() {
            return this._root;
        }
        uncacheClip(clip) {
            const actions = this._actions,
                clipUuid = clip.uuid,
                actionsByClip = this._actionsByClip,
                actionsForClip = actionsByClip[clipUuid];
            if (actionsForClip !== undefined) {
                // note: just calling _removeInactiveAction would mess up the
                // iteration state and also require updating the state we can
                // just throw away
                const actionsToRemove = actionsForClip.knownActions;
                for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
                    const action = actionsToRemove[i];
                    this._deactivateAction(action);
                    const cacheIndex = action._cacheIndex,
                        lastInactiveAction = actions[actions.length - 1];
                    action._cacheIndex = null;
                    action._byClipCacheIndex = null;
                    lastInactiveAction._cacheIndex = cacheIndex;
                    actions[cacheIndex] = lastInactiveAction;
                    actions.pop();
                    this._removeInactiveBindingsForAction(action);
                }
                delete actionsByClip[clipUuid];
            }
        }
        uncacheRoot(root) {
            const rootUuid = root.uuid,
                actionsByClip = this._actionsByClip;
            for (const clipUuid in actionsByClip) {
                const actionByRoot = actionsByClip[clipUuid].actionByRoot,
                    action = actionByRoot[rootUuid];
                if (action !== undefined) {
                    this._deactivateAction(action);
                    this._removeInactiveAction(action);
                }
            }
            const bindingsByRoot = this._bindingsByRootAndName,
                bindingByName = bindingsByRoot[rootUuid];
            if (bindingByName !== undefined) {
                for (const trackName in bindingByName) {
                    const binding = bindingByName[trackName];
                    binding.restoreOriginalState();
                    this._removeInactiveBinding(binding);
                }
            }
        }
        uncacheAction(clip, optionalRoot) {
            const action = this.existingAction(clip, optionalRoot);
            if (action !== null) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
    }
    class RenderTarget3D extends RenderTarget {
        constructor(width = 1, height = 1, depth = 1, options = {}) {
            super(width, height, options);
            this.isRenderTarget3D = true;
            this.depth = depth;
            this.texture = new Data3DTexture(null, width, height, depth);
            this._setTextureOptions(options);
            this.texture.isRenderTargetTexture = true;
        }
    }
    class Uniform$1 {
        constructor(value) {
            this.value = value;
        }
        clone() {
            return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
        }
    }
    let _id$12 = 0;
    class UniformsGroup$1 extends EventDispatcher {
        constructor() {
            super();
            this.isUniformsGroup = true;
            Object.defineProperty(this, 'id', { value: _id$12++ });
            this.name = '';
            this.usage = StaticDrawUsage;
            this.uniforms = [];
        }
        add(uniform) {
            this.uniforms.push(uniform);
            return this;
        }
        remove(uniform) {
            const index = this.uniforms.indexOf(uniform);
            if (index !== -1) this.uniforms.splice(index, 1);
            return this;
        }
        setName(name) {
            this.name = name;
            return this;
        }
        setUsage(value) {
            this.usage = value;
            return this;
        }
        dispose() {
            this.dispatchEvent({ type: 'dispose' });
        }
        copy(source) {
            this.name = source.name;
            this.usage = source.usage;
            const uniformsSource = source.uniforms;
            this.uniforms.length = 0;
            for (let i = 0, l = uniformsSource.length; i < l; i++) {
                const uniforms = Array.isArray(uniformsSource[i]) ? uniformsSource[i] : [uniformsSource[i]];
                for (let j = 0; j < uniforms.length; j++) {
                    this.uniforms.push(uniforms[j].clone());
                }
            }
            return this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    class InstancedInterleavedBuffer extends InterleavedBuffer {
        constructor(array, stride, meshPerAttribute = 1) {
            super(array, stride);
            this.isInstancedInterleavedBuffer = true;
            this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
            super.copy(source);
            this.meshPerAttribute = source.meshPerAttribute;
            return this;
        }
        clone(data) {
            const ib = super.clone(data);
            ib.meshPerAttribute = this.meshPerAttribute;
            return ib;
        }
        toJSON(data) {
            const json = super.toJSON(data);
            json.isInstancedInterleavedBuffer = true;
            json.meshPerAttribute = this.meshPerAttribute;
            return json;
        }
    }
    class GLBufferAttribute {
        constructor(buffer, type, itemSize, elementSize, count, normalized = false) {
            this.isGLBufferAttribute = true;
            this.name = '';
            this.buffer = buffer;
            this.type = type;
            this.itemSize = itemSize;
            this.elementSize = elementSize;
            this.count = count;
            this.normalized = normalized;
            this.version = 0;
        }
        set needsUpdate(value) {
            if (value === true) this.version++;
        }
        setBuffer(buffer) {
            this.buffer = buffer;
            return this;
        }
        setType(type, elementSize) {
            this.type = type;
            this.elementSize = elementSize;
            return this;
        }
        setItemSize(itemSize) {
            this.itemSize = itemSize;
            return this;
        }
        setCount(count) {
            this.count = count;
            return this;
        }
    }
    const _matrix = /*@__PURE__*/ new Matrix4();
    class Raycaster {
        constructor(origin, direction, near = 0, far = Infinity) {
            this.ray = new Ray(origin, direction);
            this.near = near;
            this.far = far;
            this.camera = null;
            this.layers = new Layers();

            this.params = {
                Mesh: {},
                Line: { threshold: 1 },
                LOD: {},
                Points: { threshold: 1 },
                Sprite: {}
            };
        }
        set(origin, direction) {
            // direction is assumed to be normalized (for accurate distance calculations)
            this.ray.set(origin, direction);
        }
        setFromCamera(coords, camera) {
            if (camera.isPerspectiveCamera) {
                this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
                this.camera = camera;
            } else if (camera.isOrthographicCamera) {
                this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
                this.camera = camera;
            } else {
                console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
            }
        }
        setFromXRController(controller) {
            _matrix.identity().extractRotation(controller.matrixWorld);
            this.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix);
            return this;
        }

        intersectObject(object, recursive = true, intersects = []) {
            intersect(object, this, intersects, recursive);
            intersects.sort(ascSort);
            return intersects;
        }
        intersectObjects(objects, recursive = true, intersects = []) {
            for (let i = 0, l = objects.length; i < l; i++) {
                intersect(objects[i], this, intersects, recursive);
            }
            intersects.sort(ascSort);
            return intersects;
        }
    }
    function ascSort(a, b) {
        return a.distance - b.distance;
    }
    function intersect(object, raycaster, intersects, recursive) {
        let propagate = true;
        if (object.layers.test(raycaster.layers)) {
            const result = object.raycast(raycaster, intersects);
            if (result === false) propagate = false;
        }
        if (propagate === true && recursive === true) {
            const children = object.children;
            for (let i = 0, l = children.length; i < l; i++) {
                intersect(children[i], raycaster, intersects, true);
            }
        }
    }
    class Timer {
        constructor() {
            this._previousTime = 0;
            this._currentTime = 0;
            this._startTime = performance.now();
            this._delta = 0;
            this._elapsed = 0;
            this._timescale = 1;
            this._document = null;
            this._pageVisibilityHandler = null;
        }
        connect(document) {
            this._document = document;
            // use Page Visibility API to avoid large time delta values
            if (document.hidden !== undefined) {
                this._pageVisibilityHandler = handleVisibilityChange.bind(this);
                document.addEventListener('visibilitychange', this._pageVisibilityHandler, false);
            }
        }
        disconnect() {
            if (this._pageVisibilityHandler !== null) {
                this._document.removeEventListener('visibilitychange', this._pageVisibilityHandler);
                this._pageVisibilityHandler = null;
            }
            this._document = null;
        }
        getDelta() {
            return this._delta / 1000;
        }
        getElapsed() {
            return this._elapsed / 1000;
        }
        getTimescale() {
            return this._timescale;
        }
        setTimescale(timescale) {
            this._timescale = timescale;
            return this;
        }
        reset() {
            this._currentTime = performance.now() - this._startTime;
            return this;
        }
        dispose() {
            this.disconnect();
        }
        update(timestamp) {
            if (this._pageVisibilityHandler !== null && this._document.hidden === true) {
                this._delta = 0;
            } else {
                this._previousTime = this._currentTime;
                this._currentTime = (timestamp !== undefined ? timestamp : performance.now()) - this._startTime;
                this._delta = (this._currentTime - this._previousTime) * this._timescale;
                this._elapsed += this._delta; // _elapsed is the accumulation of all previous deltas
            }
            return this;
        }
    }
    function handleVisibilityChange() {
        if (this._document.hidden === false) this.reset();
    }
    class Spherical {
        constructor(radius = 1, phi = 0, theta = 0) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
        }
        set(radius, phi, theta) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
            return this;
        }
        copy(other) {
            this.radius = other.radius;
            this.phi = other.phi;
            this.theta = other.theta;
            return this;
        }
        makeSafe() {
            const EPS = 0.000001;
            this.phi = clamp$1(this.phi, EPS, Math.PI - EPS);
            return this;
        }
        setFromVector3(v) {
            return this.setFromCartesianCoords(v.x, v.y, v.z);
        }
        setFromCartesianCoords(x, y, z) {
            this.radius = Math.sqrt(x * x + y * y + z * z);
            if (this.radius === 0) {
                this.theta = 0;
                this.phi = 0;
            } else {
                this.theta = Math.atan2(x, z);
                this.phi = Math.acos(clamp$1(y / this.radius, -1, 1));
            }
            return this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    class Cylindrical {
        constructor(radius = 1, theta = 0, y = 0) {
            this.radius = radius;
            this.theta = theta;
            this.y = y;
        }
        set(radius, theta, y) {
            this.radius = radius;
            this.theta = theta;
            this.y = y;
            return this;
        }
        copy(other) {
            this.radius = other.radius;
            this.theta = other.theta;
            this.y = other.y;
            return this;
        }
        setFromVector3(v) {
            return this.setFromCartesianCoords(v.x, v.y, v.z);
        }
        setFromCartesianCoords(x, y, z) {
            this.radius = Math.sqrt(x * x + z * z);
            this.theta = Math.atan2(x, z);
            this.y = y;
            return this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    class Matrix2 {
        constructor(n11, n12, n21, n22) {
            Matrix2.prototype.isMatrix2 = true;
            this.elements = [
                1, 0,
                0, 1,
            ];
            if (n11 !== undefined) {
                this.set(n11, n12, n21, n22);
            }
        }
        identity() {
            this.set(
                1, 0,
                0, 1,
            );
            return this;
        }
        fromArray(array, offset = 0) {
            for (let i = 0; i < 4; i++) {
                this.elements[i] = array[i + offset];
            }
            return this;
        }
        set(n11, n12, n21, n22) {
            const te = this.elements;
            te[0] = n11; te[2] = n12;
            te[1] = n21; te[3] = n22;
            return this;
        }
    }
    const _vector$4 = /*@__PURE__*/ new Vector2();
    class Box2 {
        constructor(min = new Vector2(+ Infinity, + Infinity), max = new Vector2(- Infinity, - Infinity)) {
            this.isBox2 = true;
            this.min = min;
            this.max = max;
        }
        set(min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        }
        setFromPoints(points) {
            this.makeEmpty();
            for (let i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
            }
            return this;
        }
        setFromCenterAndSize(center, size) {
            const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
            this.min.copy(center).sub(halfSize);
            this.max.copy(center).add(halfSize);
            return this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(box) {
            this.min.copy(box.min);
            this.max.copy(box.max);
            return this;
        }
        makeEmpty() {
            this.min.x = this.min.y = + Infinity;
            this.max.x = this.max.y = - Infinity;
            return this;
        }
        isEmpty() {
            // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
            return (this.max.x < this.min.x) || (this.max.y < this.min.y);
        }
        getCenter(target) {
            return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
            return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        }
        expandByVector(vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        }
        expandByScalar(scalar) {
            this.min.addScalar(- scalar);
            this.max.addScalar(scalar);
            return this;
        }
        containsPoint(point) {
            return point.x >= this.min.x && point.x <= this.max.x &&
                point.y >= this.min.y && point.y <= this.max.y;
        }
        containsBox(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x &&
                this.min.y <= box.min.y && box.max.y <= this.max.y;
        }
        getParameter(point, target) {
            // This can potentially have a divide by zero if the box
            // has a size dimension of 0.
            return target.set(
                (point.x - this.min.x) / (this.max.x - this.min.x),
                (point.y - this.min.y) / (this.max.y - this.min.y)
            );
        }
        intersectsBox(box) {
            // using 4 splitting planes to rule out intersections
            return box.max.x >= this.min.x && box.min.x <= this.max.x &&
                box.max.y >= this.min.y && box.min.y <= this.max.y;
        }
        clampPoint(point, target) {
            return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
            return this.clampPoint(point, _vector$4).distanceTo(point);
        }
        intersect(box) {
            this.min.max(box.min);
            this.max.min(box.max);
            if (this.isEmpty()) this.makeEmpty();
            return this;
        }
        union(box) {
            this.min.min(box.min);
            this.max.max(box.max);
            return this;
        }
        translate(offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        }
        equals(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    }
    const _startP = /*@__PURE__*/ new Vector3();
    const _startEnd = /*@__PURE__*/ new Vector3();
    const _d1 = /*@__PURE__*/ new Vector3();
    const _d2 = /*@__PURE__*/ new Vector3();
    const _r = /*@__PURE__*/ new Vector3();
    const _c1 = /*@__PURE__*/ new Vector3();
    const _c2 = /*@__PURE__*/ new Vector3();
    class Line3 {
        constructor(start = new Vector3(), end = new Vector3()) {
            this.start = start;
            this.end = end;
        }
        set(start, end) {
            this.start.copy(start);
            this.end.copy(end);
            return this;
        }
        copy(line) {
            this.start.copy(line.start);
            this.end.copy(line.end);
            return this;
        }
        getCenter(target) {
            return target.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(target) {
            return target.subVectors(this.end, this.start);
        }
        distanceSq() {
            return this.start.distanceToSquared(this.end);
        }
        distance() {
            return this.start.distanceTo(this.end);
        }
        at(t, target) {
            return this.delta(target).multiplyScalar(t).add(this.start);
        }
        closestPointToPointParameter(point, clampToLine) {
            _startP.subVectors(point, this.start);
            _startEnd.subVectors(this.end, this.start);
            const startEnd2 = _startEnd.dot(_startEnd);
            const startEnd_startP = _startEnd.dot(_startP);
            let t = startEnd_startP / startEnd2;
            if (clampToLine) {
                t = clamp$1(t, 0, 1);
            }
            return t;
        }
        closestPointToPoint(point, clampToLine, target) {
            const t = this.closestPointToPointParameter(point, clampToLine);
            return this.delta(target).multiplyScalar(t).add(this.start);
        }
        distanceSqToLine3(line, c1 = _c1, c2 = _c2) {
            // from Real-Time Collision Detection by Christer Ericson, chapter 5.1.9
            // Computes closest points C1 and C2 of S1(s)=P1+s*(Q1-P1) and
            // S2(t)=P2+t*(Q2-P2), returning s and t. Function result is squared
            // distance between between S1(s) and S2(t)
            const EPSILON = 1e-8 * 1e-8; // must be squared since we compare squared length
            let s, t;
            const p1 = this.start;
            const p2 = line.start;
            const q1 = this.end;
            const q2 = line.end;
            _d1.subVectors(q1, p1); // Direction vector of segment S1
            _d2.subVectors(q2, p2); // Direction vector of segment S2
            _r.subVectors(p1, p2);
            const a = _d1.dot(_d1); // Squared length of segment S1, always nonnegative
            const e = _d2.dot(_d2); // Squared length of segment S2, always nonnegative
            const f = _d2.dot(_r);
            // Check if either or both segments degenerate into points
            if (a <= EPSILON && e <= EPSILON) {
                // Both segments degenerate into points
                c1.copy(p1);
                c2.copy(p2);
                c1.sub(c2);
                return c1.dot(c1);
            }
            if (a <= EPSILON) {
                // First segment degenerates into a point
                s = 0;
                t = f / e; // s = 0 => t = (b*s + f) / e = f / e
                t = clamp(t, 0, 1);

            } else {
                const c = _d1.dot(_r);
                if (e <= EPSILON) {
                    // Second segment degenerates into a point
                    t = 0;
                    s = clamp(- c / a, 0, 1); // t = 0 => s = (b*t - c) / a = -c / a
                } else {
                    // The general nondegenerate case starts here
                    const b = _d1.dot(_d2);
                    const denom = a * e - b * b; // Always nonnegative
                    // If segments not parallel, compute closest point on L1 to L2 and
                    // clamp to segment S1. Else pick arbitrary s (here 0)
                    if (denom !== 0) {
                        s = clamp((b * f - c * e) / denom, 0, 1);
                    } else {
                        s = 0;
                    }
                    // Compute point on L2 closest to S1(s) using
                    // t = Dot((P1 + D1*s) - P2,D2) / Dot(D2,D2) = (b*s + f) / e
                    t = (b * s + f) / e;
                    // If t in [0,1] done. Else clamp t, recompute s for the new value
                    // of t using s = Dot((P2 + D2*t) - P1,D1) / Dot(D1,D1)= (t*b - c) / a
                    // and clamp s to [0, 1]
                    if (t < 0) {
                        t = 0.;
                        s = clamp(- c / a, 0, 1);
                    } else if (t > 1) {
                        t = 1;
                        s = clamp((b - c) / a, 0, 1);
                    }
                }
            }
            c1.copy(p1).add(_d1.multiplyScalar(s));
            c2.copy(p2).add(_d2.multiplyScalar(t));
            c1.sub(c2);
            return c1.dot(c1);
        }
        applyMatrix4(matrix) {
            this.start.applyMatrix4(matrix);
            this.end.applyMatrix4(matrix);
            return this;
        }
        equals(line) {
            return line.start.equals(this.start) && line.end.equals(this.end);
        }
        clone() {
            return new this.constructor().copy(this);
        }
    }
    const _vector$3 = /*@__PURE__*/ new Vector3();
    class SpotLightHelper extends Object3D {
        constructor(light, color) {
            super();
            this.light = light;
            this.matrixAutoUpdate = false;
            this.color = color;
            this.type = 'SpotLightHelper';
            const geometry = new BufferGeometry();
            const positions = [
                0, 0, 0, 0, 0, 1,
                0, 0, 0, 1, 0, 1,
                0, 0, 0, -1, 0, 1,
                0, 0, 0, 0, 1, 1,
                0, 0, 0, 0, -1, 1
            ];
            for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
                const p1 = (i / l) * Math.PI * 2;
                const p2 = (j / l) * Math.PI * 2;
                positions.push(
                    Math.cos(p1), Math.sin(p1), 1,
                    Math.cos(p2), Math.sin(p2), 1
                );
            }
            geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
            const material = new LineBasicMaterial({ fog: false, toneMapped: false });
            this.cone = new LineSegments(geometry, material);
            this.add(this.cone);
            this.update();
        }
        dispose() {
            this.cone.geometry.dispose();
            this.cone.material.dispose();
        }
        update() {
            this.light.updateWorldMatrix(true, false);
            this.light.target.updateWorldMatrix(true, false);
            // update the local matrix based on the parent and light target transforms
            if (this.parent) {
                this.parent.updateWorldMatrix(true);
                this.matrix
                    .copy(this.parent.matrixWorld)
                    .invert()
                    .multiply(this.light.matrixWorld);
            } else {
                this.matrix.copy(this.light.matrixWorld);
            }
            this.matrixWorld.copy(this.light.matrixWorld);
            const coneLength = this.light.distance ? this.light.distance : 1000;
            const coneWidth = coneLength * Math.tan(this.light.angle);
            this.cone.scale.set(coneWidth, coneWidth, coneLength);
            _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
            this.cone.lookAt(_vector$3);
            if (this.color !== undefined) {
                this.cone.material.color.set(this.color);
            } else {
                this.cone.material.color.copy(this.light.color);
            }
        }
    }
    const _vector$2 = /*@__PURE__*/ new Vector3();
    const _boneMatrix = /*@__PURE__*/ new Matrix4();
    const _matrixWorldInv = /*@__PURE__*/ new Matrix4();
    class SkeletonHelper extends LineSegments {
        constructor(object) {
            const bones = getBoneList(object);
            const geometry = new BufferGeometry();
            const vertices = [];
            const colors = [];
            for (let i = 0; i < bones.length; i++) {
                const bone = bones[i];
                if (bone.parent && bone.parent.isBone) {
                    vertices.push(0, 0, 0);
                    vertices.push(0, 0, 0);
                    colors.push(0, 0, 0);
                    colors.push(0, 0, 0);
                }
            }
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
            super(geometry, material);
            this.isSkeletonHelper = true;
            this.type = 'SkeletonHelper';
            this.root = object;
            this.bones = bones;
            this.matrix = object.matrixWorld;
            this.matrixAutoUpdate = false;
            // colors
            const color1 = new Color(0x0000ff);
            const color2 = new Color(0x00ff00);
            this.setColors(color1, color2);
        }
        updateMatrixWorld(force) {
            const bones = this.bones;
            const geometry = this.geometry;
            const position = geometry.getAttribute('position');
            _matrixWorldInv.copy(this.root.matrixWorld).invert();
            for (let i = 0, j = 0; i < bones.length; i++) {
                const bone = bones[i];
                if (bone.parent && bone.parent.isBone) {
                    _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
                    _vector$2.setFromMatrixPosition(_boneMatrix);
                    position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
                    _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
                    _vector$2.setFromMatrixPosition(_boneMatrix);
                    position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
                    j += 2;
                }
            }
            geometry.getAttribute('position').needsUpdate = true;
            super.updateMatrixWorld(force);
        }
        setColors(color1, color2) {
            const geometry = this.geometry;
            const colorAttribute = geometry.getAttribute('color');
            for (let i = 0; i < colorAttribute.count; i += 2) {
                colorAttribute.setXYZ(i, color1.r, color1.g, color1.b);
                colorAttribute.setXYZ(i + 1, color2.r, color2.g, color2.b);
            }
            colorAttribute.needsUpdate = true;
            return this;
        }
        dispose() {
            this.geometry.dispose();
            this.material.dispose();
        }
    }

    function getBoneList(object) {
        const boneList = [];
        if (object.isBone === true) {
            boneList.push(object);
        }
        for (let i = 0; i < object.children.length; i++) {
            boneList.push(...getBoneList(object.children[i]));
        }
        return boneList;
    }
    class PointLightHelper extends Mesh {
        constructor(light, sphereSize, color) {
            const geometry = new SphereGeometry(sphereSize, 4, 2);
            const material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
            super(geometry, material);
            this.light = light;
            this.color = color;
            this.type = 'PointLightHelper';
            this.matrix = this.light.matrixWorld;
            this.matrixAutoUpdate = false;
            this.update();

            /*
        // TODO: delete this comment?
        const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
        const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
        this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
        this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
        const d = light.distance;
        if ( d === 0.0 ) {
            this.lightDistance.visible = false;
        } else {
            this.lightDistance.scale.set( d, d, d );
        }
        this.add( this.lightDistance );
        */
        }
        dispose() {
            this.geometry.dispose();
            this.material.dispose();
        }
        update() {
            this.light.updateWorldMatrix(true, false);
            if (this.color !== undefined) {
                this.material.color.set(this.color);
            } else {
                this.material.color.copy(this.light.color);
            }
            /*
            const d = this.light.distance;
            if ( d === 0.0 ) {
                this.lightDistance.visible = false;
            } else {
                this.lightDistance.visible = true;
                this.lightDistance.scale.set( d, d, d );
            }
            */
        }
    }
    const _vector$1 = /*@__PURE__*/ new Vector3();
    const _color1 = /*@__PURE__*/ new Color();
    const _color2 = /*@__PURE__*/ new Color();
    class HemisphereLightHelper extends Object3D {
        constructor(light, size, color) {
            super();
            this.light = light;
            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;
            this.color = color;
            this.type = 'HemisphereLightHelper';
            const geometry = new OctahedronGeometry(size);
            geometry.rotateY(Math.PI * 0.5);
            this.material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
            if (this.color === undefined) this.material.vertexColors = true;
            const position = geometry.getAttribute('position');
            const colors = new Float32Array(position.count * 3);
            geometry.setAttribute('color', new BufferAttribute(colors, 3));
            this.add(new Mesh(geometry, this.material));
            this.update();
        }
        dispose() {
            this.children[0].geometry.dispose();
            this.children[0].material.dispose();
        }
        update() {
            const mesh = this.children[0];
            if (this.color !== undefined) {
                this.material.color.set(this.color);
            } else {
                const colors = mesh.geometry.getAttribute('color');
                _color1.copy(this.light.color);
                _color2.copy(this.light.groundColor);
                for (let i = 0, l = colors.count; i < l; i++) {
                    const color = (i < (l / 2)) ? _color1 : _color2;
                    colors.setXYZ(i, color.r, color.g, color.b);
                }
                colors.needsUpdate = true;
            }
            this.light.updateWorldMatrix(true, false);
            mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
    }
    class GridHelper extends LineSegments {
        constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {
            color1 = new Color(color1);
            color2 = new Color(color2);
            const center = divisions / 2;
            const step = size / divisions;
            const halfSize = size / 2;
            const vertices = [], colors = [];
            for (let i = 0, j = 0, k = - halfSize; i <= divisions; i++, k += step) {
                vertices.push(- halfSize, 0, k, halfSize, 0, k);
                vertices.push(k, 0, - halfSize, k, 0, halfSize);
                const color = i === center ? color1 : color2;
                color.toArray(colors, j); j += 3;
                color.toArray(colors, j); j += 3;
                color.toArray(colors, j); j += 3;
                color.toArray(colors, j); j += 3;
            }
            const geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
            super(geometry, material);
            this.type = 'GridHelper';
        }
        dispose() {
            this.geometry.dispose();
            this.material.dispose();
        }
    }
    class PolarGridHelper extends LineSegments {
        constructor(radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {
            color1 = new Color(color1);
            color2 = new Color(color2);
            const vertices = [];
            const colors = [];
            // create the sectors
            if (sectors > 1) {
                for (let i = 0; i < sectors; i++) {
                    const v = (i / sectors) * (Math.PI * 2);
                    const x = Math.sin(v) * radius;
                    const z = Math.cos(v) * radius;
                    vertices.push(0, 0, 0);
                    vertices.push(x, 0, z);
                    const color = (i & 1) ? color1 : color2;
                    colors.push(color.r, color.g, color.b);
                    colors.push(color.r, color.g, color.b);
                }
            }
            // create the rings
            for (let i = 0; i < rings; i++) {
                const color = (i & 1) ? color1 : color2;
                const r = radius - (radius / rings * i);
                for (let j = 0; j < divisions; j++) {
                    // first vertex
                    let v = (j / divisions) * (Math.PI * 2);
                    let x = Math.sin(v) * r;
                    let z = Math.cos(v) * r;
                    vertices.push(x, 0, z);
                    colors.push(color.r, color.g, color.b);
                    // second vertex
                    v = ((j + 1) / divisions) * (Math.PI * 2);
                    x = Math.sin(v) * r;
                    z = Math.cos(v) * r;
                    vertices.push(x, 0, z);
                    colors.push(color.r, color.g, color.b);
                }
            }
            const geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
            super(geometry, material);
            this.type = 'PolarGridHelper';
        }
        dispose() {
            this.geometry.dispose();
            this.material.dispose();
        }
    }
    const _v1 = /*@__PURE__*/ new Vector3();
    const _v2 = /*@__PURE__*/ new Vector3();
    const _v3 = /*@__PURE__*/ new Vector3();
    class DirectionalLightHelper extends Object3D {
        constructor(light, size, color) {
            super();
            this.light = light;
            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;
            this.color = color;
            this.type = 'DirectionalLightHelper';
            if (size === undefined) size = 1;
            let geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute([
                - size, size, 0,
                size, size, 0,
                size, - size, 0,
                - size, - size, 0,
                - size, size, 0
            ], 3));
            const material = new LineBasicMaterial({ fog: false, toneMapped: false });
            this.lightPlane = new Line(geometry, material);
            this.add(this.lightPlane);
            geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
            this.targetLine = new Line(geometry, material);
            this.add(this.targetLine);
            this.update();
        }
        dispose() {
            this.lightPlane.geometry.dispose();
            this.lightPlane.material.dispose();
            this.targetLine.geometry.dispose();
            this.targetLine.material.dispose();
        }
        update() {
            this.light.updateWorldMatrix(true, false);
            this.light.target.updateWorldMatrix(true, false);
            _v1.setFromMatrixPosition(this.light.matrixWorld);
            _v2.setFromMatrixPosition(this.light.target.matrixWorld);
            _v3.subVectors(_v2, _v1);
            this.lightPlane.lookAt(_v2);
            if (this.color !== undefined) {
                this.lightPlane.material.color.set(this.color);
                this.targetLine.material.color.set(this.color);
            } else {
                this.lightPlane.material.color.copy(this.light.color);
                this.targetLine.material.color.copy(this.light.color);
            }
            this.targetLine.lookAt(_v2);
            this.targetLine.scale.z = _v3.length();
        }
    }
    const _vector = /*@__PURE__*/ new Vector3();
    const _camera = /*@__PURE__*/ new Camera();
    class CameraHelper extends LineSegments {
        constructor(camera) {
            const geometry = new BufferGeometry();
            const material = new LineBasicMaterial({ color: 0xffffff, vertexColors: true, toneMapped: false });
            const vertices = [];
            const colors = [];
            const pointMap = {};
            // near
            addLine('n1', 'n2');
            addLine('n2', 'n4');
            addLine('n4', 'n3');
            addLine('n3', 'n1');
            // far
            addLine('f1', 'f2');
            addLine('f2', 'f4');
            addLine('f4', 'f3');
            addLine('f3', 'f1');
            // sides
            addLine('n1', 'f1');
            addLine('n2', 'f2');
            addLine('n3', 'f3');
            addLine('n4', 'f4');
            // cone
            addLine('p', 'n1');
            addLine('p', 'n2');
            addLine('p', 'n3');
            addLine('p', 'n4');
            // up
            addLine('u1', 'u2');
            addLine('u2', 'u3');
            addLine('u3', 'u1');
            // target
            addLine('c', 't');
            addLine('p', 'c');
            // cross
            addLine('cn1', 'cn2');
            addLine('cn3', 'cn4');
            addLine('cf1', 'cf2');
            addLine('cf3', 'cf4');
            function addLine(a, b) {
                addPoint(a);
                addPoint(b);
            }
            function addPoint(id) {
                vertices.push(0, 0, 0);
                colors.push(0, 0, 0);
                if (pointMap[id] === undefined) {
                    pointMap[id] = [];
                }
                pointMap[id].push((vertices.length / 3) - 1);
            }
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            super(geometry, material);
            this.type = 'CameraHelper';
            this.camera = camera;
            if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
            this.matrix = camera.matrixWorld;
            this.matrixAutoUpdate = false;
            this.pointMap = pointMap;
            this.update();
            // colors
            const colorFrustum = new Color(0xffaa00);
            const colorCone = new Color(0xff0000);
            const colorUp = new Color(0x00aaff);
            const colorTarget = new Color(0xffffff);
            const colorCross = new Color(0x333333);
            this.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross);
        }
        setColors(frustum, cone, up, target, cross) {
            const geometry = this.geometry;
            const colorAttribute = geometry.getAttribute('color');
            // near
            colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b); colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b); // n1, n2
            colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b); colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b); // n2, n4
            colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b); colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b); // n4, n3
            colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b); colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b); // n3, n1
            // far
            colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b); colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b); // f1, f2
            colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b); colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b); // f2, f4
            colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b); colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b); // f4, f3
            colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b); colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b); // f3, f1
            // sides
            colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b); colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b); // n1, f1
            colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b); colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b); // n2, f2
            colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b); colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b); // n3, f3
            colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b); colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b); // n4, f4
            // cone
            colorAttribute.setXYZ(24, cone.r, cone.g, cone.b); colorAttribute.setXYZ(25, cone.r, cone.g, cone.b); // p, n1
            colorAttribute.setXYZ(26, cone.r, cone.g, cone.b); colorAttribute.setXYZ(27, cone.r, cone.g, cone.b); // p, n2
            colorAttribute.setXYZ(28, cone.r, cone.g, cone.b); colorAttribute.setXYZ(29, cone.r, cone.g, cone.b); // p, n3
            colorAttribute.setXYZ(30, cone.r, cone.g, cone.b); colorAttribute.setXYZ(31, cone.r, cone.g, cone.b); // p, n4
            // up
            colorAttribute.setXYZ(32, up.r, up.g, up.b); colorAttribute.setXYZ(33, up.r, up.g, up.b); // u1, u2
            colorAttribute.setXYZ(34, up.r, up.g, up.b); colorAttribute.setXYZ(35, up.r, up.g, up.b); // u2, u3
            colorAttribute.setXYZ(36, up.r, up.g, up.b); colorAttribute.setXYZ(37, up.r, up.g, up.b); // u3, u1
            // target
            colorAttribute.setXYZ(38, target.r, target.g, target.b); colorAttribute.setXYZ(39, target.r, target.g, target.b); // c, t
            colorAttribute.setXYZ(40, cross.r, cross.g, cross.b); colorAttribute.setXYZ(41, cross.r, cross.g, cross.b); // p, c
            // cross
            colorAttribute.setXYZ(42, cross.r, cross.g, cross.b); colorAttribute.setXYZ(43, cross.r, cross.g, cross.b); // cn1, cn2
            colorAttribute.setXYZ(44, cross.r, cross.g, cross.b); colorAttribute.setXYZ(45, cross.r, cross.g, cross.b); // cn3, cn4
            colorAttribute.setXYZ(46, cross.r, cross.g, cross.b); colorAttribute.setXYZ(47, cross.r, cross.g, cross.b); // cf1, cf2
            colorAttribute.setXYZ(48, cross.r, cross.g, cross.b); colorAttribute.setXYZ(49, cross.r, cross.g, cross.b); // cf3, cf4
            colorAttribute.needsUpdate = true;
            return this;
        }
        update() {
            const geometry = this.geometry;
            const pointMap = this.pointMap;
            const w = 1, h = 1;
            let nearZ, farZ;
            // we need just camera projection matrix inverse
            // world matrix must be identity
            _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
            // Adjust z values based on coordinate system
            if (this.camera.reversedDepth === true) {
                nearZ = 1;
                farZ = 0;
            } else {
                if (this.camera.coordinateSystem === WebGLCoordinateSystem) {
                    nearZ = -1;
                    farZ = 1;
                } else if (this.camera.coordinateSystem === WebGPUCoordinateSystem) {
                    nearZ = 0;
                    farZ = 1;
                } else {
                    throw new Error('THREE.CameraHelper.update(): Invalid coordinate system: ' + this.camera.coordinateSystem);
                }
            }

            // center / target
            setPoint('c', pointMap, geometry, _camera, 0, 0, nearZ);
            setPoint('t', pointMap, geometry, _camera, 0, 0, farZ);
            // near
            setPoint('n1', pointMap, geometry, _camera, - w, - h, nearZ);
            setPoint('n2', pointMap, geometry, _camera, w, - h, nearZ);
            setPoint('n3', pointMap, geometry, _camera, - w, h, nearZ);
            setPoint('n4', pointMap, geometry, _camera, w, h, nearZ);
            // far
            setPoint('f1', pointMap, geometry, _camera, - w, - h, farZ);
            setPoint('f2', pointMap, geometry, _camera, w, - h, farZ);
            setPoint('f3', pointMap, geometry, _camera, - w, h, farZ);
            setPoint('f4', pointMap, geometry, _camera, w, h, farZ);
            // up
            setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, nearZ);
            setPoint('u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, nearZ);
            setPoint('u3', pointMap, geometry, _camera, 0, h * 2, nearZ);
            // cross
            setPoint('cf1', pointMap, geometry, _camera, - w, 0, farZ);
            setPoint('cf2', pointMap, geometry, _camera, w, 0, farZ);
            setPoint('cf3', pointMap, geometry, _camera, 0, - h, farZ);
            setPoint('cf4', pointMap, geometry, _camera, 0, h, farZ);
            setPoint('cn1', pointMap, geometry, _camera, - w, 0, nearZ);
            setPoint('cn2', pointMap, geometry, _camera, w, 0, nearZ);
            setPoint('cn3', pointMap, geometry, _camera, 0, - h, nearZ);
            setPoint('cn4', pointMap, geometry, _camera, 0, h, nearZ);
            geometry.getAttribute('position').needsUpdate = true;
        }
        dispose() {
            this.geometry.dispose();
            this.material.dispose();
        }
    }

    function setPoint(point, pointMap, geometry, camera, x, y, z) {
        _vector.set(x, y, z).unproject(camera);
        const points = pointMap[point];
        if (points !== undefined) {
            const position = geometry.getAttribute('position');
            for (let i = 0, l = points.length; i < l; i++) {
                position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
            }
        }
    }
    const _box = /*@__PURE__*/ new Box3();
    class BoxHelper extends LineSegments {
        constructor(object, color = 0xffff00) {
            const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
            const positions = new Float32Array(8 * 3);
            const geometry = new BufferGeometry();
            geometry.setIndex(new BufferAttribute(indices, 1));
            geometry.setAttribute('position', new BufferAttribute(positions, 3));
            super(geometry, new LineBasicMaterial({ color: color, toneMapped: false }));
            this.object = object;
            this.type = 'BoxHelper';
            this.matrixAutoUpdate = false;
            this.update();
        }
        update() {
            if (this.object !== undefined) {
                _box.setFromObject(this.object);
            }
            if (_box.isEmpty()) return;
            const min = _box.min;
            const max = _box.max;
            /*
                5____4
            1/___0/|
            | 6__|_7
            2/___3/
            0: max.x, max.y, max.z
            1: min.x, max.y, max.z
            2: min.x, min.y, max.z
            3: max.x, min.y, max.z
            4: max.x, max.y, min.z
            5: min.x, max.y, min.z
            6: min.x, min.y, min.z
            7: max.x, min.y, min.z
            */
            const position = this.geometry.attributes.position;
            const array = position.array;
            array[0] = max.x; array[1] = max.y; array[2] = max.z;
            array[3] = min.x; array[4] = max.y; array[5] = max.z;
            array[6] = min.x; array[7] = min.y; array[8] = max.z;
            array[9] = max.x; array[10] = min.y; array[11] = max.z;
            array[12] = max.x; array[13] = max.y; array[14] = min.z;
            array[15] = min.x; array[16] = max.y; array[17] = min.z;
            array[18] = min.x; array[19] = min.y; array[20] = min.z;
            array[21] = max.x; array[22] = min.y; array[23] = min.z;
            position.needsUpdate = true;
            this.geometry.computeBoundingSphere();
        }
        setFromObject(object) {
            this.object = object;
            this.update();
            return this;
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.object = source.object;
            return this;
        }
        dispose() {
            this.geometry.dispose();
            this.material.dispose();
        }
    }
    class Box3Helper extends LineSegments {
        constructor(box, color = 0xffff00) {
            const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
            const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
            const geometry = new BufferGeometry();
            geometry.setIndex(new BufferAttribute(indices, 1));
            geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
            super(geometry, new LineBasicMaterial({ color: color, toneMapped: false }));
            this.box = box;
            this.type = 'Box3Helper';
            this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(force) {
            const box = this.box;
            if (box.isEmpty()) return;
            box.getCenter(this.position);
            box.getSize(this.scale);
            this.scale.multiplyScalar(0.5);
            super.updateMatrixWorld(force);
        }
        dispose() {
            this.geometry.dispose();
            this.material.dispose();
        }
    }
    class PlaneHelper extends Line {
        constructor(plane, size = 1, hex = 0xffff00) {
            const color = hex;
            const positions = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
            const geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
            geometry.computeBoundingSphere();
            super(geometry, new LineBasicMaterial({ color: color, toneMapped: false }));
            this.type = 'PlaneHelper';
            this.plane = plane;
            this.size = size;
            const positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
            const geometry2 = new BufferGeometry();
            geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
            geometry2.computeBoundingSphere();
            this.add(new Mesh(geometry2, new MeshBasicMaterial({ color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
        }
        updateMatrixWorld(force) {
            this.position.set(0, 0, 0);
            this.scale.set(0.5 * this.size, 0.5 * this.size, 1);
            this.lookAt(this.plane.normal);
            this.translateZ(- this.plane.constant);
            super.updateMatrixWorld(force);
        }
        dispose() {
            this.geometry.dispose();
            this.material.dispose();
            this.children[0].geometry.dispose();
            this.children[0].material.dispose();
        }
    }
    const _axis = /*@__PURE__*/ new Vector3();
    let _lineGeometry, _coneGeometry;
    class ArrowHelper extends Object3D {
        constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {
            super();
            this.type = 'ArrowHelper';
            if (_lineGeometry === undefined) {
                _lineGeometry = new BufferGeometry();
                _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
                _coneGeometry = new ConeGeometry(0.5, 1, 5, 1);
                _coneGeometry.translate(0, -0.5, 0);
            }
            this.position.copy(origin);
            this.line = new Line(_lineGeometry, new LineBasicMaterial({ color: color, toneMapped: false }));
            this.line.matrixAutoUpdate = false;
            this.add(this.line);
            this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color: color, toneMapped: false }));
            this.cone.matrixAutoUpdate = false;
            this.add(this.cone);
            this.setDirection(dir);
            this.setLength(length, headLength, headWidth);
        }
        setDirection(dir) {
            // dir is assumed to be normalized
            if (dir.y > 0.99999) {
                this.quaternion.set(0, 0, 0, 1);
            } else if (dir.y < -0.99999) {
                this.quaternion.set(1, 0, 0, 0);
            } else {
                _axis.set(dir.z, 0, - dir.x).normalize();
                const radians = Math.acos(dir.y);
                this.quaternion.setFromAxisAngle(_axis, radians);
            }
        }
        setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
            this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
            this.line.updateMatrix();
            this.cone.scale.set(headWidth, headLength, headWidth);
            this.cone.position.y = length;
            this.cone.updateMatrix();
        }
        setColor(color) {
            this.line.material.color.set(color);
            this.cone.material.color.set(color);
        }
        copy(source) {
            super.copy(source, false);
            this.line.copy(source.line);
            this.cone.copy(source.cone);
            return this;
        }
        dispose() {
            this.line.geometry.dispose();
            this.line.material.dispose();
            this.cone.geometry.dispose();
            this.cone.material.dispose();
        }
    }
    class AxesHelper extends LineSegments {
        constructor(size = 1) {
            const vertices = [
                0, 0, 0, size, 0, 0,
                0, 0, 0, 0, size, 0,
                0, 0, 0, 0, 0, size
            ];
            const colors = [
                1, 0, 0, 1, 0.6, 0,
                0, 1, 0, 0.6, 1, 0,
                0, 0, 1, 0, 0.6, 1
            ];
            const geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
            super(geometry, material);
            this.type = 'AxesHelper';
        }
        setColors(xAxisColor, yAxisColor, zAxisColor) {
            const color = new Color();
            const array = this.geometry.attributes.color.array;
            color.set(xAxisColor);
            color.toArray(array, 0);
            color.toArray(array, 3);
            color.set(yAxisColor);
            color.toArray(array, 6);
            color.toArray(array, 9);
            color.set(zAxisColor);
            color.toArray(array, 12);
            color.toArray(array, 15);
            this.geometry.attributes.color.needsUpdate = true;
            return this;
        }
        dispose() {
            this.geometry.dispose();
            this.material.dispose();
        }
    }
    class ShapePath {
        constructor() {
            this.type = 'ShapePath';
            this.color = new Color();
            this.subPaths = [];
            this.currentPath = null;
        }
        moveTo(x, y) {
            this.currentPath = new Path();
            this.subPaths.push(this.currentPath);
            this.currentPath.moveTo(x, y);
            return this;
        }
        lineTo(x, y) {
            this.currentPath.lineTo(x, y);
            return this;
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
            this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
            return this;
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
            return this;
        }
        splineThru(pts) {
            this.currentPath.splineThru(pts);
            return this;
        }
        toShapes(isCCW) {
            function toShapesNoHoles(inSubpaths) {
                const shapes = [];
                for (let i = 0, l = inSubpaths.length; i < l; i++) {
                    const tmpPath = inSubpaths[i];
                    const tmpShape = new Shape();
                    tmpShape.curves = tmpPath.curves;
                    shapes.push(tmpShape);
                }
                return shapes;
            }
            function isPointInsidePolygon(inPt, inPolygon) {
                const polyLen = inPolygon.length;
                // inPt on polygon contour => immediate success    or
                // toggling of inside/outside at every single! intersection point of an edge
                //  with the horizontal line through inPt, left of inPt
                //  not counting lowerY endpoints of edges and whole edges on that line
                let inside = false;
                for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                    let edgeLowPt = inPolygon[p];
                    let edgeHighPt = inPolygon[q];
                    let edgeDx = edgeHighPt.x - edgeLowPt.x;
                    let edgeDy = edgeHighPt.y - edgeLowPt.y;
                    if (Math.abs(edgeDy) > Number.EPSILON) {
                        // not parallel
                        if (edgeDy < 0) {
                            edgeLowPt = inPolygon[q]; edgeDx = - edgeDx;
                            edgeHighPt = inPolygon[p]; edgeDy = - edgeDy;
                        }
                        if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y)) continue;
                        if (inPt.y === edgeLowPt.y) {
                            if (inPt.x === edgeLowPt.x) return true;		// inPt is on contour ?
                            // continue;				// no intersection or edgeLowPt => doesn't count !!!
                        } else {
                            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                            if (perpEdge === 0) return true;		// inPt is on contour ?
                            if (perpEdge < 0) continue;
                            inside = !inside;		// true intersection left of inPt
                        }
                    } else {
                        // parallel or collinear
                        if (inPt.y !== edgeLowPt.y) continue;			// parallel
                        // edge lies on the same horizontal line as inPt
                        if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) ||
                            ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x))) return true;	// inPt: Point on contour !
                        // continue;
                    }
                }
                return inside;
            }
            const isClockWise = ShapeUtils.isClockWise;
            const subPaths = this.subPaths;
            if (subPaths.length === 0) return [];
            let solid, tmpPath, tmpShape;
            const shapes = [];
            if (subPaths.length === 1) {
                tmpPath = subPaths[0];
                tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
                return shapes;
            }
            let holesFirst = !isClockWise(subPaths[0].getPoints());
            holesFirst = isCCW ? !holesFirst : holesFirst;
            // console.log("Holes first", holesFirst);
            const betterShapeHoles = [];
            const newShapes = [];
            let newShapeHoles = [];
            let mainIdx = 0;
            let tmpPoints;
            newShapes[mainIdx] = undefined;
            newShapeHoles[mainIdx] = [];
            for (let i = 0, l = subPaths.length; i < l; i++) {
                tmpPath = subPaths[i];
                tmpPoints = tmpPath.getPoints();
                solid = isClockWise(tmpPoints);
                solid = isCCW ? !solid : solid;
                if (solid) {
                    if ((!holesFirst) && (newShapes[mainIdx])) mainIdx++;
                    newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
                    newShapes[mainIdx].s.curves = tmpPath.curves;
                    if (holesFirst) mainIdx++;
                    newShapeHoles[mainIdx] = [];
                    //console.log('cw', i);
                } else {
                    newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
                    //console.log('ccw', i);
                }
            }
            // only Holes? -> probably all Shapes with wrong orientation
            if (!newShapes[0]) return toShapesNoHoles(subPaths);

            if (newShapes.length > 1) {
                let ambiguous = false;
                let toChange = 0;
                for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                    betterShapeHoles[sIdx] = [];
                }
                for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                    const sho = newShapeHoles[sIdx];
                    for (let hIdx = 0; hIdx < sho.length; hIdx++) {
                        const ho = sho[hIdx];
                        let hole_unassigned = true;
                        for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                                if (sIdx !== s2Idx) toChange++;
                                if (hole_unassigned) {
                                    hole_unassigned = false;
                                    betterShapeHoles[s2Idx].push(ho);
                                } else {
                                    ambiguous = true;
                                }
                            }
                        }
                        if (hole_unassigned) {
                            betterShapeHoles[sIdx].push(ho);
                        }
                    }
                }
                if (toChange > 0 && ambiguous === false) {
                    newShapeHoles = betterShapeHoles;
                }
            }
            let tmpHoles;
            for (let i = 0, il = newShapes.length; i < il; i++) {
                tmpShape = newShapes[i].s;
                shapes.push(tmpShape);
                tmpHoles = newShapeHoles[i];
                for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
                    tmpShape.holes.push(tmpHoles[j].h);
                }
            }
            //console.log("shape", shapes);
            return shapes;
        }
    }
    class Controls extends EventDispatcher {
        constructor(object, domElement = null) {
            super();
            this.object = object;
            this.domElement = domElement;
            this.enabled = true;
            this.state = -1;
            this.keys = {};
            this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };
            this.touches = { ONE: null, TWO: null };
        }
        connect(element) {
            if (element === undefined) {
                console.warn('THREE.Controls: connect() now requires an element.'); // @deprecated, the warning can be removed with r185
                return;
            }
            if (this.domElement !== null) this.disconnect();
            this.domElement = element;
        }
        disconnect() { }
        dispose() { }
        update( /* delta */) { }
    }
    function contain(texture, aspect) {
        const imageAspect = (texture.image && texture.image.width) ? texture.image.width / texture.image.height : 1;
        if (imageAspect > aspect) {
            texture.repeat.x = 1;
            texture.repeat.y = imageAspect / aspect;
            texture.offset.x = 0;
            texture.offset.y = (1 - texture.repeat.y) / 2;
        } else {
            texture.repeat.x = aspect / imageAspect;
            texture.repeat.y = 1;
            texture.offset.x = (1 - texture.repeat.x) / 2;
            texture.offset.y = 0;
        }
        return texture;
    }
    function cover(texture, aspect) {
        const imageAspect = (texture.image && texture.image.width) ? texture.image.width / texture.image.height : 1;
        if (imageAspect > aspect) {
            texture.repeat.x = aspect / imageAspect;
            texture.repeat.y = 1;
            texture.offset.x = (1 - texture.repeat.x) / 2;
            texture.offset.y = 0;
        } else {
            texture.repeat.x = 1;
            texture.repeat.y = imageAspect / aspect;
            texture.offset.x = 0;
            texture.offset.y = (1 - texture.repeat.y) / 2;
        }
        return texture;
    }
    function fill(texture) {
        texture.repeat.x = 1;
        texture.repeat.y = 1;
        texture.offset.x = 0;
        texture.offset.y = 0;
        return texture;
    }
    function getByteLength(width, height, format, type) {
        const typeByteLength = getTextureTypeByteLength(type);
        switch (format) {
            // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
            case AlphaFormat:
                return width * height;
            case RedFormat:
                return ((width * height) / typeByteLength.components) * typeByteLength.byteLength;
            case RedIntegerFormat:
                return ((width * height) / typeByteLength.components) * typeByteLength.byteLength;
            case RGFormat:
                return ((width * height * 2) / typeByteLength.components) * typeByteLength.byteLength;
            case RGIntegerFormat:
                return ((width * height * 2) / typeByteLength.components) * typeByteLength.byteLength;
            case RGBFormat:
                return ((width * height * 3) / typeByteLength.components) * typeByteLength.byteLength;
            case RGBAFormat:
                return ((width * height * 4) / typeByteLength.components) * typeByteLength.byteLength;
            case RGBAIntegerFormat:
                return ((width * height * 4) / typeByteLength.components) * typeByteLength.byteLength;
            // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
            case RGB_S3TC_DXT1_Format:
            case RGBA_S3TC_DXT1_Format:
                return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
            case RGBA_S3TC_DXT3_Format:
            case RGBA_S3TC_DXT5_Format:
                return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
            // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
            case RGB_PVRTC_2BPPV1_Format:
            case RGBA_PVRTC_2BPPV1_Format:
                return (Math.max(width, 16) * Math.max(height, 8)) / 4;
            case RGB_PVRTC_4BPPV1_Format:
            case RGBA_PVRTC_4BPPV1_Format:
                return (Math.max(width, 8) * Math.max(height, 8)) / 2;
            // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
            case RGB_ETC1_Format:
            case RGB_ETC2_Format:
                return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
            case RGBA_ETC2_EAC_Format:
                return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
            // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
            case RGBA_ASTC_4x4_Format:
                return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
            case RGBA_ASTC_5x4_Format:
                return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
            case RGBA_ASTC_5x5_Format:
                return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
            case RGBA_ASTC_6x5_Format:
                return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
            case RGBA_ASTC_6x6_Format:
                return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
            case RGBA_ASTC_8x5_Format:
                return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
            case RGBA_ASTC_8x6_Format:
                return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
            case RGBA_ASTC_8x8_Format:
                return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
            case RGBA_ASTC_10x5_Format:
                return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
            case RGBA_ASTC_10x6_Format:
                return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
            case RGBA_ASTC_10x8_Format:
                return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
            case RGBA_ASTC_10x10_Format:
                return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
            case RGBA_ASTC_12x10_Format:
                return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
            case RGBA_ASTC_12x12_Format:
                return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
            // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
            case RGBA_BPTC_Format:
            case RGB_BPTC_SIGNED_Format:
            case RGB_BPTC_UNSIGNED_Format:
                return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
            // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
            case RED_RGTC1_Format:
            case SIGNED_RED_RGTC1_Format:
                return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;
            case RED_GREEN_RGTC2_Format:
            case SIGNED_RED_GREEN_RGTC2_Format:
                return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
        }
        throw new Error(
            `Unable to determine texture byte length for ${format} format.`,
        );
    }
    function getTextureTypeByteLength(type) {
        switch (type) {
            case UnsignedByteType:
            case ByteType:
                return { byteLength: 1, components: 1 };
            case UnsignedShortType:
            case ShortType:
            case HalfFloatType:
                return { byteLength: 2, components: 1 };
            case UnsignedShort4444Type:
            case UnsignedShort5551Type:
                return { byteLength: 2, components: 4 };
            case UnsignedIntType:
            case IntType:
            case FloatType:
                return { byteLength: 4, components: 1 };
            case UnsignedInt5999Type:
                return { byteLength: 4, components: 3 };
        }
        throw new Error(`Unknown texture type ${type}.`);
    }
    class TextureUtils {
        static contain(texture, aspect) {
            return contain(texture, aspect);
        }
        static cover(texture, aspect) {
            return cover(texture, aspect);
        }
        static fill(texture) {
            return fill(texture);
        }
        static getByteLength(width, height, format, type) {
            return getByteLength(width, height, format, type);
        }
    }

    class WebGLMultipleRenderTargets extends WebGLRenderTarget { // @deprecated, r162

        constructor(width = 1, height = 1, count = 1, options = {}) {

            console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.');

            super(width, height, {
                ...options,
                count
            });

            this.isWebGLMultipleRenderTargets = true;

        }

        get texture() {

            return this.textures;

        }

    }

    const refreshUniforms = [
        'alphaMap',
        'alphaTest',
        'anisotropy',
        'anisotropyMap',
        'anisotropyRotation',
        'aoMap',
        'aoMapIntensity',
        'attenuationColor',
        'attenuationDistance',
        'bumpMap',
        'clearcoat',
        'clearcoatMap',
        'clearcoatNormalMap',
        'clearcoatNormalScale',
        'clearcoatRoughness',
        'color',
        'dispersion',
        'displacementMap',
        'emissive',
        'emissiveIntensity',
        'emissiveMap',
        'envMap',
        'envMapIntensity',
        'gradientMap',
        'ior',
        'iridescence',
        'iridescenceIOR',
        'iridescenceMap',
        'iridescenceThicknessMap',
        'lightMap',
        'lightMapIntensity',
        'map',
        'matcap',
        'metalness',
        'metalnessMap',
        'normalMap',
        'normalScale',
        'opacity',
        'roughness',
        'roughnessMap',
        'sheen',
        'sheenColor',
        'sheenColorMap',
        'sheenRoughnessMap',
        'shininess',
        'specular',
        'specularColor',
        'specularColorMap',
        'specularIntensity',
        'specularIntensityMap',
        'specularMap',
        'thickness',
        'transmission',
        'transmissionMap'
    ];

    const _lightsCache = new WeakMap();
    class NodeMaterialObserver {
        constructor(builder) {
            this.renderObjects = new WeakMap();
            this.hasNode = this.containsNode(builder);
            this.hasAnimation = builder.object.isSkinnedMesh === true;
            this.refreshUniforms = refreshUniforms;
            this.renderId = 0;
        }
        firstInitialization(renderObject) {
            const hasInitialized = this.renderObjects.has(renderObject);
            if (hasInitialized === false) {
                this.getRenderObjectData(renderObject);
                return true;
            }
            return false;
        }
        needsVelocity(renderer) {
            const mrt = renderer.getMRT();
            return (mrt !== null && mrt.has('velocity'));
        }
        getRenderObjectData(renderObject) {
            let data = this.renderObjects.get(renderObject);
            if (data === undefined) {
                const { geometry, material, object } = renderObject;
                data = {
                    material: this.getMaterialData(material),
                    geometry: {
                        id: geometry.id,
                        attributes: this.getAttributesData(geometry.attributes),
                        indexVersion: geometry.index ? geometry.index.version : null,
                        drawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }
                    },
                    worldMatrix: object.matrixWorld.clone()
                };
                if (object.center) {
                    data.center = object.center.clone();
                }
                if (object.morphTargetInfluences) {
                    data.morphTargetInfluences = object.morphTargetInfluences.slice();
                }
                if (renderObject.bundle !== null) {
                    data.version = renderObject.bundle.version;
                }
                if (data.material.transmission > 0) {
                    const { width, height } = renderObject.context;
                    data.bufferWidth = width;
                    data.bufferHeight = height;
                }
                data.lights = this.getLightsData(renderObject.lightsNode.getLights());
                this.renderObjects.set(renderObject, data);
            }
            return data;
        }
        getAttributesData(attributes) {
            const attributesData = {};
            for (const name in attributes) {
                const attribute = attributes[name];
                attributesData[name] = {
                    version: attribute.version
                };
            }
            return attributesData;
        }
        containsNode(builder) {
            const material = builder.material;
            for (const property in material) {
                if (material[property] && material[property].isNode)
                    return true;
            }
            if (builder.renderer.overrideNodes.modelViewMatrix !== null || builder.renderer.overrideNodes.modelNormalViewMatrix !== null)
                return true;
            return false;
        }
        getMaterialData(material) {
            const data = {};
            for (const property of this.refreshUniforms) {
                const value = material[property];
                if (value === null || value === undefined) continue;
                if (typeof value === 'object' && value.clone !== undefined) {
                    if (value.isTexture === true) {
                        data[property] = { id: value.id, version: value.version };
                    } else {
                        data[property] = value.clone();
                    }
                } else {
                    data[property] = value;
                }
            }
            return data;
        }
        equals(renderObject, lightsData) {
            const { object, material, geometry } = renderObject;
            const renderObjectData = this.getRenderObjectData(renderObject);
            // world matrix
            if (renderObjectData.worldMatrix.equals(object.matrixWorld) !== true) {
                renderObjectData.worldMatrix.copy(object.matrixWorld);
                return false;
            }
            // material
            const materialData = renderObjectData.material;
            for (const property in materialData) {
                const value = materialData[property];
                const mtlValue = material[property];
                if (value.equals !== undefined) {
                    if (value.equals(mtlValue) === false) {
                        value.copy(mtlValue);
                        return false;
                    }
                } else if (mtlValue.isTexture === true) {
                    if (value.id !== mtlValue.id || value.version !== mtlValue.version) {
                        value.id = mtlValue.id;
                        value.version = mtlValue.version;
                        return false;
                    }
                } else if (value !== mtlValue) {
                    materialData[property] = mtlValue;
                    return false;
                }
            }
            if (materialData.transmission > 0) {
                const { width, height } = renderObject.context;
                if (renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height) {
                    renderObjectData.bufferWidth = width;
                    renderObjectData.bufferHeight = height;
                    return false;
                }
            }
            // geometry
            const storedGeometryData = renderObjectData.geometry;
            const attributes = geometry.attributes;
            const storedAttributes = storedGeometryData.attributes;
            const storedAttributeNames = Object.keys(storedAttributes);
            const currentAttributeNames = Object.keys(attributes);
            if (storedGeometryData.id !== geometry.id) {
                storedGeometryData.id = geometry.id;
                return false;
            }
            if (storedAttributeNames.length !== currentAttributeNames.length) {
                renderObjectData.geometry.attributes = this.getAttributesData(attributes);
                return false;
            }
            // compare each attribute
            for (const name of storedAttributeNames) {
                const storedAttributeData = storedAttributes[name];
                const attribute = attributes[name];
                if (attribute === undefined) {
                    // attribute was removed
                    delete storedAttributes[name];
                    return false;
                }
                if (storedAttributeData.version !== attribute.version) {
                    storedAttributeData.version = attribute.version;
                    return false;
                }
            }
            // check index
            const index = geometry.index;
            const storedIndexVersion = storedGeometryData.indexVersion;
            const currentIndexVersion = index ? index.version : null;
            if (storedIndexVersion !== currentIndexVersion) {
                storedGeometryData.indexVersion = currentIndexVersion;
                return false;
            }
            // check drawRange
            if (storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count) {
                storedGeometryData.drawRange.start = geometry.drawRange.start;
                storedGeometryData.drawRange.count = geometry.drawRange.count;
                return false;
            }
            // morph targets
            if (renderObjectData.morphTargetInfluences) {
                let morphChanged = false;
                for (let i = 0; i < renderObjectData.morphTargetInfluences.length; i++) {
                    if (renderObjectData.morphTargetInfluences[i] !== object.morphTargetInfluences[i]) {
                        morphChanged = true;
                    }
                }
                if (morphChanged) return true;
            }
            // lights
            if (renderObjectData.lights) {
                for (let i = 0; i < lightsData.length; i++) {
                    if (renderObjectData.lights[i].map !== lightsData[i].map) {
                        return false;
                    }
                }
            }
            // center
            if (renderObjectData.center) {
                if (renderObjectData.center.equals(object.center) === false) {
                    renderObjectData.center.copy(object.center);
                    return true;
                }
            }
            // bundle
            if (renderObject.bundle !== null) {
                renderObjectData.version = renderObject.bundle.version;
            }
            return true;
        }
        getLightsData(materialLights) {
            const lights = [];
            for (const light of materialLights) {
                if (light.isSpotLight === true && light.map !== null) {
                    // only add lights that have a map
                    lights.push({ map: light.map.version });
                }
            }
            return lights;
        }
        getLights(lightsNode, renderId) {
            if (_lightsCache.has(lightsNode)) {
                const cached = _lightsCache.get(lightsNode);
                if (cached.renderId === renderId) {
                    return cached.lightsData;
                }
            }
            const lightsData = this.getLightsData(lightsNode.getLights());
            _lightsCache.set(lightsNode, { renderId, lightsData });
            return lightsData;
        }
        needsRefresh(renderObject, nodeFrame) {
            if (this.hasNode || this.hasAnimation || this.firstInitialization(renderObject) || this.needsVelocity(nodeFrame.renderer))
                return true;
            const { renderId } = nodeFrame;
            if (this.renderId !== renderId) {
                this.renderId = renderId;
                return true;
            }
            const isStatic = renderObject.object.static === true;
            const isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData(renderObject).version === renderObject.bundle.version;
            if (isStatic || isBundle)
                return false;
            const lightsData = this.getLights(renderObject.lightsNode, renderId);
            const notEqual = this.equals(renderObject, lightsData) !== true;
            return notEqual;
        }
    }
    // cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.
    // A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.
    // Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
    // See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480
    // https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
    function cyrb53(value, seed = 0) {
        let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
        if (value instanceof Array) {
            for (let i = 0, val; i < value.length; i++) {
                val = value[i];
                h1 = Math.imul(h1 ^ val, 2654435761);
                h2 = Math.imul(h2 ^ val, 1597334677);
            }
        } else {
            for (let i = 0, ch; i < value.length; i++) {
                ch = value.charCodeAt(i);
                h1 = Math.imul(h1 ^ ch, 2654435761);
                h2 = Math.imul(h2 ^ ch, 1597334677);
            }
        }
        h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507);
        h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);
        h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507);
        h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909);
        return 4294967296 * (2097151 & h2) + (h1 >>> 0);
    }
    const hashString = (str) => cyrb53(str);
    const hashArray = (array) => cyrb53(array);
    const hash$1 = (...params) => cyrb53(params);
    function getCacheKey$1(object, force = false) {
        const values = [];
        if (object.isNode === true) {
            values.push(object.id);
            object = object.getSelf();
        }
        for (const { property, childNode } of getNodeChildren(object)) {
            values.push(cyrb53(property.slice(0, -4)), childNode.getCacheKey(force));
        }
        return cyrb53(values);
    }
    function* getNodeChildren(node, toJSON = false) {
        for (const property in node) {
            // Ignore private properties.
            if (property.startsWith('_') === true) continue;
            const object = node[property];
            if (Array.isArray(object) === true) {
                for (let i = 0; i < object.length; i++) {
                    const child = object[i];
                    if (child && (child.isNode === true || toJSON && typeof child.toJSON === 'function')) {
                        yield { property, index: i, childNode: child };
                    }
                }
            } else if (object && object.isNode === true) {
                yield { property, childNode: object };
            } else if (object && Object.getPrototypeOf(object) === Object.prototype) {
                for (const subProperty in object) {
                    // Ignore private properties.
                    if (subProperty.startsWith('_') === true) continue;
                    const child = object[subProperty];
                    if (child && (child.isNode === true || toJSON && typeof child.toJSON === 'function')) {
                        yield { property, index: subProperty, childNode: child };
                    }
                }
            }
        }
    }
    const typeFromLength = /*@__PURE__*/ new Map([
        [1, 'float'],
        [2, 'vec2'],
        [3, 'vec3'],
        [4, 'vec4'],
        [9, 'mat3'],
        [16, 'mat4']
    ]);
    const dataFromObject = /*@__PURE__*/ new WeakMap();
    function getTypeFromLength(length) {
        return typeFromLength.get(length);
    }
    function getTypedArrayFromType(type) {
        // Handle component type for vectors and matrices
        if (/[iu]?vec\d/.test(type)) {
            // Handle int vectors
            if (type.startsWith('ivec')) return Int32Array;
            // Handle uint vectors
            if (type.startsWith('uvec')) return Uint32Array;
            // Default to float vectors
            return Float32Array;
        }
        // Handle matrices (always float)
        if (/mat\d/.test(type)) return Float32Array;
        // Basic types
        if (/float/.test(type)) return Float32Array;
        if (/uint/.test(type)) return Uint32Array;
        if (/int/.test(type)) return Int32Array;
        throw new Error(`THREE.NodeUtils: Unsupported type: ${type}`);
    }
    function getLengthFromType(type) {
        if (/float|int|uint/.test(type)) return 1;
        if (/vec2/.test(type)) return 2;
        if (/vec3/.test(type)) return 3;
        if (/vec4/.test(type)) return 4;
        if (/mat2/.test(type)) return 4;
        if (/mat3/.test(type)) return 9;
        if (/mat4/.test(type)) return 16;
        console.error('THREE.TSL: Unsupported type:', type);
    }
    function getMemoryLengthFromType(type) {
        if (/float|int|uint/.test(type)) return 1;
        if (/vec2/.test(type)) return 2;
        if (/vec3/.test(type)) return 3;
        if (/vec4/.test(type)) return 4;
        if (/mat2/.test(type)) return 4;
        if (/mat3/.test(type)) return 12;
        if (/mat4/.test(type)) return 16;
        console.error('THREE.TSL: Unsupported type:', type);
    }
    function getByteBoundaryFromType(type) {
        if (/float|int|uint/.test(type)) return 4;
        if (/vec2/.test(type)) return 8;
        if (/vec3/.test(type)) return 16;
        if (/vec4/.test(type)) return 16;
        if (/mat2/.test(type)) return 8;
        if (/mat3/.test(type)) return 48;
        if (/mat4/.test(type)) return 64;
        console.error('THREE.TSL: Unsupported type:', type);
    }
    function getValueType(value) {
        if (value === undefined || value === null) return null;
        const typeOf = typeof value;
        if (value.isNode === true) {
            return 'node';
        } else if (typeOf === 'number') {
            return 'float';
        } else if (typeOf === 'boolean') {
            return 'bool';
        } else if (typeOf === 'string') {
            return 'string';
        } else if (typeOf === 'function') {
            return 'shader';
        } else if (value.isVector2 === true) {
            return 'vec2';
        } else if (value.isVector3 === true) {
            return 'vec3';
        } else if (value.isVector4 === true) {
            return 'vec4';
        } else if (value.isMatrix2 === true) {
            return 'mat2';
        } else if (value.isMatrix3 === true) {
            return 'mat3';
        } else if (value.isMatrix4 === true) {
            return 'mat4';
        } else if (value.isColor === true) {
            return 'color';
        } else if (value instanceof ArrayBuffer) {
            return 'ArrayBuffer';
        }
        return null;
    }
    function getValueFromType(type, ...params) {
        const last4 = type ? type.slice(-4) : undefined;
        if (params.length === 1) { // ensure same behaviour as in NodeBuilder.format()
            if (last4 === 'vec2') params = [params[0], params[0]];
            else if (last4 === 'vec3') params = [params[0], params[0], params[0]];
            else if (last4 === 'vec4') params = [params[0], params[0], params[0], params[0]];
        }
        if (type === 'color') {
            return new Color(...params);
        } else if (last4 === 'vec2') {
            return new Vector2(...params);
        } else if (last4 === 'vec3') {
            return new Vector3(...params);
        } else if (last4 === 'vec4') {
            return new Vector4(...params);
        } else if (last4 === 'mat2') {
            return new Matrix2(...params);
        } else if (last4 === 'mat3') {
            return new Matrix3(...params);
        } else if (last4 === 'mat4') {
            return new Matrix4(...params);
        } else if (type === 'bool') {
            return params[0] || false;
        } else if ((type === 'float') || (type === 'int') || (type === 'uint')) {
            return params[0] || 0;
        } else if (type === 'string') {
            return params[0] || '';
        } else if (type === 'ArrayBuffer') {
            return base64ToArrayBuffer(params[0]);
        }
        return null;
    }
    function getDataFromObject(object) {
        let data = dataFromObject.get(object);
        if (data === undefined) {
            data = {};
            dataFromObject.set(object, data);
        }
        return data;
    }
    function arrayBufferToBase64(arrayBuffer) {
        let chars = '';
        const array = new Uint8Array(arrayBuffer);
        for (let i = 0; i < array.length; i++) {
            chars += String.fromCharCode(array[i]);
        }
        return btoa(chars);
    }
    function base64ToArrayBuffer(base64) {
        return Uint8Array.from(atob(base64), c => c.charCodeAt(0)).buffer;
    }
    var NodeUtils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        arrayBufferToBase64: arrayBufferToBase64,
        base64ToArrayBuffer: base64ToArrayBuffer,
        getByteBoundaryFromType: getByteBoundaryFromType,
        getCacheKey: getCacheKey$1,
        getDataFromObject: getDataFromObject,
        getLengthFromType: getLengthFromType,
        getMemoryLengthFromType: getMemoryLengthFromType,
        getNodeChildren: getNodeChildren,
        getTypeFromLength: getTypeFromLength,
        getTypedArrayFromType: getTypedArrayFromType,
        getValueFromType: getValueFromType,
        getValueType: getValueType,
        hash: hash$1,
        hashArray: hashArray,
        hashString: hashString
    });
    const NodeShaderStage = {
        VERTEX: 'vertex',
        FRAGMENT: 'fragment'
    };
    const NodeUpdateType = {
        NONE: 'none',
        FRAME: 'frame',
        RENDER: 'render',
        OBJECT: 'object'
    };
    const NodeType = {
        BOOLEAN: 'bool',
        INTEGER: 'int',
        FLOAT: 'float',
        VECTOR2: 'vec2',
        VECTOR3: 'vec3',
        VECTOR4: 'vec4',
        MATRIX2: 'mat2',
        MATRIX3: 'mat3',
        MATRIX4: 'mat4'
    };
    const NodeAccess = {
        READ_ONLY: 'readOnly',
        WRITE_ONLY: 'writeOnly',
        READ_WRITE: 'readWrite',
    };
    const defaultShaderStages = ['fragment', 'vertex'];
    const defaultBuildStages = ['setup', 'analyze', 'generate'];
    const shaderStages = [...defaultShaderStages, 'compute'];
    const vectorComponents = ['x', 'y', 'z', 'w'];
    const _parentBuildStage = {
        analyze: 'setup',
        generate: 'analyze'
    };
    let _nodeId = 0;
    class Node extends EventDispatcher {
        static get type() {
            return 'Node';
        }
        constructor(nodeType = null) {
            super();
            this.nodeType = nodeType;
            this.updateType = NodeUpdateType.NONE;
            this.updateBeforeType = NodeUpdateType.NONE;
            this.updateAfterType = NodeUpdateType.NONE;
            this.uuid = MathUtils.generateUUID();
            this.version = 0;
            this.global = false;
            this.parents = false;
            this.isNode = true;
            // private
            this._cacheKey = null;
            this._cacheKeyVersion = 0;
            Object.defineProperty(this, 'id', { value: _nodeId++ });
        }
        set needsUpdate(value) {
            if (value === true) {
                this.version++;
            }
        }
        get type() {
            return this.constructor.type;
        }
        onUpdate(callback, updateType) {
            this.updateType = updateType;
            this.update = callback.bind(this.getSelf());
            return this;
        }
        onFrameUpdate(callback) {
            return this.onUpdate(callback, NodeUpdateType.FRAME);
        }
        onRenderUpdate(callback) {
            return this.onUpdate(callback, NodeUpdateType.RENDER);
        }
        onObjectUpdate(callback) {
            return this.onUpdate(callback, NodeUpdateType.OBJECT);
        }
        onReference(callback) {
            this.updateReference = callback.bind(this.getSelf());
            return this;
        }
        getSelf() {
            // Returns non-node object.
            return this.self || this;
        }
        updateReference( /*state*/) {
            return this;
        }
        isGlobal( /*builder*/) {
            return this.global;
        }
        * getChildren() {
            for (const { childNode } of getNodeChildren(this)) {
                yield childNode;
            }
        }
        dispose() {
            this.dispatchEvent({ type: 'dispose' });
        }

        traverse(callback) {
            callback(this);
            for (const childNode of this.getChildren()) {
                childNode.traverse(callback);
            }
        }
        getCacheKey(force = false) {
            force = force || this.version !== this._cacheKeyVersion;
            if (force === true || this._cacheKey === null) {
                this._cacheKey = hash$1(getCacheKey$1(this, force), this.customCacheKey());
                this._cacheKeyVersion = this.version;
            }
            return this._cacheKey;
        }
        customCacheKey() {
            return 0;
        }
        getScope() {
            return this;
        }
        getHash( /*builder*/) {
            return this.uuid;
        }
        getUpdateType() {
            return this.updateType;
        }
        getUpdateBeforeType() {
            return this.updateBeforeType;
        }
        getUpdateAfterType() {
            return this.updateAfterType;
        }
        getElementType(builder) {
            const type = this.getNodeType(builder);
            const elementType = builder.getElementType(type);
            return elementType;
        }
        getMemberType( /*builder, name*/) {
            return 'void';
        }
        getNodeType(builder) {
            const nodeProperties = builder.getNodeProperties(this);
            if (nodeProperties.outputNode) {
                return nodeProperties.outputNode.getNodeType(builder);
            }
            return this.nodeType;
        }
        getShared(builder) {
            const hash = this.getHash(builder);
            const nodeFromHash = builder.getNodeFromHash(hash);
            return nodeFromHash || this;
        }
        getArrayCount( /*builder*/) {
            return null;
        }
        setup(builder) {
            const nodeProperties = builder.getNodeProperties(this);
            let index = 0;
            for (const childNode of this.getChildren()) {
                nodeProperties['node' + index++] = childNode;
            }
            // return a outputNode if exists or null
            return nodeProperties.outputNode || null;
        }
        analyze(builder, output = null) {
            const usageCount = builder.increaseUsage(this);
            if (this.parents === true) {
                const nodeData = builder.getDataFromNode(this, 'any');
                nodeData.stages = nodeData.stages || {};
                nodeData.stages[builder.shaderStage] = nodeData.stages[builder.shaderStage] || [];
                nodeData.stages[builder.shaderStage].push(output);
            }
            if (usageCount === 1) {
                // node flow children
                const nodeProperties = builder.getNodeProperties(this);
                for (const childNode of Object.values(nodeProperties)) {
                    if (childNode && childNode.isNode === true) {
                        childNode.build(builder, this);
                    }
                }
            }
        }
        generate(builder, output) {
            const { outputNode } = builder.getNodeProperties(this);
            if (outputNode && outputNode.isNode === true) {
                return outputNode.build(builder, output);
            }
        }
        updateBefore( /*frame*/) {
            console.warn('Abstract function.');
        }
        updateAfter( /*frame*/) {
            console.warn('Abstract function.');
        }
        update( /*frame*/) {
            console.warn('Abstract function.');
        }
        build(builder, output = null) {
            const refNode = this.getShared(builder);
            if (this !== refNode) {
                return refNode.build(builder, output);
            }
            //
            const nodeData = builder.getDataFromNode(this);
            nodeData.buildStages = nodeData.buildStages || {};
            nodeData.buildStages[builder.buildStage] = true;
            const parentBuildStage = _parentBuildStage[builder.buildStage];
            if (parentBuildStage && nodeData.buildStages[parentBuildStage] !== true) {
                // force parent build stage (setup or analyze)
                const previousBuildStage = builder.getBuildStage();
                builder.setBuildStage(parentBuildStage);
                this.build(builder);
                builder.setBuildStage(previousBuildStage);
            }
            //
            builder.addNode(this);
            builder.addChain(this);
            /* Build stages expected results:
                - "setup"		-> Node
                - "analyze"		-> null
                - "generate"	-> String
            */
            let result = null;
            const buildStage = builder.getBuildStage();
            if (buildStage === 'setup') {
                this.updateReference(builder);
                const properties = builder.getNodeProperties(this);
                if (properties.initialized !== true) {
                    //const stackNodesBeforeSetup = builder.stack.nodes.length;
                    properties.initialized = true;
                    properties.outputNode = this.setup(builder) || properties.outputNode || null;
                    /*if ( isNodeOutput && builder.stack.nodes.length !== stackNodesBeforeSetup ) {
                        // !! no outputNode !!
                        //outputNode = builder.stack;
                    }*/
                    for (const childNode of Object.values(properties)) {
                        if (childNode && childNode.isNode === true) {
                            if (childNode.parents === true) {
                                const childProperties = builder.getNodeProperties(childNode);
                                childProperties.parents = childProperties.parents || [];
                                childProperties.parents.push(this);
                            }
                            childNode.build(builder);
                        }
                    }
                }
                result = properties.outputNode;
            } else if (buildStage === 'analyze') {
                this.analyze(builder, output);
            } else if (buildStage === 'generate') {
                const isGenerateOnce = this.generate.length === 1;
                if (isGenerateOnce) {
                    const type = this.getNodeType(builder);
                    const nodeData = builder.getDataFromNode(this);
                    result = nodeData.snippet;
                    if (result === undefined) {
                        if (nodeData.generated === undefined) {
                            nodeData.generated = true;
                            result = this.generate(builder) || '';
                            nodeData.snippet = result;
                        } else {
                            console.warn('THREE.Node: Recursion detected.', this);
                            result = '/* Recursion detected. */';
                        }
                    } else if (nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined) {
                        builder.addFlowCodeHierarchy(this, builder.context.nodeBlock);
                    }
                    result = builder.format(result, type, output);
                } else {
                    result = this.generate(builder, output) || '';
                }
            }
            builder.removeChain(this);
            builder.addSequentialNode(this);
            return result;
        }
        getSerializeChildren() {
            return getNodeChildren(this);
        }
        serialize(json) {
            const nodeChildren = this.getSerializeChildren();
            const inputNodes = {};
            for (const { property, index, childNode } of nodeChildren) {
                if (index !== undefined) {
                    if (inputNodes[property] === undefined) {
                        inputNodes[property] = Number.isInteger(index) ? [] : {};
                    }
                    inputNodes[property][index] = childNode.toJSON(json.meta).uuid;
                } else {
                    inputNodes[property] = childNode.toJSON(json.meta).uuid;
                }
            }
            if (Object.keys(inputNodes).length > 0) {
                json.inputNodes = inputNodes;
            }
        }
        deserialize(json) {
            if (json.inputNodes !== undefined) {
                const nodes = json.meta.nodes;
                for (const property in json.inputNodes) {
                    if (Array.isArray(json.inputNodes[property])) {
                        const inputArray = [];
                        for (const uuid of json.inputNodes[property]) {
                            inputArray.push(nodes[uuid]);
                        }
                        this[property] = inputArray;
                    } else if (typeof json.inputNodes[property] === 'object') {
                        const inputObject = {};
                        for (const subProperty in json.inputNodes[property]) {
                            const uuid = json.inputNodes[property][subProperty];
                            inputObject[subProperty] = nodes[uuid];
                        }
                        this[property] = inputObject;
                    } else {
                        const uuid = json.inputNodes[property];
                        this[property] = nodes[uuid];
                    }
                }
            }
        }
        toJSON(meta) {
            const { uuid, type } = this;
            const isRoot = (meta === undefined || typeof meta === 'string');
            if (isRoot) {
                meta = {
                    textures: {},
                    images: {},
                    nodes: {}
                };
            }
            // serialize
            let data = meta.nodes[uuid];
            if (data === undefined) {
                data = {
                    uuid,
                    type,
                    meta,
                    metadata: {
                        version: 4.7,
                        type: 'Node',
                        generator: 'Node.toJSON'
                    }
                };
                if (isRoot !== true) meta.nodes[data.uuid] = data;
                this.serialize(data);
                delete data.meta;
            }
            // TODO: Copied from Object3D.toJSON
            function extractFromCache(cache) {
                const values = [];
                for (const key in cache) {
                    const data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
            if (isRoot) {
                const textures = extractFromCache(meta.textures);
                const images = extractFromCache(meta.images);
                const nodes = extractFromCache(meta.nodes);
                if (textures.length > 0) data.textures = textures;
                if (images.length > 0) data.images = images;
                if (nodes.length > 0) data.nodes = nodes;
            }
            return data;
        }
    }
    class ArrayElementNode extends Node { // @TODO: If extending from TempNode it breaks webgpu_compute
        static get type() {
            return 'ArrayElementNode';
        }
        constructor(node, indexNode) {
            super();
            this.node = node;
            this.indexNode = indexNode;
            this.isArrayElementNode = true;
        }
        getNodeType(builder) {
            return this.node.getElementType(builder);
        }
        generate(builder) {
            const indexType = this.indexNode.getNodeType(builder);
            const nodeSnippet = this.node.build(builder);
            const indexSnippet = this.indexNode.build(builder, !builder.isVector(indexType) && builder.isInteger(indexType) ? indexType : 'uint');
            return `${nodeSnippet}[ ${indexSnippet} ]`;
        }
    }
    class ConvertNode extends Node {
        static get type() {
            return 'ConvertNode';
        }
        constructor(node, convertTo) {
            super();
            this.node = node;
            this.convertTo = convertTo;
        }
        getNodeType(builder) {
            const requestType = this.node.getNodeType(builder);
            let convertTo = null;
            for (const overloadingType of this.convertTo.split('|')) {
                if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {
                    convertTo = overloadingType;
                }
            }
            return convertTo;
        }
        serialize(data) {
            super.serialize(data);
            data.convertTo = this.convertTo;
        }
        deserialize(data) {
            super.deserialize(data);
            this.convertTo = data.convertTo;
        }
        generate(builder, output) {
            const node = this.node;
            const type = this.getNodeType(builder);
            const snippet = node.build(builder, type);
            return builder.format(snippet, type, output);
        }
    }
    class TempNode extends Node {
        static get type() {
            return 'TempNode';
        }
        constructor(nodeType = null) {
            super(nodeType);
            this.isTempNode = true;
        }
        hasDependencies(builder) {
            return builder.getDataFromNode(this).usageCount > 1;
        }
        build(builder, output) {
            const buildStage = builder.getBuildStage();
            if (buildStage === 'generate') {
                const type = builder.getVectorType(this.getNodeType(builder, output));
                const nodeData = builder.getDataFromNode(this);
                if (nodeData.propertyName !== undefined) {
                    return builder.format(nodeData.propertyName, type, output);
                } else if (type !== 'void' && output !== 'void' && this.hasDependencies(builder)) {
                    const snippet = super.build(builder, type);
                    const nodeVar = builder.getVarFromNode(this, null, type);
                    const propertyName = builder.getPropertyName(nodeVar);
                    builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
                    nodeData.snippet = snippet;
                    nodeData.propertyName = propertyName;
                    return builder.format(nodeData.propertyName, type, output);
                }
            }
            return super.build(builder, output);
        }
    }
    class JoinNode extends TempNode {
        static get type() {
            return 'JoinNode';
        }
        constructor(nodes = [], nodeType = null) {
            super(nodeType);
            this.nodes = nodes;
        }
        getNodeType(builder) {
            if (this.nodeType !== null) {
                return builder.getVectorType(this.nodeType);
            }
            return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
        }
        generate(builder, output) {
            const type = this.getNodeType(builder);
            const maxLength = builder.getTypeLength(type);
            const nodes = this.nodes;
            const primitiveType = builder.getComponentType(type);
            const snippetValues = [];
            let length = 0;
            for (const input of nodes) {
                if (length >= maxLength) {
                    console.error(`THREE.TSL: Length of parameters exceeds maximum length of function '${type}()' type.`);
                    break;
                }
                let inputType = input.getNodeType(builder);
                let inputTypeLength = builder.getTypeLength(inputType);
                let inputSnippet;
                if (length + inputTypeLength > maxLength) {
                    console.error(`THREE.TSL: Length of '${type}()' data exceeds maximum length of output type.`);
                    inputTypeLength = maxLength - length;
                    inputType = builder.getTypeFromLength(inputTypeLength);
                }
                length += inputTypeLength;
                inputSnippet = input.build(builder, inputType);
                const inputPrimitiveType = builder.getComponentType(inputType);
                if (inputPrimitiveType !== primitiveType) {
                    inputSnippet = builder.format(inputSnippet, inputPrimitiveType, primitiveType);
                }
                snippetValues.push(inputSnippet);
            }
            const snippet = `${builder.getType(type)}( ${snippetValues.join(', ')} )`;
            return builder.format(snippet, type, output);
        }
    }
    const _stringVectorComponents = vectorComponents.join('');
    class SplitNode extends Node {
        static get type() {
            return 'SplitNode';
        }
        constructor(node, components = 'x') {
            super();
            this.node = node;
            this.components = components;
            this.isSplitNode = true;
        }
        getVectorLength() {
            let vectorLength = this.components.length;
            for (const c of this.components) {
                vectorLength = Math.max(vectorComponents.indexOf(c) + 1, vectorLength);
            }
            return vectorLength;
        }
        getComponentType(builder) {
            return builder.getComponentType(this.node.getNodeType(builder));
        }
        getNodeType(builder) {
            return builder.getTypeFromLength(this.components.length, this.getComponentType(builder));
        }
        generate(builder, output) {
            const node = this.node;
            const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
            let snippet = null;
            if (nodeTypeLength > 1) {
                let type = null;
                const componentsLength = this.getVectorLength();
                if (componentsLength >= nodeTypeLength) {
                    // needed expand the input node
                    type = builder.getTypeFromLength(this.getVectorLength(), this.getComponentType(builder));
                }
                const nodeSnippet = node.build(builder, type);
                if (this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice(0, this.components.length)) {
                    // unnecessary swizzle
                    snippet = builder.format(nodeSnippet, type, output);
                } else {
                    snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output);
                }
            } else {
                // ignore .components if .node returns float/integer
                snippet = node.build(builder, output);
            }
            return snippet;
        }
        serialize(data) {
            super.serialize(data);
            data.components = this.components;
        }
        deserialize(data) {
            super.deserialize(data);
            this.components = data.components;
        }
    }
    class SetNode extends TempNode {
        static get type() {
            return 'SetNode';
        }
        constructor(sourceNode, components, targetNode) {
            super();
            this.sourceNode = sourceNode;
            this.components = components;
            this.targetNode = targetNode;
        }
        getNodeType(builder) {
            return this.sourceNode.getNodeType(builder);
        }
        generate(builder) {
            const { sourceNode, components, targetNode } = this;
            const sourceType = this.getNodeType(builder);
            const componentType = builder.getComponentType(targetNode.getNodeType(builder));
            const targetType = builder.getTypeFromLength(components.length, componentType);
            const targetSnippet = targetNode.build(builder, targetType);
            const sourceSnippet = sourceNode.build(builder, sourceType);
            const length = builder.getTypeLength(sourceType);
            const snippetValues = [];
            for (let i = 0; i < length; i++) {
                const component = vectorComponents[i];
                if (component === components[0]) {
                    snippetValues.push(targetSnippet);
                    i += components.length - 1;
                } else {
                    snippetValues.push(sourceSnippet + '.' + component);
                }
            }
            return `${builder.getType(sourceType)}( ${snippetValues.join(', ')} )`;
        }
    }
    class FlipNode extends TempNode {
        static get type() {
            return 'FlipNode';
        }
        constructor(sourceNode, components) {
            super();
            this.sourceNode = sourceNode;
            this.components = components;
        }
        getNodeType(builder) {
            return this.sourceNode.getNodeType(builder);
        }
        generate(builder) {
            const { components, sourceNode } = this;
            const sourceType = this.getNodeType(builder);
            const sourceSnippet = sourceNode.build(builder);
            const sourceCache = builder.getVarFromNode(this);
            const sourceProperty = builder.getPropertyName(sourceCache);
            builder.addLineFlowCode(sourceProperty + ' = ' + sourceSnippet, this);
            const length = builder.getTypeLength(sourceType);
            const snippetValues = [];
            let componentIndex = 0;
            for (let i = 0; i < length; i++) {
                const component = vectorComponents[i];
                if (component === components[componentIndex]) {
                    snippetValues.push('1.0 - ' + (sourceProperty + '.' + component));
                    componentIndex++;
                } else {
                    snippetValues.push(sourceProperty + '.' + component);
                }
            }
            return `${builder.getType(sourceType)}( ${snippetValues.join(', ')} )`;
        }
    }
    class InputNode extends Node {
        static get type() {
            return 'InputNode';
        }
        constructor(value, nodeType = null) {
            super(nodeType);
            this.isInputNode = true;
            this.value = value;
            this.precision = null;
        }
        getNodeType( /*builder*/) {
            if (this.nodeType === null) {
                return getValueType(this.value);
            }
            return this.nodeType;
        }
        getInputType(builder) {
            return this.getNodeType(builder);
        }
        setPrecision(precision) {
            this.precision = precision;
            return this;
        }
        serialize(data) {
            super.serialize(data);
            data.value = this.value;
            if (this.value && this.value.toArray) data.value = this.value.toArray();
            data.valueType = getValueType(this.value);
            data.nodeType = this.nodeType;
            if (data.valueType === 'ArrayBuffer') data.value = arrayBufferToBase64(data.value);
            data.precision = this.precision;
        }
        deserialize(data) {
            super.deserialize(data);
            this.nodeType = data.nodeType;
            this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;
            this.precision = data.precision || null;
            if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);
        }
        generate( /*builder, output*/) {
            console.warn('Abstract function.');
        }
    }
    const _regNum = /float|u?int/;
    class ConstNode extends InputNode {
        static get type() {
            return 'ConstNode';
        }
        constructor(value, nodeType = null) {
            super(value, nodeType);
            this.isConstNode = true;
        }
        generateConst(builder) {
            return builder.generateConst(this.getNodeType(builder), this.value);
        }
        generate(builder, output) {
            const type = this.getNodeType(builder);
            if (_regNum.test(type) && _regNum.test(output)) {
                return builder.generateConst(output, this.value);
            }
            return builder.format(this.generateConst(builder), type, output);
        }
    }
    class MemberNode extends Node {
        static get type() {
            return 'MemberNode';
        }
        constructor(node, property) {
            super();
            this.node = node;
            this.property = property;
            this.isMemberNode = true;
        }
        getNodeType(builder) {
            return this.node.getMemberType(builder, this.property);
        }
        generate(builder) {
            const propertyName = this.node.build(builder);
            return propertyName + '.' + this.property;
        }
    }
    let currentStack = null;
    const NodeElements = new Map();
    function addMethodChaining(name, nodeElement) {
        if (NodeElements.has(name)) {
            console.warn(`THREE.TSL: Redefinition of method chaining '${name}'.`);
            return;
        }
        if (typeof nodeElement !== 'function') throw new Error(`THREE.TSL: Node element ${name} is not a function`);
        NodeElements.set(name, nodeElement);
    }
    const parseSwizzle = (props) => props.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');
    const parseSwizzleAndSort = (props) => parseSwizzle(props).split('').sort().join('');
    const shaderNodeHandler = {
        setup(NodeClosure, params) {
            const inputs = params.shift();
            return NodeClosure(nodeObjects(inputs), ...params);
        },
        get(node, prop, nodeObj) {
            if (typeof prop === 'string' && node[prop] === undefined) {
                if (node.isStackNode !== true && prop === 'assign') {
                    return (...params) => {
                        currentStack.assign(nodeObj, ...params);
                        return nodeObj;
                    };
                } else if (NodeElements.has(prop)) {
                    const nodeElement = NodeElements.get(prop);
                    return node.isStackNode ? (...params) => nodeObj.add(nodeElement(...params)) : (...params) => nodeElement(nodeObj, ...params);
                } else if (prop === 'toVarIntent') {
                    return () => nodeObj;
                } else if (prop === 'self') {
                    return node;
                } else if (prop.endsWith('Assign') && NodeElements.has(prop.slice(0, prop.length - 'Assign'.length))) {
                    const nodeElement = NodeElements.get(prop.slice(0, prop.length - 'Assign'.length));
                    return node.isStackNode ? (...params) => nodeObj.assign(params[0], nodeElement(...params)) : (...params) => nodeObj.assign(nodeElement(nodeObj, ...params));
                } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
                    // accessing properties ( swizzle )
                    prop = parseSwizzle(prop);
                    return nodeObject(new SplitNode(nodeObj, prop));
                } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {
                    // set properties ( swizzle ) and sort to xyzw sequence
                    prop = parseSwizzleAndSort(prop.slice(3).toLowerCase());
                    return (value) => nodeObject(new SetNode(node, prop, nodeObject(value)));
                } else if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {
                    // set properties ( swizzle ) and sort to xyzw sequence
                    prop = parseSwizzleAndSort(prop.slice(4).toLowerCase());
                    return () => nodeObject(new FlipNode(nodeObject(node), prop));
                } else if (prop === 'width' || prop === 'height' || prop === 'depth') {
                    // accessing property
                    if (prop === 'width') prop = 'x';
                    else if (prop === 'height') prop = 'y';
                    else if (prop === 'depth') prop = 'z';
                    return nodeObject(new SplitNode(node, prop));
                } else if (/^\d+$/.test(prop) === true) {
                    // accessing array
                    return nodeObject(new ArrayElementNode(nodeObj, new ConstNode(Number(prop), 'uint')));
                } else if (/^get$/.test(prop) === true) {
                    // accessing properties
                    return (value) => nodeObject(new MemberNode(nodeObj, value));
                }
            }
            return Reflect.get(node, prop, nodeObj);
        },
        set(node, prop, value, nodeObj) {
            if (typeof prop === 'string' && node[prop] === undefined) {
                // setting properties
                if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\d+$/.test(prop) === true) {
                    nodeObj[prop].assign(value);
                    return true;
                }
            }
            return Reflect.set(node, prop, value, nodeObj);
        }
    };
    const nodeObjectsCacheMap = new WeakMap();
    const nodeBuilderFunctionsCacheMap = new WeakMap();
    const ShaderNodeObject = function (obj, altType = null) {
        const type = getValueType(obj);
        if (type === 'node') {
            let nodeObject = nodeObjectsCacheMap.get(obj);
            if (nodeObject === undefined) {
                nodeObject = new Proxy(obj, shaderNodeHandler);
                nodeObjectsCacheMap.set(obj, nodeObject);
                nodeObjectsCacheMap.set(nodeObject, nodeObject);
            }
            return nodeObject;
        } else if ((altType === null && (type === 'float' || type === 'boolean')) || (type && type !== 'shader' && type !== 'string')) {
            return nodeObject(getConstNode(obj, altType));
        } else if (type === 'shader') {
            return obj.isFn ? obj : Fn(obj);
        }
        return obj;
    };
    const ShaderNodeObjects = function (objects, altType = null) {
        for (const name in objects) {
            objects[name] = nodeObject(objects[name], altType);
        }
        return objects;
    };
    const ShaderNodeArray = function (array, altType = null) {
        const len = array.length;
        for (let i = 0; i < len; i++) {
            array[i] = nodeObject(array[i], altType);
        }
        return array;
    };
    const ShaderNodeProxy = function (NodeClass, scope = null, factor = null, settings = null) {
        function assignNode(node) {
            if (settings !== null) {
                node = nodeObject(Object.assign(node, settings));
                if (settings.intent === true) {
                    node = node.toVarIntent();
                }
            } else {
                node = nodeObject(node);
            }
            return node;

        }
        let fn, name = scope, minParams, maxParams;
        function verifyParamsLimit(params) {
            let tslName;
            if (name) tslName = /[a-z]/i.test(name) ? name + '()' : name;
            else tslName = NodeClass.type;
            if (minParams !== undefined && params.length < minParams) {
                console.error(`THREE.TSL: "${tslName}" parameter length is less than minimum required.`);
                return params.concat(new Array(minParams - params.length).fill(0));
            } else if (maxParams !== undefined && params.length > maxParams) {
                console.error(`THREE.TSL: "${tslName}" parameter length exceeds limit.`);
                return params.slice(0, maxParams);
            }
            return params;
        }
        if (scope === null) {
            fn = (...params) => {
                return assignNode(new NodeClass(...nodeArray(verifyParamsLimit(params))));
            };
        } else if (factor !== null) {
            factor = nodeObject(factor);
            fn = (...params) => {
                return assignNode(new NodeClass(scope, ...nodeArray(verifyParamsLimit(params)), factor));
            };
        } else {
            fn = (...params) => {
                return assignNode(new NodeClass(scope, ...nodeArray(verifyParamsLimit(params))));
            };
        }
        fn.setParameterLength = (...params) => {
            if (params.length === 1) minParams = maxParams = params[0];
            else if (params.length === 2) [minParams, maxParams] = params;
            return fn;
        };
        fn.setName = (value) => {
            name = value;
            return fn;
        };
        return fn;
    };
    const ShaderNodeImmutable = function (NodeClass, ...params) {
        return nodeObject(new NodeClass(...nodeArray(params)));
    };
    class ShaderCallNodeInternal extends Node {
        constructor(shaderNode, inputNodes) {
            super();
            this.shaderNode = shaderNode;
            this.inputNodes = inputNodes;
            this.isShaderCallNodeInternal = true;
        }
        getNodeType(builder) {
            return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);
        }
        getMemberType(builder, name) {
            return this.getOutputNode(builder).getMemberType(builder, name);
        }
        call(builder) {
            const { shaderNode, inputNodes } = this;
            const properties = builder.getNodeProperties(shaderNode);
            const subBuild = builder.getClosestSubBuild(shaderNode.subBuilds) || '';
            const subBuildProperty = subBuild || 'default';
            if (properties[subBuildProperty]) {
                return properties[subBuildProperty];
            }
            //
            const previousSubBuildFn = builder.subBuildFn;
            builder.subBuildFn = subBuild;
            let result = null;
            if (shaderNode.layout) {
                let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);
                if (functionNodesCacheMap === undefined) {
                    functionNodesCacheMap = new WeakMap();
                    nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);
                }
                let functionNode = functionNodesCacheMap.get(shaderNode);
                if (functionNode === undefined) {
                    functionNode = nodeObject(builder.buildFunctionNode(shaderNode));
                    functionNodesCacheMap.set(shaderNode, functionNode);
                }
                builder.addInclude(functionNode);
                result = nodeObject(functionNode.call(inputNodes));
            } else {
                let inputs = inputNodes;
                if (Array.isArray(inputs)) {
                    // If inputs is an array, we need to convert it to a Proxy
                    // so we can call TSL functions using the syntax `Fn( ( { r, g, b } ) => { ... } )`
                    // and call through `fn( 0, 1, 0 )` or `fn( { r: 0, g: 1, b: 0 } )`
                    let index = 0;
                    inputs = new Proxy(inputs, {
                        get: (target, property, receiver) => {
                            if (target[property] === undefined) {
                                return target[index++];
                            } else {
                                return Reflect.get(target, property, receiver);
                            }
                        }
                    });
                }
                const jsFunc = shaderNode.jsFunc;
                const outputNode = inputs !== null || jsFunc.length > 1 ? jsFunc(inputs || [], builder) : jsFunc(builder);
                result = nodeObject(outputNode);
            }
            builder.subBuildFn = previousSubBuildFn;
            if (shaderNode.once) {
                properties[subBuildProperty] = result;
            }
            return result;
        }
        setupOutput(builder) {
            builder.addStack();
            builder.stack.outputNode = this.call(builder);
            return builder.removeStack();
        }
        getOutputNode(builder) {
            const properties = builder.getNodeProperties(this);
            const subBuildOutput = builder.getSubBuildOutput(this);
            properties[subBuildOutput] = properties[subBuildOutput] || this.setupOutput(builder);
            properties[subBuildOutput].subBuild = builder.getClosestSubBuild(this);
            return properties[subBuildOutput];
        }
        build(builder, output = null) {
            let result = null;
            const buildStage = builder.getBuildStage();
            const properties = builder.getNodeProperties(this);
            const subBuildOutput = builder.getSubBuildOutput(this);
            const outputNode = this.getOutputNode(builder);
            if (buildStage === 'setup') {
                const subBuildInitialized = builder.getSubBuildProperty('initialized', this);
                if (properties[subBuildInitialized] !== true) {
                    properties[subBuildInitialized] = true;
                    properties[subBuildOutput] = this.getOutputNode(builder);
                    properties[subBuildOutput].build(builder);
                    // If the shaderNode has subBuilds, add them to the chaining nodes
                    // so they can be built later in the build process.
                    if (this.shaderNode.subBuilds) {
                        for (const node of builder.chaining) {
                            const nodeData = builder.getDataFromNode(node, 'any');
                            nodeData.subBuilds = nodeData.subBuilds || new Set();
                            for (const subBuild of this.shaderNode.subBuilds) {
                                nodeData.subBuilds.add(subBuild);
                            }
                            //builder.getDataFromNode( node ).subBuilds = nodeData.subBuilds;
                        }
                    }
                }
                result = properties[subBuildOutput];
            } else if (buildStage === 'analyze') {
                outputNode.build(builder, output);
            } else if (buildStage === 'generate') {
                result = outputNode.build(builder, output) || '';
            }
            return result;
        }
    }
    class ShaderNodeInternal extends Node {
        constructor(jsFunc, nodeType) {
            super(nodeType);
            this.jsFunc = jsFunc;
            this.layout = null;
            this.global = true;
            this.once = false;
        }
        setLayout(layout) {
            this.layout = layout;
            return this;
        }
        call(inputs = null) {
            nodeObjects(inputs);
            return nodeObject(new ShaderCallNodeInternal(this, inputs));
        }
        setup() {
            return this.call();
        }
    }
    const bools = [false, true];
    const uints = [0, 1, 2, 3];
    const ints = [-1, -2];
    const floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
    const boolsCacheMap = new Map();
    for (const bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));
    const uintsCacheMap = new Map();
    for (const uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));
    const intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));
    for (const int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));
    const floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));
    for (const float of floats) floatsCacheMap.set(float, new ConstNode(float));
    for (const float of floats) floatsCacheMap.set(- float, new ConstNode(- float));
    const cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
    const constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
    const getConstNode = (value, type) => {
        if (constNodesCacheMap.has(value)) {
            return constNodesCacheMap.get(value);
        } else if (value.isNode === true) {
            return value;
        } else {
            return new ConstNode(value, type);
        }
    };
    const ConvertType = function (type, cacheMap = null) {
        return (...params) => {
            if (params.length === 0 || (!['bool', 'float', 'int', 'uint'].includes(type) && params.every(param => typeof param !== 'object'))) {
                params = [getValueFromType(type, ...params)];
            }
            if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
                return nodeObjectIntent(cacheMap.get(params[0]));
            }
            if (params.length === 1) {
                const node = getConstNode(params[0], type);
                if (node.nodeType === type) return nodeObjectIntent(node);
                return nodeObjectIntent(new ConvertNode(node, type));
            }
            const nodes = params.map(param => getConstNode(param));
            return nodeObjectIntent(new JoinNode(nodes, type));
        };
    };
    // exports
    const defined = (v) => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function
    // utils
    const getConstNodeType = (value) => (value !== undefined && value !== null) ? (value.nodeType || value.convertTo || (typeof value === 'string' ? value : null)) : null;
    // shader node base
    function ShaderNode(jsFunc, nodeType) {
        return new Proxy(new ShaderNodeInternal(jsFunc, nodeType), shaderNodeHandler);
    }
    const nodeObject = (val, altType = null) => /* new */ ShaderNodeObject(val, altType);
    const nodeObjectIntent = (val, altType = null) => /* new */ nodeObject(val, altType).toVarIntent();
    const nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
    const nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
    const nodeProxy = (NodeClass, scope = null, factor = null, settings = null) => new ShaderNodeProxy(NodeClass, scope, factor, settings);
    const nodeImmutable = (NodeClass, ...params) => new ShaderNodeImmutable(NodeClass, ...params);
    const nodeProxyIntent = (NodeClass, scope = null, factor = null, settings = {}) => new ShaderNodeProxy(NodeClass, scope, factor, { intent: true, ...settings });
    let fnId = 0;
    const Fn = (jsFunc, layout = null) => {
        let nodeType = null;
        if (layout !== null) {
            if (typeof layout === 'object') {
                nodeType = layout.return;
            } else {
                if (typeof layout === 'string') {
                    nodeType = layout;
                } else {
                    console.error('THREE.TSL: Invalid layout type.');
                }
                layout = null;
            }
        }
        const shaderNode = new ShaderNode(jsFunc, nodeType);
        const fn = (...params) => {
            let inputs;
            nodeObjects(params);
            const isArrayAsParameter = params[0] && (params[0].isNode || Object.getPrototypeOf(params[0]) !== Object.prototype);
            if (isArrayAsParameter) {
                inputs = [...params];
            } else {
                inputs = params[0];
            }
            const fnCall = shaderNode.call(inputs);
            if (nodeType === 'void') fnCall.toStack();
            return fnCall.toVarIntent();
        };
        fn.shaderNode = shaderNode;
        fn.id = shaderNode.id;
        fn.isFn = true;
        fn.getNodeType = (...params) => shaderNode.getNodeType(...params);
        fn.getCacheKey = (...params) => shaderNode.getCacheKey(...params);
        fn.setLayout = (layout) => {
            shaderNode.setLayout(layout);
            return fn;
        };
        fn.once = (subBuilds = null) => {
            shaderNode.once = true;
            shaderNode.subBuilds = subBuilds;
            return fn;
        };
        if (layout !== null) {
            if (typeof layout.inputs !== 'object') {
                const fullLayout = {
                    name: 'fn' + fnId++,
                    type: nodeType,
                    inputs: []
                };
                for (const name in layout) {
                    if (name === 'return') continue;
                    fullLayout.inputs.push({
                        name: name,
                        type: layout[name]
                    });
                }
                layout = fullLayout;
            }
            fn.setLayout(layout);
        }
        return fn;
    };
    //
    const setCurrentStack = (stack) => {
        currentStack = stack;
    };
    const getCurrentStack = () => currentStack;
    const If = (...params) => currentStack.If(...params);
    const Switch = (...params) => currentStack.Switch(...params);
    function Stack(node) {
        if (currentStack) currentStack.add(node);
        return node;
    }
    addMethodChaining('toStack', Stack);
    // types
    const color = new ConvertType('color');
    const float = new ConvertType('float', cacheMaps.float);
    const int = new ConvertType('int', cacheMaps.ints);
    const uint = new ConvertType('uint', cacheMaps.uint);
    const bool = new ConvertType('bool', cacheMaps.bool);
    const vec2 = new ConvertType('vec2');
    const ivec2 = new ConvertType('ivec2');
    const uvec2 = new ConvertType('uvec2');
    const bvec2 = new ConvertType('bvec2');
    const vec3 = new ConvertType('vec3');
    const ivec3 = new ConvertType('ivec3');
    const uvec3 = new ConvertType('uvec3');
    const bvec3 = new ConvertType('bvec3');
    const vec4 = new ConvertType('vec4');
    const ivec4 = new ConvertType('ivec4');
    const uvec4 = new ConvertType('uvec4');
    const bvec4 = new ConvertType('bvec4');
    const mat2 = new ConvertType('mat2');
    const mat3 = new ConvertType('mat3');
    const mat4 = new ConvertType('mat4');
    const string = (value = '') => nodeObject(new ConstNode(value, 'string'));
    const arrayBuffer = (value) => nodeObject(new ConstNode(value, 'ArrayBuffer'));
    addMethodChaining('toColor', color);
    addMethodChaining('toFloat', float);
    addMethodChaining('toInt', int);
    addMethodChaining('toUint', uint);
    addMethodChaining('toBool', bool);
    addMethodChaining('toVec2', vec2);
    addMethodChaining('toIVec2', ivec2);
    addMethodChaining('toUVec2', uvec2);
    addMethodChaining('toBVec2', bvec2);
    addMethodChaining('toVec3', vec3);
    addMethodChaining('toIVec3', ivec3);
    addMethodChaining('toUVec3', uvec3);
    addMethodChaining('toBVec3', bvec3);
    addMethodChaining('toVec4', vec4);
    addMethodChaining('toIVec4', ivec4);
    addMethodChaining('toUVec4', uvec4);
    addMethodChaining('toBVec4', bvec4);
    addMethodChaining('toMat2', mat2);
    addMethodChaining('toMat3', mat3);
    addMethodChaining('toMat4', mat4);
    // basic nodes
    const element = /*@__PURE__*/ nodeProxy(ArrayElementNode).setParameterLength(2);
    const convert = (node, types) => nodeObject(new ConvertNode(nodeObject(node), types));
    const split = (node, channels) => nodeObject(new SplitNode(nodeObject(node), channels));
    addMethodChaining('element', element);
    addMethodChaining('convert', convert);
    // deprecated
    const append = (node) => { // @deprecated, r176
        console.warn('THREE.TSL: append() has been renamed to Stack().');
        return Stack(node);
    };
    addMethodChaining('append', (node) => { // @deprecated, r176
        console.warn('THREE.TSL: .append() has been renamed to .toStack().');
        return Stack(node);
    });
    class PropertyNode extends Node {
        static get type() {
            return 'PropertyNode';
        }
        constructor(nodeType, name = null, varying = false) {
            super(nodeType);
            this.name = name;
            this.varying = varying;
            this.isPropertyNode = true;
            this.global = true;
        }
        getHash(builder) {
            return this.name || super.getHash(builder);
        }
        generate(builder) {
            let nodeVar;
            if (this.varying === true) {
                nodeVar = builder.getVaryingFromNode(this, this.name);
                nodeVar.needsInterpolation = true;
            } else {
                nodeVar = builder.getVarFromNode(this, this.name);
            }
            return builder.getPropertyName(nodeVar);
        }
    }
    const property = (type, name) => nodeObject(new PropertyNode(type, name));
    const varyingProperty = (type, name) => nodeObject(new PropertyNode(type, name, true));
    const diffuseColor = /*@__PURE__*/ nodeImmutable(PropertyNode, 'vec4', 'DiffuseColor');
    const emissive = /*@__PURE__*/ nodeImmutable(PropertyNode, 'vec3', 'EmissiveColor');
    const roughness = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'Roughness');
    const metalness = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'Metalness');
    const clearcoat = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'Clearcoat');
    const clearcoatRoughness = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'ClearcoatRoughness');
    const sheen = /*@__PURE__*/ nodeImmutable(PropertyNode, 'vec3', 'Sheen');
    const sheenRoughness = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'SheenRoughness');
    const iridescence = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'Iridescence');
    const iridescenceIOR = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'IridescenceIOR');
    const iridescenceThickness = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'IridescenceThickness');
    const alphaT = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'AlphaT');
    const anisotropy = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'Anisotropy');
    const anisotropyT = /*@__PURE__*/ nodeImmutable(PropertyNode, 'vec3', 'AnisotropyT');
    const anisotropyB = /*@__PURE__*/ nodeImmutable(PropertyNode, 'vec3', 'AnisotropyB');
    const specularColor = /*@__PURE__*/ nodeImmutable(PropertyNode, 'color', 'SpecularColor');
    const specularF90 = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'SpecularF90');
    const shininess = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'Shininess');
    const output = /*@__PURE__*/ nodeImmutable(PropertyNode, 'vec4', 'Output');
    const dashSize = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'dashSize');
    const gapSize = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'gapSize');
    const pointWidth = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'pointWidth');
    const ior = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'IOR');
    const transmission = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'Transmission');
    const thickness = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'Thickness');
    const attenuationDistance = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'AttenuationDistance');
    const attenuationColor = /*@__PURE__*/ nodeImmutable(PropertyNode, 'color', 'AttenuationColor');
    const dispersion = /*@__PURE__*/ nodeImmutable(PropertyNode, 'float', 'Dispersion');
    class UniformGroupNode extends Node {
        static get type() {
            return 'UniformGroupNode';
        }
        constructor(name, shared = false, order = 1) {
            super('string');
            this.name = name;
            this.shared = shared;
            this.order = order;
            this.isUniformGroup = true;
        }
        serialize(data) {
            super.serialize(data);
            data.name = this.name;
            data.version = this.version;
            data.shared = this.shared;
        }
        deserialize(data) {
            super.deserialize(data);
            this.name = data.name;
            this.version = data.version;
            this.shared = data.shared;
        }
    }
    const uniformGroup = (name) => new UniformGroupNode(name);
    const sharedUniformGroup = (name, order = 0) => new UniformGroupNode(name, true, order);
    const frameGroup = /*@__PURE__*/ sharedUniformGroup('frame');
    const renderGroup = /*@__PURE__*/ sharedUniformGroup('render');
    const objectGroup = /*@__PURE__*/ uniformGroup('object');
    class UniformNode extends InputNode {
        static get type() {
            return 'UniformNode';
        }
        constructor(value, nodeType = null) {
            super(value, nodeType);
            this.isUniformNode = true;
            this.name = '';
            this.groupNode = objectGroup;
        }
        setName(name) {
            this.name = name;
            return this;
        }
        label(name) {
            console.warn('THREE.TSL: "label()" has been deprecated. Use "setName()" instead.'); // @deprecated r179
            return this.setName(name);
        }
        setGroup(group) {
            this.groupNode = group;
            return this;
        }
        getGroup() {
            return this.groupNode;
        }
        getUniformHash(builder) {
            return this.getHash(builder);
        }
        onUpdate(callback, updateType) {
            const self = this.getSelf();
            callback = callback.bind(self);
            return super.onUpdate((frame) => {
                const value = callback(frame, self);
                if (value !== undefined) {
                    this.value = value;
                }
            }, updateType);
        }
        getInputType(builder) {
            let type = super.getInputType(builder);
            if (type === 'bool') {
                type = 'uint';
            }
            return type;
        }
        generate(builder, output) {
            const type = this.getNodeType(builder);
            const hash = this.getUniformHash(builder);
            let sharedNode = builder.getNodeFromHash(hash);
            if (sharedNode === undefined) {
                builder.setHashNode(this, hash);
                sharedNode = this;
            }
            const sharedNodeType = sharedNode.getInputType(builder);
            const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.nodeName);
            const uniformName = builder.getPropertyName(nodeUniform);
            if (builder.context.nodeName !== undefined) delete builder.context.nodeName;
            //
            let snippet = uniformName;
            if (type === 'bool') {
                // cache to variable
                const nodeData = builder.getDataFromNode(this);
                let propertyName = nodeData.propertyName;
                if (propertyName === undefined) {
                    const nodeVar = builder.getVarFromNode(this, null, 'bool');
                    propertyName = builder.getPropertyName(nodeVar);
                    nodeData.propertyName = propertyName;
                    snippet = builder.format(uniformName, sharedNodeType, type);
                    builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
                }
                snippet = propertyName;
            }
            return builder.format(snippet, type, output);
        }
    }
    const uniform = (arg1, arg2) => {
        const nodeType = getConstNodeType(arg2 || arg1);
        // @TODO: get ConstNode from .traverse() in the future
        const value = (arg1 && arg1.isNode === true) ? (arg1.node && arg1.node.value) || arg1.value : arg1;
        return nodeObject(new UniformNode(value, nodeType));
    };
    class ArrayNode extends TempNode {
        static get type() {
            return 'ArrayNode';
        }
        constructor(nodeType, count, values = null) {
            super(nodeType);
            this.count = count;
            this.values = values;
            this.isArrayNode = true;
        }
        getArrayCount( /*builder*/) {
            return this.count;
        }
        getNodeType(builder) {
            if (this.nodeType === null) {
                this.nodeType = this.values[0].getNodeType(builder);
            }
            return this.nodeType;
        }
        getElementType(builder) {
            return this.getNodeType(builder);
        }
        generate(builder) {
            const type = this.getNodeType(builder);
            return builder.generateArray(type, this.count, this.values);
        }
    }
    const array = (...params) => {
        let node;
        if (params.length === 1) {
            const values = params[0];
            node = new ArrayNode(null, values.length, values);
        } else {
            const nodeType = params[0];
            const count = params[1];
            node = new ArrayNode(nodeType, count);
        }
        return nodeObject(node);
    };
    addMethodChaining('toArray', (node, count) => array(Array(count).fill(node)));
    class AssignNode extends TempNode {
        static get type() {
            return 'AssignNode';
        }
        constructor(targetNode, sourceNode) {
            super();
            this.targetNode = targetNode;
            this.sourceNode = sourceNode;
            this.isAssignNode = true;
        }
        hasDependencies() {
            return false;
        }
        getNodeType(builder, output) {
            return output !== 'void' ? this.targetNode.getNodeType(builder) : 'void';
        }
        needsSplitAssign(builder) {
            const { targetNode } = this;
            if (builder.isAvailable('swizzleAssign') === false && targetNode.isSplitNode && targetNode.components.length > 1) {
                const targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));
                const assignDifferentVector = vectorComponents.join('').slice(0, targetLength) !== targetNode.components;
                return assignDifferentVector;
            }
            return false;
        }
        setup(builder) {
            const { targetNode, sourceNode } = this;
            const targetProperties = builder.getNodeProperties(targetNode);
            targetProperties.assign = true;
            const properties = builder.getNodeProperties(this);
            properties.sourceNode = sourceNode;
            properties.targetNode = targetNode.context({ assign: true });
        }
        generate(builder, output) {
            const { targetNode, sourceNode } = builder.getNodeProperties(this);
            const needsSplitAssign = this.needsSplitAssign(builder);
            const targetType = targetNode.getNodeType(builder);
            const target = targetNode.build(builder);
            const source = sourceNode.build(builder, targetType);
            const sourceType = sourceNode.getNodeType(builder);
            const nodeData = builder.getDataFromNode(this);
            //
            let snippet;
            if (nodeData.initialized === true) {
                if (output !== 'void') {
                    snippet = target;
                }
            } else if (needsSplitAssign) {
                const sourceVar = builder.getVarFromNode(this, null, targetType);
                const sourceProperty = builder.getPropertyName(sourceVar);
                builder.addLineFlowCode(`${sourceProperty} = ${source}`, this);
                const splitNode = targetNode.node;
                const splitTargetNode = splitNode.node.context({ assign: true });
                const targetRoot = splitTargetNode.build(builder);
                for (let i = 0; i < splitNode.components.length; i++) {
                    const component = splitNode.components[i];
                    builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} ]`, this);
                }
                if (output !== 'void') {
                    snippet = target;
                }
            } else {
                snippet = `${target} = ${source}`;
                if (output === 'void' || sourceType === 'void') {
                    builder.addLineFlowCode(snippet, this);
                    if (output !== 'void') {
                        snippet = target;
                    }
                }
            }
            nodeData.initialized = true;
            return builder.format(snippet, targetType, output);
        }
    }
    const assign = /*@__PURE__*/ nodeProxy(AssignNode).setParameterLength(2);
    addMethodChaining('assign', assign);
    class FunctionCallNode extends TempNode {
        static get type() {
            return 'FunctionCallNode';
        }
        constructor(functionNode = null, parameters = {}) {
            super();
            this.functionNode = functionNode;
            this.parameters = parameters;
        }
        setParameters(parameters) {
            this.parameters = parameters;
            return this;
        }
        getParameters() {
            return this.parameters;
        }
        getNodeType(builder) {
            return this.functionNode.getNodeType(builder);
        }
        generate(builder) {
            const params = [];
            const functionNode = this.functionNode;
            const inputs = functionNode.getInputs(builder);
            const parameters = this.parameters;
            const generateInput = (node, inputNode) => {
                const type = inputNode.type;
                const pointer = type === 'pointer';
                let output;
                if (pointer) output = '&' + node.build(builder);
                else output = node.build(builder, type);
                return output;
            };
            if (Array.isArray(parameters)) {
                if (parameters.length > inputs.length) {
                    console.error('THREE.TSL: The number of provided parameters exceeds the expected number of inputs in \'Fn()\'.');
                    parameters.length = inputs.length;
                } else if (parameters.length < inputs.length) {
                    console.error('THREE.TSL: The number of provided parameters is less than the expected number of inputs in \'Fn()\'.');
                    while (parameters.length < inputs.length) {
                        parameters.push(float(0));
                    }
                }
                for (let i = 0; i < parameters.length; i++) {
                    params.push(generateInput(parameters[i], inputs[i]));
                }
            } else {
                for (const inputNode of inputs) {
                    const node = parameters[inputNode.name];
                    if (node !== undefined) {
                        params.push(generateInput(node, inputNode));
                    } else {
                        console.error(`THREE.TSL: Input '${inputNode.name}' not found in \'Fn()\'.`);
                        params.push(generateInput(float(0), inputNode));
                    }
                }
            }
            const functionName = functionNode.build(builder, 'property');
            return `${functionName}( ${params.join(', ')} )`;
        }
    }
    const call = (func, ...params) => {
        params = params.length > 1 || (params[0] && params[0].isNode === true) ? nodeArray(params) : nodeObjects(params[0]);
        return nodeObject(new FunctionCallNode(nodeObject(func), params));
    };
    addMethodChaining('call', call);
    const _vectorOperators = {
        '==': 'equal',
        '!=': 'notEqual',
        '<': 'lessThan',
        '>': 'greaterThan',
        '<=': 'lessThanEqual',
        '>=': 'greaterThanEqual',
        '%': 'mod'
    };
    class OperatorNode extends TempNode {
        static get type() {
            return 'OperatorNode';
        }
        constructor(op, aNode, bNode, ...params) {
            super();
            if (params.length > 0) {
                let finalOp = new OperatorNode(op, aNode, bNode);
                for (let i = 0; i < params.length - 1; i++) {
                    finalOp = new OperatorNode(op, finalOp, params[i]);
                }
                aNode = finalOp;
                bNode = params[params.length - 1];
            }
            this.op = op;
            this.aNode = aNode;
            this.bNode = bNode;
            this.isOperatorNode = true;
        }
        getOperatorMethod(builder, output) {
            return builder.getMethod(_vectorOperators[this.op], output);
        }
        getNodeType(builder) {
            const op = this.op;
            const aNode = this.aNode;
            const bNode = this.bNode;
            const typeA = aNode.getNodeType(builder);
            const typeB = bNode ? bNode.getNodeType(builder) : null;
            if (typeA === 'void' || typeB === 'void') {
                return 'void';
            } else if (op === '%') {
                return typeA;
            } else if (op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<') {
                return builder.getIntegerType(typeA);
            } else if (op === '!' || op === '&&' || op === '||' || op === '^^') {
                return 'bool';
            } else if (op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=') {
                const typeLength = Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));
                return typeLength > 1 ? `bvec${typeLength}` : 'bool';
            } else {
                // Handle matrix operations
                if (builder.isMatrix(typeA)) {
                    if (typeB === 'float') {
                        return typeA; // matrix * scalar = matrix
                    } else if (builder.isVector(typeB)) {
                        return builder.getVectorFromMatrix(typeA); // matrix * vector
                    } else if (builder.isMatrix(typeB)) {
                        return typeA; // matrix * matrix
                    }
                } else if (builder.isMatrix(typeB)) {
                    if (typeA === 'float') {
                        return typeB; // scalar * matrix = matrix
                    } else if (builder.isVector(typeA)) {
                        return builder.getVectorFromMatrix(typeB); // vector * matrix
                    }
                }
                // Handle non-matrix cases
                if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
                    // anytype x anytype: use the greater length vector
                    return typeB;
                }
                return typeA;
            }
        }
        generate(builder, output) {
            const op = this.op;
            const { aNode, bNode } = this;
            const type = this.getNodeType(builder);
            let typeA = null;
            let typeB = null;
            if (type !== 'void') {
                typeA = aNode.getNodeType(builder);
                typeB = bNode ? bNode.getNodeType(builder) : null;
                if (op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==' || op === '!=') {
                    if (builder.isVector(typeA)) {
                        typeB = typeA;
                    } else if (builder.isVector(typeB)) {
                        typeA = typeB;
                    } else if (typeA !== typeB) {
                        typeA = typeB = 'float';
                    }
                } else if (op === '>>' || op === '<<') {
                    typeA = type;
                    typeB = builder.changeComponentType(typeB, 'uint');
                } else if (op === '%') {
                    typeA = type;
                    typeB = builder.isInteger(typeA) && builder.isInteger(typeB) ? typeB : typeA;
                } else if (builder.isMatrix(typeA)) {
                    if (typeB === 'float') {
                        // Keep matrix type for typeA, but ensure typeB stays float
                        typeB = 'float';
                    } else if (builder.isVector(typeB)) {
                        // matrix x vector
                        typeB = builder.getVectorFromMatrix(typeA);
                    } else if (builder.isMatrix(typeB)); else {
                        typeA = typeB = type;
                    }
                } else if (builder.isMatrix(typeB)) {
                    if (typeA === 'float') {
                        // Keep matrix type for typeB, but ensure typeA stays float
                        typeA = 'float';
                    } else if (builder.isVector(typeA)) {
                        // vector x matrix
                        typeA = builder.getVectorFromMatrix(typeB);
                    } else {
                        typeA = typeB = type;
                    }
                } else {
                    // anytype x anytype
                    typeA = typeB = type;
                }
            } else {
                typeA = typeB = type;
            }
            const a = aNode.build(builder, typeA);
            const b = bNode ? bNode.build(builder, typeB) : null;
            const fnOpSnippet = builder.getFunctionOperator(op);
            if (output !== 'void') {
                const isGLSL = builder.renderer.coordinateSystem === WebGLCoordinateSystem;
                if (op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=') {
                    if (isGLSL) {
                        if (builder.isVector(typeA)) {
                            return builder.format(`${this.getOperatorMethod(builder, output)}( ${a}, ${b} )`, type, output);
                        } else {
                            return builder.format(`( ${a} ${op} ${b} )`, type, output);
                        }
                    } else {
                        // WGSL
                        return builder.format(`( ${a} ${op} ${b} )`, type, output);
                    }
                } else if (op === '%') {
                    if (builder.isInteger(typeB)) {
                        return builder.format(`( ${a} % ${b} )`, type, output);
                    } else {
                        return builder.format(`${this.getOperatorMethod(builder, type)}( ${a}, ${b} )`, type, output);
                    }
                } else if (op === '!' || op === '~') {
                    return builder.format(`(${op}${a})`, typeA, output);
                } else if (fnOpSnippet) {
                    return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output);
                } else {
                    // Handle matrix operations
                    if (builder.isMatrix(typeA) && typeB === 'float') {
                        return builder.format(`( ${b} ${op} ${a} )`, type, output);
                    } else if (typeA === 'float' && builder.isMatrix(typeB)) {
                        return builder.format(`${a} ${op} ${b}`, type, output);
                    } else {
                        let snippet = `( ${a} ${op} ${b} )`;
                        if (!isGLSL && type === 'bool' && builder.isVector(typeA) && builder.isVector(typeB)) {
                            snippet = `all${snippet}`;
                        }
                        return builder.format(snippet, type, output);
                    }
                }
            } else if (typeA !== 'void') {
                if (fnOpSnippet) {
                    return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output);
                } else {
                    if (builder.isMatrix(typeA) && typeB === 'float') {
                        return builder.format(`${b} ${op} ${a}`, type, output);
                    } else {
                        return builder.format(`${a} ${op} ${b}`, type, output);
                    }
                }
            }
        }
        serialize(data) {
            super.serialize(data);
            data.op = this.op;
        }
        deserialize(data) {
            super.deserialize(data);
            this.op = data.op;
        }
    }
    const add = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '+').setParameterLength(2, Infinity).setName('add');
    const sub = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '-').setParameterLength(2, Infinity).setName('sub');
    const mul = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '*').setParameterLength(2, Infinity).setName('mul');
    const div = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '/').setParameterLength(2, Infinity).setName('div');
    const mod = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '%').setParameterLength(2).setName('mod');
    const equal = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '==').setParameterLength(2).setName('equal');
    const notEqual = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '!=').setParameterLength(2).setName('notEqual');
    const lessThan = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '<').setParameterLength(2).setName('lessThan');
    const greaterThan = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '>').setParameterLength(2).setName('greaterThan');
    const lessThanEqual = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '<=').setParameterLength(2).setName('lessThanEqual');
    const greaterThanEqual = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '>=').setParameterLength(2).setName('greaterThanEqual');
    const and = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '&&').setParameterLength(2, Infinity).setName('and');
    const or = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '||').setParameterLength(2, Infinity).setName('or');
    const not = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '!').setParameterLength(1).setName('not');
    const xor = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '^^').setParameterLength(2).setName('xor');
    const bitAnd = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '&').setParameterLength(2).setName('bitAnd');
    const bitNot = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '~').setParameterLength(2).setName('bitNot');
    const bitOr = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '|').setParameterLength(2).setName('bitOr');
    const bitXor = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '^').setParameterLength(2).setName('bitXor');
    const shiftLeft = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '<<').setParameterLength(2).setName('shiftLeft');
    const shiftRight = /*@__PURE__*/ nodeProxyIntent(OperatorNode, '>>').setParameterLength(2).setName('shiftRight');
    const incrementBefore = Fn(([a]) => {
        a.addAssign(1);
        return a;
    });
    const decrementBefore = Fn(([a]) => {
        a.subAssign(1);
        return a;
    });
    const increment = /*@__PURE__*/ Fn(([a]) => {
        const temp = int(a).toConst();
        a.addAssign(1);
        return temp;
    });
    const decrement = /*@__PURE__*/ Fn(([a]) => {
        const temp = int(a).toConst();
        a.subAssign(1);
        return temp;
    });
    addMethodChaining('add', add);
    addMethodChaining('sub', sub);
    addMethodChaining('mul', mul);
    addMethodChaining('div', div);
    addMethodChaining('mod', mod);
    addMethodChaining('equal', equal);
    addMethodChaining('notEqual', notEqual);
    addMethodChaining('lessThan', lessThan);
    addMethodChaining('greaterThan', greaterThan);
    addMethodChaining('lessThanEqual', lessThanEqual);
    addMethodChaining('greaterThanEqual', greaterThanEqual);
    addMethodChaining('and', and);
    addMethodChaining('or', or);
    addMethodChaining('not', not);
    addMethodChaining('xor', xor);
    addMethodChaining('bitAnd', bitAnd);
    addMethodChaining('bitNot', bitNot);
    addMethodChaining('bitOr', bitOr);
    addMethodChaining('bitXor', bitXor);
    addMethodChaining('shiftLeft', shiftLeft);
    addMethodChaining('shiftRight', shiftRight);
    addMethodChaining('incrementBefore', incrementBefore);
    addMethodChaining('decrementBefore', decrementBefore);
    addMethodChaining('increment', increment);
    addMethodChaining('decrement', decrement);
    const modInt = (a, b) => { // @deprecated, r175
        console.warn('THREE.TSL: "modInt()" is deprecated. Use "mod( int( ... ) )" instead.');
        return mod(int(a), int(b));
    };
    addMethodChaining('modInt', modInt);
    class MathNode extends TempNode {
        static get type() {
            return 'MathNode';
        }
        constructor(method, aNode, bNode = null, cNode = null) {
            super();
            // Allow the max() and min() functions to take an arbitrary number of arguments.
            if ((method === MathNode.MAX || method === MathNode.MIN) && arguments.length > 3) {
                let finalOp = new MathNode(method, aNode, bNode);
                for (let i = 2; i < arguments.length - 1; i++) {
                    finalOp = new MathNode(method, finalOp, arguments[i]);
                }
                aNode = finalOp;
                bNode = arguments[arguments.length - 1];
                cNode = null;
            }
            this.method = method;
            this.aNode = aNode;
            this.bNode = bNode;
            this.cNode = cNode;
            this.isMathNode = true;
        }
        getInputType(builder) {
            const aType = this.aNode.getNodeType(builder);
            const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
            const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
            const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
            const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
            const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
            if (aLen > bLen && aLen > cLen) {
                return aType;
            } else if (bLen > cLen) {
                return bType;
            } else if (cLen > aLen) {
                return cType;
            }
            return aType;
        }
        getNodeType(builder) {
            const method = this.method;
            if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {
                return 'float';
            } else if (method === MathNode.CROSS) {
                return 'vec3';
            } else if (method === MathNode.ALL || method === MathNode.ANY) {
                return 'bool';
            } else if (method === MathNode.EQUALS) {
                return builder.changeComponentType(this.aNode.getNodeType(builder), 'bool');
            } else {
                return this.getInputType(builder);
            }
        }
        setup(builder) {
            const { aNode, bNode, method } = this;
            let outputNode = null;
            if (method === MathNode.ONE_MINUS) {
                outputNode = sub(1.0, aNode);
            } else if (method === MathNode.RECIPROCAL) {
                outputNode = div(1.0, aNode);
            } else if (method === MathNode.DIFFERENCE) {
                outputNode = abs(sub(aNode, bNode));
            } else if (method === MathNode.TRANSFORM_DIRECTION) {
                // dir can be either a direction vector or a normal vector
                // upper-left 3x3 of matrix is assumed to be orthogonal
                let tA = aNode;
                let tB = bNode;
                if (builder.isMatrix(tA.getNodeType(builder))) {
                    tB = vec4(vec3(tB), 0.0);
                } else {
                    tA = vec4(vec3(tA), 0.0);
                }
                const mulNode = mul(tA, tB).xyz;
                outputNode = normalize(mulNode);
            }
            if (outputNode !== null) {
                return outputNode;
            } else {
                return super.setup(builder);
            }
        }
        generate(builder, output) {
            const properties = builder.getNodeProperties(this);
            if (properties.outputNode) {
                return super.generate(builder, output);
            }
            let method = this.method;
            const type = this.getNodeType(builder);
            const inputType = this.getInputType(builder);
            const a = this.aNode;
            const b = this.bNode;
            const c = this.cNode;
            const coordinateSystem = builder.renderer.coordinateSystem;
            if (method === MathNode.NEGATE) {
                return builder.format('( - ' + a.build(builder, inputType) + ' )', type, output);
            } else {
                const params = [];
                if (method === MathNode.CROSS) {
                    params.push(
                        a.build(builder, type),
                        b.build(builder, type)
                    );
                } else if (coordinateSystem === WebGLCoordinateSystem && method === MathNode.STEP) {
                    params.push(
                        a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? 'float' : inputType),
                        b.build(builder, inputType)
                    );
                } else if (coordinateSystem === WebGLCoordinateSystem && (method === MathNode.MIN || method === MathNode.MAX)) {
                    params.push(
                        a.build(builder, inputType),
                        b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? 'float' : inputType)
                    );
                } else if (method === MathNode.REFRACT) {
                    params.push(
                        a.build(builder, inputType),
                        b.build(builder, inputType),
                        c.build(builder, 'float')
                    );
                } else if (method === MathNode.MIX) {
                    params.push(
                        a.build(builder, inputType),
                        b.build(builder, inputType),
                        c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? 'float' : inputType)
                    );
                } else {
                    if (coordinateSystem === WebGPUCoordinateSystem && method === MathNode.ATAN && b !== null) {
                        method = 'atan2';
                    }
                    if (builder.shaderStage !== 'fragment' && (method === MathNode.DFDX || method === MathNode.DFDY)) {
                        console.warn(`THREE.TSL: '${method}' is not supported in the ${builder.shaderStage} stage.`);
                        method = '/*' + method + '*/';
                    }
                    params.push(a.build(builder, inputType));
                    if (b !== null) params.push(b.build(builder, inputType));
                    if (c !== null) params.push(c.build(builder, inputType));
                }
                return builder.format(`${builder.getMethod(method, type)}( ${params.join(', ')} )`, type, output);
            }
        }
        serialize(data) {
            super.serialize(data);
            data.method = this.method;
        }
        deserialize(data) {
            super.deserialize(data);
            this.method = data.method;
        }
    }
    // 1 input
    MathNode.ALL = 'all';
    MathNode.ANY = 'any';
    MathNode.RADIANS = 'radians';
    MathNode.DEGREES = 'degrees';
    MathNode.EXP = 'exp';
    MathNode.EXP2 = 'exp2';
    MathNode.LOG = 'log';
    MathNode.LOG2 = 'log2';
    MathNode.SQRT = 'sqrt';
    MathNode.INVERSE_SQRT = 'inversesqrt';
    MathNode.FLOOR = 'floor';
    MathNode.CEIL = 'ceil';
    MathNode.NORMALIZE = 'normalize';
    MathNode.FRACT = 'fract';
    MathNode.SIN = 'sin';
    MathNode.COS = 'cos';
    MathNode.TAN = 'tan';
    MathNode.ASIN = 'asin';
    MathNode.ACOS = 'acos';
    MathNode.ATAN = 'atan';
    MathNode.ABS = 'abs';
    MathNode.SIGN = 'sign';
    MathNode.LENGTH = 'length';
    MathNode.NEGATE = 'negate';
    MathNode.ONE_MINUS = 'oneMinus';
    MathNode.DFDX = 'dFdx';
    MathNode.DFDY = 'dFdy';
    MathNode.ROUND = 'round';
    MathNode.RECIPROCAL = 'reciprocal';
    MathNode.TRUNC = 'trunc';
    MathNode.FWIDTH = 'fwidth';
    MathNode.TRANSPOSE = 'transpose';
    MathNode.DETERMINANT = 'determinant';
    MathNode.INVERSE = 'inverse';
    // 2 inputs
    MathNode.BITCAST = 'bitcast';
    MathNode.EQUALS = 'equals';
    MathNode.MIN = 'min';
    MathNode.MAX = 'max';
    MathNode.STEP = 'step';
    MathNode.REFLECT = 'reflect';
    MathNode.DISTANCE = 'distance';
    MathNode.DIFFERENCE = 'difference';
    MathNode.DOT = 'dot';
    MathNode.CROSS = 'cross';
    MathNode.POW = 'pow';
    MathNode.TRANSFORM_DIRECTION = 'transformDirection';
    // 3 inputs
    MathNode.MIX = 'mix';
    MathNode.CLAMP = 'clamp';
    MathNode.REFRACT = 'refract';
    MathNode.SMOOTHSTEP = 'smoothstep';
    MathNode.FACEFORWARD = 'faceforward';
    // 1 inputs
    const EPSILON = /*@__PURE__*/ float(1e-6);
    const INFINITY = /*@__PURE__*/ float(1e6);
    const PI = /*@__PURE__*/ float(Math.PI);
    const PI2 = /*@__PURE__*/ float(Math.PI * 2);
    const all = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.ALL).setParameterLength(1);
    const any = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.ANY).setParameterLength(1);
    const radians = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.RADIANS).setParameterLength(1);
    const degrees = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.DEGREES).setParameterLength(1);
    const exp = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.EXP).setParameterLength(1);
    const exp2 = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.EXP2).setParameterLength(1);
    const log = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.LOG).setParameterLength(1);
    const log2 = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.LOG2).setParameterLength(1);
    const sqrt = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.SQRT).setParameterLength(1);
    const inverseSqrt = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.INVERSE_SQRT).setParameterLength(1);
    const floor = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.FLOOR).setParameterLength(1);
    const ceil = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.CEIL).setParameterLength(1);
    const normalize = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.NORMALIZE).setParameterLength(1);
    const fract = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.FRACT).setParameterLength(1);
    const sin = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.SIN).setParameterLength(1);
    const cos = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.COS).setParameterLength(1);
    const tan = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.TAN).setParameterLength(1);
    const asin = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.ASIN).setParameterLength(1);
    const acos = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.ACOS).setParameterLength(1);
    const atan = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.ATAN).setParameterLength(1, 2);
    const abs = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.ABS).setParameterLength(1);
    const sign = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.SIGN).setParameterLength(1);
    const length = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.LENGTH).setParameterLength(1);
    const negate = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.NEGATE).setParameterLength(1);
    const oneMinus = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.ONE_MINUS).setParameterLength(1);
    const dFdx = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.DFDX).setParameterLength(1);
    const dFdy = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.DFDY).setParameterLength(1);
    const round = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.ROUND).setParameterLength(1);
    const reciprocal = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.RECIPROCAL).setParameterLength(1);
    const trunc = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.TRUNC).setParameterLength(1);
    const fwidth = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.FWIDTH).setParameterLength(1);
    const transpose = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.TRANSPOSE).setParameterLength(1);
    const determinant = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.DETERMINANT).setParameterLength(1);
    const inverse = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.INVERSE).setParameterLength(1);
    // 2 inputs
    const bitcast = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.BITCAST).setParameterLength(2);
    const equals = (x, y) => { // @deprecated, r172
        console.warn('THREE.TSL: "equals" is deprecated. Use "equal" inside a vector instead, like: "bvec*( equal( ... ) )"');
        return equal(x, y);
    };
    const min$1 = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.MIN).setParameterLength(2, Infinity);
    const max$1 = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.MAX).setParameterLength(2, Infinity);
    const step = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.STEP).setParameterLength(2);
    const reflect = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.REFLECT).setParameterLength(2);
    const distance = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.DISTANCE).setParameterLength(2);
    const difference = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.DIFFERENCE).setParameterLength(2);
    const dot = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.DOT).setParameterLength(2);
    const cross = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.CROSS).setParameterLength(2);
    const pow = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.POW).setParameterLength(2);
    const pow2 = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.POW, 2).setParameterLength(1);
    const pow3 = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.POW, 3).setParameterLength(1);
    const pow4 = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.POW, 4).setParameterLength(1);
    const transformDirection = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.TRANSFORM_DIRECTION).setParameterLength(2);
    const cbrt = (a) => mul(sign(a), pow(abs(a), 1.0 / 3.0));
    const lengthSq = (a) => dot(a, a);
    const mix = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.MIX).setParameterLength(3);
    const clamp = (value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));
    const saturate = (value) => clamp(value);
    const refract = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.REFRACT).setParameterLength(3);
    const smoothstep = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.SMOOTHSTEP).setParameterLength(3);
    const faceForward = /*@__PURE__*/ nodeProxyIntent(MathNode, MathNode.FACEFORWARD).setParameterLength(3);
    const rand = /*@__PURE__*/ Fn(([uv]) => {
        const a = 12.9898, b = 78.233, c = 43758.5453;
        const dt = dot(uv.xy, vec2(a, b)), sn = mod(dt, PI);
        return fract(sin(sn).mul(c));
    });
    const mixElement = (t, e1, e2) => mix(e1, e2, t);
    const smoothstepElement = (x, low, high) => smoothstep(low, high, x);
    const stepElement = (x, edge) => step(edge, x);
    const atan2 = (y, x) => { // @deprecated, r172
        console.warn('THREE.TSL: "atan2" is overloaded. Use "atan" instead.');
        return atan(y, x);
    };
    // GLSL alias function
    const faceforward = faceForward;
    const inversesqrt = inverseSqrt;
    // Method chaining
    addMethodChaining('all', all);
    addMethodChaining('any', any);
    addMethodChaining('equals', equals);
    addMethodChaining('radians', radians);
    addMethodChaining('degrees', degrees);
    addMethodChaining('exp', exp);
    addMethodChaining('exp2', exp2);
    addMethodChaining('log', log);
    addMethodChaining('log2', log2);
    addMethodChaining('sqrt', sqrt);
    addMethodChaining('inverseSqrt', inverseSqrt);
    addMethodChaining('floor', floor);
    addMethodChaining('ceil', ceil);
    addMethodChaining('normalize', normalize);
    addMethodChaining('fract', fract);
    addMethodChaining('sin', sin);
    addMethodChaining('cos', cos);
    addMethodChaining('tan', tan);
    addMethodChaining('asin', asin);
    addMethodChaining('acos', acos);
    addMethodChaining('atan', atan);
    addMethodChaining('abs', abs);
    addMethodChaining('sign', sign);
    addMethodChaining('length', length);
    addMethodChaining('lengthSq', lengthSq);
    addMethodChaining('negate', negate);
    addMethodChaining('oneMinus', oneMinus);
    addMethodChaining('dFdx', dFdx);
    addMethodChaining('dFdy', dFdy);
    addMethodChaining('round', round);
    addMethodChaining('reciprocal', reciprocal);
    addMethodChaining('trunc', trunc);
    addMethodChaining('fwidth', fwidth);
    addMethodChaining('atan2', atan2);
    addMethodChaining('min', min$1);
    addMethodChaining('max', max$1);
    addMethodChaining('step', stepElement);
    addMethodChaining('reflect', reflect);
    addMethodChaining('distance', distance);
    addMethodChaining('dot', dot);
    addMethodChaining('cross', cross);
    addMethodChaining('pow', pow);
    addMethodChaining('pow2', pow2);
    addMethodChaining('pow3', pow3);
    addMethodChaining('pow4', pow4);
    addMethodChaining('transformDirection', transformDirection);
    addMethodChaining('mix', mixElement);
    addMethodChaining('clamp', clamp);
    addMethodChaining('refract', refract);
    addMethodChaining('smoothstep', smoothstepElement);
    addMethodChaining('faceForward', faceForward);
    addMethodChaining('difference', difference);
    addMethodChaining('saturate', saturate);
    addMethodChaining('cbrt', cbrt);
    addMethodChaining('transpose', transpose);
    addMethodChaining('determinant', determinant);
    addMethodChaining('inverse', inverse);
    addMethodChaining('rand', rand);
    class ConditionalNode extends Node {
        static get type() {
            return 'ConditionalNode';
        }
        constructor(condNode, ifNode, elseNode = null) {
            super();
            this.condNode = condNode;
            this.ifNode = ifNode;
            this.elseNode = elseNode;
        }
        getNodeType(builder) {
            const { ifNode, elseNode } = builder.getNodeProperties(this);
            if (ifNode === undefined) {
                // fallback setup
                builder.flowBuildStage(this, 'setup');
                return this.getNodeType(builder);
            }
            const ifType = ifNode.getNodeType(builder);
            if (elseNode !== null) {
                const elseType = elseNode.getNodeType(builder);
                if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
                    return elseType;
                }
            }
            return ifType;
        }
        setup(builder) {
            const condNode = this.condNode.cache();
            const ifNode = this.ifNode.cache();
            const elseNode = this.elseNode ? this.elseNode.cache() : null;
            //
            const currentNodeBlock = builder.context.nodeBlock;
            builder.getDataFromNode(ifNode).parentNodeBlock = currentNodeBlock;
            if (elseNode !== null) builder.getDataFromNode(elseNode).parentNodeBlock = currentNodeBlock;
            //
            const properties = builder.getNodeProperties(this);
            properties.condNode = condNode;
            properties.ifNode = ifNode.context({ nodeBlock: ifNode });
            properties.elseNode = elseNode ? elseNode.context({ nodeBlock: elseNode }) : null;
        }
        generate(builder, output) {
            const type = this.getNodeType(builder);
            const nodeData = builder.getDataFromNode(this);
            if (nodeData.nodeProperty !== undefined) {
                return nodeData.nodeProperty;
            }
            const { condNode, ifNode, elseNode } = builder.getNodeProperties(this);
            const functionNode = builder.currentFunctionNode;
            const needsOutput = output !== 'void';
            const nodeProperty = needsOutput ? property(type).build(builder) : '';
            nodeData.nodeProperty = nodeProperty;
            const nodeSnippet = condNode.build(builder, 'bool');
            builder.addFlowCode(`\n${builder.tab}if ( ${nodeSnippet} ) {\n\n`).addFlowTab();
            let ifSnippet = ifNode.build(builder, type);
            if (ifSnippet) {
                if (needsOutput) {
                    ifSnippet = nodeProperty + ' = ' + ifSnippet + ';';
                } else {
                    ifSnippet = 'return ' + ifSnippet + ';';
                    if (functionNode === null) {
                        console.warn('THREE.TSL: Return statement used in an inline \'Fn()\'. Define a layout struct to allow return values.');
                        ifSnippet = '// ' + ifSnippet;
                    }
                }
            }
            builder.removeFlowTab().addFlowCode(builder.tab + '\t' + ifSnippet + '\n\n' + builder.tab + '}');
            if (elseNode !== null) {
                builder.addFlowCode(' else {\n\n').addFlowTab();
                let elseSnippet = elseNode.build(builder, type);
                if (elseSnippet) {
                    if (needsOutput) {
                        elseSnippet = nodeProperty + ' = ' + elseSnippet + ';';
                    } else {
                        elseSnippet = 'return ' + elseSnippet + ';';
                        if (functionNode === null) {
                            console.warn('THREE.TSL: Return statement used in an inline \'Fn()\'. Define a layout struct to allow return values.');
                            elseSnippet = '// ' + elseSnippet;
                        }
                    }
                }
                builder.removeFlowTab().addFlowCode(builder.tab + '\t' + elseSnippet + '\n\n' + builder.tab + '}\n\n');
            } else {
                builder.addFlowCode('\n\n');
            }
            return builder.format(nodeProperty, type, output);
        }
    }
    const select = /*@__PURE__*/ nodeProxy(ConditionalNode).setParameterLength(2, 3);
    addMethodChaining('select', select);
    class ContextNode extends Node {
        static get type() {
            return 'ContextNode';
        }
        constructor(node, value = {}) {
            super();
            this.isContextNode = true;
            this.node = node;
            this.value = value;
        }
        getScope() {
            return this.node.getScope();
        }
        getNodeType(builder) {
            return this.node.getNodeType(builder);
        }
        analyze(builder) {
            const previousContext = builder.getContext();
            builder.setContext({ ...builder.context, ...this.value });
            this.node.build(builder);
            builder.setContext(previousContext);
        }
        setup(builder) {
            const previousContext = builder.getContext();
            builder.setContext({ ...builder.context, ...this.value });
            this.node.build(builder);
            builder.setContext(previousContext);
        }
        generate(builder, output) {
            const previousContext = builder.getContext();
            builder.setContext({ ...builder.context, ...this.value });
            const snippet = this.node.build(builder, output);
            builder.setContext(previousContext);
            return snippet;
        }
    }
    const context = /*@__PURE__*/ nodeProxy(ContextNode).setParameterLength(1, 2);
    const setName = (node, name) => context(node, { nodeName: name });
    function label(node, name) {
        console.warn('THREE.TSL: "label()" has been deprecated. Use "setName()" instead.'); // @deprecated r179
        return setName(node, name);
    }
    addMethodChaining('context', context);
    addMethodChaining('label', label);
    addMethodChaining('setName', setName);
    class VarNode extends Node {
        static get type() {
            return 'VarNode';
        }
        constructor(node, name = null, readOnly = false) {
            super();
            this.node = node;
            this.name = name;
            this.global = true;
            this.isVarNode = true;
            this.readOnly = readOnly;
            this.parents = true;
            this.intent = false;
        }
        setIntent(value) {
            this.intent = value;
            return this;
        }
        getIntent() {
            return this.intent;
        }
        getMemberType(builder, name) {
            return this.node.getMemberType(builder, name);
        }
        getElementType(builder) {
            return this.node.getElementType(builder);
        }
        getNodeType(builder) {
            return this.node.getNodeType(builder);
        }
        getArrayCount(builder) {
            return this.node.getArrayCount(builder);
        }
        build(...params) {
            if (this.intent === true) {
                const builder = params[0];
                const properties = builder.getNodeProperties(this);
                if (properties.assign !== true) {
                    return this.node.build(...params);
                }
            }
            return super.build(...params);
        }
        generate(builder) {
            const { node, name, readOnly } = this;
            const { renderer } = builder;
            const isWebGPUBackend = renderer.backend.isWebGPUBackend === true;
            let isDeterministic = false;
            let shouldTreatAsReadOnly = false;
            if (readOnly) {
                isDeterministic = builder.isDeterministic(node);
                shouldTreatAsReadOnly = isWebGPUBackend ? readOnly : isDeterministic;
            }
            const vectorType = builder.getVectorType(this.getNodeType(builder));
            const snippet = node.build(builder, vectorType);
            const nodeVar = builder.getVarFromNode(this, name, vectorType, undefined, shouldTreatAsReadOnly);
            const propertyName = builder.getPropertyName(nodeVar);
            let declarationPrefix = propertyName;
            if (shouldTreatAsReadOnly) {
                if (isWebGPUBackend) {
                    declarationPrefix = isDeterministic
                        ? `const ${propertyName}`
                        : `let ${propertyName}`;
                } else {
                    const count = node.getArrayCount(builder);
                    declarationPrefix = `const ${builder.getVar(nodeVar.type, propertyName, count)}`;
                }
            }
            builder.addLineFlowCode(`${declarationPrefix} = ${snippet}`, this);
            return propertyName;
        }
    }
    const createVar = /*@__PURE__*/ nodeProxy(VarNode);
    const Var = (node, name = null) => createVar(node, name).toStack();
    const Const = (node, name = null) => createVar(node, name, true).toStack();
    //
    //
    const VarIntent = (node) => {
        if (getCurrentStack() === null) {
            return node;
        }
        return createVar(node).setIntent(true).toStack();
    };
    // Method chaining
    addMethodChaining('toVar', Var);
    addMethodChaining('toConst', Const);
    addMethodChaining('toVarIntent', VarIntent);
    // Deprecated
    const temp = (node) => { // @deprecated, r170
        console.warn('TSL: "temp( node )" is deprecated. Use "Var( node )" or "node.toVar()" instead.');
        return createVar(node);
    };
    addMethodChaining('temp', temp);
    class SubBuildNode extends Node {
        static get type() {
            return 'SubBuild';
        }
        constructor(node, name, nodeType = null) {
            super(nodeType);
            this.node = node;
            this.name = name;
            this.isSubBuildNode = true;
        }
        getNodeType(builder) {
            if (this.nodeType !== null) return this.nodeType;
            builder.addSubBuild(this.name);
            const nodeType = this.node.getNodeType(builder);
            builder.removeSubBuild();
            return nodeType;
        }
        build(builder, ...params) {
            builder.addSubBuild(this.name);
            const data = this.node.build(builder, ...params);
            builder.removeSubBuild();
            return data;
        }
    }
    const subBuild = (node, name, type = null) => nodeObject(new SubBuildNode(nodeObject(node), name, type));
    class VaryingNode extends Node {
        static get type() {
            return 'VaryingNode';
        }
        constructor(node, name = null) {
            super();
            this.node = node;
            this.name = name;
            this.isVaryingNode = true;
            this.interpolationType = null;
            this.interpolationSampling = null;
            this.global = true;
        }
        setInterpolation(type, sampling = null) {
            this.interpolationType = type;
            this.interpolationSampling = sampling;
            return this;
        }
        getHash(builder) {
            return this.name || super.getHash(builder);
        }
        getNodeType(builder) {
            // VaryingNode is auto type
            return this.node.getNodeType(builder);
        }
        setupVarying(builder) {
            const properties = builder.getNodeProperties(this);
            let varying = properties.varying;
            if (varying === undefined) {
                const name = this.name;
                const type = this.getNodeType(builder);
                const interpolationType = this.interpolationType;
                const interpolationSampling = this.interpolationSampling;
                properties.varying = varying = builder.getVaryingFromNode(this, name, type, interpolationType, interpolationSampling);
                properties.node = subBuild(this.node, 'VERTEX');
            }
            // this property can be used to check if the varying can be optimized for a variable
            varying.needsInterpolation || (varying.needsInterpolation = (builder.shaderStage === 'fragment'));
            return varying;
        }
        setup(builder) {
            this.setupVarying(builder);
            builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node);
        }
        analyze(builder) {
            this.setupVarying(builder);
            builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node);
        }
        generate(builder) {
            const propertyKey = builder.getSubBuildProperty('property', builder.currentStack);
            const properties = builder.getNodeProperties(this);
            const varying = this.setupVarying(builder);
            if (properties[propertyKey] === undefined) {
                const type = this.getNodeType(builder);
                const propertyName = builder.getPropertyName(varying, NodeShaderStage.VERTEX);
                // force node run in vertex stage
                builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, properties.node, type, propertyName);
                properties[propertyKey] = propertyName;
            }
            return builder.getPropertyName(varying);
        }
    }
    const varying = /*@__PURE__*/ nodeProxy(VaryingNode).setParameterLength(1, 2);
    const vertexStage = (node) => varying(node);
    addMethodChaining('toVarying', varying);
    addMethodChaining('toVertexStage', vertexStage);
    // Deprecated
    addMethodChaining('varying', (...params) => { // @deprecated, r173
        console.warn('THREE.TSL: .varying() has been renamed to .toVarying().');
        return varying(...params);
    });
    addMethodChaining('vertexStage', (...params) => { // @deprecated, r173
        console.warn('THREE.TSL: .vertexStage() has been renamed to .toVertexStage().');
        return varying(...params);
    });
    const sRGBTransferEOTF = /*@__PURE__*/ Fn(([color]) => {
        const a = color.mul(0.9478672986).add(0.0521327014).pow(2.4);
        const b = color.mul(0.0773993808);
        const factor = color.lessThanEqual(0.04045);
        const rgbResult = mix(a, b, factor);
        return rgbResult;
    }).setLayout({
        name: 'sRGBTransferEOTF',
        type: 'vec3',
        inputs: [
            { name: 'color', type: 'vec3' }
        ]
    });
    const sRGBTransferOETF = /*@__PURE__*/ Fn(([color]) => {
        const a = color.pow(0.41666).mul(1.055).sub(0.055);
        const b = color.mul(12.92);
        const factor = color.lessThanEqual(0.0031308);
        const rgbResult = mix(a, b, factor);
        return rgbResult;
    }).setLayout({
        name: 'sRGBTransferOETF',
        type: 'vec3',
        inputs: [
            { name: 'color', type: 'vec3' }
        ]
    });
    const WORKING_COLOR_SPACE = 'WorkingColorSpace';
    const OUTPUT_COLOR_SPACE = 'OutputColorSpace';
    class ColorSpaceNode extends TempNode {
        static get type() {
            return 'ColorSpaceNode';
        }
        constructor(colorNode, source, target) {
            super('vec4');
            this.colorNode = colorNode;
            this.source = source;
            this.target = target;
        }
        resolveColorSpace(builder, colorSpace) {
            if (colorSpace === WORKING_COLOR_SPACE) {
                return ColorManagement.workingColorSpace;
            } else if (colorSpace === OUTPUT_COLOR_SPACE) {
                return builder.context.outputColorSpace || builder.renderer.outputColorSpace;
            }
            return colorSpace;
        }
        setup(builder) {
            const { colorNode } = this;
            const source = this.resolveColorSpace(builder, this.source);
            const target = this.resolveColorSpace(builder, this.target);
            let outputNode = colorNode;
            if (ColorManagement.enabled === false || source === target || !source || !target) {
                return outputNode;
            }
            if (ColorManagement.getTransfer(source) === SRGBTransfer) {
                outputNode = vec4(sRGBTransferEOTF(outputNode.rgb), outputNode.a);
            }
            if (ColorManagement.getPrimaries(source) !== ColorManagement.getPrimaries(target)) {
                outputNode = vec4(
                    mat3(ColorManagement._getMatrix(new Matrix3(), source, target)).mul(outputNode.rgb),
                    outputNode.a
                );
            }
            if (ColorManagement.getTransfer(target) === SRGBTransfer) {
                outputNode = vec4(sRGBTransferOETF(outputNode.rgb), outputNode.a);
            }
            return outputNode;
        }
    }
    const workingToColorSpace = (node, targetColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, targetColorSpace));
    const colorSpaceToWorking = (node, sourceColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), sourceColorSpace, WORKING_COLOR_SPACE));
    const convertColorSpace = (node, sourceColorSpace, targetColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), sourceColorSpace, targetColorSpace));
    addMethodChaining('workingToColorSpace', workingToColorSpace);
    addMethodChaining('colorSpaceToWorking', colorSpaceToWorking);
    // TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode
    let ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {
        static get type() {
            return 'ReferenceElementNode';
        }
        constructor(referenceNode, indexNode) {
            super(referenceNode, indexNode);
            this.referenceNode = referenceNode;
            this.isReferenceElementNode = true;
        }
        getNodeType() {
            return this.referenceNode.uniformType;
        }
        generate(builder) {
            const snippet = super.generate(builder);
            const arrayType = this.referenceNode.getNodeType();
            const elementType = this.getNodeType();
            return builder.format(snippet, arrayType, elementType);
        }
    };
    class ReferenceBaseNode extends Node {
        static get type() {
            return 'ReferenceBaseNode';
        }
        constructor(property, uniformType, object = null, count = null) {
            super();
            this.property = property;
            this.uniformType = uniformType;
            this.object = object;
            this.count = count;
            this.properties = property.split('.');
            this.reference = object;
            this.node = null;
            this.group = null;
            this.updateType = NodeUpdateType.OBJECT;
        }
        setGroup(group) {
            this.group = group;
            return this;
        }
        element(indexNode) {
            return nodeObject(new ReferenceElementNode$1(this, nodeObject(indexNode)));
        }
        setNodeType(uniformType) {
            const node = uniform(null, uniformType).getSelf();
            if (this.group !== null) {
                node.setGroup(this.group);
            }
            this.node = node;
        }
        getNodeType(builder) {
            if (this.node === null) {
                this.updateReference(builder);
                this.updateValue();
            }
            return this.node.getNodeType(builder);
        }
        getValueFromReference(object = this.reference) {
            const { properties } = this;
            let value = object[properties[0]];
            for (let i = 1; i < properties.length; i++) {
                value = value[properties[i]];
            }
            return value;
        }
        updateReference(state) {
            this.reference = this.object !== null ? this.object : state.object;
            return this.reference;
        }
        setup() {
            this.updateValue();
            return this.node;
        }
        update( /*frame*/) {
            this.updateValue();
        }
        updateValue() {
            if (this.node === null) this.setNodeType(this.uniformType);
            const value = this.getValueFromReference();
            if (Array.isArray(value)) {
                this.node.array = value;
            } else {
                this.node.value = value;
            }
        }
    }
    const reference$1 = (name, type, object) => nodeObject(new ReferenceBaseNode(name, type, object));
    class RendererReferenceNode extends ReferenceBaseNode {
        static get type() {
            return 'RendererReferenceNode';
        }
        constructor(property, inputType, renderer = null) {
            super(property, inputType, renderer);
            this.renderer = renderer;
            this.setGroup(renderGroup);
        }
        updateReference(state) {
            this.reference = this.renderer !== null ? this.renderer : state.renderer;
            return this.reference;
        }
    }
    const rendererReference = (name, type, renderer = null) => nodeObject(new RendererReferenceNode(name, type, renderer));
    class ToneMappingNode extends TempNode {
        static get type() {
            return 'ToneMappingNode';
        }
        constructor(toneMapping, exposureNode = toneMappingExposure, colorNode = null) {
            super('vec3');
            this.toneMapping = toneMapping;
            this.exposureNode = exposureNode;
            this.colorNode = colorNode;
        }
        customCacheKey() {
            return hash$1(this.toneMapping);
        }
        setup(builder) {
            const colorNode = this.colorNode || builder.context.color;
            const toneMapping = this.toneMapping;
            if (toneMapping === NoToneMapping) return colorNode;
            let outputNode = null;
            const toneMappingFn = builder.renderer.library.getToneMappingFunction(toneMapping);
            if (toneMappingFn !== null) {
                outputNode = vec4(toneMappingFn(colorNode.rgb, this.exposureNode), colorNode.a);
            } else {
                console.error('ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping);
                outputNode = colorNode;
            }
            return outputNode;
        }
    }
    const toneMapping = (mapping, exposure, color) => nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color)));
    const toneMappingExposure = /*@__PURE__*/ rendererReference('toneMappingExposure', 'float');
    addMethodChaining('toneMapping', (color, mapping, exposure) => toneMapping(mapping, exposure, color));
    class BufferAttributeNode extends InputNode {
        static get type() {
            return 'BufferAttributeNode';
        }
        constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
            super(value, bufferType);
            this.isBufferNode = true;
            this.bufferType = bufferType;
            this.bufferStride = bufferStride;
            this.bufferOffset = bufferOffset;
            this.usage = StaticDrawUsage;
            this.instanced = false;
            this.attribute = null;
            this.global = true;
            if (value && value.isBufferAttribute === true) {
                this.attribute = value;
                this.usage = value.usage;
                this.instanced = value.isInstancedBufferAttribute;
            }
        }
        getHash(builder) {
            if (this.bufferStride === 0 && this.bufferOffset === 0) {
                let bufferData = builder.globalCache.getData(this.value);
                if (bufferData === undefined) {
                    bufferData = {
                        node: this
                    };
                    builder.globalCache.setData(this.value, bufferData);
                }
                return bufferData.node.uuid;
            }
            return this.uuid;
        }
        getNodeType(builder) {
            if (this.bufferType === null) {
                this.bufferType = builder.getTypeFromAttribute(this.attribute);
            }
            return this.bufferType;
        }
        setup(builder) {
            if (this.attribute !== null) return;
            const type = this.getNodeType(builder);
            const array = this.value;
            const itemSize = builder.getTypeLength(type);
            const stride = this.bufferStride || itemSize;
            const offset = this.bufferOffset;
            const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer(array, stride);
            const bufferAttribute = new InterleavedBufferAttribute(buffer, itemSize, offset);
            buffer.setUsage(this.usage);
            this.attribute = bufferAttribute;
            this.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute
        }
        generate(builder) {
            const nodeType = this.getNodeType(builder);
            const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
            const propertyName = builder.getPropertyName(nodeAttribute);
            let output = null;
            if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {
                this.name = propertyName;
                output = propertyName;
            } else {
                const nodeVarying = varying(this);
                output = nodeVarying.build(builder, nodeType);
            }
            return output;
        }
        getInputType( /*builder*/) {
            return 'bufferAttribute';
        }
        setUsage(value) {
            this.usage = value;
            if (this.attribute && this.attribute.isBufferAttribute === true) {
                this.attribute.usage = value;
            }
            return this;
        }
        setInstanced(value) {
            this.instanced = value;
            return this;
        }
    }
    const bufferAttribute = (array, type = null, stride = 0, offset = 0) => nodeObject(new BufferAttributeNode(array, type, stride, offset));
    const dynamicBufferAttribute = (array, type = null, stride = 0, offset = 0) => bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);
    const instancedBufferAttribute = (array, type = null, stride = 0, offset = 0) => bufferAttribute(array, type, stride, offset).setInstanced(true);
    const instancedDynamicBufferAttribute = (array, type = null, stride = 0, offset = 0) => dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);
    addMethodChaining('toAttribute', (bufferNode) => bufferAttribute(bufferNode.value));
    class ComputeNode extends Node {
        static get type() {
            return 'ComputeNode';
        }
        constructor(computeNode, workgroupSize) {
            super('void');
            this.isComputeNode = true;
            this.computeNode = computeNode;

            this.workgroupSize = workgroupSize;
            this.count = null;
            this.version = 1;
            this.name = '';
            this.updateBeforeType = NodeUpdateType.OBJECT;
            this.onInitFunction = null;
        }
        setCount(count) {
            this.count = count;
            return this;
        }
        getCount() {
            return this.count;
        }
        dispose() {
            this.dispatchEvent({ type: 'dispose' });
        }
        setName(name) {
            this.name = name;
            return this;
        }
        label(name) {
            console.warn('THREE.TSL: "label()" has been deprecated. Use "setName()" instead.'); // @deprecated r179
            return this.setName(name);
        }
        onInit(callback) {
            this.onInitFunction = callback;
            return this;
        }
        updateBefore({ renderer }) {
            renderer.compute(this);
        }
        setup(builder) {
            const result = this.computeNode.build(builder);
            if (result) {
                const properties = builder.getNodeProperties(this);
                properties.outputComputeNode = result.outputNode;
                result.outputNode = null;
            }
            return result;
        }
        generate(builder, output) {
            const { shaderStage } = builder;
            if (shaderStage === 'compute') {
                const snippet = this.computeNode.build(builder, 'void');
                if (snippet !== '') {
                    builder.addLineFlowCode(snippet, this);
                }
            } else {
                const properties = builder.getNodeProperties(this);
                const outputComputeNode = properties.outputComputeNode;
                if (outputComputeNode) {
                    return outputComputeNode.build(builder, output);
                }
            }
        }
    }
    const computeKernel = (node, workgroupSize = [64]) => {
        if (workgroupSize.length === 0 || workgroupSize.length > 3) {
            console.error('THREE.TSL: compute() workgroupSize must have 1, 2, or 3 elements');
        }
        for (let i = 0; i < workgroupSize.length; i++) {
            const val = workgroupSize[i];
            if (typeof val !== 'number' || val <= 0 || !Number.isInteger(val)) {
                console.error(`THREE.TSL: compute() workgroupSize element at index [ ${i} ] must be a positive integer`);
            }
        }
        // Implicit fill-up to [ x, y, z ] with 1s, just like WGSL treats @workgroup_size when fewer dimensions are specified
        while (workgroupSize.length < 3) workgroupSize.push(1);
        //
        return nodeObject(new ComputeNode(nodeObject(node), workgroupSize));
    };
    const compute = (node, count, workgroupSize) => computeKernel(node, workgroupSize).setCount(count);
    addMethodChaining('compute', compute);
    addMethodChaining('computeKernel', computeKernel);
    class CacheNode extends Node {
        static get type() {
            return 'CacheNode';
        }
        constructor(node, parent = true) {
            super();
            this.node = node;
            this.parent = parent;
            this.isCacheNode = true;
        }
        getNodeType(builder) {
            const previousCache = builder.getCache();
            const cache = builder.getCacheFromNode(this, this.parent);
            builder.setCache(cache);
            const nodeType = this.node.getNodeType(builder);
            builder.setCache(previousCache);
            return nodeType;
        }
        build(builder, ...params) {
            const previousCache = builder.getCache();
            const cache = builder.getCacheFromNode(this, this.parent);
            builder.setCache(cache);
            const data = this.node.build(builder, ...params);
            builder.setCache(previousCache);
            return data;
        }
    }
    const cache = (node, parent) => nodeObject(new CacheNode(nodeObject(node), parent));
    addMethodChaining('cache', cache);
    class BypassNode extends Node {
        static get type() {
            return 'BypassNode';
        }
        constructor(outputNode, callNode) {
            super();
            this.isBypassNode = true;
            this.outputNode = outputNode;
            this.callNode = callNode;
        }
        getNodeType(builder) {
            return this.outputNode.getNodeType(builder);
        }
        generate(builder) {
            const snippet = this.callNode.build(builder, 'void');
            if (snippet !== '') {
                builder.addLineFlowCode(snippet, this);
            }
            return this.outputNode.build(builder);
        }
    }
    const bypass = /*@__PURE__*/ nodeProxy(BypassNode).setParameterLength(2);
    addMethodChaining('bypass', bypass);
    class RemapNode extends Node {
        static get type() {
            return 'RemapNode';
        }
        constructor(node, inLowNode, inHighNode, outLowNode = float(0), outHighNode = float(1)) {
            super();
            this.node = node;
            this.inLowNode = inLowNode;
            this.inHighNode = inHighNode;
            this.outLowNode = outLowNode;
            this.outHighNode = outHighNode;
            this.doClamp = true;
        }
        setup() {
            const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;
            let t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));
            if (doClamp === true) t = t.clamp();
            return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);
        }
    }
    const remap = /*@__PURE__*/ nodeProxy(RemapNode, null, null, { doClamp: false }).setParameterLength(3, 5);
    const remapClamp = /*@__PURE__*/ nodeProxy(RemapNode).setParameterLength(3, 5);
    addMethodChaining('remap', remap);
    addMethodChaining('remapClamp', remapClamp);
    class ExpressionNode extends Node {
        static get type() {
            return 'ExpressionNode';
        }
        constructor(snippet = '', nodeType = 'void') {
            super(nodeType);
            this.snippet = snippet;
        }
        generate(builder, output) {
            const type = this.getNodeType(builder);
            const snippet = this.snippet;
            if (type === 'void') {
                builder.addLineFlowCode(snippet, this);
            } else {
                return builder.format(snippet, type, output);
            }
        }
    }
    const expression = /*@__PURE__*/ nodeProxy(ExpressionNode).setParameterLength(1, 2);
    const Discard = (conditional) => (conditional ? select(conditional, expression('discard')) : expression('discard')).toStack();
    const Return = () => expression('return').toStack();
    addMethodChaining('discard', Discard);
    class RenderOutputNode extends TempNode {
        static get type() {
            return 'RenderOutputNode';
        }
        constructor(colorNode, toneMapping, outputColorSpace) {
            super('vec4');
            this.colorNode = colorNode;
            this.toneMapping = toneMapping;
            this.outputColorSpace = outputColorSpace;
            this.isRenderOutputNode = true;
        }
        setup({ context }) {
            let outputNode = this.colorNode || context.color;
            // tone mapping
            const toneMapping = (this.toneMapping !== null ? this.toneMapping : context.toneMapping) || NoToneMapping;
            const outputColorSpace = (this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace) || NoColorSpace;
            if (toneMapping !== NoToneMapping) {
                outputNode = outputNode.toneMapping(toneMapping);
            }
            // working to output color space
            if (outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace) {
                outputNode = outputNode.workingToColorSpace(outputColorSpace);
            }
            return outputNode;
        }
    }
    const renderOutput = (color, toneMapping = null, outputColorSpace = null) => nodeObject(new RenderOutputNode(nodeObject(color), toneMapping, outputColorSpace));
    addMethodChaining('renderOutput', renderOutput);
    class DebugNode extends TempNode {
        static get type() {
            return 'DebugNode';
        }
        constructor(node, callback = null) {
            super();
            this.node = node;
            this.callback = callback;
        }
        getNodeType(builder) {
            return this.node.getNodeType(builder);
        }
        setup(builder) {
            return this.node.build(builder);
        }
        analyze(builder) {
            return this.node.build(builder);
        }
        generate(builder) {
            const callback = this.callback;
            const snippet = this.node.build(builder);
            const title = '--- TSL debug - ' + builder.shaderStage + ' shader ---';
            const border = '-'.repeat(title.length);
            let code = '';
            code += '// #' + title + '#\n';
            code += builder.flow.code.replace(/^\t/mg, '') + '\n';
            code += '/* ... */ ' + snippet + ' /* ... */\n';
            code += '// #' + border + '#\n';
            if (callback !== null) {
                callback(builder, code);
            } else {
                console.log(code);
            }
            return snippet;
        }
    }
    const debug = (node, callback = null) => nodeObject(new DebugNode(nodeObject(node), callback)).toStack();
    addMethodChaining('debug', debug);
    // Non-PURE exports list, side-effects are required here.
    // TSL Base Syntax

    function addNodeElement(name/*, nodeElement*/) {
        console.warn('THREE.TSL: AddNodeElement has been removed in favor of tree-shaking. Trying add', name);
    }
    class AttributeNode extends Node {
        static get type() {
            return 'AttributeNode';
        }
        constructor(attributeName, nodeType = null) {
            super(nodeType);
            this.global = true;
            this._attributeName = attributeName;
        }
        getHash(builder) {
            return this.getAttributeName(builder);
        }
        getNodeType(builder) {
            let nodeType = this.nodeType;
            if (nodeType === null) {
                const attributeName = this.getAttributeName(builder);
                if (builder.hasGeometryAttribute(attributeName)) {
                    const attribute = builder.geometry.getAttribute(attributeName);
                    nodeType = builder.getTypeFromAttribute(attribute);
                } else {
                    nodeType = 'float';
                }
            }
            return nodeType;
        }
        setAttributeName(attributeName) {
            this._attributeName = attributeName;
            return this;
        }
        getAttributeName( /*builder*/) {
            return this._attributeName;
        }
        generate(builder) {
            const attributeName = this.getAttributeName(builder);
            const nodeType = this.getNodeType(builder);
            const geometryAttribute = builder.hasGeometryAttribute(attributeName);
            if (geometryAttribute === true) {
                const attribute = builder.geometry.getAttribute(attributeName);
                const attributeType = builder.getTypeFromAttribute(attribute);
                const nodeAttribute = builder.getAttribute(attributeName, attributeType);
                if (builder.shaderStage === 'vertex') {
                    return builder.format(nodeAttribute.name, attributeType, nodeType);
                } else {
                    const nodeVarying = varying(this);
                    return nodeVarying.build(builder, nodeType);
                }
            } else {
                console.warn(`AttributeNode: Vertex attribute "${attributeName}" not found on geometry.`);
                return builder.generateConst(nodeType);
            }
        }
        serialize(data) {
            super.serialize(data);
            data.global = this.global;
            data._attributeName = this._attributeName;
        }
        deserialize(data) {
            super.deserialize(data);
            this.global = data.global;
            this._attributeName = data._attributeName;
        }
    }
    const attribute = (name, nodeType = null) => nodeObject(new AttributeNode(name, nodeType));
    const uv = (index = 0) => attribute('uv' + (index > 0 ? index : ''), 'vec2');
    class TextureSizeNode extends Node {
        static get type() {
            return 'TextureSizeNode';
        }
        constructor(textureNode, levelNode = null) {
            super('uvec2');
            this.isTextureSizeNode = true;
            this.textureNode = textureNode;
            this.levelNode = levelNode;
        }
        generate(builder, output) {
            const textureProperty = this.textureNode.build(builder, 'property');
            const level = this.levelNode === null ? '0' : this.levelNode.build(builder, 'int');
            return builder.format(`${builder.getMethod('textureDimensions')}( ${textureProperty}, ${level} )`, this.getNodeType(builder), output);
        }
    }
    const textureSize = /*@__PURE__*/ nodeProxy(TextureSizeNode).setParameterLength(1, 2);
    class MaxMipLevelNode extends UniformNode {
        static get type() {
            return 'MaxMipLevelNode';
        }
        constructor(textureNode) {
            super(0);
            this._textureNode = textureNode;
            this.updateType = NodeUpdateType.FRAME;
        }
        get textureNode() {
            return this._textureNode;
        }
        get texture() {
            return this._textureNode.value;
        }
        update() {
            const texture = this.texture;
            const images = texture.images;
            const image = (images && images.length > 0) ? ((images[0] && images[0].image) || images[0]) : texture.image;
            if (image && image.width !== undefined) {
                const { width, height } = image;
                this.value = Math.log2(Math.max(width, height));
            }
        }
    }
    const maxMipLevel = /*@__PURE__*/ nodeProxy(MaxMipLevelNode).setParameterLength(1);
    const EmptyTexture$1 = /*@__PURE__*/ new Texture();
    class TextureNode extends UniformNode {
        static get type() {
            return 'TextureNode';
        }
        constructor(value = EmptyTexture$1, uvNode = null, levelNode = null, biasNode = null) {
            super(value);
            this.isTextureNode = true;
            this.uvNode = uvNode;
            this.levelNode = levelNode;
            this.biasNode = biasNode;
            this.compareNode = null;
            this.depthNode = null;
            this.gradNode = null;
            this.sampler = true;
            this.updateMatrix = false;
            this.updateType = NodeUpdateType.NONE;
            this.referenceNode = null;
            this._value = value;
            this._matrixUniform = null;
            this.setUpdateMatrix(uvNode === null);
        }
        set value(value) {
            if (this.referenceNode) {
                this.referenceNode.value = value;
            } else {
                this._value = value;
            }
        }
        get value() {
            return this.referenceNode ? this.referenceNode.value : this._value;
        }
        getUniformHash( /*builder*/) {
            return this.value.uuid;
        }
        getNodeType( /*builder*/) {
            if (this.value.isDepthTexture === true) return 'float';
            if (this.value.type === UnsignedIntType) {
                return 'uvec4';
            } else if (this.value.type === IntType) {
                return 'ivec4';
            }
            return 'vec4';
        }
        getInputType( /*builder*/) {
            return 'texture';
        }
        getDefaultUV() {
            return uv(this.value.channel);
        }
        updateReference( /*state*/) {
            return this.value;
        }
        getTransformedUV(uvNode) {
            if (this._matrixUniform === null) this._matrixUniform = uniform(this.value.matrix);
            return this._matrixUniform.mul(vec3(uvNode, 1)).xy;
        }
        setUpdateMatrix(value) {
            this.updateMatrix = value;
            this.updateType = value ? NodeUpdateType.OBJECT : NodeUpdateType.NONE;
            return this;
        }
        setupUV(builder, uvNode) {
            const texture = this.value;
            if (builder.isFlipY() && ((texture.image instanceof ImageBitmap && texture.flipY === true) || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true)) {
                if (this.sampler) {
                    uvNode = uvNode.flipY();
                } else {
                    uvNode = uvNode.setY(int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1));
                }
            }
            return uvNode;
        }
        setup(builder) {
            const properties = builder.getNodeProperties(this);
            properties.referenceNode = this.referenceNode;
            //
            const texture = this.value;
            if (!texture || texture.isTexture !== true) {
                throw new Error('THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().');
            }
            //
            let uvNode = this.uvNode;
            if ((uvNode === null || builder.context.forceUVContext === true) && builder.context.getUV) {
                uvNode = builder.context.getUV(this, builder);
            }
            if (!uvNode) uvNode = this.getDefaultUV();
            if (this.updateMatrix === true) {
                uvNode = this.getTransformedUV(uvNode);
            }
            uvNode = this.setupUV(builder, uvNode);
            //
            let levelNode = this.levelNode;
            if (levelNode === null && builder.context.getTextureLevel) {
                levelNode = builder.context.getTextureLevel(this);
            }
            //
            properties.uvNode = uvNode;
            properties.levelNode = levelNode;
            properties.biasNode = this.biasNode;
            properties.compareNode = this.compareNode;
            properties.gradNode = this.gradNode;
            properties.depthNode = this.depthNode;
        }
        generateUV(builder, uvNode) {
            return uvNode.build(builder, this.sampler === true ? 'vec2' : 'ivec2');
        }
        generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet) {
            const texture = this.value;
            let snippet;
            if (levelSnippet) {
                snippet = builder.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet);
            } else if (biasSnippet) {
                snippet = builder.generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, depthSnippet);
            } else if (gradSnippet) {
                snippet = builder.generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet);
            } else if (compareSnippet) {
                snippet = builder.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet);
            } else if (this.sampler === false) {
                snippet = builder.generateTextureLoad(texture, textureProperty, uvSnippet, depthSnippet);
            } else {
                snippet = builder.generateTexture(texture, textureProperty, uvSnippet, depthSnippet);
            }
            return snippet;
        }
        generate(builder, output) {
            const texture = this.value;
            const properties = builder.getNodeProperties(this);
            const textureProperty = super.generate(builder, 'property');
            if (/^sampler/.test(output)) {
                return textureProperty + '_sampler';
            } else if (builder.isReference(output)) {
                return textureProperty;
            } else {
                const nodeData = builder.getDataFromNode(this);
                let propertyName = nodeData.propertyName;
                if (propertyName === undefined) {
                    const { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode } = properties;
                    const uvSnippet = this.generateUV(builder, uvNode);
                    const levelSnippet = levelNode ? levelNode.build(builder, 'float') : null;
                    const biasSnippet = biasNode ? biasNode.build(builder, 'float') : null;
                    const depthSnippet = depthNode ? depthNode.build(builder, 'int') : null;
                    const compareSnippet = compareNode ? compareNode.build(builder, 'float') : null;
                    const gradSnippet = gradNode ? [gradNode[0].build(builder, 'vec2'), gradNode[1].build(builder, 'vec2')] : null;
                    const nodeVar = builder.getVarFromNode(this);
                    propertyName = builder.getPropertyName(nodeVar);
                    const snippet = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet);
                    builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
                    nodeData.snippet = snippet;
                    nodeData.propertyName = propertyName;
                }
                let snippet = propertyName;
                const nodeType = this.getNodeType(builder);
                if (builder.needsToWorkingColorSpace(texture)) {
                    snippet = colorSpaceToWorking(expression(snippet, nodeType), texture.colorSpace).setup(builder).build(builder, nodeType);
                }
                return builder.format(snippet, nodeType, output);
            }
        }
        setSampler(value) {
            this.sampler = value;
            return this;
        }
        getSampler() {
            return this.sampler;
        }
        // @TODO: Move to TSL
        uv(uvNode) { // @deprecated, r172
            console.warn('THREE.TextureNode: .uv() has been renamed. Use .sample() instead.');
            return this.sample(uvNode);
        }
        sample(uvNode) {
            const textureNode = this.clone();
            textureNode.uvNode = nodeObject(uvNode);
            textureNode.referenceNode = this.getSelf();
            return nodeObject(textureNode);
        }
        load(uvNode) {
            return this.sample(uvNode).setSampler(false);
        }
        blur(amountNode) {
            const textureNode = this.clone();
            textureNode.biasNode = nodeObject(amountNode).mul(maxMipLevel(textureNode));
            textureNode.referenceNode = this.getSelf();
            const map = textureNode.value;
            if (textureNode.generateMipmaps === false && (map && map.generateMipmaps === false || map.minFilter === NearestFilter || map.magFilter === NearestFilter)) {
                console.warn('THREE.TSL: texture().blur() requires mipmaps and sampling. Use .generateMipmaps=true and .minFilter/.magFilter=THREE.LinearFilter in the Texture.');
                textureNode.biasNode = null;
            }
            return nodeObject(textureNode);
        }
        level(levelNode) {
            const textureNode = this.clone();
            textureNode.levelNode = nodeObject(levelNode);
            textureNode.referenceNode = this.getSelf();
            return nodeObject(textureNode);
        }
        size(levelNode) {
            return textureSize(this, levelNode);
        }
        bias(biasNode) {
            const textureNode = this.clone();
            textureNode.biasNode = nodeObject(biasNode);
            textureNode.referenceNode = this.getSelf();
            return nodeObject(textureNode);
        }
        compare(compareNode) {
            const textureNode = this.clone();
            textureNode.compareNode = nodeObject(compareNode);
            textureNode.referenceNode = this.getSelf();
            return nodeObject(textureNode);
        }
        grad(gradNodeX, gradNodeY) {
            const textureNode = this.clone();
            textureNode.gradNode = [nodeObject(gradNodeX), nodeObject(gradNodeY)];
            textureNode.referenceNode = this.getSelf();
            return nodeObject(textureNode);
        }
        depth(depthNode) {
            const textureNode = this.clone();
            textureNode.depthNode = nodeObject(depthNode);
            textureNode.referenceNode = this.getSelf();
            return nodeObject(textureNode);
        }
        // --
        serialize(data) {
            super.serialize(data);
            data.value = this.value.toJSON(data.meta).uuid;
            data.sampler = this.sampler;
            data.updateMatrix = this.updateMatrix;
            data.updateType = this.updateType;
        }
        deserialize(data) {
            super.deserialize(data);
            this.value = data.meta.textures[data.value];
            this.sampler = data.sampler;
            this.updateMatrix = data.updateMatrix;
            this.updateType = data.updateType;
        }
        update() {
            const texture = this.value;
            const matrixUniform = this._matrixUniform;
            if (matrixUniform !== null) matrixUniform.value = texture.matrix;
            if (texture.matrixAutoUpdate === true) {
                texture.updateMatrix();
            }
        }
        clone() {
            const newNode = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);
            newNode.sampler = this.sampler;
            newNode.depthNode = this.depthNode;
            newNode.compareNode = this.compareNode;
            newNode.gradNode = this.gradNode;
            return newNode;
        }
    }
    const textureBase = /*@__PURE__*/ nodeProxy(TextureNode).setParameterLength(1, 4).setName('texture');
    const texture = (value = EmptyTexture$1, uvNode = null, levelNode = null, biasNode = null) => {
        let textureNode;
        if (value && value.isTextureNode === true) {
            textureNode = nodeObject(value.clone());
            textureNode.referenceNode = value.getSelf(); // Ensure the reference is set to the original node
            if (uvNode !== null) textureNode.uvNode = nodeObject(uvNode);
            if (levelNode !== null) textureNode.levelNode = nodeObject(levelNode);
            if (biasNode !== null) textureNode.biasNode = nodeObject(biasNode);
        } else {
            textureNode = textureBase(value, uvNode, levelNode, biasNode);
        }
        return textureNode;
    };
    const uniformTexture = (value = EmptyTexture$1) => texture(value);
    const textureLoad = (...params) => texture(...params).setSampler(false);
    //export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );
    const sampler = (value) => (value.isNode === true ? value : texture(value)).convert('sampler');
    const samplerComparison = (value) => (value.isNode === true ? value : texture(value)).convert('samplerComparison');
    class BufferNode extends UniformNode {
        static get type() {
            return 'BufferNode';
        }
        constructor(value, bufferType, bufferCount = 0) {
            super(value, bufferType);
            this.isBufferNode = true;
            this.bufferType = bufferType;
            this.bufferCount = bufferCount;
        }
        getElementType(builder) {
            return this.getNodeType(builder);
        }
        getInputType( /*builder*/) {
            return 'buffer';
        }
    }
    const buffer = (value, type, count) => nodeObject(new BufferNode(value, type, count));
    class UniformArrayElementNode extends ArrayElementNode {
        static get type() {
            return 'UniformArrayElementNode';
        }
        constructor(uniformArrayNode, indexNode) {
            super(uniformArrayNode, indexNode);
            this.isArrayBufferElementNode = true;
        }
        generate(builder) {
            const snippet = super.generate(builder);
            const type = this.getNodeType();
            const paddedType = this.node.getPaddedType();
            return builder.format(snippet, paddedType, type);
        }
    }
    class UniformArrayNode extends BufferNode {
        static get type() {
            return 'UniformArrayNode';
        }
        constructor(value, elementType = null) {
            super(null);
            this.array = value;
            this.elementType = elementType === null ? getValueType(value[0]) : elementType;
            this.paddedType = this.getPaddedType();
            this.updateType = NodeUpdateType.RENDER;
            this.isArrayBufferNode = true;
        }
        getNodeType( /*builder*/) {
            return this.paddedType;
        }
        getElementType() {
            return this.elementType;
        }
        getPaddedType() {
            const elementType = this.elementType;
            let paddedType = 'vec4';
            if (elementType === 'mat2') {
                paddedType = 'mat2';
            } else if (/mat/.test(elementType) === true) {
                paddedType = 'mat4';
            } else if (elementType.charAt(0) === 'i') {
                paddedType = 'ivec4';
            } else if (elementType.charAt(0) === 'u') {
                paddedType = 'uvec4';
            }
            return paddedType;
        }
        update( /*frame*/) {
            const { array, value } = this;
            const elementType = this.elementType;
            if (elementType === 'float' || elementType === 'int' || elementType === 'uint') {
                for (let i = 0; i < array.length; i++) {
                    const index = i * 4;
                    value[index] = array[i];
                }
            } else if (elementType === 'color') {
                for (let i = 0; i < array.length; i++) {
                    const index = i * 4;
                    const vector = array[i];
                    value[index] = vector.r;
                    value[index + 1] = vector.g;
                    value[index + 2] = vector.b || 0;
                    //value[ index + 3 ] = vector.a || 0;
                }
            } else if (elementType === 'mat2') {
                for (let i = 0; i < array.length; i++) {
                    const index = i * 4;
                    const matrix = array[i];
                    value[index] = matrix.elements[0];
                    value[index + 1] = matrix.elements[1];
                    value[index + 2] = matrix.elements[2];
                    value[index + 3] = matrix.elements[3];
                }
            } else if (elementType === 'mat3') {
                for (let i = 0; i < array.length; i++) {
                    const index = i * 16;
                    const matrix = array[i];
                    value[index] = matrix.elements[0];
                    value[index + 1] = matrix.elements[1];
                    value[index + 2] = matrix.elements[2];
                    value[index + 4] = matrix.elements[3];
                    value[index + 5] = matrix.elements[4];
                    value[index + 6] = matrix.elements[5];
                    value[index + 8] = matrix.elements[6];
                    value[index + 9] = matrix.elements[7];
                    value[index + 10] = matrix.elements[8];
                    value[index + 15] = 1;
                }
            } else if (elementType === 'mat4') {
                for (let i = 0; i < array.length; i++) {
                    const index = i * 16;
                    const matrix = array[i];
                    for (let i = 0; i < matrix.elements.length; i++) {
                        value[index + i] = matrix.elements[i];
                    }
                }
            } else {
                for (let i = 0; i < array.length; i++) {
                    const index = i * 4;
                    const vector = array[i];
                    value[index] = vector.x;
                    value[index + 1] = vector.y;
                    value[index + 2] = vector.z || 0;
                    value[index + 3] = vector.w || 0;
                }
            }
        }
        setup(builder) {
            const length = this.array.length;
            const elementType = this.elementType;
            let arrayType = Float32Array;
            const paddedType = this.paddedType;
            const paddedElementLength = builder.getTypeLength(paddedType);
            if (elementType.charAt(0) === 'i') arrayType = Int32Array;
            if (elementType.charAt(0) === 'u') arrayType = Uint32Array;
            this.value = new arrayType(length * paddedElementLength);
            this.bufferCount = length;
            this.bufferType = paddedType;
            return super.setup(builder);
        }
        element(indexNode) {
            return nodeObject(new UniformArrayElementNode(this, nodeObject(indexNode)));
        }
    }
    const uniformArray = (values, nodeType) => nodeObject(new UniformArrayNode(values, nodeType));
    class BuiltinNode extends Node {
        constructor(name) {
            super('float');
            this.name = name;
            this.isBuiltinNode = true;
        }
        generate( /* builder */) {
            return this.name;
        }
    }
    const builtin = nodeProxy(BuiltinNode).setParameterLength(1);
    const cameraIndex = /*@__PURE__*/ uniform(0, 'uint').setName('u_cameraIndex').setGroup(sharedUniformGroup('cameraIndex')).toVarying('v_cameraIndex');
    const cameraNear = /*@__PURE__*/ uniform('float').setName('cameraNear').setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.near);
    const cameraFar = /*@__PURE__*/ uniform('float').setName('cameraFar').setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.far);
    const cameraProjectionMatrix = /*@__PURE__*/ (Fn(({ camera }) => {
        let cameraProjectionMatrix;
        if (camera.isArrayCamera && camera.cameras.length > 0) {
            const matrices = [];
            for (const subCamera of camera.cameras) {
                matrices.push(subCamera.projectionMatrix);
            }
            const cameraProjectionMatrices = uniformArray(matrices).setGroup(renderGroup).setName('cameraProjectionMatrices');
            cameraProjectionMatrix = cameraProjectionMatrices.element(camera.isMultiViewCamera ? builtin('gl_ViewID_OVR') : cameraIndex).toVar('cameraProjectionMatrix');
        } else {
            cameraProjectionMatrix = uniform('mat4').setName('cameraProjectionMatrix').setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.projectionMatrix);
        }
        return cameraProjectionMatrix;
    }).once())();
    const cameraProjectionMatrixInverse = /*@__PURE__*/ (Fn(({ camera }) => {
        let cameraProjectionMatrixInverse;
        if (camera.isArrayCamera && camera.cameras.length > 0) {
            const matrices = [];
            for (const subCamera of camera.cameras) {
                matrices.push(subCamera.projectionMatrixInverse);
            }
            const cameraProjectionMatricesInverse = uniformArray(matrices).setGroup(renderGroup).setName('cameraProjectionMatricesInverse');
            cameraProjectionMatrixInverse = cameraProjectionMatricesInverse.element(camera.isMultiViewCamera ? builtin('gl_ViewID_OVR') : cameraIndex).toVar('cameraProjectionMatrixInverse');
        } else {
            cameraProjectionMatrixInverse = uniform('mat4').setName('cameraProjectionMatrixInverse').setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.projectionMatrixInverse);
        }
        return cameraProjectionMatrixInverse;
    }).once())();
    const cameraViewMatrix = /*@__PURE__*/ (Fn(({ camera }) => {
        let cameraViewMatrix;
        if (camera.isArrayCamera && camera.cameras.length > 0) {
            const matrices = [];
            for (const subCamera of camera.cameras) {
                matrices.push(subCamera.matrixWorldInverse);
            }
            const cameraViewMatrices = uniformArray(matrices).setGroup(renderGroup).setName('cameraViewMatrices');
            cameraViewMatrix = cameraViewMatrices.element(camera.isMultiViewCamera ? builtin('gl_ViewID_OVR') : cameraIndex).toVar('cameraViewMatrix');
        } else {
            cameraViewMatrix = uniform('mat4').setName('cameraViewMatrix').setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.matrixWorldInverse);
        }
        return cameraViewMatrix;
    }).once())();
    const cameraWorldMatrix = /*@__PURE__*/ uniform('mat4').setName('cameraWorldMatrix').setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.matrixWorld);
    const cameraNormalMatrix = /*@__PURE__*/ uniform('mat3').setName('cameraNormalMatrix').setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.normalMatrix);
    const cameraPosition = /*@__PURE__*/ uniform(new Vector3()).setName('cameraPosition').setGroup(renderGroup).onRenderUpdate(({ camera }, self) => self.value.setFromMatrixPosition(camera.matrixWorld));
    const _sphere$7 = /*@__PURE__*/ new Sphere();
    class Object3DNode extends Node {
        static get type() {
            return 'Object3DNode';
        }
        constructor(scope, object3d = null) {
            super();
            this.scope = scope;
            this.object3d = object3d;
            this.updateType = NodeUpdateType.OBJECT;
            this.uniformNode = new UniformNode(null);
        }
        getNodeType() {
            const scope = this.scope;
            if (scope === Object3DNode.WORLD_MATRIX) {
                return 'mat4';
            } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE) {
                return 'vec3';
            } else if (scope === Object3DNode.RADIUS) {
                return 'float';
            }
        }
        update(frame) {
            const object = this.object3d;
            const uniformNode = this.uniformNode;
            const scope = this.scope;
            if (scope === Object3DNode.WORLD_MATRIX) {
                uniformNode.value = object.matrixWorld;
            } else if (scope === Object3DNode.POSITION) {
                uniformNode.value = uniformNode.value || new Vector3();
                uniformNode.value.setFromMatrixPosition(object.matrixWorld);
            } else if (scope === Object3DNode.SCALE) {
                uniformNode.value = uniformNode.value || new Vector3();
                uniformNode.value.setFromMatrixScale(object.matrixWorld);
            } else if (scope === Object3DNode.DIRECTION) {
                uniformNode.value = uniformNode.value || new Vector3();
                object.getWorldDirection(uniformNode.value);
            } else if (scope === Object3DNode.VIEW_POSITION) {
                const camera = frame.camera;
                uniformNode.value = uniformNode.value || new Vector3();
                uniformNode.value.setFromMatrixPosition(object.matrixWorld);
                uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
            } else if (scope === Object3DNode.RADIUS) {
                const geometry = frame.object.geometry;
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                _sphere$7.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
                uniformNode.value = _sphere$7.radius;
            }
        }
        generate(builder) {
            const scope = this.scope;
            if (scope === Object3DNode.WORLD_MATRIX) {
                this.uniformNode.nodeType = 'mat4';
            } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE) {
                this.uniformNode.nodeType = 'vec3';
            } else if (scope === Object3DNode.RADIUS) {
                this.uniformNode.nodeType = 'float';
            }
            return this.uniformNode.build(builder);
        }
        serialize(data) {
            super.serialize(data);
            data.scope = this.scope;
        }
        deserialize(data) {
            super.deserialize(data);
            this.scope = data.scope;
        }
    }
    Object3DNode.WORLD_MATRIX = 'worldMatrix';
    Object3DNode.POSITION = 'position';
    Object3DNode.SCALE = 'scale';
    Object3DNode.VIEW_POSITION = 'viewPosition';
    Object3DNode.DIRECTION = 'direction';
    Object3DNode.RADIUS = 'radius';
    const objectDirection = /*@__PURE__*/ nodeProxy(Object3DNode, Object3DNode.DIRECTION).setParameterLength(1);
    const objectWorldMatrix = /*@__PURE__*/ nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX).setParameterLength(1);
    const objectPosition = /*@__PURE__*/ nodeProxy(Object3DNode, Object3DNode.POSITION).setParameterLength(1);
    const objectScale = /*@__PURE__*/ nodeProxy(Object3DNode, Object3DNode.SCALE).setParameterLength(1);
    const objectViewPosition = /*@__PURE__*/ nodeProxy(Object3DNode, Object3DNode.VIEW_POSITION).setParameterLength(1);
    const objectRadius = /*@__PURE__*/ nodeProxy(Object3DNode, Object3DNode.RADIUS).setParameterLength(1);
    class ModelNode extends Object3DNode {
        static get type() {
            return 'ModelNode';
        }
        constructor(scope) {
            super(scope);
        }
        update(frame) {
            this.object3d = frame.object;
            super.update(frame);
        }
    }
    const modelDirection = /*@__PURE__*/ nodeImmutable(ModelNode, ModelNode.DIRECTION);
    const modelWorldMatrix = /*@__PURE__*/ nodeImmutable(ModelNode, ModelNode.WORLD_MATRIX);
    const modelPosition = /*@__PURE__*/ nodeImmutable(ModelNode, ModelNode.POSITION);
    const modelScale = /*@__PURE__*/ nodeImmutable(ModelNode, ModelNode.SCALE);
    const modelViewPosition = /*@__PURE__*/ nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);
    const modelRadius = /*@__PURE__*/ nodeImmutable(ModelNode, ModelNode.RADIUS);
    const modelNormalMatrix = /*@__PURE__*/ uniform(new Matrix3()).onObjectUpdate(({ object }, self) => self.value.getNormalMatrix(object.matrixWorld));
    const modelWorldMatrixInverse = /*@__PURE__*/ uniform(new Matrix4()).onObjectUpdate(({ object }, self) => self.value.copy(object.matrixWorld).invert());
    const modelViewMatrix = /*@__PURE__*/ (Fn((builder) => {
        return builder.renderer.overrideNodes.modelViewMatrix || mediumpModelViewMatrix;
    }).once())().toVar('modelViewMatrix');
    // GPU Precision
    const mediumpModelViewMatrix = /*@__PURE__*/ cameraViewMatrix.mul(modelWorldMatrix);
    // CPU Precision
    const highpModelViewMatrix = /*@__PURE__*/ (Fn((builder) => {
        builder.context.isHighPrecisionModelViewMatrix = true;
        return uniform('mat4').onObjectUpdate(({ object, camera }) => {
            return object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        });
    }).once())().toVar('highpModelViewMatrix');
    const highpModelNormalViewMatrix = /*@__PURE__*/ (Fn((builder) => {
        const isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;
        return uniform('mat3').onObjectUpdate(({ object, camera }) => {
            if (isHighPrecisionModelViewMatrix !== true) {
                object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
            }
            return object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        });
    }).once())().toVar('highpModelNormalViewMatrix');
    const positionGeometry = /*@__PURE__*/ attribute('position', 'vec3');
    const positionLocal = /*@__PURE__*/ positionGeometry.toVarying('positionLocal');
    const positionPrevious = /*@__PURE__*/ positionGeometry.toVarying('positionPrevious');
    const positionWorld = /*@__PURE__*/ (Fn((builder) => {
        return modelWorldMatrix.mul(positionLocal).xyz.toVarying(builder.getSubBuildProperty('v_positionWorld'));
    }, 'vec3').once(['POSITION']))();
    const positionWorldDirection = /*@__PURE__*/ (Fn(() => {
        const vertexPWD = positionLocal.transformDirection(modelWorldMatrix).toVarying('v_positionWorldDirection');
        return vertexPWD.normalize().toVar('positionWorldDirection');
    }, 'vec3').once(['POSITION']))();
    const positionView = /*@__PURE__*/ (Fn((builder) => {
        return builder.context.setupPositionView().toVarying('v_positionView');
    }, 'vec3').once(['POSITION']))();
    const positionViewDirection = /*@__PURE__*/ positionView.negate().toVarying('v_positionViewDirection').normalize().toVar('positionViewDirection');
    class FrontFacingNode extends Node {
        static get type() {
            return 'FrontFacingNode';
        }
        constructor() {
            super('bool');
            this.isFrontFacingNode = true;
        }
        generate(builder) {
            if (builder.shaderStage !== 'fragment') return 'true';
            //
            const { renderer, material } = builder;
            if (renderer.coordinateSystem === WebGLCoordinateSystem) {
                if (material.side === BackSide) {
                    return 'false';
                }
            }
            return builder.getFrontFacing();
        }
    }
    const frontFacing = /*@__PURE__*/ nodeImmutable(FrontFacingNode);
    const faceDirection = /*@__PURE__*/ float(frontFacing).mul(2.0).sub(1.0);
    const directionToFaceDirection = /*@__PURE__*/ Fn(([direction], { material }) => {
        const side = material.side;
        if (side === BackSide) {
            direction = direction.mul(-1);
        } else if (side === DoubleSide) {
            direction = direction.mul(faceDirection);
        }
        return direction;
    });
    const normalGeometry = /*@__PURE__*/ attribute('normal', 'vec3');
    const normalLocal = /*@__PURE__*/ (Fn((builder) => {
        if (builder.geometry.hasAttribute('normal') === false) {
            console.warn('THREE.TSL: Vertex attribute "normal" not found on geometry.');
            return vec3(0, 1, 0);
        }
        return normalGeometry;
    }, 'vec3').once())().toVar('normalLocal');
    const normalFlat = /*@__PURE__*/ positionView.dFdx().cross(positionView.dFdy()).normalize().toVar('normalFlat');
    const normalViewGeometry = /*@__PURE__*/ (Fn((builder) => {
        let node;
        if (builder.material.flatShading === true) {
            node = normalFlat;
        } else {
            node = transformNormalToView(normalLocal).toVarying('v_normalViewGeometry').normalize();
        }
        return node;
    }, 'vec3').once())().toVar('normalViewGeometry');
    const normalWorldGeometry = /*@__PURE__*/ (Fn((builder) => {
        let normal = normalViewGeometry.transformDirection(cameraViewMatrix);
        if (builder.material.flatShading !== true) {
            normal = normal.toVarying('v_normalWorldGeometry');
        }
        return normal.normalize().toVar('normalWorldGeometry');
    }, 'vec3').once())();
    const normalView = /*@__PURE__*/ (Fn(({ subBuildFn, material, context }) => {
        let node;
        if (subBuildFn === 'NORMAL' || subBuildFn === 'VERTEX') {
            node = normalViewGeometry;
            if (material.flatShading !== true) {
                node = directionToFaceDirection(node);
            }
        } else {
            // Use getUV context to avoid side effects from nodes overwriting getUV in the context (e.g. EnvironmentNode)
            node = context.setupNormal().context({ getUV: null });
        }
        return node;
    }, 'vec3').once(['NORMAL', 'VERTEX']))().toVar('normalView');
    const normalWorld = /*@__PURE__*/ normalView.transformDirection(cameraViewMatrix).toVar('normalWorld');
    const clearcoatNormalView = /*@__PURE__*/ (Fn(({ subBuildFn, context }) => {
        let node;
        if (subBuildFn === 'NORMAL' || subBuildFn === 'VERTEX') {
            node = normalView;
        } else {
            // Use getUV context to avoid side effects from nodes overwriting getUV in the context (e.g. EnvironmentNode)
            node = context.setupClearcoatNormal().context({ getUV: null });
        }
        return node;
    }, 'vec3').once(['NORMAL', 'VERTEX']))().toVar('clearcoatNormalView');
    const transformNormal = /*@__PURE__*/ Fn(([normal, matrix = modelWorldMatrix]) => {
        const m = mat3(matrix);
        const transformedNormal = normal.div(vec3(m[0].dot(m[0]), m[1].dot(m[1]), m[2].dot(m[2])));
        return m.mul(transformedNormal).xyz;
    });
    const transformNormalToView = /*@__PURE__*/ Fn(([normal], builder) => {
        const modelNormalViewMatrix = builder.renderer.overrideNodes.modelNormalViewMatrix;
        if (modelNormalViewMatrix !== null) {
            return modelNormalViewMatrix.transformDirection(normal);
        }
        //
        const transformedNormal = modelNormalMatrix.mul(normal);
        return cameraViewMatrix.transformDirection(transformedNormal);
    });
    // Deprecated
    const transformedNormalView = (Fn(() => { // @deprecated, r177
        console.warn('THREE.TSL: "transformedNormalView" is deprecated. Use "normalView" instead.');
        return normalView;
    }).once(['NORMAL', 'VERTEX']))();
    const transformedNormalWorld = (Fn(() => { // @deprecated, r177
        console.warn('THREE.TSL: "transformedNormalWorld" is deprecated. Use "normalWorld" instead.');
        return normalWorld;
    }).once(['NORMAL', 'VERTEX']))();
    const transformedClearcoatNormalView = (Fn(() => { // @deprecated, r177
        console.warn('THREE.TSL: "transformedClearcoatNormalView" is deprecated. Use "clearcoatNormalView" instead.');
        return clearcoatNormalView;
    }).once(['NORMAL', 'VERTEX']))();
    const _e1$1 = /*@__PURE__*/ new Euler();
    const _m1$3 = /*@__PURE__*/ new Matrix4();
    const materialRefractionRatio = /*@__PURE__*/ uniform(0).onReference(({ material }) => material).onObjectUpdate(({ material }) => material.refractionRatio);
    const materialEnvIntensity = /*@__PURE__*/ uniform(1).onReference(({ material }) => material).onObjectUpdate(function ({ material, scene }) {
        return material.envMap ? material.envMapIntensity : scene.environmentIntensity;
    });
    const materialEnvRotation = /*@__PURE__*/ uniform(new Matrix4()).onReference(function (frame) {
        return frame.material;
    }).onObjectUpdate(function ({ material, scene }) {
        const rotation = (scene.environment !== null && material.envMap === null) ? scene.environmentRotation : material.envMapRotation;
        if (rotation) {
            _e1$1.copy(rotation);
            _m1$3.makeRotationFromEuler(_e1$1);
        } else {
            _m1$3.identity();
        }
        return _m1$3;
    });
    const reflectView = /*@__PURE__*/ positionViewDirection.negate().reflect(normalView);
    const refractView = /*@__PURE__*/ positionViewDirection.negate().refract(normalView, materialRefractionRatio);
    const reflectVector = /*@__PURE__*/ reflectView.transformDirection(cameraViewMatrix).toVar('reflectVector');
    const refractVector = /*@__PURE__*/ refractView.transformDirection(cameraViewMatrix).toVar('reflectVector');
    const EmptyTexture = /*@__PURE__*/ new CubeTexture();
    class CubeTextureNode extends TextureNode {
        static get type() {
            return 'CubeTextureNode';
        }
        constructor(value, uvNode = null, levelNode = null, biasNode = null) {
            super(value, uvNode, levelNode, biasNode);
            this.isCubeTextureNode = true;
        }
        getInputType( /*builder*/) {
            return 'cubeTexture';
        }
        getDefaultUV() {
            const texture = this.value;
            if (texture.mapping === CubeReflectionMapping) {
                return reflectVector;
            } else if (texture.mapping === CubeRefractionMapping) {
                return refractVector;
            } else {
                console.error('THREE.CubeTextureNode: Mapping "%s" not supported.', texture.mapping);
                return vec3(0, 0, 0);
            }
        }
        setUpdateMatrix( /*updateMatrix*/) { } // Ignore .updateMatrix for CubeTextureNode
        setupUV(builder, uvNode) {
            const texture = this.value;
            if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem || !texture.isRenderTargetTexture) {
                uvNode = vec3(uvNode.x.negate(), uvNode.yz);
            }
            return materialEnvRotation.mul(uvNode);
        }
        generateUV(builder, cubeUV) {
            return cubeUV.build(builder, 'vec3');
        }
    }
    const cubeTextureBase = /*@__PURE__*/ nodeProxy(CubeTextureNode).setParameterLength(1, 4).setName('cubeTexture');
    const cubeTexture = (value = EmptyTexture, uvNode = null, levelNode = null, biasNode = null) => {
        let textureNode;
        if (value && value.isCubeTextureNode === true) {
            textureNode = nodeObject(value.clone());
            textureNode.referenceNode = value.getSelf(); // Ensure the reference is set to the original node
            if (uvNode !== null) textureNode.uvNode = nodeObject(uvNode);
            if (levelNode !== null) textureNode.levelNode = nodeObject(levelNode);
            if (biasNode !== null) textureNode.biasNode = nodeObject(biasNode);
        } else {
            textureNode = cubeTextureBase(value, uvNode, levelNode, biasNode);
        }
        return textureNode;
    };
    const uniformCubeTexture = (value = EmptyTexture) => cubeTextureBase(value);
    // TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode
    class ReferenceElementNode extends ArrayElementNode {
        static get type() {
            return 'ReferenceElementNode';
        }
        constructor(referenceNode, indexNode) {
            super(referenceNode, indexNode);
            this.referenceNode = referenceNode;
            this.isReferenceElementNode = true;
        }
        getNodeType() {
            return this.referenceNode.uniformType;
        }
        generate(builder) {
            const snippet = super.generate(builder);
            const arrayType = this.referenceNode.getNodeType();
            const elementType = this.getNodeType();
            return builder.format(snippet, arrayType, elementType);
        }
    }
    class ReferenceNode extends Node {
        static get type() {
            return 'ReferenceNode';
        }
        constructor(property, uniformType, object = null, count = null) {
            super();
            this.property = property;
            this.uniformType = uniformType;
            this.object = object;
            this.count = count;
            this.properties = property.split('.');
            this.reference = object;
            this.node = null;
            this.group = null;
            this.name = null;
            this.updateType = NodeUpdateType.OBJECT;
        }
        element(indexNode) {
            return nodeObject(new ReferenceElementNode(this, nodeObject(indexNode)));
        }
        setGroup(group) {
            this.group = group;
            return this;
        }
        setName(name) {
            this.name = name;
            return this;
        }
        label(name) {
            console.warn('THREE.TSL: "label()" has been deprecated. Use "setName()" instead.'); // @deprecated r179
            return this.setName(name);
        }
        setNodeType(uniformType) {
            let node = null;
            if (this.count !== null) {
                node = buffer(null, uniformType, this.count);
            } else if (Array.isArray(this.getValueFromReference())) {
                node = uniformArray(null, uniformType);
            } else if (uniformType === 'texture') {
                node = texture(null);
            } else if (uniformType === 'cubeTexture') {
                node = cubeTexture(null);
            } else {
                node = uniform(null, uniformType);
            }
            if (this.group !== null) {
                node.setGroup(this.group);
            }
            if (this.name !== null) node.setName(this.name);
            this.node = node.getSelf();
        }
        getNodeType(builder) {
            if (this.node === null) {
                this.updateReference(builder);
                this.updateValue();
            }
            return this.node.getNodeType(builder);
        }
        getValueFromReference(object = this.reference) {
            const { properties } = this;
            let value = object[properties[0]];
            for (let i = 1; i < properties.length; i++) {
                value = value[properties[i]];
            }
            return value;
        }
        updateReference(state) {
            this.reference = this.object !== null ? this.object : state.object;
            return this.reference;
        }
        setup( /* builder */) {
            this.updateValue();
            return this.node;
        }
        update( /*frame*/) {
            this.updateValue();
        }
        updateValue() {
            if (this.node === null) this.setNodeType(this.uniformType);
            const value = this.getValueFromReference();
            if (Array.isArray(value)) {
                this.node.array = value;
            } else {
                this.node.value = value;
            }
        }
    }
    const reference = (name, type, object) => nodeObject(new ReferenceNode(name, type, object));
    const referenceBuffer = (name, type, count, object) => nodeObject(new ReferenceNode(name, type, object, count));
    class MaterialReferenceNode extends ReferenceNode {
        static get type() {
            return 'MaterialReferenceNode';
        }
        constructor(property, inputType, material = null) {
            super(property, inputType, material);
            this.material = material;
            this.isMaterialReferenceNode = true;
        }
        updateReference(state) {
            this.reference = this.material !== null ? this.material : state.material;
            return this.reference;
        }
    }
    const materialReference = (name, type, material = null) => nodeObject(new MaterialReferenceNode(name, type, material));
    // Normal Mapping Without Precomputed Tangents
    // http://www.thetenthplanet.de/archives/1180
    const uv$1 = uv();
    const q0 = positionView.dFdx();
    const q1 = positionView.dFdy();
    const st0 = uv$1.dFdx();
    const st1 = uv$1.dFdy();
    const N = normalView;
    const q1perp = q1.cross(N);
    const q0perp = N.cross(q0);
    const T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));
    const B = q1perp.mul(st0.y).add(q0perp.mul(st1.y));
    const det = T.dot(T).max(B.dot(B));
    const scale = det.equal(0.0).select(0.0, det.inverseSqrt());
    const tangentViewFrame = /*@__PURE__*/ T.mul(scale).toVar('tangentViewFrame');
    const bitangentViewFrame = /*@__PURE__*/ B.mul(scale).toVar('bitangentViewFrame');
    const tangentGeometry = /*@__PURE__*/ Fn((builder) => {
        if (builder.geometry.hasAttribute('tangent') === false) {
            builder.geometry.computeTangents();
        }
        return attribute('tangent', 'vec4');
    })();
    const tangentLocal = /*@__PURE__*/ tangentGeometry.xyz.toVar('tangentLocal');
    const tangentView = /*@__PURE__*/ (Fn(({ subBuildFn, geometry, material }) => {
        let node;
        if (subBuildFn === 'VERTEX' || geometry.hasAttribute('tangent')) {
            node = modelViewMatrix.mul(vec4(tangentLocal, 0)).xyz.toVarying('v_tangentView').normalize();
        } else {
            node = tangentViewFrame;
        }
        if (material.flatShading !== true) {
            node = directionToFaceDirection(node);
        }
        return node;
    }, 'vec3').once(['NORMAL', 'VERTEX']))().toVar('tangentView');
    const tangentWorld = /*@__PURE__*/ tangentView.transformDirection(cameraViewMatrix).toVarying('v_tangentWorld').normalize().toVar('tangentWorld');
    const getBitangent = /*@__PURE__*/ Fn(([crossNormalTangent, varyingName], { subBuildFn, material }) => {
        let bitangent = crossNormalTangent.mul(tangentGeometry.w).xyz;
        if (subBuildFn === 'NORMAL' && material.flatShading !== true) {
            bitangent = bitangent.toVarying(varyingName);
        }
        return bitangent;
    }).once(['NORMAL']);
    const bitangentGeometry = /*@__PURE__*/ getBitangent(normalGeometry.cross(tangentGeometry), 'v_bitangentGeometry').normalize().toVar('bitangentGeometry');
    const bitangentLocal = /*@__PURE__*/ getBitangent(normalLocal.cross(tangentLocal), 'v_bitangentLocal').normalize().toVar('bitangentLocal');
    const bitangentView = /*@__PURE__*/ (Fn(({ subBuildFn, geometry, material }) => {
        let node;
        if (subBuildFn === 'VERTEX' || geometry.hasAttribute('tangent')) {
            node = getBitangent(normalView.cross(tangentView), 'v_bitangentView').normalize();
        } else {
            node = bitangentViewFrame;
        }
        if (material.flatShading !== true) {
            node = directionToFaceDirection(node);
        }
        return node;
    }, 'vec3').once(['NORMAL', 'VERTEX']))().toVar('bitangentView');
    const bitangentWorld = /*@__PURE__*/ getBitangent(normalWorld.cross(tangentWorld), 'v_bitangentWorld').normalize().toVar('bitangentWorld');
    const TBNViewMatrix = /*@__PURE__*/ mat3(tangentView, bitangentView, normalView).toVar('TBNViewMatrix');
    const parallaxDirection = /*@__PURE__*/ positionViewDirection.mul(TBNViewMatrix)/*.normalize()*/;
    const parallaxUV = (uv, scale) => uv.sub(parallaxDirection.mul(scale));
    const bentNormalView = /*@__PURE__*/ (Fn(() => {
        // https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy
        let bentNormal = anisotropyB.cross(positionViewDirection);
        bentNormal = bentNormal.cross(anisotropyB).normalize();
        bentNormal = mix(bentNormal, normalView, anisotropy.mul(roughness.oneMinus()).oneMinus().pow2().pow2()).normalize();
        return bentNormal;
    }).once())();
    class NormalMapNode extends TempNode {
        static get type() {
            return 'NormalMapNode';
        }
        constructor(node, scaleNode = null) {
            super('vec3');
            this.node = node;
            this.scaleNode = scaleNode;
            this.normalMapType = TangentSpaceNormalMap;
        }
        setup({ material }) {
            const { normalMapType, scaleNode } = this;
            let normalMap = this.node.mul(2.0).sub(1.0);
            if (scaleNode !== null) {
                let scale = scaleNode;
                if (material.flatShading === true) {
                    scale = directionToFaceDirection(scale);
                }
                normalMap = vec3(normalMap.xy.mul(scale), normalMap.z);
            }
            let output = null;
            if (normalMapType === ObjectSpaceNormalMap) {
                output = transformNormalToView(normalMap);
            } else if (normalMapType === TangentSpaceNormalMap) {
                output = TBNViewMatrix.mul(normalMap).normalize();
            } else {
                console.error(`THREE.NodeMaterial: Unsupported normal map type: ${normalMapType}`);
                output = normalView; // Fallback to default normal view
            }
            return output;
        }
    }
    const normalMap = /*@__PURE__*/ nodeProxy(NormalMapNode).setParameterLength(1, 2);
    // Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
    // https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf
    const dHdxy_fwd = Fn(({ textureNode, bumpScale }) => {
        // It's used to preserve the same TextureNode instance
        const sampleTexture = (callback) => textureNode.cache().context({ getUV: (texNode) => callback(texNode.uvNode || uv()), forceUVContext: true });
        const Hll = float(sampleTexture((uvNode) => uvNode));
        return vec2(
            float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdx()))).sub(Hll),
            float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdy()))).sub(Hll)
        ).mul(bumpScale);
    });
    // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)
    const perturbNormalArb = Fn((inputs) => {
        const { surf_pos, surf_norm, dHdxy } = inputs;
        // normalize is done to ensure that the bump map looks the same regardless of the texture's scale
        const vSigmaX = surf_pos.dFdx().normalize();
        const vSigmaY = surf_pos.dFdy().normalize();
        const vN = surf_norm; // normalized
        const R1 = vSigmaY.cross(vN);
        const R2 = vN.cross(vSigmaX);
        const fDet = vSigmaX.dot(R1).mul(faceDirection);
        const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));
        return fDet.abs().mul(surf_norm).sub(vGrad).normalize();
    });
    class BumpMapNode extends TempNode {
        static get type() {
            return 'BumpMapNode';
        }
        constructor(textureNode, scaleNode = null) {
            super('vec3');
            this.textureNode = textureNode;
            this.scaleNode = scaleNode;
        }
        setup() {
            const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
            const dHdxy = dHdxy_fwd({ textureNode: this.textureNode, bumpScale });
            return perturbNormalArb({
                surf_pos: positionView,
                surf_norm: normalView,
                dHdxy
            });
        }
    }
    const bumpMap = /*@__PURE__*/ nodeProxy(BumpMapNode).setParameterLength(1, 2);
    const _propertyCache = new Map();
    class MaterialNode extends Node {
        static get type() {
            return 'MaterialNode';
        }
        constructor(scope) {
            super();
            this.scope = scope;
        }
        getCache(property, type) {
            let node = _propertyCache.get(property);
            if (node === undefined) {
                node = materialReference(property, type);
                _propertyCache.set(property, node);
            }
            return node;
        }
        getFloat(property) {
            return this.getCache(property, 'float');
        }
        getColor(property) {
            return this.getCache(property, 'color');
        }
        getTexture(property) {
            return this.getCache(property === 'map' ? 'map' : property + 'Map', 'texture');
        }
        setup(builder) {
            const material = builder.context.material;
            const scope = this.scope;
            let node = null;
            if (scope === MaterialNode.COLOR) {
                const colorNode = material.color !== undefined ? this.getColor(scope) : vec3();
                if (material.map && material.map.isTexture === true) {
                    node = colorNode.mul(this.getTexture('map'));
                } else {
                    node = colorNode;
                }
            } else if (scope === MaterialNode.OPACITY) {
                const opacityNode = this.getFloat(scope);
                if (material.alphaMap && material.alphaMap.isTexture === true) {
                    node = opacityNode.mul(this.getTexture('alpha'));
                } else {
                    node = opacityNode;
                }
            } else if (scope === MaterialNode.SPECULAR_STRENGTH) {
                if (material.specularMap && material.specularMap.isTexture === true) {
                    node = this.getTexture('specular').r;
                } else {
                    node = float(1);
                }
            } else if (scope === MaterialNode.SPECULAR_INTENSITY) {
                const specularIntensityNode = this.getFloat(scope);
                if (material.specularIntensityMap && material.specularIntensityMap.isTexture === true) {
                    node = specularIntensityNode.mul(this.getTexture(scope).a);
                } else {
                    node = specularIntensityNode;
                }
            } else if (scope === MaterialNode.SPECULAR_COLOR) {
                const specularColorNode = this.getColor(scope);
                if (material.specularColorMap && material.specularColorMap.isTexture === true) {
                    node = specularColorNode.mul(this.getTexture(scope).rgb);
                } else {
                    node = specularColorNode;
                }
            } else if (scope === MaterialNode.ROUGHNESS) { // TODO: cleanup similar branches
                const roughnessNode = this.getFloat(scope);
                if (material.roughnessMap && material.roughnessMap.isTexture === true) {
                    node = roughnessNode.mul(this.getTexture(scope).g);
                } else {
                    node = roughnessNode;
                }
            } else if (scope === MaterialNode.METALNESS) {
                const metalnessNode = this.getFloat(scope);
                if (material.metalnessMap && material.metalnessMap.isTexture === true) {
                    node = metalnessNode.mul(this.getTexture(scope).b);
                } else {
                    node = metalnessNode;
                }
            } else if (scope === MaterialNode.EMISSIVE) {
                const emissiveIntensityNode = this.getFloat('emissiveIntensity');
                const emissiveNode = this.getColor(scope).mul(emissiveIntensityNode);
                if (material.emissiveMap && material.emissiveMap.isTexture === true) {
                    node = emissiveNode.mul(this.getTexture(scope));
                } else {
                    node = emissiveNode;
                }
            } else if (scope === MaterialNode.NORMAL) {
                if (material.normalMap) {
                    node = normalMap(this.getTexture('normal'), this.getCache('normalScale', 'vec2'));
                    node.normalMapType = material.normalMapType;
                } else if (material.bumpMap) {
                    node = bumpMap(this.getTexture('bump').r, this.getFloat('bumpScale'));
                } else {
                    node = normalView;
                }
            } else if (scope === MaterialNode.CLEARCOAT) {
                const clearcoatNode = this.getFloat(scope);
                if (material.clearcoatMap && material.clearcoatMap.isTexture === true) {
                    node = clearcoatNode.mul(this.getTexture(scope).r);
                } else {
                    node = clearcoatNode;
                }
            } else if (scope === MaterialNode.CLEARCOAT_ROUGHNESS) {
                const clearcoatRoughnessNode = this.getFloat(scope);
                if (material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true) {
                    node = clearcoatRoughnessNode.mul(this.getTexture(scope).r);
                } else {
                    node = clearcoatRoughnessNode;
                }
            } else if (scope === MaterialNode.CLEARCOAT_NORMAL) {
                if (material.clearcoatNormalMap) {
                    node = normalMap(this.getTexture(scope), this.getCache(scope + 'Scale', 'vec2'));
                } else {
                    node = normalView;
                }
            } else if (scope === MaterialNode.SHEEN) {
                const sheenNode = this.getColor('sheenColor').mul(this.getFloat('sheen')); // Move this mul() to CPU
                if (material.sheenColorMap && material.sheenColorMap.isTexture === true) {
                    node = sheenNode.mul(this.getTexture('sheenColor').rgb);
                } else {
                    node = sheenNode;
                }
            } else if (scope === MaterialNode.SHEEN_ROUGHNESS) {
                const sheenRoughnessNode = this.getFloat(scope);
                if (material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true) {
                    node = sheenRoughnessNode.mul(this.getTexture(scope).a);
                } else {
                    node = sheenRoughnessNode;
                }
                node = node.clamp(0.07, 1.0);
            } else if (scope === MaterialNode.ANISOTROPY) {
                if (material.anisotropyMap && material.anisotropyMap.isTexture === true) {
                    const anisotropyPolar = this.getTexture(scope);
                    const anisotropyMat = mat2(materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x);
                    node = anisotropyMat.mul(anisotropyPolar.rg.mul(2.0).sub(vec2(1.0)).normalize().mul(anisotropyPolar.b));
                } else {
                    node = materialAnisotropyVector;
                }
            } else if (scope === MaterialNode.IRIDESCENCE_THICKNESS) {
                const iridescenceThicknessMaximum = reference('1', 'float', material.iridescenceThicknessRange);
                if (material.iridescenceThicknessMap) {
                    const iridescenceThicknessMinimum = reference('0', 'float', material.iridescenceThicknessRange);
                    node = iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(scope).g).add(iridescenceThicknessMinimum);
                } else {
                    node = iridescenceThicknessMaximum;
                }
            } else if (scope === MaterialNode.TRANSMISSION) {
                const transmissionNode = this.getFloat(scope);
                if (material.transmissionMap) {
                    node = transmissionNode.mul(this.getTexture(scope).r);
                } else {
                    node = transmissionNode;
                }
            } else if (scope === MaterialNode.THICKNESS) {
                const thicknessNode = this.getFloat(scope);
                if (material.thicknessMap) {
                    node = thicknessNode.mul(this.getTexture(scope).g);
                } else {
                    node = thicknessNode;
                }
            } else if (scope === MaterialNode.IOR) {
                node = this.getFloat(scope);
            } else if (scope === MaterialNode.LIGHT_MAP) {
                node = this.getTexture(scope).rgb.mul(this.getFloat('lightMapIntensity'));
            } else if (scope === MaterialNode.AO) {
                node = this.getTexture(scope).r.sub(1.0).mul(this.getFloat('aoMapIntensity')).add(1.0);
            } else if (scope === MaterialNode.LINE_DASH_OFFSET) {
                node = (material.dashOffset) ? this.getFloat(scope) : float(0);
            } else {
                const outputType = this.getNodeType(builder);
                node = this.getCache(scope, outputType);
            }
            return node;
        }
    }
    MaterialNode.ALPHA_TEST = 'alphaTest';
    MaterialNode.COLOR = 'color';
    MaterialNode.OPACITY = 'opacity';
    MaterialNode.SHININESS = 'shininess';
    MaterialNode.SPECULAR = 'specular';
    MaterialNode.SPECULAR_STRENGTH = 'specularStrength';
    MaterialNode.SPECULAR_INTENSITY = 'specularIntensity';
    MaterialNode.SPECULAR_COLOR = 'specularColor';
    MaterialNode.REFLECTIVITY = 'reflectivity';
    MaterialNode.ROUGHNESS = 'roughness';
    MaterialNode.METALNESS = 'metalness';
    MaterialNode.NORMAL = 'normal';
    MaterialNode.CLEARCOAT = 'clearcoat';
    MaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';
    MaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';
    MaterialNode.EMISSIVE = 'emissive';
    MaterialNode.ROTATION = 'rotation';
    MaterialNode.SHEEN = 'sheen';
    MaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';
    MaterialNode.ANISOTROPY = 'anisotropy';
    MaterialNode.IRIDESCENCE = 'iridescence';
    MaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';
    MaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';
    MaterialNode.IOR = 'ior';
    MaterialNode.TRANSMISSION = 'transmission';
    MaterialNode.THICKNESS = 'thickness';
    MaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';
    MaterialNode.ATTENUATION_COLOR = 'attenuationColor';
    MaterialNode.LINE_SCALE = 'scale';
    MaterialNode.LINE_DASH_SIZE = 'dashSize';
    MaterialNode.LINE_GAP_SIZE = 'gapSize';
    MaterialNode.LINE_WIDTH = 'linewidth';
    MaterialNode.LINE_DASH_OFFSET = 'dashOffset';
    MaterialNode.POINT_SIZE = 'size';
    MaterialNode.DISPERSION = 'dispersion';
    MaterialNode.LIGHT_MAP = 'light';
    MaterialNode.AO = 'ao';
    const materialAlphaTest = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.ALPHA_TEST);
    const materialColor = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.COLOR);
    const materialShininess = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.SHININESS);
    const materialEmissive = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.EMISSIVE);
    const materialOpacity = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.OPACITY);
    const materialSpecular = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.SPECULAR);
    const materialSpecularIntensity = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.SPECULAR_INTENSITY);
    const materialSpecularColor = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);
    const materialSpecularStrength = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.SPECULAR_STRENGTH);
    const materialReflectivity = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);
    const materialRoughness = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.ROUGHNESS);
    const materialMetalness = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.METALNESS);
    const materialNormal = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.NORMAL);
    const materialClearcoat = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT);
    const materialClearcoatRoughness = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS);
    const materialClearcoatNormal = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_NORMAL);
    const materialRotation = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.ROTATION);
    const materialSheen = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.SHEEN);
    const materialSheenRoughness = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.SHEEN_ROUGHNESS);
    const materialAnisotropy = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.ANISOTROPY);
    const materialIridescence = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE);
    const materialIridescenceIOR = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_IOR);
    const materialIridescenceThickness = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS);
    const materialTransmission = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.TRANSMISSION);
    const materialThickness = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.THICKNESS);
    const materialIOR = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.IOR);
    const materialAttenuationDistance = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_DISTANCE);
    const materialAttenuationColor = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_COLOR);
    const materialLineScale = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.LINE_SCALE);
    const materialLineDashSize = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_SIZE);
    const materialLineGapSize = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.LINE_GAP_SIZE);
    const materialLineWidth = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.LINE_WIDTH);
    const materialLineDashOffset = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_OFFSET);
    const materialPointSize = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.POINT_SIZE);
    const materialDispersion = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.DISPERSION);
    const materialLightMap = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.LIGHT_MAP);
    const materialAO = /*@__PURE__*/ nodeImmutable(MaterialNode, MaterialNode.AO);
    const materialAnisotropyVector = /*@__PURE__*/ uniform(new Vector2()).onReference(function (frame) {
        return frame.material;
    }).onRenderUpdate(function ({ material }) {
        this.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
    });
    const modelViewProjection = /*@__PURE__*/ (Fn((builder) => {
        return builder.context.setupModelViewProjection();
    }, 'vec4').once())().toVarying('v_modelViewProjection');
    class IndexNode extends Node {
        static get type() {
            return 'IndexNode';
        }
        constructor(scope) {
            super('uint');
            this.scope = scope;
            this.isIndexNode = true;
        }
        generate(builder) {
            const nodeType = this.getNodeType(builder);
            const scope = this.scope;
            let propertyName;
            if (scope === IndexNode.VERTEX) {
                propertyName = builder.getVertexIndex();
            } else if (scope === IndexNode.INSTANCE) {
                propertyName = builder.getInstanceIndex();
            } else if (scope === IndexNode.DRAW) {
                propertyName = builder.getDrawIndex();
            } else if (scope === IndexNode.INVOCATION_LOCAL) {
                propertyName = builder.getInvocationLocalIndex();
            } else if (scope === IndexNode.INVOCATION_SUBGROUP) {
                propertyName = builder.getInvocationSubgroupIndex();
            } else if (scope === IndexNode.SUBGROUP) {
                propertyName = builder.getSubgroupIndex();
            } else {
                throw new Error('THREE.IndexNode: Unknown scope: ' + scope);
            }
            let output;
            if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {
                output = propertyName;
            } else {
                const nodeVarying = varying(this);
                output = nodeVarying.build(builder, nodeType);
            }
            return output;
        }
    }
    IndexNode.VERTEX = 'vertex';
    IndexNode.INSTANCE = 'instance';
    IndexNode.SUBGROUP = 'subgroup';
    IndexNode.INVOCATION_LOCAL = 'invocationLocal';
    IndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';
    IndexNode.DRAW = 'draw';
    const vertexIndex = /*@__PURE__*/ nodeImmutable(IndexNode, IndexNode.VERTEX);
    const instanceIndex = /*@__PURE__*/ nodeImmutable(IndexNode, IndexNode.INSTANCE);
    const subgroupIndex = /*@__PURE__*/ nodeImmutable(IndexNode, IndexNode.SUBGROUP);
    const invocationSubgroupIndex = /*@__PURE__*/ nodeImmutable(IndexNode, IndexNode.INVOCATION_SUBGROUP);
    const invocationLocalIndex = /*@__PURE__*/ nodeImmutable(IndexNode, IndexNode.INVOCATION_LOCAL);
    const drawIndex = /*@__PURE__*/ nodeImmutable(IndexNode, IndexNode.DRAW);
    class InstanceNode extends Node {
        static get type() {
            return 'InstanceNode';
        }
        constructor(count, instanceMatrix, instanceColor = null) {
            super('void');
            this.count = count;
            this.instanceMatrix = instanceMatrix;
            this.instanceColor = instanceColor;
            this.instanceMatrixNode = null;
            this.instanceColorNode = null;
            this.updateType = NodeUpdateType.FRAME;
            this.buffer = null;
            this.bufferColor = null;
        }
        setup(builder) {
            const { count, instanceMatrix, instanceColor } = this;
            let { instanceMatrixNode, instanceColorNode } = this;
            if (instanceMatrixNode === null) {
                // Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.
                if (count <= 1000) {
                    instanceMatrixNode = buffer(instanceMatrix.array, 'mat4', Math.max(count, 1)).element(instanceIndex);
                } else {
                    const buffer = new InstancedInterleavedBuffer(instanceMatrix.array, 16, 1);
                    this.buffer = buffer;
                    const bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
                    const instanceBuffers = [
                        // F.Signature -> bufferAttribute( array, type, stride, offset )
                        bufferFn(buffer, 'vec4', 16, 0),
                        bufferFn(buffer, 'vec4', 16, 4),
                        bufferFn(buffer, 'vec4', 16, 8),
                        bufferFn(buffer, 'vec4', 16, 12)
                    ];
                    instanceMatrixNode = mat4(...instanceBuffers);
                }
                this.instanceMatrixNode = instanceMatrixNode;
            }
            if (instanceColor && instanceColorNode === null) {
                const buffer = new InstancedBufferAttribute(instanceColor.array, 3);
                const bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
                this.bufferColor = buffer;
                instanceColorNode = vec3(bufferFn(buffer, 'vec3', 3, 0));
                this.instanceColorNode = instanceColorNode;
            }
            // POSITION
            const instancePosition = instanceMatrixNode.mul(positionLocal).xyz;
            positionLocal.assign(instancePosition);
            // NORMAL
            if (builder.hasGeometryAttribute('normal')) {
                const instanceNormal = transformNormal(normalLocal, instanceMatrixNode);
                // ASSIGNS
                normalLocal.assign(instanceNormal);
            }
            // COLOR
            if (this.instanceColorNode !== null) {
                varyingProperty('vec3', 'vInstanceColor').assign(this.instanceColorNode);
            }
        }
        update( /*frame*/) {
            if (this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer !== null && this.instanceMatrix.version !== this.buffer.version) {
                this.buffer.version = this.instanceMatrix.version;
            }
            if (this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor !== null && this.instanceColor.version !== this.bufferColor.version) {
                this.bufferColor.version = this.instanceColor.version;
            }
        }
    }
    const instance = /*@__PURE__*/ nodeProxy(InstanceNode).setParameterLength(2, 3);
    class InstancedMeshNode extends InstanceNode {
        static get type() {
            return 'InstancedMeshNode';
        }
        constructor(instancedMesh) {
            const { count, instanceMatrix, instanceColor } = instancedMesh;
            super(count, instanceMatrix, instanceColor);
            this.instancedMesh = instancedMesh;
        }
    }
    const instancedMesh = /*@__PURE__*/ nodeProxy(InstancedMeshNode).setParameterLength(1);
    class BatchNode extends Node {
        static get type() {
            return 'BatchNode';
        }
        constructor(batchMesh) {
            super('void');
            this.batchMesh = batchMesh;
            this.batchingIdNode = null;
        }
        setup(builder) {
            if (this.batchingIdNode === null) {
                if (builder.getDrawIndex() === null) {
                    this.batchingIdNode = instanceIndex;
                } else {
                    this.batchingIdNode = drawIndex;
                }
            }
            const getIndirectIndex = Fn(([id]) => {
                const size = int(textureSize(textureLoad(this.batchMesh._indirectTexture), 0).x);
                const x = int(id).mod(size);
                const y = int(id).div(size);
                return textureLoad(this.batchMesh._indirectTexture, ivec2(x, y)).x;
            }).setLayout({
                name: 'getIndirectIndex',
                type: 'uint',
                inputs: [
                    { name: 'id', type: 'int' }
                ]
            });
            const indirectId = getIndirectIndex(int(this.batchingIdNode));
            const matricesTexture = this.batchMesh._matricesTexture;
            const size = int(textureSize(textureLoad(matricesTexture), 0).x);
            const j = float(indirectId).mul(4).toInt().toVar();
            const x = j.mod(size);
            const y = j.div(size);
            const batchingMatrix = mat4(
                textureLoad(matricesTexture, ivec2(x, y)),
                textureLoad(matricesTexture, ivec2(x.add(1), y)),
                textureLoad(matricesTexture, ivec2(x.add(2), y)),
                textureLoad(matricesTexture, ivec2(x.add(3), y))
            );

            const colorsTexture = this.batchMesh._colorsTexture;
            if (colorsTexture !== null) {
                const getBatchingColor = Fn(([id]) => {
                    const size = int(textureSize(textureLoad(colorsTexture), 0).x);
                    const j = id;
                    const x = j.mod(size);
                    const y = j.div(size);
                    return textureLoad(colorsTexture, ivec2(x, y)).rgb;
                }).setLayout({
                    name: 'getBatchingColor',
                    type: 'vec3',
                    inputs: [
                        { name: 'id', type: 'int' }
                    ]
                });
                const color = getBatchingColor(indirectId);
                varyingProperty('vec3', 'vBatchColor').assign(color);
            }
            const bm = mat3(batchingMatrix);
            positionLocal.assign(batchingMatrix.mul(positionLocal));
            const transformedNormal = normalLocal.div(vec3(bm[0].dot(bm[0]), bm[1].dot(bm[1]), bm[2].dot(bm[2])));
            const batchingNormal = bm.mul(transformedNormal).xyz;
            normalLocal.assign(batchingNormal);
            if (builder.hasGeometryAttribute('tangent')) {
                tangentLocal.mulAssign(bm);
            }
        }
    }
    const batch = /*@__PURE__*/ nodeProxy(BatchNode).setParameterLength(1);
    class StorageArrayElementNode extends ArrayElementNode {
        static get type() {
            return 'StorageArrayElementNode';
        }
        constructor(storageBufferNode, indexNode) {
            super(storageBufferNode, indexNode);
            this.isStorageArrayElementNode = true;
        }
        set storageBufferNode(value) {
            this.node = value;
        }
        get storageBufferNode() {
            return this.node;
        }
        getMemberType(builder, name) {
            const structTypeNode = this.storageBufferNode.structTypeNode;
            if (structTypeNode) {
                return structTypeNode.getMemberType(builder, name);
            }
            return 'void';
        }
        setup(builder) {
            if (builder.isAvailable('storageBuffer') === false) {
                if (this.node.isPBO === true) {
                    builder.setupPBO(this.node);
                }
            }
            return super.setup(builder);
        }
        generate(builder, output) {
            let snippet;
            const isAssignContext = builder.context.assign;
            //
            if (builder.isAvailable('storageBuffer') === false) {
                if (this.node.isPBO === true && isAssignContext !== true && (this.node.value.isInstancedBufferAttribute || builder.shaderStage !== 'compute')) {
                    snippet = builder.generatePBO(this);
                } else {
                    snippet = this.node.build(builder);
                }
            } else {
                snippet = super.generate(builder);
            }
            if (isAssignContext !== true) {
                const type = this.getNodeType(builder);
                snippet = builder.format(snippet, type, output);
            }
            return snippet;
        }
    }
    const storageElement = /*@__PURE__*/ nodeProxy(StorageArrayElementNode).setParameterLength(2);
    class StorageBufferNode extends BufferNode {
        static get type() {
            return 'StorageBufferNode';
        }
        constructor(value, bufferType = null, bufferCount = 0) {
            let nodeType, structTypeNode = null;
            if (bufferType && bufferType.isStruct) {
                nodeType = 'struct';
                structTypeNode = bufferType.layout;
                if (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute) {
                    bufferCount = value.count;
                }
            } else if (bufferType === null && (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute)) {
                nodeType = getTypeFromLength(value.itemSize);
                bufferCount = value.count;
            } else {
                nodeType = bufferType;
            }
            super(value, nodeType, bufferCount);
            this.isStorageBufferNode = true;

            this.structTypeNode = structTypeNode;
            this.access = NodeAccess.READ_WRITE;
            this.isAtomic = false;
            this.isPBO = false;
            this._attribute = null;
            this._varying = null;
            this.global = true;
            if (value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true) {
                // TODO: Improve it, possibly adding a new property to the BufferAttribute to identify it as a storage buffer read-only attribute in Renderer
                if (value.isInstancedBufferAttribute) value.isStorageInstancedBufferAttribute = true;
                else value.isStorageBufferAttribute = true;
            }
        }
        getHash(builder) {
            if (this.bufferCount === 0) {
                let bufferData = builder.globalCache.getData(this.value);
                if (bufferData === undefined) {
                    bufferData = {
                        node: this
                    };
                    builder.globalCache.setData(this.value, bufferData);
                }
                return bufferData.node.uuid;
            }
            return this.uuid;
        }
        getInputType( /*builder*/) {
            return this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer';
        }
        element(indexNode) {
            return storageElement(this, indexNode);
        }
        setPBO(value) {
            this.isPBO = value;
            return this;
        }
        getPBO() {
            return this.isPBO;
        }
        setAccess(value) {
            this.access = value;
            return this;
        }
        toReadOnly() {
            return this.setAccess(NodeAccess.READ_ONLY);
        }
        setAtomic(value) {
            this.isAtomic = value;
            return this;
        }
        toAtomic() {
            return this.setAtomic(true);
        }
        getAttributeData() {
            if (this._attribute === null) {
                this._attribute = bufferAttribute(this.value);
                this._varying = varying(this._attribute);
            }
            return {
                attribute: this._attribute,
                varying: this._varying
            };
        }
        getNodeType(builder) {
            if (this.structTypeNode !== null) {
                return this.structTypeNode.getNodeType(builder);
            }
            if (builder.isAvailable('storageBuffer') || builder.isAvailable('indirectStorageBuffer')) {
                return super.getNodeType(builder);
            }
            const { attribute } = this.getAttributeData();
            return attribute.getNodeType(builder);
        }
        getMemberType(builder, name) {
            if (this.structTypeNode !== null) {
                return this.structTypeNode.getMemberType(builder, name);
            }
            return 'void';
        }
        generate(builder) {
            if (this.structTypeNode !== null) this.structTypeNode.build(builder);
            if (builder.isAvailable('storageBuffer') || builder.isAvailable('indirectStorageBuffer')) {
                return super.generate(builder);
            }
            const { attribute, varying } = this.getAttributeData();
            const output = varying.build(builder);
            builder.registerTransform(output, attribute);
            return output;
        }
    }
    const storage = (value, type = null, count = 0) => nodeObject(new StorageBufferNode(value, type, count));
    const storageObject = (value, type, count) => { // @deprecated, r171
        console.warn('THREE.TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.');
        return storage(value, type, count).setPBO(true);
    };
    const _frameId = new WeakMap();
    class SkinningNode extends Node {
        static get type() {
            return 'SkinningNode';
        }
        constructor(skinnedMesh) {
            super('void');
            this.skinnedMesh = skinnedMesh;
            this.updateType = NodeUpdateType.OBJECT;
            //
            this.skinIndexNode = attribute('skinIndex', 'uvec4');
            this.skinWeightNode = attribute('skinWeight', 'vec4');
            this.bindMatrixNode = reference('bindMatrix', 'mat4');
            this.bindMatrixInverseNode = reference('bindMatrixInverse', 'mat4');
            this.boneMatricesNode = referenceBuffer('skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length);
            this.positionNode = positionLocal;
            this.toPositionNode = positionLocal;
            this.previousBoneMatricesNode = null;
        }
        getSkinnedPosition(boneMatrices = this.boneMatricesNode, position = this.positionNode) {
            const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;
            const boneMatX = boneMatrices.element(skinIndexNode.x);
            const boneMatY = boneMatrices.element(skinIndexNode.y);
            const boneMatZ = boneMatrices.element(skinIndexNode.z);
            const boneMatW = boneMatrices.element(skinIndexNode.w);
            // POSITION
            const skinVertex = bindMatrixNode.mul(position);
            const skinned = add(
                boneMatX.mul(skinWeightNode.x).mul(skinVertex),
                boneMatY.mul(skinWeightNode.y).mul(skinVertex),
                boneMatZ.mul(skinWeightNode.z).mul(skinVertex),
                boneMatW.mul(skinWeightNode.w).mul(skinVertex)
            );
            return bindMatrixInverseNode.mul(skinned).xyz;
        }
        getSkinnedNormal(boneMatrices = this.boneMatricesNode, normal = normalLocal) {
            const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;
            const boneMatX = boneMatrices.element(skinIndexNode.x);
            const boneMatY = boneMatrices.element(skinIndexNode.y);
            const boneMatZ = boneMatrices.element(skinIndexNode.z);
            const boneMatW = boneMatrices.element(skinIndexNode.w);
            // NORMAL
            let skinMatrix = add(
                skinWeightNode.x.mul(boneMatX),
                skinWeightNode.y.mul(boneMatY),
                skinWeightNode.z.mul(boneMatZ),
                skinWeightNode.w.mul(boneMatW)
            );
            skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);
            return skinMatrix.transformDirection(normal).xyz;
        }
        getPreviousSkinnedPosition(builder) {
            const skinnedMesh = builder.object;
            if (this.previousBoneMatricesNode === null) {
                skinnedMesh.skeleton.previousBoneMatrices = new Float32Array(skinnedMesh.skeleton.boneMatrices);
                this.previousBoneMatricesNode = referenceBuffer('skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length);
            }
            return this.getSkinnedPosition(this.previousBoneMatricesNode, positionPrevious);
        }
        needsPreviousBoneMatrices(builder) {
            const mrt = builder.renderer.getMRT();
            return (mrt && mrt.has('velocity')) || getDataFromObject(builder.object).useVelocity === true;
        }
        setup(builder) {
            if (this.needsPreviousBoneMatrices(builder)) {
                positionPrevious.assign(this.getPreviousSkinnedPosition(builder));
            }
            const skinPosition = this.getSkinnedPosition();
            if (this.toPositionNode) this.toPositionNode.assign(skinPosition);
            //
            if (builder.hasGeometryAttribute('normal')) {
                const skinNormal = this.getSkinnedNormal();
                normalLocal.assign(skinNormal);
                if (builder.hasGeometryAttribute('tangent')) {
                    tangentLocal.assign(skinNormal);
                }
            }
            return skinPosition;
        }
        generate(builder, output) {
            if (output !== 'void') {
                return super.generate(builder, output);
            }
        }
        update(frame) {
            const skeleton = frame.object && frame.object.skeleton ? frame.object.skeleton : this.skinnedMesh.skeleton;
            if (_frameId.get(skeleton) === frame.frameId) return;
            _frameId.set(skeleton, frame.frameId);
            if (this.previousBoneMatricesNode !== null) skeleton.previousBoneMatrices.set(skeleton.boneMatrices);
            skeleton.update();
        }
    }
    const skinning = (skinnedMesh) => nodeObject(new SkinningNode(skinnedMesh));
    const computeSkinning = (skinnedMesh, toPosition = null) => {
        const node = new SkinningNode(skinnedMesh);
        node.positionNode = storage(new InstancedBufferAttribute(skinnedMesh.geometry.getAttribute('position').array, 3), 'vec3').setPBO(true).toReadOnly().element(instanceIndex).toVar();
        node.skinIndexNode = storage(new InstancedBufferAttribute(new Uint32Array(skinnedMesh.geometry.getAttribute('skinIndex').array), 4), 'uvec4').setPBO(true).toReadOnly().element(instanceIndex).toVar();
        node.skinWeightNode = storage(new InstancedBufferAttribute(skinnedMesh.geometry.getAttribute('skinWeight').array, 4), 'vec4').setPBO(true).toReadOnly().element(instanceIndex).toVar();
        node.bindMatrixNode = uniform(skinnedMesh.bindMatrix, 'mat4');
        node.bindMatrixInverseNode = uniform(skinnedMesh.bindMatrixInverse, 'mat4');
        node.boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length);
        node.toPositionNode = toPosition;
        return nodeObject(node);
    };
    class LoopNode extends Node {
        static get type() {
            return 'LoopNode';
        }
        constructor(params = []) {
            super();
            this.params = params;
        }
        getVarName(index) {
            return String.fromCharCode('i'.charCodeAt(0) + index);
        }
        getProperties(builder) {
            const properties = builder.getNodeProperties(this);
            if (properties.stackNode !== undefined) return properties;
            //
            const inputs = {};
            for (let i = 0, l = this.params.length - 1; i < l; i++) {
                const param = this.params[i];
                const name = (param.isNode !== true && param.name) || this.getVarName(i);
                const type = (param.isNode !== true && param.type) || 'int';
                inputs[name] = expression(name, type);
            }
            const stack = builder.addStack(); // TODO: cache() it
            properties.returnsNode = this.params[this.params.length - 1](inputs, builder);
            properties.stackNode = stack;
            const baseParam = this.params[0];
            if (baseParam.isNode !== true && typeof baseParam.update === 'function') {
                properties.updateNode = Fn(this.params[0].update)(inputs);
            }
            builder.removeStack();
            return properties;
        }
        getNodeType(builder) {
            const { returnsNode } = this.getProperties(builder);
            return returnsNode ? returnsNode.getNodeType(builder) : 'void';
        }
        setup(builder) {
            // setup properties
            this.getProperties(builder);
        }
        generate(builder) {
            const properties = this.getProperties(builder);
            const params = this.params;
            const stackNode = properties.stackNode;
            for (let i = 0, l = params.length - 1; i < l; i++) {
                const param = params[i];
                let isWhile = false, start = null, end = null, name = null, type = null, condition = null, update = null;
                if (param.isNode) {
                    if (param.getNodeType(builder) === 'bool') {
                        isWhile = true;
                        type = 'bool';
                        end = param.build(builder, type);
                    } else {
                        type = 'int';
                        name = this.getVarName(i);
                        start = '0';
                        end = param.build(builder, type);
                        condition = '<';
                    }
                } else {
                    type = param.type || 'int';
                    name = param.name || this.getVarName(i);
                    start = param.start;
                    end = param.end;
                    condition = param.condition;
                    update = param.update;
                    if (typeof start === 'number') start = builder.generateConst(type, start);
                    else if (start && start.isNode) start = start.build(builder, type);
                    if (typeof end === 'number') end = builder.generateConst(type, end);
                    else if (end && end.isNode) end = end.build(builder, type);
                    if (start !== undefined && end === undefined) {
                        start = start + ' - 1';
                        end = '0';
                        condition = '>=';
                    } else if (end !== undefined && start === undefined) {
                        start = '0';
                        condition = '<';
                    }
                    if (condition === undefined) {
                        if (Number(start) > Number(end)) {
                            condition = '>=';
                        } else {
                            condition = '<';
                        }
                    }
                }
                let loopSnippet;
                if (isWhile) {
                    loopSnippet = `while ( ${end} )`;
                } else {
                    const internalParam = { start, end };
                    //
                    const startSnippet = internalParam.start;
                    const endSnippet = internalParam.end;
                    let updateSnippet;
                    const deltaOperator = () => condition.includes('<') ? '+=' : '-=';
                    if (update !== undefined && update !== null) {
                        switch (typeof update) {
                            case 'function':
                                const flow = builder.flowStagesNode(properties.updateNode, 'void');
                                const snippet = flow.code.replace(/\t|;/g, '');
                                updateSnippet = snippet;
                                break;
                            case 'number':
                                updateSnippet = name + ' ' + deltaOperator() + ' ' + builder.generateConst(type, update);
                                break;
                            case 'string':
                                updateSnippet = name + ' ' + update;
                                break;
                            default:
                                if (update.isNode) {
                                    updateSnippet = name + ' ' + deltaOperator() + ' ' + update.build(builder);
                                } else {
                                    console.error('THREE.TSL: \'Loop( { update: ... } )\' is not a function, string or number.');
                                    updateSnippet = 'break /* invalid update */';
                                }
                        }
                    } else {
                        if (type === 'int' || type === 'uint') {
                            update = condition.includes('<') ? '++' : '--';
                        } else {
                            update = deltaOperator() + ' 1.';
                        }
                        updateSnippet = name + ' ' + update;
                    }
                    const declarationSnippet = builder.getVar(type, name) + ' = ' + startSnippet;
                    const conditionalSnippet = name + ' ' + condition + ' ' + endSnippet;
                    loopSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;
                }
                builder.addFlowCode((i === 0 ? '\n' : '') + builder.tab + loopSnippet + ' {\n\n').addFlowTab();
            }
            const stackSnippet = stackNode.build(builder, 'void');
            const returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : '';
            builder.removeFlowTab().addFlowCode('\n' + builder.tab + stackSnippet);
            for (let i = 0, l = this.params.length - 1; i < l; i++) {
                builder.addFlowCode((i === 0 ? '' : builder.tab) + '}\n\n').removeFlowTab();
            }
            builder.addFlowTab();
            return returnsSnippet;
        }
    }
    const Loop = (...params) => nodeObject(new LoopNode(nodeArray(params, 'int'))).toStack();
    const Continue = () => expression('continue').toStack();
    const Break = () => expression('break').toStack();
    const _morphTextures = /*@__PURE__*/ new WeakMap();
    const _morphVec4 = /*@__PURE__*/ new Vector4();
    const getMorph = /*@__PURE__*/ Fn(({ bufferMap, influence, stride, width, depth, offset }) => {
        const texelIndex = int(vertexIndex).mul(stride).add(offset);
        const y = texelIndex.div(width);
        const x = texelIndex.sub(y.mul(width));
        const bufferAttrib = textureLoad(bufferMap, ivec2(x, y)).depth(depth).xyz;
        return bufferAttrib.mul(influence);
    });
    function getEntry(geometry) {
        const hasMorphPosition = geometry.morphAttributes.position !== undefined;
        const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
        const hasMorphColors = geometry.morphAttributes.color !== undefined;
        // instead of using attributes, the WebGL 2 code path encodes morph targets
        // into an array of data textures. Each layer represents a single morph target.
        const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
        const morphTargetsCount = (morphAttribute !== undefined) ? morphAttribute.length : 0;
        let entry = _morphTextures.get(geometry);
        if (entry === undefined || entry.count !== morphTargetsCount) {
            if (entry !== undefined) entry.texture.dispose();
            const morphTargets = geometry.morphAttributes.position || [];
            const morphNormals = geometry.morphAttributes.normal || [];
            const morphColors = geometry.morphAttributes.color || [];
            let vertexDataCount = 0;
            if (hasMorphPosition === true) vertexDataCount = 1;
            if (hasMorphNormals === true) vertexDataCount = 2;
            if (hasMorphColors === true) vertexDataCount = 3;
            let width = geometry.attributes.position.count * vertexDataCount;
            let height = 1;
            const maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'
            if (width > maxTextureSize) {
                height = Math.ceil(width / maxTextureSize);
                width = maxTextureSize;
            }
            const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
            const bufferTexture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
            bufferTexture.type = FloatType;
            bufferTexture.needsUpdate = true;
            // fill buffer
            const vertexDataStride = vertexDataCount * 4;
            for (let i = 0; i < morphTargetsCount; i++) {
                const morphTarget = morphTargets[i];
                const morphNormal = morphNormals[i];
                const morphColor = morphColors[i];
                const offset = width * height * 4 * i;
                for (let j = 0; j < morphTarget.count; j++) {
                    const stride = j * vertexDataStride;
                    if (hasMorphPosition === true) {
                        _morphVec4.fromBufferAttribute(morphTarget, j);
                        buffer[offset + stride + 0] = _morphVec4.x;
                        buffer[offset + stride + 1] = _morphVec4.y;
                        buffer[offset + stride + 2] = _morphVec4.z;
                        buffer[offset + stride + 3] = 0;
                    }
                    if (hasMorphNormals === true) {
                        _morphVec4.fromBufferAttribute(morphNormal, j);
                        buffer[offset + stride + 4] = _morphVec4.x;
                        buffer[offset + stride + 5] = _morphVec4.y;
                        buffer[offset + stride + 6] = _morphVec4.z;
                        buffer[offset + stride + 7] = 0;
                    }
                    if (hasMorphColors === true) {
                        _morphVec4.fromBufferAttribute(morphColor, j);
                        buffer[offset + stride + 8] = _morphVec4.x;
                        buffer[offset + stride + 9] = _morphVec4.y;
                        buffer[offset + stride + 10] = _morphVec4.z;
                        buffer[offset + stride + 11] = (morphColor.itemSize === 4) ? _morphVec4.w : 1;
                    }
                }
            }
            entry = {
                count: morphTargetsCount,
                texture: bufferTexture,
                stride: vertexDataCount,
                size: new Vector2(width, height)
            };
            _morphTextures.set(geometry, entry);
            function disposeTexture() {
                bufferTexture.dispose();
                _morphTextures.delete(geometry);
                geometry.removeEventListener('dispose', disposeTexture);
            }
            geometry.addEventListener('dispose', disposeTexture);
        }
        return entry;
    }
    class MorphNode extends Node {
        static get type() {
            return 'MorphNode';
        }
        constructor(mesh) {
            super('void');
            this.mesh = mesh;
            this.morphBaseInfluence = uniform(1);
            this.updateType = NodeUpdateType.OBJECT;
        }
        setup(builder) {
            const { geometry } = builder;
            const hasMorphPosition = geometry.morphAttributes.position !== undefined;
            const hasMorphNormals = geometry.hasAttribute('normal') && geometry.morphAttributes.normal !== undefined;
            const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
            const morphTargetsCount = (morphAttribute !== undefined) ? morphAttribute.length : 0;
            // nodes
            const { texture: bufferMap, stride, size } = getEntry(geometry);
            if (hasMorphPosition === true) positionLocal.mulAssign(this.morphBaseInfluence);
            if (hasMorphNormals === true) normalLocal.mulAssign(this.morphBaseInfluence);
            const width = int(size.width);
            Loop(morphTargetsCount, ({ i }) => {
                const influence = float(0).toVar();
                if (this.mesh.count > 1 && (this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined)) {
                    influence.assign(textureLoad(this.mesh.morphTexture, ivec2(int(i).add(1), int(instanceIndex))).r);
                } else {
                    influence.assign(reference('morphTargetInfluences', 'float').element(i).toVar());
                }
                If(influence.notEqual(0), () => {
                    if (hasMorphPosition === true) {
                        positionLocal.addAssign(getMorph({
                            bufferMap,
                            influence,
                            stride,
                            width,
                            depth: i,
                            offset: int(0)
                        }));
                    }
                    if (hasMorphNormals === true) {
                        normalLocal.addAssign(getMorph({
                            bufferMap,
                            influence,
                            stride,
                            width,
                            depth: i,
                            offset: int(1)
                        }));
                    }
                });
            });
        }
        update( /*frame*/) {
            const morphBaseInfluence = this.morphBaseInfluence;
            if (this.mesh.geometry.morphTargetsRelative) {
                morphBaseInfluence.value = 1;
            } else {
                morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a, b) => a + b, 0);
            }
        }
    }
    const morphReference = /*@__PURE__*/ nodeProxy(MorphNode).setParameterLength(1);
    class LightingNode extends Node {
        static get type() {
            return 'LightingNode';
        }
        constructor() {
            super('vec3');
            this.isLightingNode = true;
        }
    }
    class AONode extends LightingNode {
        static get type() {
            return 'AONode';
        }
        constructor(aoNode = null) {
            super();
            this.aoNode = aoNode;
        }
        setup(builder) {
            builder.context.ambientOcclusion.mulAssign(this.aoNode);
        }
    }
    class LightingContextNode extends ContextNode {
        static get type() {
            return 'LightingContextNode';
        }
        constructor(lightsNode, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
            super(lightsNode);
            this.lightingModel = lightingModel;
            this.backdropNode = backdropNode;
            this.backdropAlphaNode = backdropAlphaNode;
            this._value = null;
        }
        getContext() {
            const { backdropNode, backdropAlphaNode } = this;
            const directDiffuse = vec3().toVar('directDiffuse'),
                directSpecular = vec3().toVar('directSpecular'),
                indirectDiffuse = vec3().toVar('indirectDiffuse'),
                indirectSpecular = vec3().toVar('indirectSpecular');
            const reflectedLight = {
                directDiffuse,
                directSpecular,
                indirectDiffuse,
                indirectSpecular
            };
            const context = {
                radiance: vec3().toVar('radiance'),
                irradiance: vec3().toVar('irradiance'),
                iblIrradiance: vec3().toVar('iblIrradiance'),
                ambientOcclusion: float(1).toVar('ambientOcclusion'),
                reflectedLight,
                backdrop: backdropNode,
                backdropAlpha: backdropAlphaNode
            };
            return context;
        }
        setup(builder) {
            this.value = this._value || (this._value = this.getContext());
            this.value.lightingModel = this.lightingModel || builder.context.lightingModel;
            return super.setup(builder);
        }
    }
    const lightingContext = /*@__PURE__*/ nodeProxy(LightingContextNode);
    class IrradianceNode extends LightingNode {
        static get type() {
            return 'IrradianceNode';
        }
        constructor(node) {
            super();
            this.node = node;
        }
        setup(builder) {
            builder.context.irradiance.addAssign(this.node);
        }
    }
    let screenSizeVec, viewportVec;
    class ScreenNode extends Node {
        static get type() {
            return 'ScreenNode';
        }
        constructor(scope) {
            super();
            this.scope = scope;
            this.isViewportNode = true;
        }
        getNodeType() {
            if (this.scope === ScreenNode.VIEWPORT) return 'vec4';
            else return 'vec2';
        }
        getUpdateType() {
            let updateType = NodeUpdateType.NONE;
            if (this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT) {
                updateType = NodeUpdateType.RENDER;
            }
            this.updateType = updateType;
            return updateType;
        }
        update({ renderer }) {
            const renderTarget = renderer.getRenderTarget();
            if (this.scope === ScreenNode.VIEWPORT) {
                if (renderTarget !== null) {
                    viewportVec.copy(renderTarget.viewport);
                } else {
                    renderer.getViewport(viewportVec);
                    viewportVec.multiplyScalar(renderer.getPixelRatio());
                }
            } else {
                if (renderTarget !== null) {
                    screenSizeVec.width = renderTarget.width;
                    screenSizeVec.height = renderTarget.height;
                } else {
                    renderer.getDrawingBufferSize(screenSizeVec);
                }
            }
        }
        setup( /*builder*/) {
            const scope = this.scope;
            let output = null;
            if (scope === ScreenNode.SIZE) {
                output = uniform(screenSizeVec || (screenSizeVec = new Vector2()));
            } else if (scope === ScreenNode.VIEWPORT) {
                output = uniform(viewportVec || (viewportVec = new Vector4()));
            } else {
                output = vec2(screenCoordinate.div(screenSize));
            }
            return output;
        }
        generate(builder) {
            if (this.scope === ScreenNode.COORDINATE) {
                let coord = builder.getFragCoord();
                if (builder.isFlipY()) {
                    // follow webgpu standards
                    const size = builder.getNodeProperties(screenSize).outputNode.build(builder);
                    coord = `${builder.getType('vec2')}( ${coord}.x, ${size}.y - ${coord}.y )`;
                }
                return coord;
            }
            return super.generate(builder);
        }
    }
    ScreenNode.COORDINATE = 'coordinate';
    ScreenNode.VIEWPORT = 'viewport';
    ScreenNode.SIZE = 'size';
    ScreenNode.UV = 'uv';
    // Screen
    const screenUV = /*@__PURE__*/ nodeImmutable(ScreenNode, ScreenNode.UV);
    const screenSize = /*@__PURE__*/ nodeImmutable(ScreenNode, ScreenNode.SIZE);
    const screenCoordinate = /*@__PURE__*/ nodeImmutable(ScreenNode, ScreenNode.COORDINATE);
    // Viewport
    const viewport = /*@__PURE__*/ nodeImmutable(ScreenNode, ScreenNode.VIEWPORT);
    const viewportSize = viewport.zw;
    const viewportCoordinate = /*@__PURE__*/ screenCoordinate.sub(viewport.xy);
    const viewportUV = /*@__PURE__*/ viewportCoordinate.div(viewportSize);
    // Deprecated
    const viewportResolution = /*@__PURE__*/ (Fn(() => { // @deprecated, r169
        console.warn('THREE.TSL: "viewportResolution" is deprecated. Use "screenSize" instead.');
        return screenSize;
    }, 'vec2').once())();
    const _size$4 = /*@__PURE__*/ new Vector2();
    class ViewportTextureNode extends TextureNode {
        static get type() {
            return 'ViewportTextureNode';
        }
        constructor(uvNode = screenUV, levelNode = null, framebufferTexture = null) {
            let defaultFramebuffer = null;
            if (framebufferTexture === null) {
                defaultFramebuffer = new FramebufferTexture();
                defaultFramebuffer.minFilter = LinearMipmapLinearFilter;
                framebufferTexture = defaultFramebuffer;
            } else {
                defaultFramebuffer = framebufferTexture;
            }
            super(framebufferTexture, uvNode, levelNode);
            this.generateMipmaps = false;
            this.defaultFramebuffer = defaultFramebuffer;
            this.isOutputTextureNode = true;
            this.updateBeforeType = NodeUpdateType.RENDER;
            this._textures = new WeakMap();
        }
        getFrameBufferTexture(reference = null) {
            const defaultFramebuffer = this.referenceNode ? this.referenceNode.defaultFramebuffer : this.defaultFramebuffer;
            if (reference === null) {
                return defaultFramebuffer;
            }
            if (this._textures.has(reference) === false) {
                const framebufferTexture = defaultFramebuffer.clone();
                this._textures.set(reference, framebufferTexture);
            }
            return this._textures.get(reference);
        }
        updateBefore(frame) {
            const renderer = frame.renderer;
            const renderTarget = renderer.getRenderTarget();
            if (renderTarget === null) {
                renderer.getDrawingBufferSize(_size$4);
            } else {
                _size$4.set(renderTarget.width, renderTarget.height);
            }
            //
            const framebufferTexture = this.getFrameBufferTexture(renderTarget);
            if (framebufferTexture.image.width !== _size$4.width || framebufferTexture.image.height !== _size$4.height) {
                framebufferTexture.image.width = _size$4.width;
                framebufferTexture.image.height = _size$4.height;
                framebufferTexture.needsUpdate = true;
            }
            //
            const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
            framebufferTexture.generateMipmaps = this.generateMipmaps;
            renderer.copyFramebufferToTexture(framebufferTexture);
            framebufferTexture.generateMipmaps = currentGenerateMipmaps;
            this.value = framebufferTexture;
        }
        clone() {
            const viewportTextureNode = new this.constructor(this.uvNode, this.levelNode, this.value);
            viewportTextureNode.generateMipmaps = this.generateMipmaps;
            return viewportTextureNode;
        }
    }
    const viewportTexture = /*@__PURE__*/ nodeProxy(ViewportTextureNode).setParameterLength(0, 3);
    const viewportMipTexture = /*@__PURE__*/ nodeProxy(ViewportTextureNode, null, null, { generateMipmaps: true }).setParameterLength(0, 3);
    let sharedDepthbuffer = null;
    class ViewportDepthTextureNode extends ViewportTextureNode {
        static get type() {
            return 'ViewportDepthTextureNode';
        }
        constructor(uvNode = screenUV, levelNode = null) {
            if (sharedDepthbuffer === null) {
                sharedDepthbuffer = new DepthTexture();
            }
            super(uvNode, levelNode, sharedDepthbuffer);
        }
    }
    const viewportDepthTexture = /*@__PURE__*/ nodeProxy(ViewportDepthTextureNode).setParameterLength(0, 2);
    class ViewportDepthNode extends Node {
        static get type() {
            return 'ViewportDepthNode';
        }
        constructor(scope, valueNode = null) {
            super('float');
            this.scope = scope;
            this.valueNode = valueNode;
            this.isViewportDepthNode = true;
        }
        generate(builder) {
            const { scope } = this;
            if (scope === ViewportDepthNode.DEPTH_BASE) {
                return builder.getFragDepth();
            }
            return super.generate(builder);
        }
        setup({ camera }) {
            const { scope } = this;
            const value = this.valueNode;
            let node = null;
            if (scope === ViewportDepthNode.DEPTH_BASE) {
                if (value !== null) {
                    node = depthBase().assign(value);
                }
            } else if (scope === ViewportDepthNode.DEPTH) {
                if (camera.isPerspectiveCamera) {
                    node = viewZToPerspectiveDepth(positionView.z, cameraNear, cameraFar);
                } else {
                    node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
                }
            } else if (scope === ViewportDepthNode.LINEAR_DEPTH) {
                if (value !== null) {
                    if (camera.isPerspectiveCamera) {
                        const viewZ = perspectiveDepthToViewZ(value, cameraNear, cameraFar);
                        node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
                    } else {
                        node = value;
                    }
                } else {
                    node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
                }
            }
            return node;
        }
    }
    ViewportDepthNode.DEPTH_BASE = 'depthBase';
    ViewportDepthNode.DEPTH = 'depth';
    ViewportDepthNode.LINEAR_DEPTH = 'linearDepth';
    // NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera
    const viewZToOrthographicDepth = (viewZ, near, far) => viewZ.add(near).div(near.sub(far));
    const orthographicDepthToViewZ = (depth, near, far) => near.sub(far).mul(depth).sub(near);
    const viewZToPerspectiveDepth = (viewZ, near, far) => near.add(viewZ).mul(far).div(far.sub(near).mul(viewZ));
    const perspectiveDepthToViewZ = (depth, near, far) => near.mul(far).div(far.sub(near).mul(depth).sub(far));
    const viewZToLogarithmicDepth = (viewZ, near, far) => {
        // NOTE: viewZ must be negative--see explanation at the end of this comment block.
        // The final logarithmic depth formula used here is adapted from one described in an
        // article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),
        // which was an improvement upon an earlier formula one described in an
        // Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).
        // Ulrich's formula is the following:
        //     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )
        //     where K = 2^k - 1, and k is the number of bits in the depth buffer.
        // The Outerra variant ignored the camera near plane (it assumed it was 0) and instead
        // opted for a "C-constant" for resolution adjustment of objects near the camera.
        // Outerra states: "Notice that the 'C' variant doesn’t use a near plane distance, it has it
        // set at 0" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).
        // Ulrich's variant has the benefit of constant relative precision over the whole near-far range.
        // It was debated here whether Outerra's "C-constant" or Ulrich's "near plane" variant should
        // be used, and ultimately Ulrich's "near plane" version was chosen.
        // Outerra eventually made another improvement to their original "C-constant" variant,
        // but it still does not incorporate the camera near plane (for this version,
        // see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).
        // Here we make 4 changes to Ulrich's formula:
        // 1. Clamp the camera near plane so we don't divide by 0.
        // 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).
        // 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).
        // 4. To maintain consistency with the functions "viewZToOrthographicDepth" and "viewZToPerspectiveDepth",
        //    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,
        //    so we do the same here, hence the 'viewZ.negate()' call.
        // For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u
        near = near.max(1e-6).toVar();
        const numerator = log2(viewZ.negate().div(near));
        const denominator = log2(far.div(near));
        return numerator.div(denominator);
    };
    const logarithmicDepthToViewZ = (depth, near, far) => {
        // NOTE: we add a 'negate()' call to the return value here to maintain consistency with
        // the functions "orthographicDepthToViewZ" and "perspectiveDepthToViewZ" (they return
        // a negative viewZ).
        const exponent = depth.mul(log(far.div(near)));
        return float(Math.E).pow(exponent).mul(near).negate();
    };
    const depthBase = /*@__PURE__*/ nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_BASE);
    const depth = /*@__PURE__*/ nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);
    const linearDepth = /*@__PURE__*/ nodeProxy(ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH).setParameterLength(0, 1);
    const viewportLinearDepth = /*@__PURE__*/ linearDepth(viewportDepthTexture());
    depth.assign = (value) => depthBase(value);
    class ClippingNode extends Node {
        static get type() {
            return 'ClippingNode';
        }
        constructor(scope = ClippingNode.DEFAULT) {
            super();
            this.scope = scope;
        }
        setup(builder) {
            super.setup(builder);
            const clippingContext = builder.clippingContext;
            const { intersectionPlanes, unionPlanes } = clippingContext;
            this.hardwareClipping = builder.material.hardwareClipping;
            if (this.scope === ClippingNode.ALPHA_TO_COVERAGE) {
                return this.setupAlphaToCoverage(intersectionPlanes, unionPlanes);
            } else if (this.scope === ClippingNode.HARDWARE) {
                return this.setupHardwareClipping(unionPlanes, builder);
            } else {
                return this.setupDefault(intersectionPlanes, unionPlanes);
            }
        }
        setupAlphaToCoverage(intersectionPlanes, unionPlanes) {
            return Fn(() => {
                const distanceToPlane = float().toVar('distanceToPlane');
                const distanceGradient = float().toVar('distanceToGradient');
                const clipOpacity = float(1).toVar('clipOpacity');
                const numUnionPlanes = unionPlanes.length;
                if (this.hardwareClipping === false && numUnionPlanes > 0) {
                    const clippingPlanes = uniformArray(unionPlanes);
                    Loop(numUnionPlanes, ({ i }) => {
                        const plane = clippingPlanes.element(i);
                        distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
                        distanceGradient.assign(distanceToPlane.fwidth().div(2.0));
                        clipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane));
                    });
                }
                const numIntersectionPlanes = intersectionPlanes.length;
                if (numIntersectionPlanes > 0) {
                    const clippingPlanes = uniformArray(intersectionPlanes);
                    const intersectionClipOpacity = float(1).toVar('intersectionClipOpacity');
                    Loop(numIntersectionPlanes, ({ i }) => {
                        const plane = clippingPlanes.element(i);
                        distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
                        distanceGradient.assign(distanceToPlane.fwidth().div(2.0));
                        intersectionClipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane).oneMinus());
                    });
                    clipOpacity.mulAssign(intersectionClipOpacity.oneMinus());
                }
                diffuseColor.a.mulAssign(clipOpacity);
                diffuseColor.a.equal(0.0).discard();
            })();
        }
        setupDefault(intersectionPlanes, unionPlanes) {
            return Fn(() => {
                const numUnionPlanes = unionPlanes.length;
                if (this.hardwareClipping === false && numUnionPlanes > 0) {
                    const clippingPlanes = uniformArray(unionPlanes);
                    Loop(numUnionPlanes, ({ i }) => {
                        const plane = clippingPlanes.element(i);
                        positionView.dot(plane.xyz).greaterThan(plane.w).discard();
                    });
                }
                const numIntersectionPlanes = intersectionPlanes.length;
                if (numIntersectionPlanes > 0) {
                    const clippingPlanes = uniformArray(intersectionPlanes);
                    const clipped = bool(true).toVar('clipped');
                    Loop(numIntersectionPlanes, ({ i }) => {
                        const plane = clippingPlanes.element(i);
                        clipped.assign(positionView.dot(plane.xyz).greaterThan(plane.w).and(clipped));
                    });
                    clipped.discard();
                }
            })();
        }
        setupHardwareClipping(unionPlanes, builder) {
            const numUnionPlanes = unionPlanes.length;
            builder.enableHardwareClipping(numUnionPlanes);
            return Fn(() => {
                const clippingPlanes = uniformArray(unionPlanes);
                const hw_clip_distances = builtin(builder.getClipDistance());
                Loop(numUnionPlanes, ({ i }) => {
                    const plane = clippingPlanes.element(i);
                    const distance = positionView.dot(plane.xyz).sub(plane.w).negate();
                    hw_clip_distances.element(i).assign(distance);
                });
            })();
        }
    }
    ClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';
    ClippingNode.DEFAULT = 'default';
    ClippingNode.HARDWARE = 'hardware';
    const clipping = () => nodeObject(new ClippingNode());
    const clippingAlpha = () => nodeObject(new ClippingNode(ClippingNode.ALPHA_TO_COVERAGE));
    const hardwareClipping = () => nodeObject(new ClippingNode(ClippingNode.HARDWARE));
    // See: https://casual-effects.com/research/Wyman2017Hashed/index.html
    const ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.
    const hash2D = /*@__PURE__*/ Fn(([value]) => {
        return fract(mul(1.0e4, sin(mul(17.0, value.x).add(mul(0.1, value.y)))).mul(add(0.1, abs(sin(mul(13.0, value.y).add(value.x))))));
    });
    const hash3D = /*@__PURE__*/ Fn(([value]) => {
        return hash2D(vec2(hash2D(value.xy), value.z));
    });
    const getAlphaHashThreshold = /*@__PURE__*/ Fn(([position]) => {
        // Find the discretized derivatives of our coordinates
        const maxDeriv = max$1(
            length(dFdx(position.xyz)),
            length(dFdy(position.xyz))
        );
        const pixScale = float(1).div(float(ALPHA_HASH_SCALE).mul(maxDeriv)).toVar('pixScale');
        // Find two nearest log-discretized noise scales
        const pixScales = vec2(
            exp2(floor(log2(pixScale))),
            exp2(ceil(log2(pixScale)))
        );
        // Compute alpha thresholds at our two noise scales
        const alpha = vec2(
            hash3D(floor(pixScales.x.mul(position.xyz))),
            hash3D(floor(pixScales.y.mul(position.xyz))),
        );
        // Factor to interpolate lerp with
        const lerpFactor = fract(log2(pixScale));
        // Interpolate alpha threshold from noise at two scales
        const x = add(mul(lerpFactor.oneMinus(), alpha.x), mul(lerpFactor, alpha.y));
        // Pass into CDF to compute uniformly distrib threshold
        const a = min$1(lerpFactor, lerpFactor.oneMinus());
        const cases = vec3(
            x.mul(x).div(mul(2.0, a).mul(sub(1.0, a))),
            x.sub(mul(0.5, a)).div(sub(1.0, a)),
            sub(1.0, sub(1.0, x).mul(sub(1.0, x)).div(mul(2.0, a).mul(sub(1.0, a)))));
        // Find our final, uniformly distributed alpha threshold (ατ)
        const threshold = x.lessThan(a.oneMinus()).select(x.lessThan(a).select(cases.x, cases.y), cases.z);
        // Avoids ατ == 0. Could also do ατ =1-ατ
        return clamp(threshold, 1.0e-6, 1.0);
    }).setLayout({
        name: 'getAlphaHashThreshold',
        type: 'float',
        inputs: [
            { name: 'position', type: 'vec3' }
        ]
    });
    class VertexColorNode extends AttributeNode {
        static get type() {
            return 'VertexColorNode';
        }
        constructor(index) {
            super(null, 'vec4');
            this.isVertexColorNode = true;
            this.index = index;
        }
        getAttributeName( /*builder*/) {
            const index = this.index;
            return 'color' + (index > 0 ? index : '');
        }
        generate(builder) {
            const attributeName = this.getAttributeName(builder);
            const geometryAttribute = builder.hasGeometryAttribute(attributeName);
            let result;
            if (geometryAttribute === true) {
                result = super.generate(builder);
            } else {
                // Vertex color fallback should be white
                result = builder.generateConst(this.nodeType, new Vector4(1, 1, 1, 1));
            }
            return result;
        }
        serialize(data) {
            super.serialize(data);
            data.index = this.index;
        }
        deserialize(data) {
            super.deserialize(data);
            this.index = data.index;
        }
    }
    const vertexColor = (index = 0) => nodeObject(new VertexColorNode(index));
    const blendBurn = /*@__PURE__*/ Fn(([base, blend]) => {
        return min$1(1.0, base.oneMinus().div(blend)).oneMinus();
    }).setLayout({
        name: 'blendBurn',
        type: 'vec3',
        inputs: [
            { name: 'base', type: 'vec3' },
            { name: 'blend', type: 'vec3' }
        ]
    });
    const blendDodge = /*@__PURE__*/ Fn(([base, blend]) => {
        return min$1(base.div(blend.oneMinus()), 1.0);
    }).setLayout({
        name: 'blendDodge',
        type: 'vec3',
        inputs: [
            { name: 'base', type: 'vec3' },
            { name: 'blend', type: 'vec3' }
        ]
    });
    const blendScreen = /*@__PURE__*/ Fn(([base, blend]) => {
        return base.oneMinus().mul(blend.oneMinus()).oneMinus();
    }).setLayout({
        name: 'blendScreen',
        type: 'vec3',
        inputs: [
            { name: 'base', type: 'vec3' },
            { name: 'blend', type: 'vec3' }
        ]
    });
    const blendOverlay = /*@__PURE__*/ Fn(([base, blend]) => {
        return mix(base.mul(2.0).mul(blend), base.oneMinus().mul(2.0).mul(blend.oneMinus()).oneMinus(), step(0.5, base));
    }).setLayout({
        name: 'blendOverlay',
        type: 'vec3',
        inputs: [
            { name: 'base', type: 'vec3' },
            { name: 'blend', type: 'vec3' }
        ]
    });
    const blendColor = /*@__PURE__*/ Fn(([base, blend]) => {
        const outAlpha = blend.a.add(base.a.mul(blend.a.oneMinus()));
        return vec4(blend.rgb.mul(blend.a).add(base.rgb.mul(base.a).mul(blend.a.oneMinus())).div(outAlpha), outAlpha);
    }).setLayout({
        name: 'blendColor',
        type: 'vec4',
        inputs: [
            { name: 'base', type: 'vec4' },
            { name: 'blend', type: 'vec4' }
        ]
    });
    const premultiplyAlpha = /*@__PURE__*/ Fn(([color]) => {
        return vec4(color.rgb.mul(color.a), color.a);
    }, { color: 'vec4', return: 'vec4' });
    const unpremultiplyAlpha = /*@__PURE__*/ Fn(([color]) => {
        If(color.a.equal(0.0), () => vec4(0.0));
        return vec4(color.rgb.div(color.a), color.a);
    }, { color: 'vec4', return: 'vec4' });

    // Deprecated
    const burn = (...params) => { // @deprecated, r171
        console.warn('THREE.TSL: "burn" has been renamed. Use "blendBurn" instead.');
        return blendBurn(params);
    };
    const dodge = (...params) => { // @deprecated, r171
        console.warn('THREE.TSL: "dodge" has been renamed. Use "blendDodge" instead.');
        return blendDodge(params);
    };
    const screen = (...params) => { // @deprecated, r171
        console.warn('THREE.TSL: "screen" has been renamed. Use "blendScreen" instead.');
        return blendScreen(params);
    };
    const overlay = (...params) => { // @deprecated, r171
        console.warn('THREE.TSL: "overlay" has been renamed. Use "blendOverlay" instead.');
        return blendOverlay(params);
    };
    class NodeMaterial extends Material {
        static get type() {
            return 'NodeMaterial';
        }
        get type() {
            return this.constructor.type;
        }
        set type(_value) { /* */ }
        constructor() {
            super();
            this.isNodeMaterial = true;
            this.fog = true;
            this.lights = false;
            this.hardwareClipping = false;
            this.lightsNode = null;
            this.envNode = null;
            this.aoNode = null;
            this.colorNode = null;
            this.normalNode = null;
            this.opacityNode = null;
            this.backdropNode = null;
            this.backdropAlphaNode = null;
            this.alphaTestNode = null;

            this.maskNode = null;
            this.positionNode = null;
            this.geometryNode = null;
            this.depthNode = null;
            this.receivedShadowPositionNode = null;
            this.castShadowPositionNode = null;
            this.receivedShadowNode = null;
            this.castShadowNode = null;
            this.outputNode = null;
            this.mrtNode = null;
            this.fragmentNode = null;
            this.vertexNode = null;
            // Deprecated properties
            Object.defineProperty(this, 'shadowPositionNode', { // @deprecated, r176
                get: () => {
                    return this.receivedShadowPositionNode;
                },
                set: (value) => {
                    console.warn('THREE.NodeMaterial: ".shadowPositionNode" was renamed to ".receivedShadowPositionNode".');
                    this.receivedShadowPositionNode = value;
                }
            });
        }
        customProgramCacheKey() {
            return this.type + getCacheKey$1(this);
        }
        build(builder) {
            this.setup(builder);
        }
        setupObserver(builder) {
            return new NodeMaterialObserver(builder);
        }
        setup(builder) {
            builder.context.setupNormal = () => subBuild(this.setupNormal(builder), 'NORMAL', 'vec3');
            builder.context.setupPositionView = () => this.setupPositionView(builder);
            builder.context.setupModelViewProjection = () => this.setupModelViewProjection(builder);
            const renderer = builder.renderer;
            const renderTarget = renderer.getRenderTarget();
            // < VERTEX STAGE >
            builder.addStack();
            const mvp = subBuild(this.setupVertex(builder), 'VERTEX');
            const vertexNode = this.vertexNode || mvp;
            builder.stack.outputNode = vertexNode;
            this.setupHardwareClipping(builder);
            if (this.geometryNode !== null) {
                builder.stack.outputNode = builder.stack.outputNode.bypass(this.geometryNode);
            }
            builder.addFlow('vertex', builder.removeStack());
            // < FRAGMENT STAGE >
            builder.addStack();
            let resultNode;
            const clippingNode = this.setupClipping(builder);
            if (this.depthWrite === true || this.depthTest === true) {
                // only write depth if depth buffer is configured
                if (renderTarget !== null) {
                    if (renderTarget.depthBuffer === true) this.setupDepth(builder);
                } else {
                    if (renderer.depth === true) this.setupDepth(builder);
                }
            }
            if (this.fragmentNode === null) {
                this.setupDiffuseColor(builder);
                this.setupVariants(builder);
                const outgoingLightNode = this.setupLighting(builder);
                if (clippingNode !== null) builder.stack.add(clippingNode);
                // force unsigned floats - useful for RenderTargets
                const basicOutput = vec4(outgoingLightNode, diffuseColor.a).max(0);
                resultNode = this.setupOutput(builder, basicOutput);
                // OUTPUT NODE
                output.assign(resultNode);
                //
                const isCustomOutput = this.outputNode !== null;
                if (isCustomOutput) resultNode = this.outputNode;
                // MRT
                if (renderTarget !== null) {
                    const mrt = renderer.getMRT();
                    const materialMRT = this.mrtNode;
                    if (mrt !== null) {
                        if (isCustomOutput) output.assign(resultNode);
                        resultNode = mrt;
                        if (materialMRT !== null) {
                            resultNode = mrt.merge(materialMRT);
                        }
                    } else if (materialMRT !== null) {
                        resultNode = materialMRT;
                    }
                }
            } else {
                let fragmentNode = this.fragmentNode;
                if (fragmentNode.isOutputStructNode !== true) {
                    fragmentNode = vec4(fragmentNode);
                }
                resultNode = this.setupOutput(builder, fragmentNode);
            }
            builder.stack.outputNode = resultNode;
            builder.addFlow('fragment', builder.removeStack());
            // < OBSERVER >
            builder.observer = this.setupObserver(builder);
        }
        setupClipping(builder) {
            if (builder.clippingContext === null) return null;
            const { unionPlanes, intersectionPlanes } = builder.clippingContext;
            let result = null;
            if (unionPlanes.length > 0 || intersectionPlanes.length > 0) {
                const samples = builder.renderer.samples;
                if (this.alphaToCoverage && samples > 1) {
                    // to be added to flow when the color/alpha value has been determined
                    result = clippingAlpha();
                } else {
                    builder.stack.add(clipping());
                }
            }
            return result;
        }
        setupHardwareClipping(builder) {
            this.hardwareClipping = false;
            if (builder.clippingContext === null) return;
            const candidateCount = builder.clippingContext.unionPlanes.length;
            // 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances
            if (candidateCount > 0 && candidateCount <= 8 && builder.isAvailable('clipDistance')) {
                builder.stack.add(hardwareClipping());
                this.hardwareClipping = true;
            }
            return;
        }
        setupDepth(builder) {
            const { renderer, camera } = builder;
            // Depth
            let depthNode = this.depthNode;
            if (depthNode === null) {
                const mrt = renderer.getMRT();
                if (mrt && mrt.has('depth')) {
                    depthNode = mrt.get('depth');
                } else if (renderer.logarithmicDepthBuffer === true) {
                    if (camera.isPerspectiveCamera) {
                        depthNode = viewZToLogarithmicDepth(positionView.z, cameraNear, cameraFar);
                    } else {
                        depthNode = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
                    }
                }
            }
            if (depthNode !== null) {
                depth.assign(depthNode).toStack();
            }
        }
        setupPositionView( /*builder*/) {
            return modelViewMatrix.mul(positionLocal).xyz;
        }
        setupModelViewProjection( /*builder*/) {
            return cameraProjectionMatrix.mul(positionView);
        }
        setupVertex(builder) {
            builder.addStack();
            this.setupPosition(builder);
            builder.context.vertex = builder.removeStack();
            return modelViewProjection;
        }
        setupPosition(builder) {
            const { object, geometry } = builder;
            if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {
                morphReference(object).toStack();
            }
            if (object.isSkinnedMesh === true) {
                skinning(object).toStack();
            }
            if (this.displacementMap) {
                const displacementMap = materialReference('displacementMap', 'texture');
                const displacementScale = materialReference('displacementScale', 'float');
                const displacementBias = materialReference('displacementBias', 'float');
                positionLocal.addAssign(normalLocal.normalize().mul((displacementMap.x.mul(displacementScale).add(displacementBias))));
            }
            if (object.isBatchedMesh) {
                batch(object).toStack();
            }
            if ((object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true)) {
                instancedMesh(object).toStack();
            }
            if (this.positionNode !== null) {
                positionLocal.assign(subBuild(this.positionNode, 'POSITION', 'vec3'));
            }
            return positionLocal;
        }
        setupDiffuseColor({ object, geometry }) {
            // MASK
            if (this.maskNode !== null) {
                // Discard if the mask is `false`
                bool(this.maskNode).not().discard();
            }
            // COLOR
            let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;
            // VERTEX COLORS
            if (this.vertexColors === true && geometry.hasAttribute('color')) {
                colorNode = colorNode.mul(vertexColor());
            }
            // INSTANCED COLORS
            if (object.instanceColor) {
                const instanceColor = varyingProperty('vec3', 'vInstanceColor');
                colorNode = instanceColor.mul(colorNode);
            }
            if (object.isBatchedMesh && object._colorsTexture) {
                const batchColor = varyingProperty('vec3', 'vBatchColor');
                colorNode = batchColor.mul(colorNode);
            }
            // DIFFUSE COLOR
            diffuseColor.assign(colorNode);
            // OPACITY
            const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
            diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));
            // ALPHA TEST
            let alphaTestNode = null;
            if (this.alphaTestNode !== null || this.alphaTest > 0) {
                alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;
                diffuseColor.a.lessThanEqual(alphaTestNode).discard();
            }
            // ALPHA HASH
            if (this.alphaHash === true) {
                diffuseColor.a.lessThan(getAlphaHashThreshold(positionLocal)).discard();
            }
            // OPAQUE
            const isOpaque = this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false;
            if (isOpaque) {
                diffuseColor.a.assign(1.0);
            } else if (alphaTestNode === null) {
                diffuseColor.a.lessThanEqual(0).discard();
            }
        }
        setupVariants( /*builder*/) {
            // Interface function.
        }
        setupOutgoingLight() {
            return (this.lights === true) ? vec3(0) : diffuseColor.rgb;
        }
        setupNormal() {
            return this.normalNode ? vec3(this.normalNode) : materialNormal;
        }
        setupEnvironment( /*builder*/) {
            let node = null;
            if (this.envNode) {
                node = this.envNode;
            } else if (this.envMap) {
                node = this.envMap.isCubeTexture ? materialReference('envMap', 'cubeTexture') : materialReference('envMap', 'texture');
            }
            return node;
        }
        setupLightMap(builder) {
            let node = null;
            if (builder.material.lightMap) {
                node = new IrradianceNode(materialLightMap);
            }
            return node;
        }
        setupLights(builder) {
            const materialLightsNode = [];
            //
            const envNode = this.setupEnvironment(builder);
            if (envNode && envNode.isLightingNode) {
                materialLightsNode.push(envNode);
            }
            const lightMapNode = this.setupLightMap(builder);
            if (lightMapNode && lightMapNode.isLightingNode) {
                materialLightsNode.push(lightMapNode);
            }
            if (this.aoNode !== null || builder.material.aoMap) {
                const aoNode = this.aoNode !== null ? this.aoNode : materialAO;
                materialLightsNode.push(new AONode(aoNode));
            }
            let lightsN = this.lightsNode || builder.lightsNode;
            if (materialLightsNode.length > 0) {
                lightsN = builder.renderer.lighting.createNode([...lightsN.getLights(), ...materialLightsNode]);
            }
            return lightsN;
        }
        setupLightingModel( /*builder*/) {
            // Interface function.
        }
        setupLighting(builder) {
            const { material } = builder;
            const { backdropNode, backdropAlphaNode, emissiveNode } = this;
            // OUTGOING LIGHT
            const lights = this.lights === true || this.lightsNode !== null;
            const lightsNode = lights ? this.setupLights(builder) : null;
            let outgoingLightNode = this.setupOutgoingLight(builder);
            if (lightsNode && lightsNode.getScope().hasLights) {
                const lightingModel = this.setupLightingModel(builder) || null;
                outgoingLightNode = lightingContext(lightsNode, lightingModel, backdropNode, backdropAlphaNode);
            } else if (backdropNode !== null) {
                outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);
            }
            // EMISSIVE
            if ((emissiveNode && emissiveNode.isNode === true) || (material.emissive && material.emissive.isColor === true)) {
                emissive.assign(vec3(emissiveNode ? emissiveNode : materialEmissive));
                outgoingLightNode = outgoingLightNode.add(emissive);
            }
            return outgoingLightNode;
        }
        setupFog(builder, outputNode) {
            const fogNode = builder.fogNode;
            if (fogNode) {
                output.assign(outputNode);
                outputNode = vec4(fogNode.toVar());
            }
            return outputNode;
        }
        setupPremultipliedAlpha(builder, outputNode) {
            return premultiplyAlpha(outputNode);
        }
        setupOutput(builder, outputNode) {
            // FOG
            if (this.fog === true) {
                outputNode = this.setupFog(builder, outputNode);
            }
            // PREMULTIPLIED ALPHA
            if (this.premultipliedAlpha === true) {
                outputNode = this.setupPremultipliedAlpha(builder, outputNode);
            }
            return outputNode;
        }
        setDefaultValues(material) {
            // This approach is to reuse the native refreshUniforms*
            // and turn available the use of features like transmission and environment in core
            for (const property in material) {
                const value = material[property];
                if (this[property] === undefined) {
                    this[property] = value;
                    if (value && value.clone) this[property] = value.clone();
                }
            }
            const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);
            for (const key in descriptors) {
                if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === undefined &&
                    descriptors[key].get !== undefined) {
                    Object.defineProperty(this.constructor.prototype, key, descriptors[key]);
                }
            }
        }
        toJSON(meta) {
            const isRoot = (meta === undefined || typeof meta === 'string');
            if (isRoot) {
                meta = {
                    textures: {},
                    images: {},
                    nodes: {}
                };
            }
            const data = Material.prototype.toJSON.call(this, meta);
            const nodeChildren = getNodeChildren(this);
            data.inputNodes = {};
            for (const { property, childNode } of nodeChildren) {
                data.inputNodes[property] = childNode.toJSON(meta).uuid;
            }
            // TODO: Copied from Object3D.toJSON
            function extractFromCache(cache) {
                const values = [];
                for (const key in cache) {
                    const data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
            if (isRoot) {
                const textures = extractFromCache(meta.textures);
                const images = extractFromCache(meta.images);
                const nodes = extractFromCache(meta.nodes);
                if (textures.length > 0) data.textures = textures;
                if (images.length > 0) data.images = images;
                if (nodes.length > 0) data.nodes = nodes;
            }
            return data;
        }
        copy(source) {
            this.lightsNode = source.lightsNode;
            this.envNode = source.envNode;
            this.colorNode = source.colorNode;
            this.normalNode = source.normalNode;
            this.opacityNode = source.opacityNode;
            this.backdropNode = source.backdropNode;
            this.backdropAlphaNode = source.backdropAlphaNode;
            this.alphaTestNode = source.alphaTestNode;
            this.maskNode = source.maskNode;
            this.positionNode = source.positionNode;
            this.geometryNode = source.geometryNode;
            this.depthNode = source.depthNode;
            this.receivedShadowPositionNode = source.receivedShadowPositionNode;
            this.castShadowPositionNode = source.castShadowPositionNode;
            this.receivedShadowNode = source.receivedShadowNode;
            this.castShadowNode = source.castShadowNode;
            this.outputNode = source.outputNode;
            this.mrtNode = source.mrtNode;
            this.fragmentNode = source.fragmentNode;
            this.vertexNode = source.vertexNode;
            return super.copy(source);
        }
    }
    const _defaultValues$d = /*@__PURE__*/ new LineBasicMaterial();
    class LineBasicNodeMaterial extends NodeMaterial {
        static get type() {
            return 'LineBasicNodeMaterial';
        }
        constructor(parameters) {
            super();
            this.isLineBasicNodeMaterial = true;
            this.setDefaultValues(_defaultValues$d);
            this.setValues(parameters);
        }
    }
    const _defaultValues$c = /*@__PURE__*/ new LineDashedMaterial();
    class LineDashedNodeMaterial extends NodeMaterial {
        static get type() {
            return 'LineDashedNodeMaterial';
        }
        constructor(parameters) {
            super();
            this.isLineDashedNodeMaterial = true;
            this.setDefaultValues(_defaultValues$c);
            this.dashOffset = 0;
            this.offsetNode = null;
            this.dashScaleNode = null;
            this.dashSizeNode = null;
            this.gapSizeNode = null;
            this.setValues(parameters);
        }
        setupVariants( /* builder */) {
            const offsetNode = this.offsetNode ? float(this.offsetNode) : materialLineDashOffset;
            const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;
            const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;
            const gapSizeNode = this.gapSizeNode ? float(this.gapSizeNode) : materialLineGapSize;
            dashSize.assign(dashSizeNode);
            gapSize.assign(gapSizeNode);
            const vLineDistance = varying(attribute('lineDistance').mul(dashScaleNode));
            const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;
            vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard();
        }
    }
    let _sharedFramebuffer = null;
    class ViewportSharedTextureNode extends ViewportTextureNode {
        static get type() {
            return 'ViewportSharedTextureNode';
        }
        constructor(uvNode = screenUV, levelNode = null) {
            if (_sharedFramebuffer === null) {
                _sharedFramebuffer = new FramebufferTexture();
            }
            super(uvNode, levelNode, _sharedFramebuffer);
        }
        updateReference() {
            return this;
        }
    }
    const viewportSharedTexture = /*@__PURE__*/ nodeProxy(ViewportSharedTextureNode).setParameterLength(0, 2);
    const _defaultValues$b = /*@__PURE__*/ new LineDashedMaterial();
    class Line2NodeMaterial extends NodeMaterial {
        static get type() {
            return 'Line2NodeMaterial';
        }
        constructor(parameters = {}) {
            super();
            this.isLine2NodeMaterial = true;
            this.setDefaultValues(_defaultValues$b);
            this.useColor = parameters.vertexColors;
            this.dashOffset = 0;
            this.lineColorNode = null;
            this.offsetNode = null;
            this.dashScaleNode = null;
            this.dashSizeNode = null;
            this.gapSizeNode = null;
            this.blending = NoBlending;
            this._useDash = parameters.dashed;
            this._useAlphaToCoverage = true;
            this._useWorldUnits = false;
            this.setValues(parameters);
        }
        setup(builder) {
            const { renderer } = builder;
            const useAlphaToCoverage = this._useAlphaToCoverage;
            const useColor = this.useColor;
            const useDash = this._useDash;
            const useWorldUnits = this._useWorldUnits;
            const trimSegment = Fn(({ start, end }) => {
                const a = cameraProjectionMatrix.element(2).element(2); // 3nd entry in 3th column
                const b = cameraProjectionMatrix.element(3).element(2); // 3nd entry in 4th column
                const nearEstimate = b.mul(-0.5).div(a);
                const alpha = nearEstimate.sub(start.z).div(end.z.sub(start.z));
                return vec4(mix(start.xyz, end.xyz, alpha), end.w);
            }).setLayout({
                name: 'trimSegment',
                type: 'vec4',
                inputs: [
                    { name: 'start', type: 'vec4' },
                    { name: 'end', type: 'vec4' }
                ]
            });
            this.vertexNode = Fn(() => {
                const instanceStart = attribute('instanceStart');
                const instanceEnd = attribute('instanceEnd');
                // camera space
                const start = vec4(modelViewMatrix.mul(vec4(instanceStart, 1.0))).toVar('start');
                const end = vec4(modelViewMatrix.mul(vec4(instanceEnd, 1.0))).toVar('end');
                if (useDash) {
                    const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;
                    const offsetNode = this.offsetNode ? float(this.offsetNode) : materialLineDashOffset;
                    const instanceDistanceStart = attribute('instanceDistanceStart');
                    const instanceDistanceEnd = attribute('instanceDistanceEnd');
                    let lineDistance = positionGeometry.y.lessThan(0.5).select(dashScaleNode.mul(instanceDistanceStart), dashScaleNode.mul(instanceDistanceEnd));
                    lineDistance = lineDistance.add(offsetNode);
                    varyingProperty('float', 'lineDistance').assign(lineDistance);
                }
                if (useWorldUnits) {
                    varyingProperty('vec3', 'worldStart').assign(start.xyz);
                    varyingProperty('vec3', 'worldEnd').assign(end.xyz);
                }
                const aspect = viewport.z.div(viewport.w);
                // special case for perspective projection, and segments that terminate either in, or behind, the camera plane
                // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
                // but we need to perform ndc-space calculations in the shader, so we must address this issue directly
                // perhaps there is a more elegant solution -- WestLangley
                const perspective = cameraProjectionMatrix.element(2).element(3).equal(-1); // 4th entry in the 3rd column
                If(perspective, () => {
                    If(start.z.lessThan(0.0).and(end.z.greaterThan(0.0)), () => {
                        end.assign(trimSegment({ start: start, end: end }));
                    }).ElseIf(end.z.lessThan(0.0).and(start.z.greaterThanEqual(0.0)), () => {
                        start.assign(trimSegment({ start: end, end: start }));
                    });
                });
                // clip space
                const clipStart = cameraProjectionMatrix.mul(start);
                const clipEnd = cameraProjectionMatrix.mul(end);
                // ndc space
                const ndcStart = clipStart.xyz.div(clipStart.w);
                const ndcEnd = clipEnd.xyz.div(clipEnd.w);
                // direction
                const dir = ndcEnd.xy.sub(ndcStart.xy).toVar();
                // account for clip-space aspect ratio
                dir.x.assign(dir.x.mul(aspect));
                dir.assign(dir.normalize());
                const clip = vec4().toVar();
                if (useWorldUnits) {
                    // get the offset direction as perpendicular to the view vector
                    const worldDir = end.xyz.sub(start.xyz).normalize();
                    const tmpFwd = mix(start.xyz, end.xyz, 0.5).normalize();
                    const worldUp = worldDir.cross(tmpFwd).normalize();
                    const worldFwd = worldDir.cross(worldUp);
                    const worldPos = varyingProperty('vec4', 'worldPos');
                    worldPos.assign(positionGeometry.y.lessThan(0.5).select(start, end));
                    // height offset
                    const hw = materialLineWidth.mul(0.5);
                    worldPos.addAssign(vec4(positionGeometry.x.lessThan(0.0).select(worldUp.mul(hw), worldUp.mul(hw).negate()), 0));
                    // don't extend the line if we're rendering dashes because we
                    // won't be rendering the endcaps
                    if (!useDash) {
                        // cap extension
                        worldPos.addAssign(vec4(positionGeometry.y.lessThan(0.5).select(worldDir.mul(hw).negate(), worldDir.mul(hw)), 0));
                        // add width to the box
                        worldPos.addAssign(vec4(worldFwd.mul(hw), 0));
                        // endcaps
                        If(positionGeometry.y.greaterThan(1.0).or(positionGeometry.y.lessThan(0.0)), () => {
                            worldPos.subAssign(vec4(worldFwd.mul(2.0).mul(hw), 0));
                        });
                    }
                    // project the worldpos
                    clip.assign(cameraProjectionMatrix.mul(worldPos));
                    // shift the depth of the projected points so the line
                    // segments overlap neatly
                    const clipPose = vec3().toVar();
                    clipPose.assign(positionGeometry.y.lessThan(0.5).select(ndcStart, ndcEnd));
                    clip.z.assign(clipPose.z.mul(clip.w));
                } else {
                    const offset = vec2(dir.y, dir.x.negate()).toVar('offset');
                    // undo aspect ratio adjustment
                    dir.x.assign(dir.x.div(aspect));
                    offset.x.assign(offset.x.div(aspect));
                    // sign flip
                    offset.assign(positionGeometry.x.lessThan(0.0).select(offset.negate(), offset));
                    // endcaps
                    If(positionGeometry.y.lessThan(0.0), () => {
                        offset.assign(offset.sub(dir));
                    }).ElseIf(positionGeometry.y.greaterThan(1.0), () => {
                        offset.assign(offset.add(dir));
                    });
                    // adjust for linewidth
                    offset.assign(offset.mul(materialLineWidth));
                    // adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
                    offset.assign(offset.div(viewport.w));
                    // select end
                    clip.assign(positionGeometry.y.lessThan(0.5).select(clipStart, clipEnd));
                    // back to clip space
                    offset.assign(offset.mul(clip.w));
                    clip.assign(clip.add(vec4(offset, 0, 0)));
                }
                return clip;
            })();
            const closestLineToLine = Fn(({ p1, p2, p3, p4 }) => {
                const p13 = p1.sub(p3);
                const p43 = p4.sub(p3);
                const p21 = p2.sub(p1);
                const d1343 = p13.dot(p43);
                const d4321 = p43.dot(p21);
                const d1321 = p13.dot(p21);
                const d4343 = p43.dot(p43);
                const d2121 = p21.dot(p21);
                const denom = d2121.mul(d4343).sub(d4321.mul(d4321));
                const numer = d1343.mul(d4321).sub(d1321.mul(d4343));
                const mua = numer.div(denom).clamp();
                const mub = d1343.add(d4321.mul(mua)).div(d4343).clamp();
                return vec2(mua, mub);
            });
            this.colorNode = Fn(() => {
                const vUv = uv();
                if (useDash) {
                    const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;
                    const gapSizeNode = this.gapSizeNode ? float(this.gapSizeNode) : materialLineGapSize;
                    dashSize.assign(dashSizeNode);
                    gapSize.assign(gapSizeNode);
                    const vLineDistance = varyingProperty('float', 'lineDistance');
                    vUv.y.lessThan(-1).or(vUv.y.greaterThan(1.0)).discard(); // discard endcaps
                    vLineDistance.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard(); // todo - FIX
                }
                const alpha = float(1).toVar('alpha');
                if (useWorldUnits) {
                    const worldStart = varyingProperty('vec3', 'worldStart');
                    const worldEnd = varyingProperty('vec3', 'worldEnd');
                    // Find the closest points on the view ray and the line segment
                    const rayEnd = varyingProperty('vec4', 'worldPos').xyz.normalize().mul(1e5);
                    const lineDir = worldEnd.sub(worldStart);
                    const params = closestLineToLine({ p1: worldStart, p2: worldEnd, p3: vec3(0.0, 0.0, 0.0), p4: rayEnd });
                    const p1 = worldStart.add(lineDir.mul(params.x));
                    const p2 = rayEnd.mul(params.y);
                    const delta = p1.sub(p2);
                    const len = delta.length();
                    const norm = len.div(materialLineWidth);
                    if (!useDash) {
                        if (useAlphaToCoverage && renderer.samples > 1) {
                            const dnorm = norm.fwidth();
                            alpha.assign(smoothstep(dnorm.negate().add(0.5), dnorm.add(0.5), norm).oneMinus());
                        } else {
                            norm.greaterThan(0.5).discard();
                        }
                    }
                } else {
                    // round endcaps
                    if (useAlphaToCoverage && renderer.samples > 1) {
                        const a = vUv.x;
                        const b = vUv.y.greaterThan(0.0).select(vUv.y.sub(1.0), vUv.y.add(1.0));
                        const len2 = a.mul(a).add(b.mul(b));
                        const dlen = float(len2.fwidth()).toVar('dlen');
                        If(vUv.y.abs().greaterThan(1.0), () => {
                            alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());
                        });
                    } else {
                        If(vUv.y.abs().greaterThan(1.0), () => {
                            const a = vUv.x;
                            const b = vUv.y.greaterThan(0.0).select(vUv.y.sub(1.0), vUv.y.add(1.0));
                            const len2 = a.mul(a).add(b.mul(b));
                            len2.greaterThan(1.0).discard();
                        });
                    }
                }
                let lineColorNode;
                if (this.lineColorNode) {
                    lineColorNode = this.lineColorNode;
                } else {
                    if (useColor) {
                        const instanceColorStart = attribute('instanceColorStart');
                        const instanceColorEnd = attribute('instanceColorEnd');
                        const instanceColor = positionGeometry.y.lessThan(0.5).select(instanceColorStart, instanceColorEnd);
                        lineColorNode = instanceColor.mul(materialColor);
                    } else {
                        lineColorNode = materialColor;
                    }
                }
                return vec4(lineColorNode, alpha);
            })();
            if (this.transparent) {
                const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
                this.outputNode = vec4(this.colorNode.rgb.mul(opacityNode).add(viewportSharedTexture().rgb.mul(opacityNode.oneMinus())), this.colorNode.a);
            }
            super.setup(builder);
        }
        get worldUnits() {
            return this._useWorldUnits;
        }
        set worldUnits(value) {
            if (this._useWorldUnits !== value) {
                this._useWorldUnits = value;
                this.needsUpdate = true;
            }
        }
        get dashed() {
            return this._useDash;
        }
        set dashed(value) {
            if (this._useDash !== value) {
                this._useDash = value;
                this.needsUpdate = true;
            }
        }
        get alphaToCoverage() {
            return this._useAlphaToCoverage;
        }
        set alphaToCoverage(value) {
            if (this._useAlphaToCoverage !== value) {
                this._useAlphaToCoverage = value;
                this.needsUpdate = true;
            }
        }
    }
    const directionToColor = (node) => nodeObject(node).mul(0.5).add(0.5);
    const colorToDirection = (node) => nodeObject(node).mul(2.0).sub(1);
    const _defaultValues$a = /*@__PURE__*/ new MeshNormalMaterial();
    class MeshNormalNodeMaterial extends NodeMaterial {
        static get type() {
            return 'MeshNormalNodeMaterial';
        }
        constructor(parameters) {
            super();
            this.isMeshNormalNodeMaterial = true;
            this.setDefaultValues(_defaultValues$a);
            this.setValues(parameters);
        }
        setupDiffuseColor() {
            const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
            // By convention, a normal packed to RGB is in sRGB color space. Convert it to working color space.
            diffuseColor.assign(colorSpaceToWorking(vec4(directionToColor(normalView), opacityNode), SRGBColorSpace));
        }
    }
    const equirectUV = /*@__PURE__*/ Fn(([dir = positionWorldDirection]) => {
        const u = dir.z.atan(dir.x).mul(1 / (Math.PI * 2)).add(0.5);
        const v = dir.y.clamp(-1, 1.0).asin().mul(1 / Math.PI).add(0.5);
        return vec2(u, v);
    });
    // @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget
    class CubeRenderTarget extends WebGLCubeRenderTarget {
        constructor(size = 1, options = {}) {
            super(size, options);
            this.isCubeRenderTarget = true;
        }
        fromEquirectangularTexture(renderer, texture$1) {
            const currentMinFilter = texture$1.minFilter;
            const currentGenerateMipmaps = texture$1.generateMipmaps;
            texture$1.generateMipmaps = true;
            this.texture.type = texture$1.type;
            this.texture.colorSpace = texture$1.colorSpace;
            this.texture.generateMipmaps = texture$1.generateMipmaps;
            this.texture.minFilter = texture$1.minFilter;
            this.texture.magFilter = texture$1.magFilter;
            const geometry = new BoxGeometry(5, 5, 5);
            const uvNode = equirectUV(positionWorldDirection);
            const material = new NodeMaterial();
            material.colorNode = texture(texture$1, uvNode, 0);
            material.side = BackSide;
            material.blending = NoBlending;
            const mesh = new Mesh(geometry, material);
            const scene = new Scene();
            scene.add(mesh);
            // Avoid blurred poles
            if (texture$1.minFilter === LinearMipmapLinearFilter) texture$1.minFilter = LinearFilter;
            const camera = new CubeCamera(1, 10, this);
            const currentMRT = renderer.getMRT();
            renderer.setMRT(null);
            camera.update(renderer, scene);
            renderer.setMRT(currentMRT);
            texture$1.minFilter = currentMinFilter;
            texture$1.currentGenerateMipmaps = currentGenerateMipmaps;
            mesh.geometry.dispose();
            mesh.material.dispose();
            return this;
        }
    }
    const _cache$1 = new WeakMap();
    class CubeMapNode extends TempNode {
        static get type() {
            return 'CubeMapNode';
        }
        constructor(envNode) {
            super('vec3');
            this.envNode = envNode;
            this._cubeTexture = null;
            this._cubeTextureNode = cubeTexture(null);
            const defaultTexture = new CubeTexture();
            defaultTexture.isRenderTargetTexture = true;
            this._defaultTexture = defaultTexture;
            this.updateBeforeType = NodeUpdateType.RENDER;
        }
        updateBefore(frame) {
            const { renderer, material } = frame;
            const envNode = this.envNode;
            if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {
                const texture = (envNode.isTextureNode) ? envNode.value : material[envNode.property];
                if (texture && texture.isTexture) {
                    const mapping = texture.mapping;
                    if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
                        // check for converted cubemap map
                        if (_cache$1.has(texture)) {
                            const cubeMap = _cache$1.get(texture);
                            mapTextureMapping(cubeMap, texture.mapping);
                            this._cubeTexture = cubeMap;
                        } else {
                            // create cube map from equirectangular map
                            const image = texture.image;
                            if (isEquirectangularMapReady$1(image)) {
                                const renderTarget = new CubeRenderTarget(image.height);
                                renderTarget.fromEquirectangularTexture(renderer, texture);
                                mapTextureMapping(renderTarget.texture, texture.mapping);
                                this._cubeTexture = renderTarget.texture;
                                _cache$1.set(texture, renderTarget.texture);
                                texture.addEventListener('dispose', onTextureDispose);
                            } else {
                                // default cube texture as fallback when equirectangular texture is not yet loaded
                                this._cubeTexture = this._defaultTexture;
                            }
                        }
                        //
                        this._cubeTextureNode.value = this._cubeTexture;
                    } else {
                        // envNode already refers to a cube map
                        this._cubeTextureNode = this.envNode;
                    }
                }
            }
        }
        setup(builder) {
            this.updateBefore(builder);
            return this._cubeTextureNode;
        }
    }
    function isEquirectangularMapReady$1(image) {
        if (image === null || image === undefined) return false;
        return image.height > 0;
    }
    function onTextureDispose(event) {
        const texture = event.target;
        texture.removeEventListener('dispose', onTextureDispose);
        const renderTarget = _cache$1.get(texture);
        if (renderTarget !== undefined) {
            _cache$1.delete(texture);
            renderTarget.dispose();
        }
    }
    function mapTextureMapping(texture, mapping) {
        if (mapping === EquirectangularReflectionMapping) {
            texture.mapping = CubeReflectionMapping;
        } else if (mapping === EquirectangularRefractionMapping) {
            texture.mapping = CubeRefractionMapping;
        }
    }
    const cubeMapNode = /*@__PURE__*/ nodeProxy(CubeMapNode).setParameterLength(1);
    class BasicEnvironmentNode extends LightingNode {
        static get type() {
            return 'BasicEnvironmentNode';
        }
        constructor(envNode = null) {
            super();
            this.envNode = envNode;
        }
        setup(builder) {
            // environment property is used in the finish() method of BasicLightingModel
            builder.context.environment = cubeMapNode(this.envNode);
        }
    }
    class BasicLightMapNode extends LightingNode {
        static get type() {
            return 'BasicLightMapNode';
        }
        constructor(lightMapNode = null) {
            super();
            this.lightMapNode = lightMapNode;
        }
        setup(builder) {
            // irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel
            const RECIPROCAL_PI = float(1 / Math.PI);
            builder.context.irradianceLightMap = this.lightMapNode.mul(RECIPROCAL_PI);
        }
    }
    class LightingModel {
        start(builder) {
            // lights ( direct )
            builder.lightsNode.setupLights(builder, builder.lightsNode.getLightNodes(builder));
            // indirect
            this.indirect(builder);
        }
        finish( /*builder*/) { }
        direct( /*lightData, builder*/) { }
        directRectArea( /*lightData, builder*/) { }
        indirect( /*builder*/) { }
        ambientOcclusion( /*input, stack, builder*/) { }
    }
    class BasicLightingModel extends LightingModel {
        constructor() {
            super();
        }
        indirect({ context }) {
            const ambientOcclusion = context.ambientOcclusion;
            const reflectedLight = context.reflectedLight;
            const irradianceLightMap = context.irradianceLightMap;
            reflectedLight.indirectDiffuse.assign(vec4(0.0));
            // accumulation (baked indirect lighting only)
            if (irradianceLightMap) {
                reflectedLight.indirectDiffuse.addAssign(irradianceLightMap);
            } else {
                reflectedLight.indirectDiffuse.addAssign(vec4(1.0, 1.0, 1.0, 0.0));
            }
            // modulation
            reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
            reflectedLight.indirectDiffuse.mulAssign(diffuseColor.rgb);
        }
        finish(builder) {
            const { material, context } = builder;
            const outgoingLight = context.outgoingLight;
            const envNode = builder.context.environment;
            if (envNode) {
                switch (material.combine) {
                    case MultiplyOperation:
                        outgoingLight.rgb.assign(mix(outgoingLight.rgb, outgoingLight.rgb.mul(envNode.rgb), materialSpecularStrength.mul(materialReflectivity)));
                        break;
                    case MixOperation:
                        outgoingLight.rgb.assign(mix(outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul(materialReflectivity)));
                        break;
                    case AddOperation:
                        outgoingLight.rgb.addAssign(envNode.rgb.mul(materialSpecularStrength.mul(materialReflectivity)));
                        break;
                    default:
                        console.warn('THREE.BasicLightingModel: Unsupported .combine value:', material.combine);
                        break;
                }
            }
        }
    }
    const _defaultValues$9 = /*@__PURE__*/ new MeshBasicMaterial();
    class MeshBasicNodeMaterial extends NodeMaterial {
        static get type() {
            return 'MeshBasicNodeMaterial';
        }
        constructor(parameters) {
            super();
            this.isMeshBasicNodeMaterial = true;
            this.lights = true;
            this.setDefaultValues(_defaultValues$9);
            this.setValues(parameters);
        }
        setupNormal() {
            return directionToFaceDirection(normalViewGeometry); // see #28839
        }
        setupEnvironment(builder) {
            const envNode = super.setupEnvironment(builder);
            return envNode ? new BasicEnvironmentNode(envNode) : null;
        }
        setupLightMap(builder) {
            let node = null;
            if (builder.material.lightMap) {
                node = new BasicLightMapNode(materialLightMap);
            }
            return node;
        }
        setupOutgoingLight() {
            return diffuseColor.rgb;
        }
        setupLightingModel() {
            return new BasicLightingModel();
        }
    }
    const F_Schlick = /*@__PURE__*/ Fn(({ f0, f90, dotVH }) => {
        // Original approximation by Christophe Schlick '94
        // float fresnel = pow( 1.0 - dotVH, 5.0 );
        // Optimized variant (presented by Epic at SIGGRAPH '13)
        // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
        const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();
        return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));
    }); // validated
    const BRDF_Lambert = /*@__PURE__*/ Fn((inputs) => {
        return inputs.diffuseColor.mul(1 / Math.PI); // punctual light
    }); // validated
    const G_BlinnPhong_Implicit = () => float(0.25);
    const D_BlinnPhong = /*@__PURE__*/ Fn(({ dotNH }) => {
        return shininess.mul(float(0.5)).add(1.0).mul(float(1 / Math.PI)).mul(dotNH.pow(shininess));
    });
    const BRDF_BlinnPhong = /*@__PURE__*/ Fn(({ lightDirection }) => {
        const halfDir = lightDirection.add(positionViewDirection).normalize();
        const dotNH = normalView.dot(halfDir).clamp();
        const dotVH = positionViewDirection.dot(halfDir).clamp();
        const F = F_Schlick({ f0: specularColor, f90: 1.0, dotVH });
        const G = G_BlinnPhong_Implicit();
        const D = D_BlinnPhong({ dotNH });
        return F.mul(G).mul(D);
    });
    class PhongLightingModel extends BasicLightingModel {
        constructor(specular = true) {
            super();
            this.specular = specular;
        }
        direct({ lightDirection, lightColor, reflectedLight }) {
            const dotNL = normalView.dot(lightDirection).clamp();
            const irradiance = dotNL.mul(lightColor);
            reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor: diffuseColor.rgb })));
            if (this.specular === true) {
                reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong({ lightDirection })).mul(materialSpecularStrength));
            }
        }
        indirect(builder) {
            const { ambientOcclusion, irradiance, reflectedLight } = builder.context;
            reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor })));
            reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
        }
    }
    const _defaultValues$8 = /*@__PURE__*/ new MeshLambertMaterial();
    class MeshLambertNodeMaterial extends NodeMaterial {
        static get type() {
            return 'MeshLambertNodeMaterial';
        }
        constructor(parameters) {
            super();
            this.isMeshLambertNodeMaterial = true;
            this.lights = true;
            this.setDefaultValues(_defaultValues$8);
            this.setValues(parameters);
        }
        setupEnvironment(builder) {
            const envNode = super.setupEnvironment(builder);
            return envNode ? new BasicEnvironmentNode(envNode) : null;
        }
        setupLightingModel( /*builder*/) {
            return new PhongLightingModel(false); // ( specular ) -> force lambert
        }
    }
    const _defaultValues$7 = /*@__PURE__*/ new MeshPhongMaterial();
    class MeshPhongNodeMaterial extends NodeMaterial {
        static get type() {
            return 'MeshPhongNodeMaterial';
        }
        constructor(parameters) {
            super();
            this.isMeshPhongNodeMaterial = true;
            this.lights = true;
            this.shininessNode = null;
            this.specularNode = null;
            this.setDefaultValues(_defaultValues$7);
            this.setValues(parameters);
        }
        setupEnvironment(builder) {
            const envNode = super.setupEnvironment(builder);
            return envNode ? new BasicEnvironmentNode(envNode) : null;
        }
        setupLightingModel( /*builder*/) {
            return new PhongLightingModel();
        }
        setupVariants( /*builder*/) {
            // SHININESS
            const shininessNode = (this.shininessNode ? float(this.shininessNode) : materialShininess).max(1e-4); // to prevent pow( 0.0, 0.0 )
            shininess.assign(shininessNode);
            // SPECULAR COLOR
            const specularNode = this.specularNode || materialSpecular;
            specularColor.assign(specularNode);
        }
        copy(source) {
            this.shininessNode = source.shininessNode;
            this.specularNode = source.specularNode;
            return super.copy(source);
        }
    }
    const getGeometryRoughness = /*@__PURE__*/ Fn((builder) => {
        if (builder.geometry.hasAttribute('normal') === false) {
            return float(0);
        }
        const dxy = normalViewGeometry.dFdx().abs().max(normalViewGeometry.dFdy().abs());
        const geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);
        return geometryRoughness;
    });
    const getRoughness = /*@__PURE__*/ Fn((inputs) => {
        const { roughness } = inputs;
        const geometryRoughness = getGeometryRoughness();
        let roughnessFactor = roughness.max(0.0525); // 0.0525 corresponds to the base mip of a 256 cubemap.
        roughnessFactor = roughnessFactor.add(geometryRoughness);
        roughnessFactor = roughnessFactor.min(1.0);
        return roughnessFactor;
    });
    // Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
    // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
    const V_GGX_SmithCorrelated = /*@__PURE__*/ Fn(({ alpha, dotNL, dotNV }) => {
        const a2 = alpha.pow2();
        const gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());
        const gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());
        return div(0.5, gv.add(gl).max(EPSILON));
    }).setLayout({
        name: 'V_GGX_SmithCorrelated',
        type: 'float',
        inputs: [
            { name: 'alpha', type: 'float' },
            { name: 'dotNL', type: 'float' },
            { name: 'dotNV', type: 'float' }
        ]
    }); // validated
    // https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf
    const V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/ Fn(({ alphaT, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL }) => {
        const gv = dotNL.mul(vec3(alphaT.mul(dotTV), alphaB.mul(dotBV), dotNV).length());
        const gl = dotNV.mul(vec3(alphaT.mul(dotTL), alphaB.mul(dotBL), dotNL).length());
        const v = div(0.5, gv.add(gl));
        return v.saturate();
    }).setLayout({
        name: 'V_GGX_SmithCorrelated_Anisotropic',
        type: 'float',
        inputs: [
            { name: 'alphaT', type: 'float', qualifier: 'in' },
            { name: 'alphaB', type: 'float', qualifier: 'in' },
            { name: 'dotTV', type: 'float', qualifier: 'in' },
            { name: 'dotBV', type: 'float', qualifier: 'in' },
            { name: 'dotTL', type: 'float', qualifier: 'in' },
            { name: 'dotBL', type: 'float', qualifier: 'in' },
            { name: 'dotNV', type: 'float', qualifier: 'in' },
            { name: 'dotNL', type: 'float', qualifier: 'in' }
        ]
    });
    // Microfacet Models for Refraction through Rough Surfaces - equation (33)
    // http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
    // alpha is "roughness squared" in Disney’s reparameterization
    const D_GGX = /*@__PURE__*/ Fn(({ alpha, dotNH }) => {
        const a2 = alpha.pow2();
        const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus(); // avoid alpha = 0 with dotNH = 1
        return a2.div(denom.pow2()).mul(1 / Math.PI);
    }).setLayout({
        name: 'D_GGX',
        type: 'float',
        inputs: [
            { name: 'alpha', type: 'float' },
            { name: 'dotNH', type: 'float' }
        ]
    }); // validated
    const RECIPROCAL_PI = /*@__PURE__*/ float(1 / Math.PI);
    // https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf
    const D_GGX_Anisotropic = /*@__PURE__*/ Fn(({ alphaT, alphaB, dotNH, dotTH, dotBH }) => {
        const a2 = alphaT.mul(alphaB);
        const v = vec3(alphaB.mul(dotTH), alphaT.mul(dotBH), a2.mul(dotNH));
        const v2 = v.dot(v);
        const w2 = a2.div(v2);
        return RECIPROCAL_PI.mul(a2.mul(w2.pow2()));
    }).setLayout({
        name: 'D_GGX_Anisotropic',
        type: 'float',
        inputs: [
            { name: 'alphaT', type: 'float', qualifier: 'in' },
            { name: 'alphaB', type: 'float', qualifier: 'in' },
            { name: 'dotNH', type: 'float', qualifier: 'in' },
            { name: 'dotTH', type: 'float', qualifier: 'in' },
            { name: 'dotBH', type: 'float', qualifier: 'in' }
        ]
    });
    // GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
    const BRDF_GGX = /*@__PURE__*/ Fn(({ lightDirection, f0, f90, roughness, f, normalView: normalView$1 = normalView, USE_IRIDESCENCE, USE_ANISOTROPY }) => {
        const alpha = roughness.pow2(); // UE4's roughness
        const halfDir = lightDirection.add(positionViewDirection).normalize();
        const dotNL = normalView$1.dot(lightDirection).clamp();
        const dotNV = normalView$1.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV
        const dotNH = normalView$1.dot(halfDir).clamp();
        const dotVH = positionViewDirection.dot(halfDir).clamp();
        let F = F_Schlick({ f0, f90, dotVH });
        let V, D;
        if (defined(USE_IRIDESCENCE)) {
            F = iridescence.mix(F, f);
        }
        if (defined(USE_ANISOTROPY)) {
            const dotTL = anisotropyT.dot(lightDirection);
            const dotTV = anisotropyT.dot(positionViewDirection);
            const dotTH = anisotropyT.dot(halfDir);
            const dotBL = anisotropyB.dot(lightDirection);
            const dotBV = anisotropyB.dot(positionViewDirection);
            const dotBH = anisotropyB.dot(halfDir);
            V = V_GGX_SmithCorrelated_Anisotropic({ alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL });
            D = D_GGX_Anisotropic({ alphaT, alphaB: alpha, dotNH, dotTH, dotBH });
        } else {
            V = V_GGX_SmithCorrelated({ alpha, dotNL, dotNV });
            D = D_GGX({ alpha, dotNH });
        }
        return F.mul(V).mul(D);
    }); // validated
    // Analytical approximation of the DFG LUT, one half of the
    // split-sum approximation used in indirect specular lighting.
    // via 'environmentBRDF' from "Physically Based Shading on Mobile"
    // https://www.unrealengine.com/blog/physically-based-shading-on-mobile
    const DFGApprox = /*@__PURE__*/ Fn(({ roughness, dotNV }) => {
        const c0 = vec4(-1, -0.0275, -0.572, 0.022);
        const c1 = vec4(1, 0.0425, 1.04, -0.04);
        const r = roughness.mul(c0).add(c1);
        const a004 = r.x.mul(r.x).min(dotNV.mul(-9.28).exp2()).mul(r.x).add(r.y);
        const fab = vec2(-1.04, 1.04).mul(a004).add(r.zw);
        return fab;
    }).setLayout({
        name: 'DFGApprox',
        type: 'vec2',
        inputs: [
            { name: 'roughness', type: 'float' },
            { name: 'dotNV', type: 'vec3' }
        ]
    });
    const EnvironmentBRDF = /*@__PURE__*/ Fn((inputs) => {
        const { dotNV, specularColor, specularF90, roughness } = inputs;
        const fab = DFGApprox({ dotNV, roughness });
        return specularColor.mul(fab.x).add(specularF90.mul(fab.y));
    });
    const Schlick_to_F0 = /*@__PURE__*/ Fn(({ f, f90, dotVH }) => {
        const x = dotVH.oneMinus().saturate();
        const x2 = x.mul(x);
        const x5 = x.mul(x2, x2).clamp(0, .9999);
        return f.sub(vec3(f90).mul(x5)).div(x5.oneMinus());
    }).setLayout({
        name: 'Schlick_to_F0',
        type: 'vec3',
        inputs: [
            { name: 'f', type: 'vec3' },
            { name: 'f90', type: 'float' },
            { name: 'dotVH', type: 'float' }
        ]
    });
    // https://github.com/google/filament/blob/master/shaders/src/brdf.fs
    const D_Charlie = /*@__PURE__*/ Fn(({ roughness, dotNH }) => {
        const alpha = roughness.pow2();
        // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
        const invAlpha = float(1.0).div(alpha);
        const cos2h = dotNH.pow2();
        const sin2h = cos2h.oneMinus().max(0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16
        return float(2.0).add(invAlpha).mul(sin2h.pow(invAlpha.mul(0.5))).div(2.0 * Math.PI);
    }).setLayout({
        name: 'D_Charlie',
        type: 'float',
        inputs: [
            { name: 'roughness', type: 'float' },
            { name: 'dotNH', type: 'float' }
        ]
    });
    // https://github.com/google/filament/blob/master/shaders/src/brdf.fs
    const V_Neubelt = /*@__PURE__*/ Fn(({ dotNV, dotNL }) => {
        // Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
        return float(1.0).div(float(4.0).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));
    }).setLayout({
        name: 'V_Neubelt',
        type: 'float',
        inputs: [
            { name: 'dotNV', type: 'float' },
            { name: 'dotNL', type: 'float' }
        ]
    });
    const BRDF_Sheen = /*@__PURE__*/ Fn(({ lightDirection }) => {
        const halfDir = lightDirection.add(positionViewDirection).normalize();
        const dotNL = normalView.dot(lightDirection).clamp();
        const dotNV = normalView.dot(positionViewDirection).clamp();
        const dotNH = normalView.dot(halfDir).clamp();
        const D = D_Charlie({ roughness: sheenRoughness, dotNH });
        const V = V_Neubelt({ dotNV, dotNL });
        return sheen.mul(D).mul(V);
    });
    // Rect Area Light
    // Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
    // by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
    // code: https://github.com/selfshadow/ltc_code/
    const LTC_Uv = /*@__PURE__*/ Fn(({ N, V, roughness }) => {
        const LUT_SIZE = 64.0;
        const LUT_SCALE = (LUT_SIZE - 1.0) / LUT_SIZE;
        const LUT_BIAS = 0.5 / LUT_SIZE;
        const dotNV = N.dot(V).saturate();
        // texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
        const uv = vec2(roughness, dotNV.oneMinus().sqrt());
        uv.assign(uv.mul(LUT_SCALE).add(LUT_BIAS));
        return uv;
    }).setLayout({
        name: 'LTC_Uv',
        type: 'vec2',
        inputs: [
            { name: 'N', type: 'vec3' },
            { name: 'V', type: 'vec3' },
            { name: 'roughness', type: 'float' }
        ]
    });
    const LTC_ClippedSphereFormFactor = /*@__PURE__*/ Fn(({ f }) => {
        // Real-Time Area Lighting: a Journey from Research to Production (p.102)
        // An approximation of the form factor of a horizon-clipped rectangle.
        const l = f.length();
        return max$1(l.mul(l).add(f.z).div(l.add(1.0)), 0);
    }).setLayout({
        name: 'LTC_ClippedSphereFormFactor',
        type: 'float',
        inputs: [
            { name: 'f', type: 'vec3' }
        ]
    });
    const LTC_EdgeVectorFormFactor = /*@__PURE__*/ Fn(({ v1, v2 }) => {
        const x = v1.dot(v2);
        const y = x.abs().toVar();
        // rational polynomial approximation to theta / sin( theta ) / 2PI
        const a = y.mul(0.0145206).add(0.4965155).mul(y).add(0.8543985).toVar();
        const b = y.add(4.1616724).mul(y).add(3.4175940).toVar();
        const v = a.div(b);
        const theta_sintheta = x.greaterThan(0.0).select(v, max$1(x.mul(x).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(v));
        return v1.cross(v2).mul(theta_sintheta);
    }).setLayout({
        name: 'LTC_EdgeVectorFormFactor',
        type: 'vec3',
        inputs: [
            { name: 'v1', type: 'vec3' },
            { name: 'v2', type: 'vec3' }
        ]
    });
    const LTC_Evaluate = /*@__PURE__*/ Fn(({ N, V, P, mInv, p0, p1, p2, p3 }) => {
        // bail if point is on back side of plane of light
        // assumes ccw winding order of light vertices
        const v1 = p1.sub(p0).toVar();
        const v2 = p3.sub(p0).toVar();
        const lightNormal = v1.cross(v2);
        const result = vec3().toVar();
        If(lightNormal.dot(P.sub(p0)).greaterThanEqual(0.0), () => {
            // construct orthonormal basis around N
            const T1 = V.sub(N.mul(V.dot(N))).normalize();
            const T2 = N.cross(T1).negate(); // negated from paper; possibly due to a different handedness of world coordinate system
            // compute transform
            const mat = mInv.mul(mat3(T1, T2, N).transpose()).toVar();
            // transform rect
            // & project rect onto sphere
            const coords0 = mat.mul(p0.sub(P)).normalize().toVar();
            const coords1 = mat.mul(p1.sub(P)).normalize().toVar();
            const coords2 = mat.mul(p2.sub(P)).normalize().toVar();
            const coords3 = mat.mul(p3.sub(P)).normalize().toVar();
            // calculate vector form factor
            const vectorFormFactor = vec3(0).toVar();
            vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords0, v2: coords1 }));
            vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords1, v2: coords2 }));
            vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords2, v2: coords3 }));
            vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords3, v2: coords0 }));
            // adjust for horizon clipping
            result.assign(vec3(LTC_ClippedSphereFormFactor({ f: vectorFormFactor })));
        });
        return result;
    }).setLayout({
        name: 'LTC_Evaluate',
        type: 'vec3',
        inputs: [
            { name: 'N', type: 'vec3' },
            { name: 'V', type: 'vec3' },
            { name: 'P', type: 'vec3' },
            { name: 'mInv', type: 'mat3' },
            { name: 'p0', type: 'vec3' },
            { name: 'p1', type: 'vec3' },
            { name: 'p2', type: 'vec3' },
            { name: 'p3', type: 'vec3' }
        ]
    });
    const LTC_Evaluate_Volume = /*@__PURE__*/ Fn(({ P, p0, p1, p2, p3 }) => {
        // bail if point is on back side of plane of light
        // assumes ccw winding order of light vertices
        const v1 = p1.sub(p0).toVar();
        const v2 = p3.sub(p0).toVar();
        const lightNormal = v1.cross(v2);
        const result = vec3().toVar();
        If(lightNormal.dot(P.sub(p0)).greaterThanEqual(0.0), () => {
            // transform rect
            // & project rect onto sphere
            const coords0 = p0.sub(P).normalize().toVar();
            const coords1 = p1.sub(P).normalize().toVar();
            const coords2 = p2.sub(P).normalize().toVar();
            const coords3 = p3.sub(P).normalize().toVar();
            // calculate vector form factor
            const vectorFormFactor = vec3(0).toVar();
            vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords0, v2: coords1 }));
            vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords1, v2: coords2 }));
            vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords2, v2: coords3 }));
            vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords3, v2: coords0 }));
            // adjust for horizon clipping
            result.assign(vec3(LTC_ClippedSphereFormFactor({ f: vectorFormFactor.abs() })));
        });
        return result;
    }).setLayout({
        name: 'LTC_Evaluate',
        type: 'vec3',
        inputs: [
            { name: 'P', type: 'vec3' },
            { name: 'p0', type: 'vec3' },
            { name: 'p1', type: 'vec3' },
            { name: 'p2', type: 'vec3' },
            { name: 'p3', type: 'vec3' }
        ]
    });
    // Mipped Bicubic Texture Filtering by N8
    // https://www.shadertoy.com/view/Dl2SDW
    const bC = 1.0 / 6.0;
    const w0 = (a) => mul(bC, mul(a, mul(a, a.negate().add(3.0)).sub(3.0)).add(1.0));
    const w1 = (a) => mul(bC, mul(a, mul(a, mul(3.0, a).sub(6.0))).add(4.0));
    const w2 = (a) => mul(bC, mul(a, mul(a, mul(-3, a).add(3.0)).add(3.0)).add(1.0));
    const w3 = (a) => mul(bC, pow(a, 3));
    const g0 = (a) => w0(a).add(w1(a));
    const g1 = (a) => w2(a).add(w3(a));
    // h0 and h1 are the two offset functions
    const h0 = (a) => add(-1, w1(a).div(w0(a).add(w1(a))));
    const h1 = (a) => add(1.0, w3(a).div(w2(a).add(w3(a))));
    const bicubic = (textureNode, texelSize, lod) => {
        const uv = textureNode.uvNode;
        const uvScaled = mul(uv, texelSize.zw).add(0.5);
        const iuv = floor(uvScaled);
        const fuv = fract(uvScaled);
        const g0x = g0(fuv.x);
        const g1x = g1(fuv.x);
        const h0x = h0(fuv.x);
        const h1x = h1(fuv.x);
        const h0y = h0(fuv.y);
        const h1y = h1(fuv.y);
        const p0 = vec2(iuv.x.add(h0x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
        const p1 = vec2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
        const p2 = vec2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
        const p3 = vec2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
        const a = g0(fuv.y).mul(add(g0x.mul(textureNode.sample(p0).level(lod)), g1x.mul(textureNode.sample(p1).level(lod))));
        const b = g1(fuv.y).mul(add(g0x.mul(textureNode.sample(p2).level(lod)), g1x.mul(textureNode.sample(p3).level(lod))));
        return a.add(b);
    };
    const textureBicubicLevel = /*@__PURE__*/ Fn(([textureNode, lodNode]) => {
        const fLodSize = vec2(textureNode.size(int(lodNode)));
        const cLodSize = vec2(textureNode.size(int(lodNode.add(1.0))));
        const fLodSizeInv = div(1.0, fLodSize);
        const cLodSizeInv = div(1.0, cLodSize);
        const fSample = bicubic(textureNode, vec4(fLodSizeInv, fLodSize), floor(lodNode));
        const cSample = bicubic(textureNode, vec4(cLodSizeInv, cLodSize), ceil(lodNode));
        return fract(lodNode).mix(fSample, cSample);
    });
    const textureBicubic = /*@__PURE__*/ Fn(([textureNode, strength]) => {
        const lod = strength.mul(maxMipLevel(textureNode));
        return textureBicubicLevel(textureNode, lod);
    });
    //
    // Transmission
    //
    const getVolumeTransmissionRay = /*@__PURE__*/ Fn(([n, v, thickness, ior, modelMatrix]) => {
        // Direction of refracted light.
        const refractionVector = vec3(refract(v.negate(), normalize(n), div(1.0, ior)));
        // Compute rotation-independent scaling of the model matrix.
        const modelScale = vec3(
            length(modelMatrix[0].xyz),
            length(modelMatrix[1].xyz),
            length(modelMatrix[2].xyz)
        );
        // The thickness is specified in local space.
        return normalize(refractionVector).mul(thickness.mul(modelScale));
    }).setLayout({
        name: 'getVolumeTransmissionRay',
        type: 'vec3',
        inputs: [
            { name: 'n', type: 'vec3' },
            { name: 'v', type: 'vec3' },
            { name: 'thickness', type: 'float' },
            { name: 'ior', type: 'float' },
            { name: 'modelMatrix', type: 'mat4' }
        ]
    });
    const applyIorToRoughness = /*@__PURE__*/ Fn(([roughness, ior]) => {
        // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
        // an IOR of 1.5 results in the default amount of microfacet refraction.
        return roughness.mul(clamp(ior.mul(2.0).sub(2.0), 0.0, 1.0));
    }).setLayout({
        name: 'applyIorToRoughness',
        type: 'float',
        inputs: [
            { name: 'roughness', type: 'float' },
            { name: 'ior', type: 'float' }
        ]
    });
    const viewportBackSideTexture = /*@__PURE__*/ viewportMipTexture();
    const viewportFrontSideTexture = /*@__PURE__*/ viewportMipTexture();
    const getTransmissionSample = /*@__PURE__*/ Fn(([fragCoord, roughness, ior], { material }) => {
        const vTexture = material.side === BackSide ? viewportBackSideTexture : viewportFrontSideTexture;
        const transmissionSample = vTexture.sample(fragCoord);
        //const transmissionSample = viewportMipTexture( fragCoord );
        const lod = log2(screenSize.x).mul(applyIorToRoughness(roughness, ior));
        return textureBicubicLevel(transmissionSample, lod);
    });
    const volumeAttenuation = /*@__PURE__*/ Fn(([transmissionDistance, attenuationColor, attenuationDistance]) => {
        If(attenuationDistance.notEqual(0), () => {
            // Compute light attenuation using Beer's law.
            const attenuationCoefficient = log(attenuationColor).negate().div(attenuationDistance);
            const transmittance = exp(attenuationCoefficient.negate().mul(transmissionDistance));
            return transmittance;
        });
        // Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.
        return vec3(1.0);
    }).setLayout({
        name: 'volumeAttenuation',
        type: 'vec3',
        inputs: [
            { name: 'transmissionDistance', type: 'float' },
            { name: 'attenuationColor', type: 'vec3' },
            { name: 'attenuationDistance', type: 'float' }
        ]
    });
    const getIBLVolumeRefraction = /*@__PURE__*/ Fn(([n, v, roughness, diffuseColor, specularColor, specularF90, position, modelMatrix, viewMatrix, projMatrix, ior, thickness, attenuationColor, attenuationDistance, dispersion]) => {
        let transmittedLight, transmittance;
        if (dispersion) {
            transmittedLight = vec4().toVar();
            transmittance = vec3().toVar();
            const halfSpread = ior.sub(1.0).mul(dispersion.mul(0.025));
            const iors = vec3(ior.sub(halfSpread), ior, ior.add(halfSpread));
            Loop({ start: 0, end: 3 }, ({ i }) => {
                const ior = iors.element(i);
                const transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);
                const refractedRayExit = position.add(transmissionRay);
                // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
                const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1.0)));
                const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
                refractionCoords.addAssign(1.0);
                refractionCoords.divAssign(2.0);
                refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus())); // webgpu
                // Sample framebuffer to get pixel the refracted ray hits.
                const transmissionSample = getTransmissionSample(refractionCoords, roughness, ior);
                transmittedLight.element(i).assign(transmissionSample.element(i));
                transmittedLight.a.addAssign(transmissionSample.a);
                transmittance.element(i).assign(diffuseColor.element(i).mul(volumeAttenuation(length(transmissionRay), attenuationColor, attenuationDistance).element(i)));
            });
            transmittedLight.a.divAssign(3.0);
        } else {
            const transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);
            const refractedRayExit = position.add(transmissionRay);
            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
            const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1.0)));
            const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
            refractionCoords.addAssign(1.0);
            refractionCoords.divAssign(2.0);
            refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus())); // webgpu
            // Sample framebuffer to get pixel the refracted ray hits.
            transmittedLight = getTransmissionSample(refractionCoords, roughness, ior);
            transmittance = diffuseColor.mul(volumeAttenuation(length(transmissionRay), attenuationColor, attenuationDistance));
        }
        const attenuatedColor = transmittance.rgb.mul(transmittedLight.rgb);
        const dotNV = n.dot(v).clamp();
        // Get the specular component.
        const F = vec3(EnvironmentBRDF({ // n, v, specularColor, specularF90, roughness
            dotNV,
            specularColor,
            specularF90,
            roughness
        }));
        // As less light is transmitted, the opacity should be increased. This simple approximation does a decent job
        // of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.
        const transmittanceFactor = transmittance.r.add(transmittance.g, transmittance.b).div(3.0);
        return vec4(F.oneMinus().mul(attenuatedColor), transmittedLight.a.oneMinus().mul(transmittanceFactor).oneMinus());
    });
    //
    // Iridescence
    //
    // XYZ to linear-sRGB color space
    const XYZ_TO_REC709 = /*@__PURE__*/ mat3(
        3.2404542, -0.969266, 0.0556434,
        -1.5371385, 1.8760108, -0.2040259,
        -0.4985314, 0.0415560, 1.0572252
    );
    // Assume air interface for top
    // Note: We don't handle the case fresnel0 == 1
    const Fresnel0ToIor = (fresnel0) => {
        const sqrtF0 = fresnel0.sqrt();
        return vec3(1.0).add(sqrtF0).div(vec3(1.0).sub(sqrtF0));
    };
    // ior is a value between 1.0 and 3.0. 1.0 is air interface
    const IorToFresnel0 = (transmittedIor, incidentIor) => {
        return transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();
    };
    // Fresnel equations for dielectric/dielectric interfaces.
    // Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html
    // Evaluation XYZ sensitivity curves in Fourier space
    const evalSensitivity = (OPD, shift) => {
        const phase = OPD.mul(2.0 * Math.PI * 1.0e-9);
        const val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
        const pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
        const VAR = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);
        const x = float(9.7470e-14 * Math.sqrt(2.0 * Math.PI * 4.5282e+09)).mul(phase.mul(2.2399e+06).add(shift.x).cos()).mul(phase.pow2().mul(-45282e5).exp());
        let xyz = val.mul(VAR.mul(2.0 * Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());
        xyz = vec3(xyz.x.add(x), xyz.y, xyz.z).div(1.0685e-7);
        const rgb = XYZ_TO_REC709.mul(xyz);
        return rgb;
    };
    const evalIridescence = /*@__PURE__*/ Fn(({ outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 }) => {
        // Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0
        const iridescenceIOR = mix(outsideIOR, eta2, smoothstep(0.0, 0.03, thinFilmThickness));
        // Evaluate the cosTheta on the base layer (Snell law)
        const sinTheta2Sq = outsideIOR.div(iridescenceIOR).pow2().mul(cosTheta1.pow2().oneMinus());
        // Handle TIR:
        const cosTheta2Sq = sinTheta2Sq.oneMinus();
        If(cosTheta2Sq.lessThan(0), () => {
            return vec3(1.0);
        });
        const cosTheta2 = cosTheta2Sq.sqrt();
        // First interface
        const R0 = IorToFresnel0(iridescenceIOR, outsideIOR);
        const R12 = F_Schlick({ f0: R0, f90: 1.0, dotVH: cosTheta1 });
        //const R21 = R12;
        const T121 = R12.oneMinus();
        const phi12 = iridescenceIOR.lessThan(outsideIOR).select(Math.PI, 0.0);
        const phi21 = float(Math.PI).sub(phi12);
        // Second interface
        const baseIOR = Fresnel0ToIor(baseF0.clamp(0.0, 0.9999)); // guard against 1.0
        const R1 = IorToFresnel0(baseIOR, iridescenceIOR.toVec3());
        const R23 = F_Schlick({ f0: R1, f90: 1.0, dotVH: cosTheta2 });
        const phi23 = vec3(
            baseIOR.x.lessThan(iridescenceIOR).select(Math.PI, 0.0),
            baseIOR.y.lessThan(iridescenceIOR).select(Math.PI, 0.0),
            baseIOR.z.lessThan(iridescenceIOR).select(Math.PI, 0.0)
        );
        // Phase shift
        const OPD = iridescenceIOR.mul(thinFilmThickness, cosTheta2, 2.0);
        const phi = vec3(phi21).add(phi23);
        // Compound terms
        const R123 = R12.mul(R23).clamp(1e-5, 0.9999);
        const r123 = R123.sqrt();
        const Rs = T121.pow2().mul(R23).div(vec3(1.0).sub(R123));
        // Reflectance term for m = 0 (DC term amplitude)
        const C0 = R12.add(Rs);
        const I = C0.toVar();
        // Reflectance term for m > 0 (pairs of diracs)
        const Cm = Rs.sub(T121).toVar();
        Loop({ start: 1, end: 2, condition: '<=', name: 'm' }, ({ m }) => {
            Cm.mulAssign(r123);
            const Sm = evalSensitivity(float(m).mul(OPD), float(m).mul(phi)).mul(2.0);
            I.addAssign(Cm.mul(Sm));
        });
        // Since out of gamut colors might be produced, negative color values are clamped to 0.
        return I.max(vec3(0.0));
    }).setLayout({
        name: 'evalIridescence',
        type: 'vec3',
        inputs: [
            { name: 'outsideIOR', type: 'float' },
            { name: 'eta2', type: 'float' },
            { name: 'cosTheta1', type: 'float' },
            { name: 'thinFilmThickness', type: 'float' },
            { name: 'baseF0', type: 'vec3' }
        ]
    });
    //
    //	Sheen
    //
    // This is a curve-fit approximation to the "Charlie sheen" BRDF integrated over the hemisphere from
    // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". The analysis can be found
    // in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
    const IBLSheenBRDF = /*@__PURE__*/ Fn(({ normal, viewDir, roughness }) => {
        const dotNV = normal.dot(viewDir).saturate();
        const r2 = roughness.pow2();
        const a = select(
            roughness.lessThan(0.25),
            float(-339.2).mul(r2).add(float(161.4).mul(roughness)).sub(25.9),
            float(-8.48).mul(r2).add(float(14.3).mul(roughness)).sub(9.95)
        );
        const b = select(
            roughness.lessThan(0.25),
            float(44.0).mul(r2).sub(float(23.7).mul(roughness)).add(3.26),
            float(1.97).mul(r2).sub(float(3.27).mul(roughness)).add(0.72)
        );
        const DG = select(roughness.lessThan(0.25), 0.0, float(0.1).mul(roughness).sub(0.025)).add(a.mul(dotNV).add(b).exp());
        return DG.mul(1.0 / Math.PI).saturate();
    });
    const clearcoatF0 = vec3(0.04);
    const clearcoatF90 = float(1);

    class PhysicalLightingModel extends LightingModel {
        constructor(clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false) {
            super();
            this.clearcoat = clearcoat;
            this.sheen = sheen;
            this.iridescence = iridescence;
            this.anisotropy = anisotropy;
            this.transmission = transmission;
            this.dispersion = dispersion;
            this.clearcoatRadiance = null;
            this.clearcoatSpecularDirect = null;
            this.clearcoatSpecularIndirect = null;
            this.sheenSpecularDirect = null;
            this.sheenSpecularIndirect = null;
            this.iridescenceFresnel = null;
            this.iridescenceF0 = null;
        }
        start(builder) {
            if (this.clearcoat === true) {
                this.clearcoatRadiance = vec3().toVar('clearcoatRadiance');
                this.clearcoatSpecularDirect = vec3().toVar('clearcoatSpecularDirect');
                this.clearcoatSpecularIndirect = vec3().toVar('clearcoatSpecularIndirect');
            }
            if (this.sheen === true) {
                this.sheenSpecularDirect = vec3().toVar('sheenSpecularDirect');
                this.sheenSpecularIndirect = vec3().toVar('sheenSpecularIndirect');
            }
            if (this.iridescence === true) {
                const dotNVi = normalView.dot(positionViewDirection).clamp();
                this.iridescenceFresnel = evalIridescence({
                    outsideIOR: float(1.0),
                    eta2: iridescenceIOR,
                    cosTheta1: dotNVi,
                    thinFilmThickness: iridescenceThickness,
                    baseF0: specularColor
                });
                this.iridescenceF0 = Schlick_to_F0({ f: this.iridescenceFresnel, f90: 1.0, dotVH: dotNVi });
            }
            if (this.transmission === true) {
                const position = positionWorld;
                const v = cameraPosition.sub(positionWorld).normalize(); // TODO: Create Node for this, same issue in MaterialX
                const n = normalWorld;
                const context = builder.context;
                context.backdrop = getIBLVolumeRefraction(
                    n,
                    v,
                    roughness,
                    diffuseColor,
                    specularColor,
                    specularF90, // specularF90
                    position, // positionWorld
                    modelWorldMatrix, // modelMatrix
                    cameraViewMatrix, // viewMatrix
                    cameraProjectionMatrix, // projMatrix
                    ior,
                    thickness,
                    attenuationColor,
                    attenuationDistance,
                    this.dispersion ? dispersion : null
                );
                context.backdropAlpha = transmission;
                diffuseColor.a.mulAssign(mix(1, context.backdrop.a, transmission));
            }
            super.start(builder);
        }
        // Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
        // Approximates multi-scattering in order to preserve energy.
        // http://www.jcgt.org/published/0008/01/03/
        computeMultiscattering(singleScatter, multiScatter, specularF90) {
            const dotNV = normalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV
            const fab = DFGApprox({ roughness, dotNV });
            const Fr = this.iridescenceF0 ? iridescence.mix(specularColor, this.iridescenceF0) : specularColor;
            const FssEss = Fr.mul(fab.x).add(specularF90.mul(fab.y));
            const Ess = fab.x.add(fab.y);
            const Ems = Ess.oneMinus();
            const Favg = specularColor.add(specularColor.oneMinus().mul(0.047619)); // 1/21
            const Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());
            singleScatter.addAssign(FssEss);
            multiScatter.addAssign(Fms.mul(Ems));
        }
        direct({ lightDirection, lightColor, reflectedLight }, /* builder */) {
            const dotNL = normalView.dot(lightDirection).clamp();
            const irradiance = dotNL.mul(lightColor);
            if (this.sheen === true) {
                this.sheenSpecularDirect.addAssign(irradiance.mul(BRDF_Sheen({ lightDirection })));
            }
            if (this.clearcoat === true) {
                const dotNLcc = clearcoatNormalView.dot(lightDirection).clamp();
                const ccIrradiance = dotNLcc.mul(lightColor);
                this.clearcoatSpecularDirect.addAssign(ccIrradiance.mul(BRDF_GGX({ lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: clearcoatNormalView })));
            }
            reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor: diffuseColor.rgb })));
            reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX({ lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy })));
        }
        directRectArea({ lightColor, lightPosition, halfWidth, halfHeight, reflectedLight, ltc_1, ltc_2 }, /* builder */) {
            const p0 = lightPosition.add(halfWidth).sub(halfHeight); // counterclockwise; light shines in local neg z direction
            const p1 = lightPosition.sub(halfWidth).sub(halfHeight);
            const p2 = lightPosition.sub(halfWidth).add(halfHeight);
            const p3 = lightPosition.add(halfWidth).add(halfHeight);
            const N = normalView;
            const V = positionViewDirection;
            const P = positionView.toVar();
            const uv = LTC_Uv({ N, V, roughness });
            const t1 = ltc_1.sample(uv).toVar();
            const t2 = ltc_2.sample(uv).toVar();
            const mInv = mat3(
                vec3(t1.x, 0, t1.y),
                vec3(0, 1, 0),
                vec3(t1.z, 0, t1.w)
            ).toVar();
            // LTC Fresnel Approximation by Stephen Hill
            // http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
            const fresnel = specularColor.mul(t2.x).add(specularColor.oneMinus().mul(t2.y)).toVar();
            reflectedLight.directSpecular.addAssign(lightColor.mul(fresnel).mul(LTC_Evaluate({ N, V, P, mInv, p0, p1, p2, p3 })));
            reflectedLight.directDiffuse.addAssign(lightColor.mul(diffuseColor).mul(LTC_Evaluate({ N, V, P, mInv: mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p0, p1, p2, p3 })));
        }
        indirect(builder) {
            this.indirectDiffuse(builder);
            this.indirectSpecular(builder);
            this.ambientOcclusion(builder);
        }
        indirectDiffuse(builder) {
            const { irradiance, reflectedLight } = builder.context;
            reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor })));
        }
        indirectSpecular(builder) {
            const { radiance, iblIrradiance, reflectedLight } = builder.context;
            if (this.sheen === true) {
                this.sheenSpecularIndirect.addAssign(iblIrradiance.mul(
                    sheen,
                    IBLSheenBRDF({
                        normal: normalView,
                        viewDir: positionViewDirection,
                        roughness: sheenRoughness
                    })
                ));
            }
            if (this.clearcoat === true) {
                const dotNVcc = clearcoatNormalView.dot(positionViewDirection).clamp();
                const clearcoatEnv = EnvironmentBRDF({
                    dotNV: dotNVcc,
                    specularColor: clearcoatF0,
                    specularF90: clearcoatF90,
                    roughness: clearcoatRoughness
                });
                this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(clearcoatEnv));
            }
            // Both indirect specular and indirect diffuse light accumulate here
            const singleScattering = vec3().toVar('singleScattering');
            const multiScattering = vec3().toVar('multiScattering');
            const cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);
            this.computeMultiscattering(singleScattering, multiScattering, specularF90);
            const totalScattering = singleScattering.add(multiScattering);
            const diffuse = diffuseColor.mul(totalScattering.r.max(totalScattering.g).max(totalScattering.b).oneMinus());
            reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));
            reflectedLight.indirectSpecular.addAssign(multiScattering.mul(cosineWeightedIrradiance));
            reflectedLight.indirectDiffuse.addAssign(diffuse.mul(cosineWeightedIrradiance));
        }
        ambientOcclusion(builder) {
            const { ambientOcclusion, reflectedLight } = builder.context;
            const dotNV = normalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV
            const aoNV = dotNV.add(ambientOcclusion);
            const aoExp = roughness.mul(-16).oneMinus().negate().exp2();
            const aoNode = ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();
            if (this.clearcoat === true) {
                this.clearcoatSpecularIndirect.mulAssign(ambientOcclusion);
            }
            if (this.sheen === true) {
                this.sheenSpecularIndirect.mulAssign(ambientOcclusion);
            }
            reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
            reflectedLight.indirectSpecular.mulAssign(aoNode);
        }
        finish({ context }) {
            const { outgoingLight } = context;
            if (this.clearcoat === true) {
                const dotNVcc = clearcoatNormalView.dot(positionViewDirection).clamp();
                const Fcc = F_Schlick({
                    dotVH: dotNVcc,
                    f0: clearcoatF0,
                    f90: clearcoatF90
                });
                const clearcoatLight = outgoingLight.mul(clearcoat.mul(Fcc).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(clearcoat));
                outgoingLight.assign(clearcoatLight);
            }
            if (this.sheen === true) {
                const sheenEnergyComp = sheen.r.max(sheen.g).max(sheen.b).mul(0.157).oneMinus();
                const sheenLight = outgoingLight.mul(sheenEnergyComp).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
                outgoingLight.assign(sheenLight);
            }
        }
    }
    // These defines must match with PMREMGenerator
    const cubeUV_r0 = /*@__PURE__*/ float(1.0);
    const cubeUV_m0 = /*@__PURE__*/ float(-2);
    const cubeUV_r1 = /*@__PURE__*/ float(0.8);
    const cubeUV_m1 = /*@__PURE__*/ float(-1);
    const cubeUV_r4 = /*@__PURE__*/ float(0.4);
    const cubeUV_m4 = /*@__PURE__*/ float(2.0);
    const cubeUV_r5 = /*@__PURE__*/ float(0.305);
    const cubeUV_m5 = /*@__PURE__*/ float(3.0);
    const cubeUV_r6 = /*@__PURE__*/ float(0.21);
    const cubeUV_m6 = /*@__PURE__*/ float(4.0);
    const cubeUV_minMipLevel = /*@__PURE__*/ float(4.0);
    const cubeUV_minTileSize = /*@__PURE__*/ float(16.0);
    // These shader functions convert between the UV coordinates of a single face of
    // a cubemap, the 0-5 integer index of a cube face, and the direction vector for
    // sampling a textureCube (not generally normalized ).
    const getFace = /*@__PURE__*/ Fn(([direction]) => {
        const absDirection = vec3(abs(direction)).toVar();
        const face = float(-1).toVar();
        If(absDirection.x.greaterThan(absDirection.z), () => {
            If(absDirection.x.greaterThan(absDirection.y), () => {
                face.assign(select(direction.x.greaterThan(0.0), 0.0, 3.0));
            }).Else(() => {
                face.assign(select(direction.y.greaterThan(0.0), 1.0, 4.0));
            });
        }).Else(() => {
            If(absDirection.z.greaterThan(absDirection.y), () => {
                face.assign(select(direction.z.greaterThan(0.0), 2.0, 5.0));
            }).Else(() => {
                face.assign(select(direction.y.greaterThan(0.0), 1.0, 4.0));
            });
        });
        return face;
    }).setLayout({
        name: 'getFace',
        type: 'float',
        inputs: [
            { name: 'direction', type: 'vec3' }
        ]
    });
    // RH coordinate system; PMREM face-indexing convention
    const getUV = /*@__PURE__*/ Fn(([direction, face]) => {
        const uv = vec2().toVar();
        If(face.equal(0.0), () => {
            uv.assign(vec2(direction.z, direction.y).div(abs(direction.x))); // pos x
        }).ElseIf(face.equal(1.0), () => {
            uv.assign(vec2(direction.x.negate(), direction.z.negate()).div(abs(direction.y))); // pos y
        }).ElseIf(face.equal(2.0), () => {
            uv.assign(vec2(direction.x.negate(), direction.y).div(abs(direction.z))); // pos z
        }).ElseIf(face.equal(3.0), () => {
            uv.assign(vec2(direction.z.negate(), direction.y).div(abs(direction.x))); // neg x
        }).ElseIf(face.equal(4.0), () => {
            uv.assign(vec2(direction.x.negate(), direction.z).div(abs(direction.y))); // neg y
        }).Else(() => {
            uv.assign(vec2(direction.x, direction.y).div(abs(direction.z))); // neg z
        });
        return mul(0.5, uv.add(1.0));
    }).setLayout({
        name: 'getUV',
        type: 'vec2',
        inputs: [
            { name: 'direction', type: 'vec3' },
            { name: 'face', type: 'float' }
        ]
    });
    const roughnessToMip = /*@__PURE__*/ Fn(([roughness]) => {
        const mip = float(0.0).toVar();
        If(roughness.greaterThanEqual(cubeUV_r1), () => {
            mip.assign(cubeUV_r0.sub(roughness).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0));
        }).ElseIf(roughness.greaterThanEqual(cubeUV_r4), () => {
            mip.assign(cubeUV_r1.sub(roughness).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1));
        }).ElseIf(roughness.greaterThanEqual(cubeUV_r5), () => {
            mip.assign(cubeUV_r4.sub(roughness).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4));
        }).ElseIf(roughness.greaterThanEqual(cubeUV_r6), () => {
            mip.assign(cubeUV_r5.sub(roughness).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5));
        }).Else(() => {
            mip.assign(float(-2).mul(log2(mul(1.16, roughness)))); // 1.16 = 1.79^0.25
        });
        return mip;
    }).setLayout({
        name: 'roughnessToMip',
        type: 'float',
        inputs: [
            { name: 'roughness', type: 'float' }
        ]
    });
    // RH coordinate system; PMREM face-indexing convention
    const getDirection = /*@__PURE__*/ Fn(([uv_immutable, face]) => {
        const uv = uv_immutable.toVar();
        uv.assign(mul(2.0, uv).sub(1.0));
        const direction = vec3(uv, 1.0).toVar();
        If(face.equal(0.0), () => {
            direction.assign(direction.zyx); // ( 1, v, u ) pos x
        }).ElseIf(face.equal(1.0), () => {
            direction.assign(direction.xzy);
            direction.xz.mulAssign(-1); // ( -u, 1, -v ) pos y
        }).ElseIf(face.equal(2.0), () => {
            direction.x.mulAssign(-1); // ( -u, v, 1 ) pos z
        }).ElseIf(face.equal(3.0), () => {
            direction.assign(direction.zyx);
            direction.xz.mulAssign(-1); // ( -1, v, -u ) neg x
        }).ElseIf(face.equal(4.0), () => {
            direction.assign(direction.xzy);
            direction.xy.mulAssign(-1); // ( -u, -1, v ) neg y
        }).ElseIf(face.equal(5.0), () => {
            direction.z.mulAssign(-1); // ( u, v, -1 ) neg zS
        });
        return direction;
    }).setLayout({
        name: 'getDirection',
        type: 'vec3',
        inputs: [
            { name: 'uv', type: 'vec2' },
            { name: 'face', type: 'float' }
        ]
    });
    //
    const textureCubeUV = /*@__PURE__*/ Fn(([envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
        const roughness = float(roughness_immutable);
        const sampleDir = vec3(sampleDir_immutable);
        const mip = clamp(roughnessToMip(roughness), cubeUV_m0, CUBEUV_MAX_MIP);
        const mipF = fract(mip);
        const mipInt = floor(mip);
        const color0 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
        If(mipF.notEqual(0.0), () => {
            const color1 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt.add(1.0), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
            color0.assign(mix(color0, color1, mipF));
        });
        return color0;
    });
    const bilinearCubeUV = /*@__PURE__*/ Fn(([envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
        const mipInt = float(mipInt_immutable).toVar();
        const direction = vec3(direction_immutable);
        const face = float(getFace(direction)).toVar();
        const filterInt = float(max$1(cubeUV_minMipLevel.sub(mipInt), 0.0)).toVar();
        mipInt.assign(max$1(mipInt, cubeUV_minMipLevel));
        const faceSize = float(exp2(mipInt)).toVar();
        const uv = vec2(getUV(direction, face).mul(faceSize.sub(2.0)).add(1.0)).toVar();
        If(face.greaterThan(2.0), () => {
            uv.y.addAssign(faceSize);
            face.subAssign(3.0);
        });
        uv.x.addAssign(face.mul(faceSize));
        uv.x.addAssign(filterInt.mul(mul(3.0, cubeUV_minTileSize)));
        uv.y.addAssign(mul(4.0, exp2(CUBEUV_MAX_MIP).sub(faceSize)));
        uv.x.mulAssign(CUBEUV_TEXEL_WIDTH);
        uv.y.mulAssign(CUBEUV_TEXEL_HEIGHT);
        return envMap.sample(uv).grad(vec2(), vec2()); // disable anisotropic filtering
    });
    const getSample = /*@__PURE__*/ Fn(({ envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
        const cosTheta = cos(theta);
        // Rodrigues' axis-angle rotation
        const sampleDirection = outputDirection.mul(cosTheta)
            .add(axis.cross(outputDirection).mul(sin(theta)))
            .add(axis.mul(axis.dot(outputDirection).mul(cosTheta.oneMinus())));
        return bilinearCubeUV(envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);
    });
    const blur = /*@__PURE__*/ Fn(({ n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
        const axis = vec3(select(latitudinal, poleAxis, cross(poleAxis, outputDirection))).toVar();
        If(axis.equal(vec3(0.0)), () => {
            axis.assign(vec3(outputDirection.z, 0.0, outputDirection.x.negate()));
        });
        axis.assign(normalize(axis));
        const gl_FragColor = vec3().toVar();
        gl_FragColor.addAssign(weights.element(0).mul(getSample({ theta: 0.0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
        Loop({ start: int(1), end: n }, ({ i }) => {
            If(i.greaterThanEqual(samples), () => {
                Break();
            });
            const theta = float(dTheta.mul(float(i))).toVar();
            gl_FragColor.addAssign(weights.element(i).mul(getSample({ theta: theta.mul(-1), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
            gl_FragColor.addAssign(weights.element(i).mul(getSample({ theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
        });
        return vec4(gl_FragColor, 1);
    });
    const LOD_MIN = 4;
    // The standard deviations (radians) associated with the extra mips. These are
    // chosen to approximate a Trowbridge-Reitz distribution function times the
    // geometric shadowing function. These sigma values squared must match the
    // variance #defines in cube_uv_reflection_fragment.glsl.js.
    const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
    // The maximum length of the blur for loop. Smaller sigmas will use fewer
    // samples and exit early, but not recompile the shader.
    const MAX_SAMPLES = 20;
    const _flatCamera = /*@__PURE__*/ new OrthographicCamera(-1, 1, 1, -1, 0, 1);
    const _cubeCamera = /*@__PURE__*/ new PerspectiveCamera(90, 1);
    const _clearColor$2 = /*@__PURE__*/ new Color();
    let _oldTarget = null;
    let _oldActiveCubeFace = 0;
    let _oldActiveMipmapLevel = 0;
    // Golden Ratio
    const PHI = (1 + Math.sqrt(5)) / 2;
    const INV_PHI = 1 / PHI;
    // Vertices of a dodecahedron (except the opposites, which represent the
    // same axis), used as axis directions evenly spread on a sphere.
    const _axisDirections = [
	/*@__PURE__*/ new Vector3(- PHI, INV_PHI, 0),
	/*@__PURE__*/ new Vector3(PHI, INV_PHI, 0),
	/*@__PURE__*/ new Vector3(- INV_PHI, 0, PHI),
	/*@__PURE__*/ new Vector3(INV_PHI, 0, PHI),
	/*@__PURE__*/ new Vector3(0, PHI, - INV_PHI),
	/*@__PURE__*/ new Vector3(0, PHI, INV_PHI),
	/*@__PURE__*/ new Vector3(-1, 1, -1),
	/*@__PURE__*/ new Vector3(1, 1, -1),
	/*@__PURE__*/ new Vector3(-1, 1, 1),
	/*@__PURE__*/ new Vector3(1, 1, 1)
    ];
    const _origin = /*@__PURE__*/ new Vector3();
    // maps blur materials to their uniforms dictionary
    const _uniformsMap = new WeakMap();
    // WebGPU Face indices
    const _faceLib = [
        3, 1, 5,
        0, 4, 2
    ];
    const _direction = /*@__PURE__*/ getDirection(uv(), attribute('faceIndex')).normalize();
    const _outputDirection = /*@__PURE__*/ vec3(_direction.x, _direction.y, _direction.z);
    class PMREMGenerator {
        constructor(renderer) {
            this._renderer = renderer;
            this._pingPongRenderTarget = null;
            this._lodMax = 0;
            this._cubeSize = 0;
            this._lodPlanes = [];
            this._sizeLods = [];
            this._sigmas = [];
            this._lodMeshes = [];
            this._blurMaterial = null;
            this._cubemapMaterial = null;
            this._equirectMaterial = null;
            this._backgroundBox = null;
        }
        get _hasInitialized() {
            return this._renderer.hasInitialized();
        }
        fromScene(scene, sigma = 0, near = 0.1, far = 100, options = {}) {
            const {
                size = 256,
                position = _origin,
                renderTarget = null,
            } = options;
            this._setSize(size);
            if (this._hasInitialized === false) {
                console.warn('THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.');
                const cubeUVRenderTarget = renderTarget || this._allocateTarget();
                options.renderTarget = cubeUVRenderTarget;
                this.fromSceneAsync(scene, sigma, near, far, options);
                return cubeUVRenderTarget;
            }
            _oldTarget = this._renderer.getRenderTarget();
            _oldActiveCubeFace = this._renderer.getActiveCubeFace();
            _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
            const cubeUVRenderTarget = renderTarget || this._allocateTarget();
            cubeUVRenderTarget.depthBuffer = true;
            this._init(cubeUVRenderTarget);
            this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget, position);
            if (sigma > 0) {
                this._blur(cubeUVRenderTarget, 0, 0, sigma);
            }
            this._applyPMREM(cubeUVRenderTarget);
            this._cleanup(cubeUVRenderTarget);
            return cubeUVRenderTarget;
        }
        async fromSceneAsync(scene, sigma = 0, near = 0.1, far = 100, options = {}) {
            if (this._hasInitialized === false) await this._renderer.init();
            return this.fromScene(scene, sigma, near, far, options);
        }
        fromEquirectangular(equirectangular, renderTarget = null) {
            if (this._hasInitialized === false) {
                console.warn('THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.');
                this._setSizeFromTexture(equirectangular);
                const cubeUVRenderTarget = renderTarget || this._allocateTarget();
                this.fromEquirectangularAsync(equirectangular, cubeUVRenderTarget);
                return cubeUVRenderTarget;
            }
            return this._fromTexture(equirectangular, renderTarget);
        }
        async fromEquirectangularAsync(equirectangular, renderTarget = null) {
            if (this._hasInitialized === false) await this._renderer.init();
            return this._fromTexture(equirectangular, renderTarget);
        }
        fromCubemap(cubemap, renderTarget = null) {
            if (this._hasInitialized === false) {
                console.warn('THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.');
                this._setSizeFromTexture(cubemap);
                const cubeUVRenderTarget = renderTarget || this._allocateTarget();
                this.fromCubemapAsync(cubemap, renderTarget);
                return cubeUVRenderTarget;
            }
            return this._fromTexture(cubemap, renderTarget);
        }
        async fromCubemapAsync(cubemap, renderTarget = null) {
            if (this._hasInitialized === false) await this._renderer.init();
            return this._fromTexture(cubemap, renderTarget);
        }
        async compileCubemapShader() {
            if (this._cubemapMaterial === null) {
                this._cubemapMaterial = _getCubemapMaterial();
                await this._compileMaterial(this._cubemapMaterial);
            }
        }
        async compileEquirectangularShader() {
            if (this._equirectMaterial === null) {
                this._equirectMaterial = _getEquirectMaterial();
                await this._compileMaterial(this._equirectMaterial);
            }
        }
        dispose() {
            this._dispose();
            if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
            if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
            if (this._backgroundBox !== null) {
                this._backgroundBox.geometry.dispose();
                this._backgroundBox.material.dispose();
            }
        }
        // private interface
        _setSizeFromTexture(texture) {
            if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
                this._setSize(texture.image.length === 0 ? 16 : (texture.image[0].width || texture.image[0].image.width));
            } else { // Equirectangular
                this._setSize(texture.image.width / 4);
            }
        }
        _setSize(cubeSize) {
            this._lodMax = Math.floor(Math.log2(cubeSize));
            this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
            if (this._blurMaterial !== null) this._blurMaterial.dispose();
            if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
            for (let i = 0; i < this._lodPlanes.length; i++) {
                this._lodPlanes[i].dispose();
            }
        }
        _cleanup(outputTarget) {
            this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
            outputTarget.scissorTest = false;
            _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
        }
        _fromTexture(texture, renderTarget) {
            this._setSizeFromTexture(texture);
            _oldTarget = this._renderer.getRenderTarget();
            _oldActiveCubeFace = this._renderer.getActiveCubeFace();
            _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
            const cubeUVRenderTarget = renderTarget || this._allocateTarget();
            this._init(cubeUVRenderTarget);
            this._textureToCubeUV(texture, cubeUVRenderTarget);
            this._applyPMREM(cubeUVRenderTarget);
            this._cleanup(cubeUVRenderTarget);
            return cubeUVRenderTarget;
        }
        _allocateTarget() {
            const width = 3 * Math.max(this._cubeSize, 16 * 7);
            const height = 4 * this._cubeSize;
            const cubeUVRenderTarget = _createRenderTarget(width, height);
            return cubeUVRenderTarget;
        }
        _init(renderTarget) {
            if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== renderTarget.width || this._pingPongRenderTarget.height !== renderTarget.height) {
                if (this._pingPongRenderTarget !== null) {
                    this._dispose();
                }
                this._pingPongRenderTarget = _createRenderTarget(renderTarget.width, renderTarget.height);
                const { _lodMax } = this;
                ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes(_lodMax));
                this._blurMaterial = _getBlurShader(_lodMax, renderTarget.width, renderTarget.height);
            }
        }
        async _compileMaterial(material) {
            const tmpMesh = new Mesh(this._lodPlanes[0], material);
            await this._renderer.compile(tmpMesh, _flatCamera);
        }
        _sceneToCubeUV(scene, near, far, cubeUVRenderTarget, position) {
            const cubeCamera = _cubeCamera;
            cubeCamera.near = near;
            cubeCamera.far = far;
            // px, py, pz, nx, ny, nz
            const upSign = [1, 1, 1, 1, -1, 1];
            const forwardSign = [1, -1, 1, -1, 1, -1];
            const renderer = this._renderer;
            const originalAutoClear = renderer.autoClear;
            renderer.getClearColor(_clearColor$2);
            renderer.autoClear = false;
            let backgroundBox = this._backgroundBox;
            if (backgroundBox === null) {
                const backgroundMaterial = new MeshBasicMaterial({
                    name: 'PMREM.Background',
                    side: BackSide,
                    depthWrite: false,
                    depthTest: false
                });
                backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
            }
            let useSolidColor = false;
            const background = scene.background;
            if (background) {
                if (background.isColor) {
                    backgroundBox.material.color.copy(background);
                    scene.background = null;
                    useSolidColor = true;
                }
            } else {
                backgroundBox.material.color.copy(_clearColor$2);
                useSolidColor = true;
            }
            renderer.setRenderTarget(cubeUVRenderTarget);
            renderer.clear();
            if (useSolidColor) {
                renderer.render(backgroundBox, cubeCamera);
            }
            for (let i = 0; i < 6; i++) {
                const col = i % 3;
                if (col === 0) {
                    cubeCamera.up.set(0, upSign[i], 0);
                    cubeCamera.position.set(position.x, position.y, position.z);
                    cubeCamera.lookAt(position.x + forwardSign[i], position.y, position.z);
                } else if (col === 1) {
                    cubeCamera.up.set(0, 0, upSign[i]);
                    cubeCamera.position.set(position.x, position.y, position.z);
                    cubeCamera.lookAt(position.x, position.y + forwardSign[i], position.z);

                } else {
                    cubeCamera.up.set(0, upSign[i], 0);
                    cubeCamera.position.set(position.x, position.y, position.z);
                    cubeCamera.lookAt(position.x, position.y, position.z + forwardSign[i]);

                }
                const size = this._cubeSize;
                _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
                renderer.render(scene, cubeCamera);
            }
            renderer.autoClear = originalAutoClear;
            scene.background = background;
        }
        _textureToCubeUV(texture, cubeUVRenderTarget) {
            const renderer = this._renderer;
            const isCubeTexture = (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping);
            if (isCubeTexture) {
                if (this._cubemapMaterial === null) {
                    this._cubemapMaterial = _getCubemapMaterial(texture);
                }
            } else {
                if (this._equirectMaterial === null) {
                    this._equirectMaterial = _getEquirectMaterial(texture);
                }
            }
            const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
            material.fragmentNode.value = texture;
            const mesh = this._lodMeshes[0];
            mesh.material = material;
            const size = this._cubeSize;
            _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
            renderer.setRenderTarget(cubeUVRenderTarget);
            renderer.render(mesh, _flatCamera);
        }
        _applyPMREM(cubeUVRenderTarget) {
            const renderer = this._renderer;
            const autoClear = renderer.autoClear;
            renderer.autoClear = false;
            const n = this._lodPlanes.length;
            for (let i = 1; i < n; i++) {
                const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
                const poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];
                this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
            }
            renderer.autoClear = autoClear;
        }
        _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
            const pingPongRenderTarget = this._pingPongRenderTarget;
            this._halfBlur(
                cubeUVRenderTarget,
                pingPongRenderTarget,
                lodIn,
                lodOut,
                sigma,
                'latitudinal',
                poleAxis);
            this._halfBlur(
                pingPongRenderTarget,
                cubeUVRenderTarget,
                lodOut,
                lodOut,
                sigma,
                'longitudinal',
                poleAxis);
        }
        _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
            const renderer = this._renderer;
            const blurMaterial = this._blurMaterial;
            if (direction !== 'latitudinal' && direction !== 'longitudinal') {
                console.error('blur direction must be either latitudinal or longitudinal!');
            }
            // Number of standard deviations at which to cut off the discrete approximation.
            const STANDARD_DEVIATIONS = 3;
            const blurMesh = this._lodMeshes[lodOut];
            blurMesh.material = blurMaterial;
            const blurUniforms = _uniformsMap.get(blurMaterial);
            const pixels = this._sizeLods[lodIn] - 1;
            const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
            const sigmaPixels = sigmaRadians / radiansPerPixel;
            const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
            if (samples > MAX_SAMPLES) {
                console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
            }
            const weights = [];
            let sum = 0;
            for (let i = 0; i < MAX_SAMPLES; ++i) {
                const x = i / sigmaPixels;
                const weight = Math.exp(- x * x / 2);
                weights.push(weight);
                if (i === 0) {
                    sum += weight;
                } else if (i < samples) {
                    sum += 2 * weight;
                }
            }
            for (let i = 0; i < weights.length; i++) {
                weights[i] = weights[i] / sum;
            }
            targetIn.texture.frame = (targetIn.texture.frame || 0) + 1;
            blurUniforms.envMap.value = targetIn.texture;
            blurUniforms.samples.value = samples;
            blurUniforms.weights.array = weights;
            blurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;
            if (poleAxis) {
                blurUniforms.poleAxis.value = poleAxis;
            }
            const { _lodMax } = this;
            blurUniforms.dTheta.value = radiansPerPixel;
            blurUniforms.mipInt.value = _lodMax - lodIn;
            const outputSize = this._sizeLods[lodOut];
            const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
            const y = 4 * (this._cubeSize - outputSize);
            _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
            renderer.setRenderTarget(targetOut);
            renderer.render(blurMesh, _flatCamera);
        }
    }
    function _createPlanes(lodMax) {
        const lodPlanes = [];
        const sizeLods = [];
        const sigmas = [];
        const lodMeshes = [];
        let lod = lodMax;
        const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
        for (let i = 0; i < totalLods; i++) {
            const sizeLod = Math.pow(2, lod);
            sizeLods.push(sizeLod);
            let sigma = 1.0 / sizeLod;
            if (i > lodMax - LOD_MIN) {
                sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
            } else if (i === 0) {
                sigma = 0;
            }
            sigmas.push(sigma);
            const texelSize = 1.0 / (sizeLod - 2);
            const min = - texelSize;
            const max = 1 + texelSize;
            const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
            const cubeFaces = 6;
            const vertices = 6;
            const positionSize = 3;
            const uvSize = 2;
            const faceIndexSize = 1;
            const position = new Float32Array(positionSize * vertices * cubeFaces);
            const uv = new Float32Array(uvSize * vertices * cubeFaces);
            const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
            for (let face = 0; face < cubeFaces; face++) {
                const x = (face % 3) * 2 / 3 - 1;
                const y = face > 2 ? 0 : -1;
                const coordinates = [
                    x, y, 0,
                    x + 2 / 3, y, 0,
                    x + 2 / 3, y + 1, 0,
                    x, y, 0,
                    x + 2 / 3, y + 1, 0,
                    x, y + 1, 0
                ];
                const faceIdx = _faceLib[face];
                position.set(coordinates, positionSize * vertices * faceIdx);
                uv.set(uv1, uvSize * vertices * faceIdx);
                const fill = [faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx];
                faceIndex.set(fill, faceIndexSize * vertices * faceIdx);
            }
            const planes = new BufferGeometry();
            planes.setAttribute('position', new BufferAttribute(position, positionSize));
            planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
            planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
            lodPlanes.push(planes);
            lodMeshes.push(new Mesh(planes, null));
            if (lod > LOD_MIN) {
                lod--;
            }
        }
        return { lodPlanes, sizeLods, sigmas, lodMeshes };
    }
    function _createRenderTarget(width, height) {
        const params = {
            magFilter: LinearFilter,
            minFilter: LinearFilter,
            generateMipmaps: false,
            type: HalfFloatType,
            format: RGBAFormat,
            colorSpace: LinearSRGBColorSpace,
            //depthBuffer: false
        };
        const cubeUVRenderTarget = new RenderTarget(width, height, params);
        cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
        cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
        cubeUVRenderTarget.texture.isPMREMTexture = true;
        cubeUVRenderTarget.scissorTest = true;
        return cubeUVRenderTarget;
    }
    function _setViewport(target, x, y, width, height) {
        target.viewport.set(x, y, width, height);
        target.scissor.set(x, y, width, height);
    }
    function _getMaterial(type) {
        const material = new NodeMaterial();
        material.depthTest = false;
        material.depthWrite = false;
        material.blending = NoBlending;
        material.name = `PMREM_${type}`;
        return material;
    }
    function _getBlurShader(lodMax, width, height) {
        const weights = uniformArray(new Array(MAX_SAMPLES).fill(0));
        const poleAxis = uniform(new Vector3(0, 1, 0));
        const dTheta = uniform(0);
        const n = float(MAX_SAMPLES);
        const latitudinal = uniform(0); // false, bool
        const samples = uniform(1); // int
        const envMap = texture(null);
        const mipInt = uniform(0); // int
        const CUBEUV_TEXEL_WIDTH = float(1 / width);
        const CUBEUV_TEXEL_HEIGHT = float(1 / height);
        const CUBEUV_MAX_MIP = float(lodMax);
        const materialUniforms = {
            n,
            latitudinal,
            weights,
            poleAxis,
            outputDirection: _outputDirection,
            dTheta,
            samples,
            envMap,
            mipInt,
            CUBEUV_TEXEL_WIDTH,
            CUBEUV_TEXEL_HEIGHT,
            CUBEUV_MAX_MIP
        };
        const material = _getMaterial('blur');
        material.fragmentNode = blur({ ...materialUniforms, latitudinal: latitudinal.equal(1) });
        _uniformsMap.set(material, materialUniforms);
        return material;
    }
    function _getCubemapMaterial(envTexture) {
        const material = _getMaterial('cubemap');
        material.fragmentNode = cubeTexture(envTexture, _outputDirection);
        return material;
    }
    function _getEquirectMaterial(envTexture) {
        const material = _getMaterial('equirect');
        material.fragmentNode = texture(envTexture, equirectUV(_outputDirection), 0);
        return material;
    }
    const _cache$2 = new WeakMap();
    function _generateCubeUVSize(imageHeight) {
        const maxMip = Math.log2(imageHeight) - 2;
        const texelHeight = 1.0 / imageHeight;
        const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
        return { texelWidth, texelHeight, maxMip };
    }
    function _getPMREMFromTexture(texture, renderer, generator) {
        const cache = _getCache(renderer);
        let cacheTexture = cache.get(texture);
        const pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : -1;
        if (pmremVersion !== texture.pmremVersion) {
            const image = texture.image;
            if (texture.isCubeTexture) {
                if (isCubeMapReady(image)) {
                    cacheTexture = generator.fromCubemap(texture, cacheTexture);
                } else {
                    return null;
                }

            } else {
                if (isEquirectangularMapReady(image)) {
                    cacheTexture = generator.fromEquirectangular(texture, cacheTexture);
                } else {
                    return null;
                }
            }
            cacheTexture.pmremVersion = texture.pmremVersion;
            cache.set(texture, cacheTexture);
        }
        return cacheTexture.texture;
    }
    function _getCache(renderer) {
        let rendererCache = _cache$2.get(renderer);
        if (rendererCache === undefined) {
            rendererCache = new WeakMap();
            _cache$2.set(renderer, rendererCache);
        }
        return rendererCache;
    }
    class PMREMNode extends TempNode {
        static get type() {
            return 'PMREMNode';
        }
        constructor(value, uvNode = null, levelNode = null) {
            super('vec3');
            this._value = value;
            this._pmrem = null;
            this.uvNode = uvNode;
            this.levelNode = levelNode;
            this._generator = null;
            const defaultTexture = new Texture();
            defaultTexture.isRenderTargetTexture = true;
            this._texture = texture(defaultTexture);
            this._width = uniform(0);
            this._height = uniform(0);
            this._maxMip = uniform(0);
            this.updateBeforeType = NodeUpdateType.RENDER;
        }
        set value(value) {
            this._value = value;
            this._pmrem = null;
        }
        get value() {
            return this._value;
        }
        updateFromTexture(texture) {
            const cubeUVSize = _generateCubeUVSize(texture.image.height);
            this._texture.value = texture;
            this._width.value = cubeUVSize.texelWidth;
            this._height.value = cubeUVSize.texelHeight;
            this._maxMip.value = cubeUVSize.maxMip;
        }
        updateBefore(frame) {
            let pmrem = this._pmrem;
            const pmremVersion = pmrem ? pmrem.pmremVersion : -1;
            const texture = this._value;
            if (pmremVersion !== texture.pmremVersion) {
                if (texture.isPMREMTexture === true) {
                    pmrem = texture;
                } else {
                    pmrem = _getPMREMFromTexture(texture, frame.renderer, this._generator);
                }
                if (pmrem !== null) {
                    this._pmrem = pmrem;
                    this.updateFromTexture(pmrem);
                }
            }
        }
        setup(builder) {
            if (this._generator === null) {
                this._generator = new PMREMGenerator(builder.renderer);
            }
            this.updateBefore(builder);
            //
            let uvNode = this.uvNode;
            if (uvNode === null && builder.context.getUV) {
                uvNode = builder.context.getUV(this);
            }
            //
            uvNode = materialEnvRotation.mul(vec3(uvNode.x, uvNode.y.negate(), uvNode.z));
            //
            let levelNode = this.levelNode;
            if (levelNode === null && builder.context.getTextureLevel) {
                levelNode = builder.context.getTextureLevel(this);
            }
            //
            return textureCubeUV(this._texture, uvNode, levelNode, this._width, this._height, this._maxMip);
        }
        dispose() {
            super.dispose();
            if (this._generator !== null) this._generator.dispose();
        }
    }
    function isCubeMapReady(image) {
        if (image === null || image === undefined) return false;
        let count = 0;
        const length = 6;
        for (let i = 0; i < length; i++) {
            if (image[i] !== undefined) count++;
        }
        return count === length;

    }
    function isEquirectangularMapReady(image) {
        if (image === null || image === undefined) return false;
        return image.height > 0;
    }
    const pmremTexture = /*@__PURE__*/ nodeProxy(PMREMNode).setParameterLength(1, 3);
    const _envNodeCache = new WeakMap();
    class EnvironmentNode extends LightingNode {
        static get type() {
            return 'EnvironmentNode';
        }
        constructor(envNode = null) {
            super();
            this.envNode = envNode;
        }
        setup(builder) {
            const { material } = builder;
            let envNode = this.envNode;
            if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {
                const value = (envNode.isTextureNode) ? envNode.value : material[envNode.property];
                let cacheEnvNode = _envNodeCache.get(value);
                if (cacheEnvNode === undefined) {
                    cacheEnvNode = pmremTexture(value);
                    _envNodeCache.set(value, cacheEnvNode);
                }
                envNode = cacheEnvNode;
            }
            //
            const useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;
            const radianceNormalView = useAnisotropy ? bentNormalView : normalView;
            const radiance = envNode.context(createRadianceContext(roughness, radianceNormalView)).mul(materialEnvIntensity);
            const irradiance = envNode.context(createIrradianceContext(normalWorld)).mul(Math.PI).mul(materialEnvIntensity);
            const isolateRadiance = cache(radiance);
            const isolateIrradiance = cache(irradiance);
            //
            builder.context.radiance.addAssign(isolateRadiance);
            builder.context.iblIrradiance.addAssign(isolateIrradiance);
            //
            const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;
            if (clearcoatRadiance) {
                const clearcoatRadianceContext = envNode.context(createRadianceContext(clearcoatRoughness, clearcoatNormalView)).mul(materialEnvIntensity);
                const isolateClearcoatRadiance = cache(clearcoatRadianceContext);
                clearcoatRadiance.addAssign(isolateClearcoatRadiance);
            }
        }
    }
    const createRadianceContext = (roughnessNode, normalViewNode) => {
        let reflectVec = null;
        return {
            getUV: () => {
                if (reflectVec === null) {
                    reflectVec = positionViewDirection.negate().reflect(normalViewNode);
                    // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
                    reflectVec = roughnessNode.mul(roughnessNode).mix(reflectVec, normalViewNode).normalize();
                    reflectVec = reflectVec.transformDirection(cameraViewMatrix);
                }
                return reflectVec;
            },
            getTextureLevel: () => {
                return roughnessNode;
            }
        };
    };
    const createIrradianceContext = (normalWorldNode) => {
        return {
            getUV: () => {
                return normalWorldNode;
            },
            getTextureLevel: () => {
                return float(1.0);
            }
        };
    };
    const _defaultValues$6 = /*@__PURE__*/ new MeshStandardMaterial();
    class MeshStandardNodeMaterial extends NodeMaterial {
        static get type() {
            return 'MeshStandardNodeMaterial';
        }
        constructor(parameters) {
            super();
            this.isMeshStandardNodeMaterial = true;
            this.lights = true;
            this.emissiveNode = null;
            this.metalnessNode = null;
            this.roughnessNode = null;
            this.setDefaultValues(_defaultValues$6);
            this.setValues(parameters);
        }
        setupEnvironment(builder) {
            let envNode = super.setupEnvironment(builder);
            if (envNode === null && builder.environmentNode) {
                envNode = builder.environmentNode;
            }
            return envNode ? new EnvironmentNode(envNode) : null;
        }
        setupLightingModel( /*builder*/) {
            return new PhysicalLightingModel();
        }
        setupSpecular() {
            const specularColorNode = mix(vec3(0.04), diffuseColor.rgb, metalness);
            specularColor.assign(specularColorNode);
            specularF90.assign(1.0);
        }
        setupVariants() {
            // METALNESS
            const metalnessNode = this.metalnessNode ? float(this.metalnessNode) : materialMetalness;
            metalness.assign(metalnessNode);
            // ROUGHNESS
            let roughnessNode = this.roughnessNode ? float(this.roughnessNode) : materialRoughness;
            roughnessNode = getRoughness({ roughness: roughnessNode });
            roughness.assign(roughnessNode);
            // SPECULAR COLOR
            this.setupSpecular();
            // DIFFUSE COLOR
            diffuseColor.assign(vec4(diffuseColor.rgb.mul(metalnessNode.oneMinus()), diffuseColor.a));
        }
        copy(source) {
            this.emissiveNode = source.emissiveNode;
            this.metalnessNode = source.metalnessNode;
            this.roughnessNode = source.roughnessNode;
            return super.copy(source);
        }
    }
    const _defaultValues$5 = /*@__PURE__*/ new MeshPhysicalMaterial();
    class MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {
        static get type() {
            return 'MeshPhysicalNodeMaterial';
        }
        constructor(parameters) {
            super();
            this.isMeshPhysicalNodeMaterial = true;
            this.clearcoatNode = null;
            this.clearcoatRoughnessNode = null;
            this.clearcoatNormalNode = null;
            this.sheenNode = null;
            this.sheenRoughnessNode = null;
            this.iridescenceNode = null;
            this.iridescenceIORNode = null;
            this.iridescenceThicknessNode = null;
            this.specularIntensityNode = null;
            this.specularColorNode = null;
            this.iorNode = null;
            this.transmissionNode = null;
            this.thicknessNode = null;
            this.attenuationDistanceNode = null;
            this.attenuationColorNode = null;
            this.dispersionNode = null;
            this.anisotropyNode = null;
            this.setDefaultValues(_defaultValues$5);
            this.setValues(parameters);
        }
        get useClearcoat() {
            return this.clearcoat > 0 || this.clearcoatNode !== null;
        }
        get useIridescence() {
            return this.iridescence > 0 || this.iridescenceNode !== null;
        }
        get useSheen() {
            return this.sheen > 0 || this.sheenNode !== null;
        }
        get useAnisotropy() {
            return this.anisotropy > 0 || this.anisotropyNode !== null;
        }
        get useTransmission() {
            return this.transmission > 0 || this.transmissionNode !== null;
        }
        get useDispersion() {
            return this.dispersion > 0 || this.dispersionNode !== null;
        }
        setupSpecular() {
            const iorNode = this.iorNode ? float(this.iorNode) : materialIOR;
            ior.assign(iorNode);
            specularColor.assign(mix(min$1(pow2(ior.sub(1.0).div(ior.add(1.0))).mul(materialSpecularColor), vec3(1.0)).mul(materialSpecularIntensity), diffuseColor.rgb, metalness));
            specularF90.assign(mix(materialSpecularIntensity, 1.0, metalness));
        }
        setupLightingModel( /*builder*/) {
            return new PhysicalLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);
        }
        setupVariants(builder) {
            super.setupVariants(builder);
            // CLEARCOAT
            if (this.useClearcoat) {
                const clearcoatNode = this.clearcoatNode ? float(this.clearcoatNode) : materialClearcoat;
                const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float(this.clearcoatRoughnessNode) : materialClearcoatRoughness;
                clearcoat.assign(clearcoatNode);
                clearcoatRoughness.assign(getRoughness({ roughness: clearcoatRoughnessNode }));
            }
            // SHEEN
            if (this.useSheen) {
                const sheenNode = this.sheenNode ? vec3(this.sheenNode) : materialSheen;
                const sheenRoughnessNode = this.sheenRoughnessNode ? float(this.sheenRoughnessNode) : materialSheenRoughness;
                sheen.assign(sheenNode);
                sheenRoughness.assign(sheenRoughnessNode);
            }
            // IRIDESCENCE
            if (this.useIridescence) {
                const iridescenceNode = this.iridescenceNode ? float(this.iridescenceNode) : materialIridescence;
                const iridescenceIORNode = this.iridescenceIORNode ? float(this.iridescenceIORNode) : materialIridescenceIOR;
                const iridescenceThicknessNode = this.iridescenceThicknessNode ? float(this.iridescenceThicknessNode) : materialIridescenceThickness;
                iridescence.assign(iridescenceNode);
                iridescenceIOR.assign(iridescenceIORNode);
                iridescenceThickness.assign(iridescenceThicknessNode);
            }
            // ANISOTROPY
            if (this.useAnisotropy) {
                const anisotropyV = (this.anisotropyNode ? vec2(this.anisotropyNode) : materialAnisotropy).toVar();
                anisotropy.assign(anisotropyV.length());
                If(anisotropy.equal(0.0), () => {
                    anisotropyV.assign(vec2(1.0, 0.0));
                }).Else(() => {
                    anisotropyV.divAssign(vec2(anisotropy));
                    anisotropy.assign(anisotropy.saturate());
                });
                // Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.
                alphaT.assign(anisotropy.pow2().mix(roughness.pow2(), 1.0));
                anisotropyT.assign(TBNViewMatrix[0].mul(anisotropyV.x).add(TBNViewMatrix[1].mul(anisotropyV.y)));
                anisotropyB.assign(TBNViewMatrix[1].mul(anisotropyV.x).sub(TBNViewMatrix[0].mul(anisotropyV.y)));
            }
            // TRANSMISSION
            if (this.useTransmission) {
                const transmissionNode = this.transmissionNode ? float(this.transmissionNode) : materialTransmission;
                const thicknessNode = this.thicknessNode ? float(this.thicknessNode) : materialThickness;
                const attenuationDistanceNode = this.attenuationDistanceNode ? float(this.attenuationDistanceNode) : materialAttenuationDistance;
                const attenuationColorNode = this.attenuationColorNode ? vec3(this.attenuationColorNode) : materialAttenuationColor;
                transmission.assign(transmissionNode);
                thickness.assign(thicknessNode);
                attenuationDistance.assign(attenuationDistanceNode);
                attenuationColor.assign(attenuationColorNode);
                if (this.useDispersion) {
                    const dispersionNode = this.dispersionNode ? float(this.dispersionNode) : materialDispersion;
                    dispersion.assign(dispersionNode);
                }
            }
        }
        setupClearcoatNormal() {
            return this.clearcoatNormalNode ? vec3(this.clearcoatNormalNode) : materialClearcoatNormal;
        }
        setup(builder) {
            builder.context.setupClearcoatNormal = () => subBuild(this.setupClearcoatNormal(builder), 'NORMAL', 'vec3');
            super.setup(builder);
        }
        copy(source) {
            this.clearcoatNode = source.clearcoatNode;
            this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
            this.clearcoatNormalNode = source.clearcoatNormalNode;
            this.sheenNode = source.sheenNode;
            this.sheenRoughnessNode = source.sheenRoughnessNode;
            this.iridescenceNode = source.iridescenceNode;
            this.iridescenceIORNode = source.iridescenceIORNode;
            this.iridescenceThicknessNode = source.iridescenceThicknessNode;
            this.specularIntensityNode = source.specularIntensityNode;
            this.specularColorNode = source.specularColorNode;
            this.transmissionNode = source.transmissionNode;
            this.thicknessNode = source.thicknessNode;
            this.attenuationDistanceNode = source.attenuationDistanceNode;
            this.attenuationColorNode = source.attenuationColorNode;
            this.dispersionNode = source.dispersionNode;
            this.anisotropyNode = source.anisotropyNode;
            return super.copy(source);
        }
    }
    class SSSLightingModel extends PhysicalLightingModel {
        constructor(clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false, sss = false) {
            super(clearcoat, sheen, iridescence, anisotropy, transmission, dispersion);
            this.useSSS = sss;
        }
        direct({ lightDirection, lightColor, reflectedLight }, builder) {
            if (this.useSSS === true) {
                const material = builder.material;
                const { thicknessColorNode, thicknessDistortionNode, thicknessAmbientNode, thicknessAttenuationNode, thicknessPowerNode, thicknessScaleNode } = material;
                const scatteringHalf = lightDirection.add(normalView.mul(thicknessDistortionNode)).normalize();
                const scatteringDot = float(positionViewDirection.dot(scatteringHalf.negate()).saturate().pow(thicknessPowerNode).mul(thicknessScaleNode));
                const scatteringIllu = vec3(scatteringDot.add(thicknessAmbientNode).mul(thicknessColorNode));
                reflectedLight.directDiffuse.addAssign(scatteringIllu.mul(thicknessAttenuationNode.mul(lightColor)));
            }
            super.direct({ lightDirection, lightColor, reflectedLight }, builder);
        }
    }
    class MeshSSSNodeMaterial extends MeshPhysicalNodeMaterial {
        static get type() {
            return 'MeshSSSNodeMaterial';
        }
        constructor(parameters) {
            super(parameters);
            this.thicknessColorNode = null;
            this.thicknessDistortionNode = float(0.1);
            this.thicknessAmbientNode = float(0.0);
            this.thicknessAttenuationNode = float(.1);
            this.thicknessPowerNode = float(2.0);
            this.thicknessScaleNode = float(10.0);
        }
        get useSSS() {
            return this.thicknessColorNode !== null;
        }
        setupLightingModel( /*builder*/) {
            return new SSSLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion, this.useSSS);
        }
        copy(source) {
            this.thicknessColorNode = source.thicknessColorNode;
            this.thicknessDistortionNode = source.thicknessDistortionNode;
            this.thicknessAmbientNode = source.thicknessAmbientNode;
            this.thicknessAttenuationNode = source.thicknessAttenuationNode;
            this.thicknessPowerNode = source.thicknessPowerNode;
            this.thicknessScaleNode = source.thicknessScaleNode;
            return super.copy(source);
        }
    }
    const getGradientIrradiance = /*@__PURE__*/ Fn(({ normal, lightDirection, builder }) => {
        // dotNL will be from -1.0 to 1.0
        const dotNL = normal.dot(lightDirection);
        const coord = vec2(dotNL.mul(0.5).add(0.5), 0.0);
        if (builder.material.gradientMap) {
            const gradientMap = materialReference('gradientMap', 'texture').context({ getUV: () => coord });
            return vec3(gradientMap.r);
        } else {
            const fw = coord.fwidth().mul(0.5);
            return mix(vec3(0.7), vec3(1.0), smoothstep(float(0.7).sub(fw.x), float(0.7).add(fw.x), coord.x));
        }
    });
    class ToonLightingModel extends LightingModel {
        direct({ lightDirection, lightColor, reflectedLight }, builder) {
            const irradiance = getGradientIrradiance({ normal: normalGeometry, lightDirection, builder }).mul(lightColor);
            reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor: diffuseColor.rgb })));
        }
        indirect(builder) {
            const { ambientOcclusion, irradiance, reflectedLight } = builder.context;
            reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor })));
            reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
        }
    }
    const _defaultValues$4 = /*@__PURE__*/ new MeshToonMaterial();
    class MeshToonNodeMaterial extends NodeMaterial {
        static get type() {
            return 'MeshToonNodeMaterial';
        }
        constructor(parameters) {
            super();
            this.isMeshToonNodeMaterial = true;
            this.lights = true;
            this.setDefaultValues(_defaultValues$4);
            this.setValues(parameters);
        }
        setupLightingModel( /*builder*/) {
            return new ToonLightingModel();
        }
    }
    const matcapUV = /*@__PURE__*/ Fn(() => {
        const x = vec3(positionViewDirection.z, 0, positionViewDirection.x.negate()).normalize();
        const y = positionViewDirection.cross(x);
        return vec2(x.dot(normalView), y.dot(normalView)).mul(0.495).add(0.5); // 0.495 to remove artifacts caused by undersized matcap disks
    }).once(['NORMAL', 'VERTEX'])().toVar('matcapUV');
    const _defaultValues$3 = /*@__PURE__*/ new MeshMatcapMaterial();
    class MeshMatcapNodeMaterial extends NodeMaterial {
        static get type() {
            return 'MeshMatcapNodeMaterial';
        }
        constructor(parameters) {
            super();
            this.isMeshMatcapNodeMaterial = true;
            this.setDefaultValues(_defaultValues$3);
            this.setValues(parameters);
        }
        setupVariants(builder) {
            const uv = matcapUV;
            let matcapColor;
            if (builder.material.matcap) {
                matcapColor = materialReference('matcap', 'texture').context({ getUV: () => uv });
            } else {
                matcapColor = vec3(mix(0.2, 0.8, uv.y)); // default if matcap is missing
            }
            diffuseColor.rgb.mulAssign(matcapColor.rgb);
        }
    }
    class RotateNode extends TempNode {
        static get type() {
            return 'RotateNode';
        }
        constructor(positionNode, rotationNode) {
            super();
            this.positionNode = positionNode;
            this.rotationNode = rotationNode;
        }
        getNodeType(builder) {
            return this.positionNode.getNodeType(builder);
        }
        setup(builder) {
            const { rotationNode, positionNode } = this;
            const nodeType = this.getNodeType(builder);
            if (nodeType === 'vec2') {
                const cosAngle = rotationNode.cos();
                const sinAngle = rotationNode.sin();
                const rotationMatrix = mat2(
                    cosAngle, sinAngle,
                    sinAngle.negate(), cosAngle
                );
                return rotationMatrix.mul(positionNode);
            } else {
                const rotation = rotationNode;
                const rotationXMatrix = mat4(vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, cos(rotation.x), sin(rotation.x).negate(), 0.0), vec4(0.0, sin(rotation.x), cos(rotation.x), 0.0), vec4(0.0, 0.0, 0.0, 1.0));
                const rotationYMatrix = mat4(vec4(cos(rotation.y), 0.0, sin(rotation.y), 0.0), vec4(0.0, 1.0, 0.0, 0.0), vec4(sin(rotation.y).negate(), 0.0, cos(rotation.y), 0.0), vec4(0.0, 0.0, 0.0, 1.0));
                const rotationZMatrix = mat4(vec4(cos(rotation.z), sin(rotation.z).negate(), 0.0, 0.0), vec4(sin(rotation.z), cos(rotation.z), 0.0, 0.0), vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0));
                return rotationXMatrix.mul(rotationYMatrix).mul(rotationZMatrix).mul(vec4(positionNode, 1.0)).xyz;
            }
        }
    }
    const rotate = /*@__PURE__*/ nodeProxy(RotateNode).setParameterLength(2);
    const _defaultValues$2 = /*@__PURE__*/ new SpriteMaterial();
    class SpriteNodeMaterial extends NodeMaterial {
        static get type() {
            return 'SpriteNodeMaterial';
        }
        constructor(parameters) {
            super();
            this.isSpriteNodeMaterial = true;
            this._useSizeAttenuation = true;
            this.positionNode = null;
            this.rotationNode = null;
            this.scaleNode = null;
            this.transparent = true;
            this.setDefaultValues(_defaultValues$2);
            this.setValues(parameters);
        }
        setupPositionView(builder) {
            const { object, camera } = builder;
            const sizeAttenuation = this.sizeAttenuation;
            const { positionNode, rotationNode, scaleNode } = this;
            const mvPosition = modelViewMatrix.mul(vec3(positionNode || 0));
            let scale = vec2(modelWorldMatrix[0].xyz.length(), modelWorldMatrix[1].xyz.length());
            if (scaleNode !== null) {
                scale = scale.mul(vec2(scaleNode));
            }
            if (sizeAttenuation === false) {
                if (camera.isPerspectiveCamera) {
                    scale = scale.mul(mvPosition.z.negate());
                } else {
                    const orthoScale = float(2.0).div(cameraProjectionMatrix.element(1).element(1));
                    scale = scale.mul(orthoScale.mul(2));
                }
            }
            let alignedPosition = positionGeometry.xy;
            if (object.center && object.center.isVector2 === true) {
                const center = reference$1('center', 'vec2', object);
                alignedPosition = alignedPosition.sub(center.sub(0.5));
            }
            alignedPosition = alignedPosition.mul(scale);
            const rotation = float(rotationNode || materialRotation);
            const rotatedPosition = rotate(alignedPosition, rotation);
            return vec4(mvPosition.xy.add(rotatedPosition), mvPosition.zw);
        }
        copy(source) {
            this.positionNode = source.positionNode;
            this.rotationNode = source.rotationNode;
            this.scaleNode = source.scaleNode;
            return super.copy(source);
        }
        get sizeAttenuation() {
            return this._useSizeAttenuation;
        }
        set sizeAttenuation(value) {
            if (this._useSizeAttenuation !== value) {
                this._useSizeAttenuation = value;
                this.needsUpdate = true;
            }
        }
    }
    const _defaultValues$1 = /*@__PURE__*/ new PointsMaterial();
    class PointsNodeMaterial extends SpriteNodeMaterial {
        static get type() {
            return 'PointsNodeMaterial';
        }
        constructor(parameters) {
            super();
            this.sizeNode = null;
            this.isPointsNodeMaterial = true;
            this.setDefaultValues(_defaultValues$1);
            this.setValues(parameters);
        }
        setupPositionView() {
            const { positionNode } = this;
            return modelViewMatrix.mul(vec3(positionNode || positionLocal)).xyz;
        }
        setupVertex(builder) {
            const mvp = super.setupVertex(builder);
            // skip further processing if the material is not a node material
            if (builder.material.isNodeMaterial !== true) {
                return mvp;
            }
            // ndc space
            const { rotationNode, scaleNode, sizeNode } = this;
            const alignedPosition = positionGeometry.xy.toVar();
            const aspect = viewport.z.div(viewport.w);
            // rotation
            if (rotationNode && rotationNode.isNode) {
                const rotation = float(rotationNode);
                alignedPosition.assign(rotate(alignedPosition, rotation));
            }
            // point size
            let pointSize = sizeNode !== null ? vec2(sizeNode) : materialPointSize;
            if (this.sizeAttenuation === true) {
                pointSize = pointSize.mul(pointSize.div(positionView.z.negate()));
            }
            // scale
            if (scaleNode && scaleNode.isNode) {
                pointSize = pointSize.mul(vec2(scaleNode));
            }
            alignedPosition.mulAssign(pointSize.mul(2));
            alignedPosition.assign(alignedPosition.div(viewport.z));
            alignedPosition.y.assign(alignedPosition.y.mul(aspect));
            // back to clip space
            alignedPosition.assign(alignedPosition.mul(mvp.w));
            //clipPos.xy += offset;
            mvp.addAssign(vec4(alignedPosition, 0, 0));
            return mvp;
        }
        get alphaToCoverage() {
            return this._useAlphaToCoverage;
        }
        set alphaToCoverage(value) {
            if (this._useAlphaToCoverage !== value) {
                this._useAlphaToCoverage = value;
                this.needsUpdate = true;
            }
        }
    }
    class ShadowMaskModel extends LightingModel {
        constructor() {
            super();
            this.shadowNode = float(1).toVar('shadowMask');
        }
        direct({ lightNode }) {
            if (lightNode.shadowNode !== null) {
                this.shadowNode.mulAssign(lightNode.shadowNode);
            }
        }
        finish({ context }) {
            diffuseColor.a.mulAssign(this.shadowNode.oneMinus());
            context.outgoingLight.rgb.assign(diffuseColor.rgb); // TODO: Optimize LightsNode to avoid this assignment
        }
    }
    const _defaultValues = /*@__PURE__*/ new ShadowMaterial();
    class ShadowNodeMaterial extends NodeMaterial {
        static get type() {
            return 'ShadowNodeMaterial';
        }
        constructor(parameters) {
            super();
            this.isShadowNodeMaterial = true;
            this.lights = true;
            this.transparent = true;
            this.setDefaultValues(_defaultValues);
            this.setValues(parameters);
        }
        setupLightingModel( /*builder*/) {
            return new ShadowMaskModel();
        }
    }
    const scatteringDensity = property('vec3');
    const linearDepthRay = property('vec3');
    const outgoingRayLight = property('vec3');
    class VolumetricLightingModel extends LightingModel {
        constructor() {
            super();
        }
        start(builder) {
            const { material, context } = builder;
            const startPos = property('vec3');
            const endPos = property('vec3');
            // This approach dynamically changes the direction of the ray,
            // prioritizing the ray from the camera to the object if it is inside the mesh, and from the object to the camera if it is far away.
            If(cameraPosition.sub(positionWorld).length().greaterThan(modelRadius.mul(2)), () => {
                startPos.assign(cameraPosition);
                endPos.assign(positionWorld);
            }).Else(() => {
                startPos.assign(positionWorld);
                endPos.assign(cameraPosition);
            });
            //
            const viewVector = endPos.sub(startPos);
            const steps = uniform('int').onRenderUpdate(({ material }) => material.steps);
            const stepSize = viewVector.length().div(steps).toVar();
            const rayDir = viewVector.normalize().toVar(); // TODO: toVar() should be automatic here ( in loop )
            const distTravelled = float(0.0).toVar();
            const transmittance = vec3(1).toVar();
            if (material.offsetNode) {
                // reduce banding
                distTravelled.addAssign(material.offsetNode.mul(stepSize));
            }
            Loop(steps, () => {
                const positionRay = startPos.add(rayDir.mul(distTravelled));
                const positionViewRay = cameraViewMatrix.mul(vec4(positionRay, 1)).xyz;
                if (material.depthNode !== null) {
                    linearDepthRay.assign(linearDepth(viewZToPerspectiveDepth(positionViewRay.z, cameraNear, cameraFar)));
                    context.sceneDepthNode = linearDepth(material.depthNode).toVar();
                }
                context.positionWorld = positionRay;
                context.shadowPositionWorld = positionRay;
                context.positionView = positionViewRay;
                scatteringDensity.assign(0);
                let scatteringNode;
                if (material.scatteringNode) {
                    scatteringNode = material.scatteringNode({
                        positionRay
                    });
                }
                super.start(builder);
                if (scatteringNode) {
                    scatteringDensity.mulAssign(scatteringNode);
                }
                // beer's law
                const falloff = scatteringDensity.mul(.01).negate().mul(stepSize).exp();
                transmittance.mulAssign(falloff);
                // move along the ray
                distTravelled.addAssign(stepSize);
            });
            outgoingRayLight.addAssign(transmittance.saturate().oneMinus());
        }
        scatteringLight(lightColor, builder) {
            const sceneDepthNode = builder.context.sceneDepthNode;
            if (sceneDepthNode) {
                If(sceneDepthNode.greaterThanEqual(linearDepthRay), () => {
                    scatteringDensity.addAssign(lightColor);
                });
            } else {
                scatteringDensity.addAssign(lightColor);
            }
        }
        direct({ lightNode, lightColor }, builder) {
            // Ignore lights with infinite distance
            if (lightNode.light.distance === undefined) return;
            // TODO: We need a viewportOpaque*() ( output, depth ) to fit with modern rendering approaches
            const directLight = lightColor.xyz.toVar();
            directLight.mulAssign(lightNode.shadowNode); // it no should be necessary if used in the same render pass
            this.scatteringLight(directLight, builder);
        }
        directRectArea({ lightColor, lightPosition, halfWidth, halfHeight }, builder) {
            const p0 = lightPosition.add(halfWidth).sub(halfHeight); // counterclockwise; light shines in local neg z direction
            const p1 = lightPosition.sub(halfWidth).sub(halfHeight);
            const p2 = lightPosition.sub(halfWidth).add(halfHeight);
            const p3 = lightPosition.add(halfWidth).add(halfHeight);
            const P = builder.context.positionView;
            const directLight = lightColor.xyz.mul(LTC_Evaluate_Volume({ P, p0, p1, p2, p3 })).pow(1.5);
            this.scatteringLight(directLight, builder);
        }
        finish(builder) {
            builder.context.outgoingLight.assign(outgoingRayLight);
        }
    }
    class VolumeNodeMaterial extends NodeMaterial {
        static get type() {
            return 'VolumeNodeMaterial';
        }
        constructor(parameters) {
            super();
            this.isVolumeNodeMaterial = true;
            this.steps = 25;
            this.offsetNode = null;
            this.scatteringNode = null;
            this.lights = true;
            this.transparent = true;
            this.side = BackSide;
            this.depthTest = false;
            this.depthWrite = false;
            this.setValues(parameters);
        }
        setupLightingModel() {
            return new VolumetricLightingModel();
        }
    }
    class Animation {
        constructor(nodes, info) {
            this.nodes = nodes;
            this.info = info;
            this._context = typeof self !== 'undefined' ? self : null;
            this._animationLoop = null;
            this._requestId = null;
        }
        start() {
            const update = (time, xrFrame) => {
                this._requestId = this._context.requestAnimationFrame(update);
                if (this.info.autoReset === true) this.info.reset();
                this.nodes.nodeFrame.update();
                this.info.frame = this.nodes.nodeFrame.frameId;
                if (this._animationLoop !== null) this._animationLoop(time, xrFrame);
            };
            update();
        }
        stop() {
            this._context.cancelAnimationFrame(this._requestId);
            this._requestId = null;
        }
        getAnimationLoop() {
            return this._animationLoop;
        }
        setAnimationLoop(callback) {
            this._animationLoop = callback;
        }
        getContext() {
            return this._context;
        }
        setContext(context) {
            this._context = context;
        }
        dispose() {
            this.stop();
        }
    }
    class ChainMap {
        constructor() {
            this.weakMap = new WeakMap();
        }
        get(keys) {
            let map = this.weakMap;
            for (let i = 0; i < keys.length - 1; i++) {
                map = map.get(keys[i]);
                if (map === undefined) return undefined;
            }
            return map.get(keys[keys.length - 1]);
        }
        set(keys, value) {
            let map = this.weakMap;
            for (let i = 0; i < keys.length - 1; i++) {
                const key = keys[i];
                if (map.has(key) === false) map.set(key, new WeakMap());
                map = map.get(key);
            }
            map.set(keys[keys.length - 1], value);
            return this;
        }
        delete(keys) {
            let map = this.weakMap;
            for (let i = 0; i < keys.length - 1; i++) {
                map = map.get(keys[i]);
                if (map === undefined) return false;
            }
            return map.delete(keys[keys.length - 1]);
        }
    }
    let _id$9 = 0;
    function getKeys(obj) {
        const keys = Object.keys(obj);
        let proto = Object.getPrototypeOf(obj);
        while (proto) {
            const descriptors = Object.getOwnPropertyDescriptors(proto);
            for (const key in descriptors) {
                if (descriptors[key] !== undefined) {
                    const descriptor = descriptors[key];
                    if (descriptor && typeof descriptor.get === 'function') {
                        keys.push(key);
                    }
                }
            }
            proto = Object.getPrototypeOf(proto);
        }
        return keys;
    }
    class RenderObject {
        constructor(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext) {
            this.id = _id$9++;
            this._nodes = nodes;
            this._geometries = geometries;
            this.renderer = renderer;
            this.object = object;
            this.material = material;
            this.scene = scene;
            this.camera = camera;
            this.lightsNode = lightsNode;
            this.context = renderContext;
            this.geometry = object.geometry;
            this.version = material.version;
            this.drawRange = null;
            this.attributes = null;
            this.attributesId = null;
            this.pipeline = null;
            this.group = null;
            this.vertexBuffers = null;
            this.drawParams = null;
            this.bundle = null;
            this.clippingContext = clippingContext;
            this.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';
            this.initialNodesCacheKey = this.getDynamicCacheKey();
            this.initialCacheKey = this.getCacheKey();
            this._nodeBuilderState = null;
            this._bindings = null;
            this._monitor = null;
            this.onDispose = null;
            this.isRenderObject = true;
            this.onMaterialDispose = () => {
                this.dispose();
            };
            this.onGeometryDispose = () => {
                // clear geometry cache attributes
                this.attributes = null;
                this.attributesId = null;
            };
            this.material.addEventListener('dispose', this.onMaterialDispose);
            this.geometry.addEventListener('dispose', this.onGeometryDispose);
        }
        updateClipping(context) {
            this.clippingContext = context;
        }
        get clippingNeedsUpdate() {
            if (this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey) return false;
            this.clippingContextCacheKey = this.clippingContext.cacheKey;
            return true;
        }
        get hardwareClippingPlanes() {
            return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;
        }
        getNodeBuilderState() {
            return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));
        }
        getMonitor() {
            return this._monitor || (this._monitor = this.getNodeBuilderState().observer);
        }
        getBindings() {
            return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());
        }
        getBindingGroup(name) {
            for (const bindingGroup of this.getBindings()) {
                if (bindingGroup.name === name) {
                    return bindingGroup;
                }
            }
        }
        getIndex() {
            return this._geometries.getIndex(this);
        }
        getIndirect() {
            return this._geometries.getIndirect(this);
        }
        getChainArray() {
            return [this.object, this.material, this.context, this.lightsNode];
        }
        setGeometry(geometry) {
            this.geometry = geometry;
            this.attributes = null;
            this.attributesId = null;
        }
        getAttributes() {
            if (this.attributes !== null) return this.attributes;
            const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
            const geometry = this.geometry;
            const attributes = [];
            const vertexBuffers = new Set();
            const attributesId = {};
            for (const nodeAttribute of nodeAttributes) {
                let attribute;
                if (nodeAttribute.node && nodeAttribute.node.attribute) {
                    // node attribute
                    attribute = nodeAttribute.node.attribute;
                } else {
                    // geometry attribute
                    attribute = geometry.getAttribute(nodeAttribute.name);
                    attributesId[nodeAttribute.name] = attribute.version;
                }
                if (attribute === undefined) continue;
                attributes.push(attribute);
                const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
                vertexBuffers.add(bufferAttribute);
            }
            this.attributes = attributes;
            this.attributesId = attributesId;
            this.vertexBuffers = Array.from(vertexBuffers.values());
            return attributes;
        }
        getVertexBuffers() {
            if (this.vertexBuffers === null) this.getAttributes();
            return this.vertexBuffers;
        }
        getDrawParameters() {
            const { object, material, geometry, group, drawRange } = this;
            const drawParams = this.drawParams || (this.drawParams = {
                vertexCount: 0,
                firstVertex: 0,
                instanceCount: 0,
                firstInstance: 0
            });
            const index = this.getIndex();
            const hasIndex = (index !== null);
            let instanceCount = 1;
            if (geometry.isInstancedBufferGeometry === true) {
                instanceCount = geometry.instanceCount;
            } else if (object.count !== undefined) {
                instanceCount = Math.max(0, object.count);
            }
            if (instanceCount === 0) return null;
            drawParams.instanceCount = instanceCount;
            if (object.isBatchedMesh === true) return drawParams;
            let rangeFactor = 1;
            if (material.wireframe === true && !object.isPoints && !object.isLineSegments && !object.isLine && !object.isLineLoop) {
                rangeFactor = 2;
            }
            let firstVertex = drawRange.start * rangeFactor;
            let lastVertex = (drawRange.start + drawRange.count) * rangeFactor;
            if (group !== null) {
                firstVertex = Math.max(firstVertex, group.start * rangeFactor);
                lastVertex = Math.min(lastVertex, (group.start + group.count) * rangeFactor);
            }
            const position = geometry.attributes.position;
            let itemCount = Infinity;
            if (hasIndex) {
                itemCount = index.count;
            } else if (position !== undefined && position !== null) {
                itemCount = position.count;
            }
            firstVertex = Math.max(firstVertex, 0);
            lastVertex = Math.min(lastVertex, itemCount);
            const count = lastVertex - firstVertex;
            if (count < 0 || count === Infinity) return null;
            drawParams.vertexCount = count;
            drawParams.firstVertex = firstVertex;
            return drawParams;
        }
        getGeometryCacheKey() {
            const { geometry } = this;
            let cacheKey = '';
            for (const name of Object.keys(geometry.attributes).sort()) {
                const attribute = geometry.attributes[name];
                cacheKey += name + ',';
                if (attribute.data) cacheKey += attribute.data.stride + ',';
                if (attribute.offset) cacheKey += attribute.offset + ',';
                if (attribute.itemSize) cacheKey += attribute.itemSize + ',';
                if (attribute.normalized) cacheKey += 'n,';
            }
            // structural equality isn't sufficient for morph targets since the
            // data are maintained in textures. only if the targets are all equal
            // the texture and thus the instance of `MorphNode` can be shared.
            for (const name of Object.keys(geometry.morphAttributes).sort()) {
                const targets = geometry.morphAttributes[name];
                cacheKey += 'morph-' + name + ',';
                for (let i = 0, l = targets.length; i < l; i++) {
                    const attribute = targets[i];
                    cacheKey += attribute.id + ',';
                }
            }
            if (geometry.index) {
                cacheKey += 'index,';
            }
            return cacheKey;
        }
        getMaterialCacheKey() {
            const { object, material } = this;
            let cacheKey = material.customProgramCacheKey();
            for (const property of getKeys(material)) {
                if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(property)) continue;
                const value = material[property];
                let valueKey;
                if (value !== null) {
                    // some material values require a formatting
                    const type = typeof value;
                    if (type === 'number') {
                        valueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc
                    } else if (type === 'object') {
                        valueKey = '{';
                        if (value.isTexture) {
                            valueKey += value.mapping;
                        }
                        valueKey += '}';
                    } else {
                        valueKey = String(value);
                    }
                } else {
                    valueKey = String(value);
                }
                cacheKey += /*property + ':' +*/ valueKey + ',';
            }
            cacheKey += this.clippingContextCacheKey + ',';
            if (object.geometry) {
                cacheKey += this.getGeometryCacheKey();
            }
            if (object.skeleton) {
                cacheKey += object.skeleton.bones.length + ',';
            }
            if (object.isBatchedMesh) {
                cacheKey += object._matricesTexture.uuid + ',';
                if (object._colorsTexture !== null) {
                    cacheKey += object._colorsTexture.uuid + ',';
                }
            }
            if (object.count > 1) {
                // TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850
                cacheKey += object.uuid + ',';
            }
            cacheKey += object.receiveShadow + ',';
            return hashString(cacheKey);
        }
        get needsGeometryUpdate() {
            if (this.geometry.id !== this.object.geometry.id) return true;
            if (this.attributes !== null) {
                const attributesId = this.attributesId;
                for (const name in attributesId) {
                    const attribute = this.geometry.getAttribute(name);
                    if (attribute === undefined || attributesId[name] !== attribute.id) {
                        return true;
                    }
                }
            }
            return false;
        }
        get needsUpdate() {
            return /*this.object.static !== true &&*/ (this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate);
        }
        getDynamicCacheKey() {
            let cacheKey = 0;
            // `Nodes.getCacheKey()` returns an environment cache key which is not relevant when
            // the renderer is inside a shadow pass.
            if (this.material.isShadowPassMaterial !== true) {
                cacheKey = this._nodes.getCacheKey(this.scene, this.lightsNode);
            }
            if (this.camera.isArrayCamera) {
                cacheKey = hash$1(cacheKey, this.camera.cameras.length);
            }
            if (this.object.receiveShadow) {
                cacheKey = hash$1(cacheKey, 1);
            }
            return cacheKey;
        }
        getCacheKey() {
            return this.getMaterialCacheKey() + this.getDynamicCacheKey();
        }
        dispose() {
            this.material.removeEventListener('dispose', this.onMaterialDispose);
            this.geometry.removeEventListener('dispose', this.onGeometryDispose);
            this.onDispose();
        }
    }
    const _chainKeys$5 = [];
    class RenderObjects {
        constructor(renderer, nodes, geometries, pipelines, bindings, info) {
            this.renderer = renderer;
            this.nodes = nodes;
            this.geometries = geometries;
            this.pipelines = pipelines;
            this.bindings = bindings;
            this.info = info;
            this.chainMaps = {};
        }
        get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {
            const chainMap = this.getChainMap(passId);
            // reuse chainArray
            _chainKeys$5[0] = object;
            _chainKeys$5[1] = material;
            _chainKeys$5[2] = renderContext;
            _chainKeys$5[3] = lightsNode;
            let renderObject = chainMap.get(_chainKeys$5);
            if (renderObject === undefined) {
                renderObject = this.createRenderObject(this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId);
                chainMap.set(_chainKeys$5, renderObject);
            } else {
                renderObject.updateClipping(clippingContext);
                if (renderObject.needsGeometryUpdate) {
                    renderObject.setGeometry(object.geometry);
                }
                if (renderObject.version !== material.version || renderObject.needsUpdate) {
                    if (renderObject.initialCacheKey !== renderObject.getCacheKey()) {
                        renderObject.dispose();
                        renderObject = this.get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId);
                    } else {
                        renderObject.version = material.version;
                    }
                }
            }
            _chainKeys$5.length = 0;
            return renderObject;
        }
        getChainMap(passId = 'default') {
            return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());
        }
        dispose() {
            this.chainMaps = {};
        }
        createRenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {
            const chainMap = this.getChainMap(passId);
            const renderObject = new RenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext);
            renderObject.onDispose = () => {
                this.pipelines.delete(renderObject);
                this.bindings.delete(renderObject);
                this.nodes.delete(renderObject);
                chainMap.delete(renderObject.getChainArray());
            };
            return renderObject;
        }

    }
    class DataMap {
        constructor() {
            this.data = new WeakMap();
        }
        get(object) {
            let map = this.data.get(object);
            if (map === undefined) {
                map = {};
                this.data.set(object, map);
            }
            return map;
        }
        delete(object) {
            let map = null;
            if (this.data.has(object)) {
                map = this.data.get(object);
                this.data.delete(object);
            }
            return map;
        }
        has(object) {
            return this.data.has(object);
        }
        dispose() {
            this.data = new WeakMap();
        }
    }
    const AttributeType = {
        VERTEX: 1,
        INDEX: 2,
        STORAGE: 3,
        INDIRECT: 4
    };
    // size of a chunk in bytes (STD140 layout)
    const GPU_CHUNK_BYTES = 16;
    // @TODO: Move to src/constants.js
    const BlendColorFactor = 211;
    const OneMinusBlendColorFactor = 212;
    class Attributes extends DataMap {
        constructor(backend) {
            super();
            this.backend = backend;
        }
        delete(attribute) {
            const attributeData = super.delete(attribute);
            if (attributeData !== null) {
                this.backend.destroyAttribute(attribute);
            }
            return attributeData;
        }
        update(attribute, type) {
            const data = this.get(attribute);
            if (data.version === undefined) {
                if (type === AttributeType.VERTEX) {
                    this.backend.createAttribute(attribute);
                } else if (type === AttributeType.INDEX) {
                    this.backend.createIndexAttribute(attribute);
                } else if (type === AttributeType.STORAGE) {
                    this.backend.createStorageAttribute(attribute);
                } else if (type === AttributeType.INDIRECT) {
                    this.backend.createIndirectStorageAttribute(attribute);
                }
                data.version = this._getBufferAttribute(attribute).version;
            } else {
                const bufferAttribute = this._getBufferAttribute(attribute);
                if (data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage) {
                    this.backend.updateAttribute(attribute);
                    data.version = bufferAttribute.version;
                }
            }
        }
        _getBufferAttribute(attribute) {
            if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
            return attribute;
        }
    }
    function getWireframeVersion(geometry) {
        return (geometry.index !== null) ? geometry.index.version : geometry.attributes.position.version;
    }
    function getWireframeIndex(geometry) {
        const indices = [];
        const geometryIndex = geometry.index;
        const geometryPosition = geometry.attributes.position;
        if (geometryIndex !== null) {
            const array = geometryIndex.array;
            for (let i = 0, l = array.length; i < l; i += 3) {
                const a = array[i + 0];
                const b = array[i + 1];
                const c = array[i + 2];
                indices.push(a, b, b, c, c, a);
            }
        } else {
            const array = geometryPosition.array;
            for (let i = 0, l = (array.length / 3) - 1; i < l; i += 3) {
                const a = i + 0;
                const b = i + 1;
                const c = i + 2;
                indices.push(a, b, b, c, c, a);
            }
        }
        const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
        attribute.version = getWireframeVersion(geometry);
        return attribute;
    }
    class Geometries extends DataMap {
        constructor(attributes, info) {
            super();
            this.attributes = attributes;
            this.info = info;
            this.wireframes = new WeakMap();
            this.attributeCall = new WeakMap();
        }
        has(renderObject) {
            const geometry = renderObject.geometry;
            return super.has(geometry) && this.get(geometry).initialized === true;
        }
        updateForRender(renderObject) {
            if (this.has(renderObject) === false) this.initGeometry(renderObject);
            this.updateAttributes(renderObject);
        }
        initGeometry(renderObject) {
            const geometry = renderObject.geometry;
            const geometryData = this.get(geometry);
            geometryData.initialized = true;
            this.info.memory.geometries++;
            const onDispose = () => {
                this.info.memory.geometries--;
                const index = geometry.index;
                const geometryAttributes = renderObject.getAttributes();
                if (index !== null) {
                    this.attributes.delete(index);
                }
                for (const geometryAttribute of geometryAttributes) {
                    this.attributes.delete(geometryAttribute);
                }
                const wireframeAttribute = this.wireframes.get(geometry);
                if (wireframeAttribute !== undefined) {
                    this.attributes.delete(wireframeAttribute);
                }
                geometry.removeEventListener('dispose', onDispose);
            };
            geometry.addEventListener('dispose', onDispose);
        }
        updateAttributes(renderObject) {
            // attributes
            const attributes = renderObject.getAttributes();
            for (const attribute of attributes) {
                if (attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute) {
                    this.updateAttribute(attribute, AttributeType.STORAGE);
                } else {
                    this.updateAttribute(attribute, AttributeType.VERTEX);
                }
            }
            // indexes
            const index = this.getIndex(renderObject);
            if (index !== null) {
                this.updateAttribute(index, AttributeType.INDEX);
            }
            // indirect
            const indirect = renderObject.geometry.indirect;
            if (indirect !== null) {
                this.updateAttribute(indirect, AttributeType.INDIRECT);
            }
        }
        updateAttribute(attribute, type) {
            const callId = this.info.render.calls;
            if (!attribute.isInterleavedBufferAttribute) {
                if (this.attributeCall.get(attribute) !== callId) {
                    this.attributes.update(attribute, type);
                    this.attributeCall.set(attribute, callId);
                }
            } else {
                if (this.attributeCall.get(attribute) === undefined) {
                    this.attributes.update(attribute, type);
                    this.attributeCall.set(attribute, callId);
                } else if (this.attributeCall.get(attribute.data) !== callId) {
                    this.attributes.update(attribute, type);
                    this.attributeCall.set(attribute.data, callId);
                    this.attributeCall.set(attribute, callId);
                }
            }
        }
        getIndirect(renderObject) {
            return renderObject.geometry.indirect;
        }
        getIndex(renderObject) {
            const { geometry, material } = renderObject;
            let index = geometry.index;
            if (material.wireframe === true) {
                const wireframes = this.wireframes;
                let wireframeAttribute = wireframes.get(geometry);
                if (wireframeAttribute === undefined) {
                    wireframeAttribute = getWireframeIndex(geometry);
                    wireframes.set(geometry, wireframeAttribute);
                } else if (wireframeAttribute.version !== getWireframeVersion(geometry)) {
                    this.attributes.delete(wireframeAttribute);
                    wireframeAttribute = getWireframeIndex(geometry);
                    wireframes.set(geometry, wireframeAttribute);
                }
                index = wireframeAttribute;
            }
            return index;
        }
    }
    class Info {
        constructor() {
            this.autoReset = true;
            this.frame = 0;
            this.calls = 0;
            this.render = {
                calls: 0,
                frameCalls: 0,
                drawCalls: 0,
                triangles: 0,
                points: 0,
                lines: 0,
                timestamp: 0,
            };
            this.compute = {
                calls: 0,
                frameCalls: 0,
                timestamp: 0
            };
            this.memory = {
                geometries: 0,
                textures: 0
            };
        }
        update(object, count, instanceCount) {
            this.render.drawCalls++;
            if (object.isMesh || object.isSprite) {
                this.render.triangles += instanceCount * (count / 3);
            } else if (object.isPoints) {
                this.render.points += instanceCount * count;
            } else if (object.isLineSegments) {
                this.render.lines += instanceCount * (count / 2);
            } else if (object.isLine) {
                this.render.lines += instanceCount * (count - 1);
            } else {
                console.error('THREE.WebGPUInfo: Unknown object type.');
            }
        }
        reset() {
            this.render.drawCalls = 0;
            this.render.frameCalls = 0;
            this.compute.frameCalls = 0;
            this.render.triangles = 0;
            this.render.points = 0;
            this.render.lines = 0;

        }
        dispose() {
            this.reset();
            this.calls = 0;
            this.render.calls = 0;
            this.compute.calls = 0;
            this.render.timestamp = 0;
            this.compute.timestamp = 0;
            this.memory.geometries = 0;
            this.memory.textures = 0;
        }
    }
    class Pipeline {
        constructor(cacheKey) {
            this.cacheKey = cacheKey;
            this.usedTimes = 0;
        }
    }
    class RenderPipeline extends Pipeline {
        constructor(cacheKey, vertexProgram, fragmentProgram) {
            super(cacheKey);
            this.vertexProgram = vertexProgram;
            this.fragmentProgram = fragmentProgram;
        }
    }
    class ComputePipeline extends Pipeline {
        constructor(cacheKey, computeProgram) {
            super(cacheKey);
            this.computeProgram = computeProgram;
            this.isComputePipeline = true;
        }
    }
    let _id$8 = 0;
    class ProgrammableStage {
        constructor(code, stage, name, transforms = null, attributes = null) {
            this.id = _id$8++;
            this.code = code;
            this.stage = stage;
            this.name = name;
            this.transforms = transforms;
            this.attributes = attributes;
            this.usedTimes = 0;
        }
    }
    class Pipelines extends DataMap {
        constructor(backend, nodes) {
            super();
            this.backend = backend;
            this.nodes = nodes;
            this.bindings = null;
            this.caches = new Map();
            this.programs = {
                vertex: new Map(),
                fragment: new Map(),
                compute: new Map()
            };
        }
        getForCompute(computeNode, bindings) {
            const { backend } = this;
            const data = this.get(computeNode);
            if (this._needsComputeUpdate(computeNode)) {
                const previousPipeline = data.pipeline;
                if (previousPipeline) {
                    previousPipeline.usedTimes--;
                    previousPipeline.computeProgram.usedTimes--;
                }
                // get shader
                const nodeBuilderState = this.nodes.getForCompute(computeNode);
                // programmable stage
                let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);
                if (stageCompute === undefined) {
                    if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0) this._releaseProgram(previousPipeline.computeProgram);
                    stageCompute = new ProgrammableStage(nodeBuilderState.computeShader, 'compute', computeNode.name, nodeBuilderState.transforms, nodeBuilderState.nodeAttributes);
                    this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);
                    backend.createProgram(stageCompute);
                }
                // determine compute pipeline
                const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);
                let pipeline = this.caches.get(cacheKey);
                if (pipeline === undefined) {
                    if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
                    pipeline = this._getComputePipeline(computeNode, stageCompute, cacheKey, bindings);
                }
                // keep track of all used times
                pipeline.usedTimes++;
                stageCompute.usedTimes++;
                //
                data.version = computeNode.version;
                data.pipeline = pipeline;
            }
            return data.pipeline;
        }
        getForRender(renderObject, promises = null) {
            const { backend } = this;
            const data = this.get(renderObject);
            if (this._needsRenderUpdate(renderObject)) {
                const previousPipeline = data.pipeline;
                if (previousPipeline) {
                    previousPipeline.usedTimes--;
                    previousPipeline.vertexProgram.usedTimes--;
                    previousPipeline.fragmentProgram.usedTimes--;
                }
                // get shader
                const nodeBuilderState = renderObject.getNodeBuilderState();
                const name = renderObject.material ? renderObject.material.name : '';
                // programmable stages
                let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);
                if (stageVertex === undefined) {
                    if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0) this._releaseProgram(previousPipeline.vertexProgram);
                    stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader, 'vertex', name);
                    this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);
                    backend.createProgram(stageVertex);
                }
                let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);
                if (stageFragment === undefined) {
                    if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(previousPipeline.fragmentProgram);
                    stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, 'fragment', name);
                    this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);
                    backend.createProgram(stageFragment);
                }
                // determine render pipeline
                const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
                let pipeline = this.caches.get(cacheKey);
                if (pipeline === undefined) {
                    if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
                    pipeline = this._getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises);
                } else {
                    renderObject.pipeline = pipeline;
                }
                // keep track of all used times
                pipeline.usedTimes++;
                stageVertex.usedTimes++;
                stageFragment.usedTimes++;
                //
                data.pipeline = pipeline;
            }
            return data.pipeline;
        }
        delete(object) {
            const pipeline = this.get(object).pipeline;
            if (pipeline) {
                // pipeline
                pipeline.usedTimes--;
                if (pipeline.usedTimes === 0) this._releasePipeline(pipeline);
                // programs
                if (pipeline.isComputePipeline) {
                    pipeline.computeProgram.usedTimes--;
                    if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);
                } else {
                    pipeline.fragmentProgram.usedTimes--;
                    pipeline.vertexProgram.usedTimes--;
                    if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);
                    if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);
                }
            }
            return super.delete(object);
        }
        dispose() {
            super.dispose();
            this.caches = new Map();
            this.programs = {
                vertex: new Map(),
                fragment: new Map(),
                compute: new Map()
            };
        }
        updateForRender(renderObject) {
            this.getForRender(renderObject);
        }
        _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {
            // check for existing pipeline
            cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);
            let pipeline = this.caches.get(cacheKey);
            if (pipeline === undefined) {
                pipeline = new ComputePipeline(cacheKey, stageCompute);
                this.caches.set(cacheKey, pipeline);
                this.backend.createComputePipeline(pipeline, bindings);
            }
            return pipeline;
        }
        _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises) {
            // check for existing pipeline
            cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
            let pipeline = this.caches.get(cacheKey);
            if (pipeline === undefined) {
                pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);
                this.caches.set(cacheKey, pipeline);
                renderObject.pipeline = pipeline;
                // The `promises` array is `null` by default and only set to an empty array when
                // `Renderer.compileAsync()` is used. The next call actually fills the array with
                // pending promises that resolve when the render pipelines are ready for rendering.
                this.backend.createRenderPipeline(renderObject, promises);
            }
            return pipeline;
        }
        _getComputeCacheKey(computeNode, stageCompute) {
            return computeNode.id + ',' + stageCompute.id;
        }
        _getRenderCacheKey(renderObject, stageVertex, stageFragment) {
            return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey(renderObject);
        }
        _releasePipeline(pipeline) {
            this.caches.delete(pipeline.cacheKey);
        }
        _releaseProgram(program) {
            const code = program.code;
            const stage = program.stage;
            this.programs[stage].delete(code);
        }
        _needsComputeUpdate(computeNode) {
            const data = this.get(computeNode);
            return data.pipeline === undefined || data.version !== computeNode.version;
        }
        _needsRenderUpdate(renderObject) {
            const data = this.get(renderObject);
            return data.pipeline === undefined || this.backend.needsRenderUpdate(renderObject);
        }
    }
    class Bindings extends DataMap {
        constructor(backend, nodes, textures, attributes, pipelines, info) {
            super();
            this.backend = backend;
            this.textures = textures;
            this.pipelines = pipelines;
            this.attributes = attributes;
            this.nodes = nodes;
            this.info = info;
            this.pipelines.bindings = this; // assign bindings to pipelines
        }
        getForRender(renderObject) {
            const bindings = renderObject.getBindings();
            for (const bindGroup of bindings) {
                const groupData = this.get(bindGroup);
                if (groupData.bindGroup === undefined) {
                    // each object defines an array of bindings (ubos, textures, samplers etc.)
                    this._init(bindGroup);
                    this.backend.createBindings(bindGroup, bindings, 0);
                    groupData.bindGroup = bindGroup;
                }
            }
            return bindings;
        }
        getForCompute(computeNode) {
            const bindings = this.nodes.getForCompute(computeNode).bindings;
            for (const bindGroup of bindings) {
                const groupData = this.get(bindGroup);
                if (groupData.bindGroup === undefined) {
                    this._init(bindGroup);
                    this.backend.createBindings(bindGroup, bindings, 0);
                    groupData.bindGroup = bindGroup;
                }
            }
            return bindings;
        }
        updateForCompute(computeNode) {
            this._updateBindings(this.getForCompute(computeNode));
        }
        updateForRender(renderObject) {
            this._updateBindings(this.getForRender(renderObject));
        }
        _updateBindings(bindings) {
            for (const bindGroup of bindings) {
                this._update(bindGroup, bindings);
            }
        }
        _init(bindGroup) {
            for (const binding of bindGroup.bindings) {
                if (binding.isSampledTexture) {
                    this.textures.updateTexture(binding.texture);
                } else if (binding.isStorageBuffer) {
                    const attribute = binding.attribute;
                    const attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;
                    this.attributes.update(attribute, attributeType);
                }
            }
        }
        _update(bindGroup, bindings) {
            const { backend } = this;
            let needsBindingsUpdate = false;
            let cacheBindings = true;
            let cacheIndex = 0;
            let version = 0;
            // iterate over all bindings and check if buffer updates or a new binding group is required
            for (const binding of bindGroup.bindings) {
                if (binding.isNodeUniformsGroup) {
                    const updated = this.nodes.updateGroup(binding);
                    // every uniforms group is a uniform buffer. So if no update is required,
                    // we move one with the next binding. Otherwise the next if block will update the group.
                    if (updated === false) continue;
                }
                if (binding.isStorageBuffer) {
                    const attribute = binding.attribute;
                    const attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;
                    this.attributes.update(attribute, attributeType);

                }
                if (binding.isUniformBuffer) {
                    const updated = binding.update();
                    if (updated) {
                        backend.updateBinding(binding);
                    }
                } else if (binding.isSampledTexture) {
                    const updated = binding.update();
                    // get the texture data after the update, to sync the texture reference from node
                    const texture = binding.texture;
                    const texturesTextureData = this.textures.get(texture);
                    if (updated) {
                        // version: update the texture data or create a new one
                        this.textures.updateTexture(texture);
                        // generation: update the bindings if a new texture has been created
                        if (binding.generation !== texturesTextureData.generation) {
                            binding.generation = texturesTextureData.generation;
                            needsBindingsUpdate = true;
                        }
                    }
                    const textureData = backend.get(texture);
                    if (textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture) {
                        cacheBindings = false;
                    } else {
                        cacheIndex = cacheIndex * 10 + texture.id;
                        version += texture.version;
                    }
                    if (texture.isStorageTexture === true) {
                        const textureData = this.get(texture);
                        if (binding.store === true) {
                            textureData.needsMipmap = true;
                        } else if (this.textures.needsMipmaps(texture) && textureData.needsMipmap === true) {
                            this.backend.generateMipmaps(texture);
                            textureData.needsMipmap = false;
                        }
                    }
                } else if (binding.isSampler) {
                    binding.update();
                }
            }
            if (needsBindingsUpdate === true) {
                this.backend.updateBindings(bindGroup, bindings, cacheBindings ? cacheIndex : 0, version);
            }
        }
    }
    function painterSortStable(a, b) {
        if (a.groupOrder !== b.groupOrder) {
            return a.groupOrder - b.groupOrder;
        } else if (a.renderOrder !== b.renderOrder) {
            return a.renderOrder - b.renderOrder;
        } else if (a.z !== b.z) {
            return a.z - b.z;
        } else {
            return a.id - b.id;
        }
    }
    function reversePainterSortStable(a, b) {
        if (a.groupOrder !== b.groupOrder) {
            return a.groupOrder - b.groupOrder;
        } else if (a.renderOrder !== b.renderOrder) {
            return a.renderOrder - b.renderOrder;
        } else if (a.z !== b.z) {
            return b.z - a.z;
        } else {
            return a.id - b.id;
        }
    }
    function needsDoublePass(material) {
        const hasTransmission = material.transmission > 0 || material.transmissionNode;
        return hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;
    }
    class RenderList {
        constructor(lighting, scene, camera) {
            this.renderItems = [];
            this.renderItemsIndex = 0;
            this.opaque = [];
            this.transparentDoublePass = [];
            this.transparent = [];
            this.bundles = [];
            this.lightsNode = lighting.getNode(scene, camera);
            this.lightsArray = [];
            this.scene = scene;
            this.camera = camera;
            this.occlusionQueryCount = 0;
        }
        begin() {
            this.renderItemsIndex = 0;
            this.opaque.length = 0;
            this.transparentDoublePass.length = 0;
            this.transparent.length = 0;
            this.bundles.length = 0;
            this.lightsArray.length = 0;
            this.occlusionQueryCount = 0;
            return this;
        }
        getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext) {
            let renderItem = this.renderItems[this.renderItemsIndex];
            if (renderItem === undefined) {
                renderItem = {
                    id: object.id,
                    object: object,
                    geometry: geometry,
                    material: material,
                    groupOrder: groupOrder,
                    renderOrder: object.renderOrder,
                    z: z,
                    group: group,
                    clippingContext: clippingContext
                };
                this.renderItems[this.renderItemsIndex] = renderItem;
            } else {
                renderItem.id = object.id;
                renderItem.object = object;
                renderItem.geometry = geometry;
                renderItem.material = material;
                renderItem.groupOrder = groupOrder;
                renderItem.renderOrder = object.renderOrder;
                renderItem.z = z;
                renderItem.group = group;
                renderItem.clippingContext = clippingContext;
            }
            this.renderItemsIndex++;
            return renderItem;
        }
        push(object, geometry, material, groupOrder, z, group, clippingContext) {
            const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);
            if (object.occlusionTest === true) this.occlusionQueryCount++;
            if (material.transparent === true || material.transmission > 0) {
                if (needsDoublePass(material)) this.transparentDoublePass.push(renderItem);
                this.transparent.push(renderItem);
            } else {
                this.opaque.push(renderItem);
            }
        }
        unshift(object, geometry, material, groupOrder, z, group, clippingContext) {
            const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);
            if (material.transparent === true || material.transmission > 0) {
                if (needsDoublePass(material)) this.transparentDoublePass.unshift(renderItem);
                this.transparent.unshift(renderItem);
            } else {
                this.opaque.unshift(renderItem);
            }
        }
        pushBundle(group) {
            this.bundles.push(group);
        }
        pushLight(light) {
            this.lightsArray.push(light);
        }
        sort(customOpaqueSort, customTransparentSort) {
            if (this.opaque.length > 1) this.opaque.sort(customOpaqueSort || painterSortStable);
            if (this.transparentDoublePass.length > 1) this.transparentDoublePass.sort(customTransparentSort || reversePainterSortStable);
            if (this.transparent.length > 1) this.transparent.sort(customTransparentSort || reversePainterSortStable);
        }
        finish() {
            // update lights
            this.lightsNode.setLights(this.lightsArray);
            // Clear references from inactive renderItems in the list
            for (let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i++) {
                const renderItem = this.renderItems[i];
                if (renderItem.id === null) break;
                renderItem.id = null;
                renderItem.object = null;
                renderItem.geometry = null;
                renderItem.material = null;
                renderItem.groupOrder = null;
                renderItem.renderOrder = null;
                renderItem.z = null;
                renderItem.group = null;
                renderItem.clippingContext = null;
            }
        }
    }
    const _chainKeys$4 = [];
    class RenderLists {
        constructor(lighting) {
            this.lighting = lighting;
            this.lists = new ChainMap();
        }
        get(scene, camera) {
            const lists = this.lists;
            _chainKeys$4[0] = scene;
            _chainKeys$4[1] = camera;
            let list = lists.get(_chainKeys$4);
            if (list === undefined) {
                list = new RenderList(this.lighting, scene, camera);
                lists.set(_chainKeys$4, list);
            }
            _chainKeys$4.length = 0;
            return list;
        }
        dispose() {
            this.lists = new ChainMap();
        }
    }
    let _id$7 = 0;
    class RenderContext {
        constructor() {
            this.id = _id$7++;
            this.color = true;
            this.clearColor = true;
            this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };
            this.depth = true;
            this.clearDepth = true;
            this.clearDepthValue = 1;
            this.stencil = false;
            this.clearStencil = true;
            this.clearStencilValue = 1;
            this.viewport = false;
            this.viewportValue = new Vector4();
            this.scissor = false;
            this.scissorValue = new Vector4();
            this.renderTarget = null;
            this.textures = null;
            this.depthTexture = null;
            this.activeCubeFace = 0;
            this.activeMipmapLevel = 0;
            this.sampleCount = 1;
            this.width = 0;
            this.height = 0;
            this.occlusionQueryCount = 0;
            this.clippingContext = null;
            this.isRenderContext = true;
        }
        getCacheKey() {
            return getCacheKey(this);
        }
    }
    function getCacheKey(renderContext) {
        const { textures, activeCubeFace } = renderContext;
        const values = [activeCubeFace];
        for (const texture of textures) {
            values.push(texture.id);
        }
        return hashArray(values);
    }
    const _chainKeys$3 = [];
    const _defaultScene = /*@__PURE__*/ new Scene();
    const _defaultCamera = /*@__PURE__*/ new Camera();
    class RenderContexts {
        constructor() {
            this.chainMaps = {};
        }
        get(scene, camera, renderTarget = null) {
            _chainKeys$3[0] = scene;
            _chainKeys$3[1] = camera;
            let attachmentState;
            if (renderTarget === null) {
                attachmentState = 'default';
            } else {
                const format = renderTarget.texture.format;
                const count = renderTarget.textures.length;
                attachmentState = `${count}:${format}:${renderTarget.samples}:${renderTarget.depthBuffer}:${renderTarget.stencilBuffer}`;
            }
            const chainMap = this._getChainMap(attachmentState);
            let renderState = chainMap.get(_chainKeys$3);
            if (renderState === undefined) {
                renderState = new RenderContext();
                chainMap.set(_chainKeys$3, renderState);
            }
            _chainKeys$3.length = 0;
            if (renderTarget !== null) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
            return renderState;
        }
        getForClear(renderTarget = null) {
            return this.get(_defaultScene, _defaultCamera, renderTarget);
        }
        _getChainMap(attachmentState) {
            return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());
        }
        dispose() {
            this.chainMaps = {};
        }
    }
    const _size$3 = /*@__PURE__*/ new Vector3();
    class Textures extends DataMap {
        constructor(renderer, backend, info) {
            super();
            this.renderer = renderer;
            this.backend = backend;
            this.info = info;
        }
        updateRenderTarget(renderTarget, activeMipmapLevel = 0) {
            const renderTargetData = this.get(renderTarget);
            const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
            const depthTextureMips = renderTargetData.depthTextureMips || (renderTargetData.depthTextureMips = {});
            const textures = renderTarget.textures;
            const size = this.getSize(textures[0]);
            const mipWidth = size.width >> activeMipmapLevel;
            const mipHeight = size.height >> activeMipmapLevel;
            let depthTexture = renderTarget.depthTexture || depthTextureMips[activeMipmapLevel];
            const useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;
            let textureNeedsUpdate = false;
            if (depthTexture === undefined && useDepthTexture) {
                depthTexture = new DepthTexture();
                depthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;
                depthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType
                depthTexture.image.width = mipWidth;
                depthTexture.image.height = mipHeight;
                depthTexture.image.depth = size.depth;
                depthTexture.isArrayTexture = renderTarget.multiview === true && size.depth > 1;
                depthTextureMips[activeMipmapLevel] = depthTexture;
            }
            if (renderTargetData.width !== size.width || size.height !== renderTargetData.height) {
                textureNeedsUpdate = true;
                if (depthTexture) {
                    depthTexture.needsUpdate = true;
                    depthTexture.image.width = mipWidth;
                    depthTexture.image.height = mipHeight;
                    depthTexture.image.depth = depthTexture.isArrayTexture ? depthTexture.image.depth : 1;
                }
            }
            renderTargetData.width = size.width;
            renderTargetData.height = size.height;
            renderTargetData.textures = textures;
            renderTargetData.depthTexture = depthTexture || null;
            renderTargetData.depth = renderTarget.depthBuffer;
            renderTargetData.stencil = renderTarget.stencilBuffer;
            renderTargetData.renderTarget = renderTarget;
            if (renderTargetData.sampleCount !== sampleCount) {
                textureNeedsUpdate = true;
                if (depthTexture) {
                    depthTexture.needsUpdate = true;
                }
                renderTargetData.sampleCount = sampleCount;
            }
            //

            const options = { sampleCount };
            // XR render targets require no texture updates
            if (renderTarget.isXRRenderTarget !== true) {
                for (let i = 0; i < textures.length; i++) {
                    const texture = textures[i];
                    if (textureNeedsUpdate) texture.needsUpdate = true;
                    this.updateTexture(texture, options);
                }
                if (depthTexture) {
                    this.updateTexture(depthTexture, options);
                }
            }
            // dispose handler
            if (renderTargetData.initialized !== true) {
                renderTargetData.initialized = true;
                // dispose
                const onDispose = () => {
                    renderTarget.removeEventListener('dispose', onDispose);
                    for (let i = 0; i < textures.length; i++) {
                        this._destroyTexture(textures[i]);
                    }
                    if (depthTexture) {
                        this._destroyTexture(depthTexture);
                    }
                    this.delete(renderTarget);
                };
                renderTarget.addEventListener('dispose', onDispose);
            }
        }
        updateTexture(texture, options = {}) {
            const textureData = this.get(texture);
            if (textureData.initialized === true && textureData.version === texture.version) return;
            const isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;
            const backend = this.backend;
            if (isRenderTarget && textureData.initialized === true) {
                // it's an update
                backend.destroySampler(texture);
                backend.destroyTexture(texture);
            }
            //
            if (texture.isFramebufferTexture) {
                const renderTarget = this.renderer.getRenderTarget();
                if (renderTarget) {
                    texture.type = renderTarget.texture.type;
                } else {
                    texture.type = UnsignedByteType;
                }
            }
            //
            const { width, height, depth } = this.getSize(texture);
            options.width = width;
            options.height = height;
            options.depth = depth;
            options.needsMipmaps = this.needsMipmaps(texture);
            options.levels = options.needsMipmaps ? this.getMipLevels(texture, width, height) : 1;
            //
            if (isRenderTarget || texture.isStorageTexture === true) {
                backend.createSampler(texture);
                backend.createTexture(texture, options);
                textureData.generation = texture.version;
            } else {
                const needsCreate = textureData.initialized !== true;
                if (needsCreate) backend.createSampler(texture);
                if (texture.version > 0) {
                    const image = texture.image;
                    if (image === undefined) {
                        console.warn('THREE.Renderer: Texture marked for update but image is undefined.');
                    } else if (image.complete === false) {
                        console.warn('THREE.Renderer: Texture marked for update but image is incomplete.');
                    } else {
                        if (texture.images) {
                            const images = [];
                            for (const image of texture.images) {
                                images.push(image);
                            }
                            options.images = images;
                        } else {
                            options.image = image;
                        }
                        if (textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true) {
                            backend.createTexture(texture, options);
                            textureData.isDefaultTexture = false;
                            textureData.generation = texture.version;
                        }
                        if (texture.source.dataReady === true) backend.updateTexture(texture, options);
                        if (options.needsMipmaps && texture.mipmaps.length === 0) backend.generateMipmaps(texture);
                    }
                } else {
                    // async update
                    backend.createDefaultTexture(texture);
                    textureData.isDefaultTexture = true;
                    textureData.generation = texture.version;
                }
            }
            // dispose handler
            if (textureData.initialized !== true) {
                textureData.initialized = true;
                textureData.generation = texture.version;
                //
                this.info.memory.textures++;
                // dispose
                const onDispose = () => {
                    texture.removeEventListener('dispose', onDispose);
                    this._destroyTexture(texture);
                };
                texture.addEventListener('dispose', onDispose);
            }
            //
            textureData.version = texture.version;
        }
        getSize(texture, target = _size$3) {
            let image = texture.images ? texture.images[0] : texture.image;
            if (image) {
                if (image.image !== undefined) image = image.image;
                if (image instanceof HTMLVideoElement) {
                    target.width = image.videoWidth || 1;
                    target.height = image.videoHeight || 1;
                    target.depth = 1;
                } else if (image instanceof VideoFrame) {
                    target.width = image.displayWidth || 1;
                    target.height = image.displayHeight || 1;
                    target.depth = 1;
                } else {
                    target.width = image.width || 1;
                    target.height = image.height || 1;
                    target.depth = texture.isCubeTexture ? 6 : (image.depth || 1);
                }
            } else {
                target.width = target.height = target.depth = 1;
            }
            return target;
        }
        getMipLevels(texture, width, height) {
            let mipLevelCount;
            if (texture.isCompressedTexture) {
                if (texture.mipmaps) {
                    mipLevelCount = texture.mipmaps.length;
                } else {
                    mipLevelCount = 1;
                }
            } else {
                mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;
            }
            return mipLevelCount;
        }
        needsMipmaps(texture) {
            return texture.isCompressedTexture === true || texture.generateMipmaps;
        }
        _destroyTexture(texture) {
            if (this.has(texture) === true) {
                this.backend.destroySampler(texture);
                this.backend.destroyTexture(texture);
                this.delete(texture);
                this.info.memory.textures--;
            }
        }
    }
    class Color4 extends Color {
        constructor(r, g, b, a = 1) {
            super(r, g, b);
            this.a = a;
        }
        set(r, g, b, a = 1) {
            this.a = a;
            return super.set(r, g, b);
        }
        copy(color) {
            if (color.a !== undefined) this.a = color.a;
            return super.copy(color);
        }
        clone() {
            return new this.constructor(this.r, this.g, this.b, this.a);
        }
    }
    class ParameterNode extends PropertyNode {
        static get type() {
            return 'ParameterNode';
        }
        constructor(nodeType, name = null) {
            super(nodeType, name);
            this.isParameterNode = true;
        }
        getHash() {
            return this.uuid;
        }
        generate() {
            return this.name;
        }
    }
    const parameter = (type, name) => nodeObject(new ParameterNode(type, name));
    class StackNode extends Node {
        static get type() {
            return 'StackNode';
        }
        constructor(parent = null) {
            super();
            this.nodes = [];
            this.outputNode = null;
            this.parent = parent;
            this._currentCond = null;
            this._expressionNode = null;
            this.isStackNode = true;
        }
        getNodeType(builder) {
            return this.outputNode ? this.outputNode.getNodeType(builder) : 'void';
        }
        getMemberType(builder, name) {
            return this.outputNode ? this.outputNode.getMemberType(builder, name) : 'void';
        }
        add(node) {
            this.nodes.push(node);
            return this;
        }
        If(boolNode, method) {
            const methodNode = new ShaderNode(method);
            this._currentCond = select(boolNode, methodNode);
            return this.add(this._currentCond);
        }
        ElseIf(boolNode, method) {
            const methodNode = new ShaderNode(method);
            const ifNode = select(boolNode, methodNode);
            this._currentCond.elseNode = ifNode;
            this._currentCond = ifNode;
            return this;
        }
        Else(method) {
            this._currentCond.elseNode = new ShaderNode(method);
            return this;
        }
        Switch(expression) {
            this._expressionNode = nodeObject(expression);
            return this;
        }
        Case(...params) {
            const caseNodes = [];
            // extract case nodes from the parameter list
            if (params.length >= 2) {
                for (let i = 0; i < params.length - 1; i++) {
                    caseNodes.push(this._expressionNode.equal(nodeObject(params[i])));
                }
            } else {
                throw new Error('TSL: Invalid parameter length. Case() requires at least two parameters.');
            }
            // extract method
            const method = params[params.length - 1];
            const methodNode = new ShaderNode(method);
            // chain multiple cases when using Case( 1, 2, 3, () => {} )
            let caseNode = caseNodes[0];
            for (let i = 1; i < caseNodes.length; i++) {
                caseNode = caseNode.or(caseNodes[i]);
            }
            // build condition
            const condNode = select(caseNode, methodNode);
            if (this._currentCond === null) {
                this._currentCond = condNode;
                return this.add(this._currentCond);
            } else {
                this._currentCond.elseNode = condNode;
                this._currentCond = condNode;
                return this;
            }
        }
        Default(method) {
            this.Else(method);
            return this;
        }
        setup(builder) {
            const nodeProperties = builder.getNodeProperties(this);
            let index = 0;
            for (const childNode of this.getChildren()) {
                if (childNode.isVarNode && childNode.intent === true) {
                    const properties = builder.getNodeProperties(childNode);
                    if (properties.assign !== true) {
                        continue;
                    }
                }
                nodeProperties['node' + index++] = childNode;
            }
            // return a outputNode if exists or null
            return nodeProperties.outputNode || null;
        }
        build(builder, ...params) {
            const previousBuildStack = builder.currentStack;
            const previousStack = getCurrentStack();
            setCurrentStack(this);
            builder.currentStack = this;
            const buildStage = builder.buildStage;
            for (const node of this.nodes) {
                if (node.isVarNode && node.intent === true) {
                    const properties = builder.getNodeProperties(node);
                    if (properties.assign !== true) {
                        continue;
                    }
                }
                if (buildStage === 'setup') {
                    node.build(builder);
                } else if (buildStage === 'analyze') {
                    node.build(builder, this);
                } else if (buildStage === 'generate') {
                    const stages = builder.getDataFromNode(node, 'any').stages;
                    const parents = stages && stages[builder.shaderStage];
                    if (node.isVarNode && parents && parents.length === 1 && parents[0] && parents[0].isStackNode) {
                        continue; // skip var nodes that are only used in .toVarying()
                    }
                    node.build(builder, 'void');
                }
            }
            const result = this.outputNode ? this.outputNode.build(builder, ...params) : super.build(builder, ...params);
            setCurrentStack(previousStack);
            builder.currentStack = previousBuildStack;
            return result;
        }
    }
    const stack = /*@__PURE__*/ nodeProxy(StackNode).setParameterLength(0, 1);
    function getMembersLayout(members) {
        return Object.entries(members).map(([name, value]) => {
            if (typeof value === 'string') {
                return { name, type: value, atomic: false };
            }
            return { name, type: value.type, atomic: value.atomic || false };
        });
    }
    class StructTypeNode extends Node {
        static get type() {
            return 'StructTypeNode';
        }
        constructor(membersLayout, name = null) {
            super('struct');
            this.membersLayout = getMembersLayout(membersLayout);
            this.name = name;
            this.isStructLayoutNode = true;
        }
        getLength() {
            const GPU_CHUNK_BYTES = 8;
            const BYTES_PER_ELEMENT = Float32Array.BYTES_PER_ELEMENT;
            let offset = 0; // global buffer offset in bytes
            for (const member of this.membersLayout) {
                const type = member.type;
                const itemSize = getMemoryLengthFromType(type) * BYTES_PER_ELEMENT;
                const boundary = getByteBoundaryFromType(type);
                const chunkOffset = offset % GPU_CHUNK_BYTES; // offset in the current chunk
                const chunkPadding = chunkOffset % boundary; // required padding to match boundary
                const chunkStart = chunkOffset + chunkPadding; // start position in the current chunk for the data
                offset += chunkPadding;
                // Check for chunk overflow
                if (chunkStart !== 0 && (GPU_CHUNK_BYTES - chunkStart) < itemSize) {
                    // Add padding to the end of the chunk
                    offset += (GPU_CHUNK_BYTES - chunkStart);
                }
                offset += itemSize;
            }
            return (Math.ceil(offset / GPU_CHUNK_BYTES) * GPU_CHUNK_BYTES) / BYTES_PER_ELEMENT;
        }
        getMemberType(builder, name) {
            const member = this.membersLayout.find(m => m.name === name);
            return member ? member.type : 'void';
        }
        getNodeType(builder) {
            const structType = builder.getStructTypeFromNode(this, this.membersLayout, this.name);
            return structType.name;
        }
        setup(builder) {
            builder.addInclude(this);
        }
        generate(builder) {
            return this.getNodeType(builder);
        }
    }
    class StructNode extends Node {
        static get type() {
            return 'StructNode';
        }
        constructor(structLayoutNode, values) {
            super('vec3');
            this.structLayoutNode = structLayoutNode;
            this.values = values;
            this.isStructNode = true;
        }
        getNodeType(builder) {
            return this.structLayoutNode.getNodeType(builder);
        }
        getMemberType(builder, name) {
            return this.structLayoutNode.getMemberType(builder, name);
        }
        generate(builder) {
            const nodeVar = builder.getVarFromNode(this);
            const structType = nodeVar.type;
            const propertyName = builder.getPropertyName(nodeVar);
            builder.addLineFlowCode(`${propertyName} = ${builder.generateStruct(structType, this.structLayoutNode.membersLayout, this.values)}`, this);
            return nodeVar.name;
        }
    }
    const struct = (membersLayout, name = null) => {
        const structLayout = new StructTypeNode(membersLayout, name);
        const struct = (...params) => {
            let values = null;
            if (params.length > 0) {
                if (params[0].isNode) {
                    values = {};
                    const names = Object.keys(membersLayout);
                    for (let i = 0; i < params.length; i++) {
                        values[names[i]] = params[i];
                    }
                } else {
                    values = params[0];
                }
            }
            return nodeObject(new StructNode(structLayout, values));
        };
        struct.layout = structLayout;
        struct.isStruct = true;
        return struct;
    };
    class OutputStructNode extends Node {
        static get type() {
            return 'OutputStructNode';
        }
        constructor(...members) {
            super();
            this.members = members;
            this.isOutputStructNode = true;
        }
        getNodeType(builder) {
            const properties = builder.getNodeProperties(this);
            if (properties.membersLayout === undefined) {
                const members = this.members;
                const membersLayout = [];
                for (let i = 0; i < members.length; i++) {
                    const name = 'm' + i;
                    const type = members[i].getNodeType(builder);
                    membersLayout.push({ name, type, index: i });
                }
                properties.membersLayout = membersLayout;
                properties.structType = builder.getOutputStructTypeFromNode(this, properties.membersLayout);
            }
            return properties.structType.name;
        }
        generate(builder) {
            const propertyName = builder.getOutputStructName();
            const members = this.members;
            const structPrefix = propertyName !== '' ? propertyName + '.' : '';
            for (let i = 0; i < members.length; i++) {
                const snippet = members[i].build(builder);
                builder.addLineFlowCode(`${structPrefix}m${i} = ${snippet}`, this);
            }
            return propertyName;
        }
    }
    const outputStruct = /*@__PURE__*/ nodeProxy(OutputStructNode);
    function getTextureIndex(textures, name) {
        for (let i = 0; i < textures.length; i++) {
            if (textures[i].name === name) {
                return i;
            }
        }
        return -1;
    }
    class MRTNode extends OutputStructNode {
        static get type() {
            return 'MRTNode';
        }
        constructor(outputNodes) {
            super();
            this.outputNodes = outputNodes;
            this.isMRTNode = true;
        }
        has(name) {
            return this.outputNodes[name] !== undefined;
        }
        get(name) {
            return this.outputNodes[name];
        }
        merge(mrtNode) {
            const outputs = { ...this.outputNodes, ...mrtNode.outputNodes };
            return mrt(outputs);
        }
        setup(builder) {
            const outputNodes = this.outputNodes;
            const mrt = builder.renderer.getRenderTarget();
            const members = [];
            const textures = mrt.textures;
            for (const name in outputNodes) {
                const index = getTextureIndex(textures, name);
                members[index] = vec4(outputNodes[name]);
            }
            this.members = members;
            return super.setup(builder);
        }
    }
    const mrt = /*@__PURE__*/ nodeProxy(MRTNode);
    const hash = /*@__PURE__*/ Fn(([seed]) => {
        // Taken from https://www.shadertoy.com/view/XlGcRh, originally from pcg-random.org
        const state = seed.toUint().mul(747796405).add(2891336453);
        const word = state.shiftRight(state.shiftRight(28).add(4)).bitXor(state).mul(277803737);
        const result = word.shiftRight(22).bitXor(word);
        return result.toFloat().mul(1 / 2 ** 32); // Convert to range [0, 1)
    });
    const parabola = (x, k) => pow(mul(4.0, x.mul(sub(1.0, x))), k);
    const gain = (x, k) => x.lessThan(0.5) ? parabola(x.mul(2.0), k).div(2.0) : sub(1.0, parabola(mul(sub(1.0, x), 2.0), k).div(2.0));
    const pcurve = (x, a, b) => pow(div(pow(x, a), add(pow(x, a), pow(sub(1.0, x), b))), 1.0 / a);
    const sinc = (x, k) => sin(PI.mul(k.mul(x).sub(1.0))).div(PI.mul(k.mul(x).sub(1.0)));
    // https://github.com/cabbibo/glsl-tri-noise-3d

    const tri = /*@__PURE__*/ Fn(([x]) => {
        return x.fract().sub(.5).abs();
    }).setLayout({
        name: 'tri',
        type: 'float',
        inputs: [
            { name: 'x', type: 'float' }
        ]
    });
    const tri3 = /*@__PURE__*/ Fn(([p]) => {
        return vec3(tri(p.z.add(tri(p.y.mul(1.)))), tri(p.z.add(tri(p.x.mul(1.)))), tri(p.y.add(tri(p.x.mul(1.)))));
    }).setLayout({
        name: 'tri3',
        type: 'vec3',
        inputs: [
            { name: 'p', type: 'vec3' }
        ]
    });
    const triNoise3D = /*@__PURE__*/ Fn(([position, speed, time]) => {
        const p = vec3(position).toVar();
        const z = float(1.4).toVar();
        const rz = float(0.0).toVar();
        const bp = vec3(p).toVar();
        Loop({ start: float(0.0), end: float(3.0), type: 'float', condition: '<=' }, () => {
            const dg = vec3(tri3(bp.mul(2.0))).toVar();
            p.addAssign(dg.add(time.mul(float(0.1).mul(speed))));
            bp.mulAssign(1.8);
            z.mulAssign(1.5);
            p.mulAssign(1.2);
            const t = float(tri(p.z.add(tri(p.x.add(tri(p.y)))))).toVar();
            rz.addAssign(t.div(z));
            bp.addAssign(0.14);
        });
        return rz;
    }).setLayout({
        name: 'triNoise3D',
        type: 'float',
        inputs: [
            { name: 'position', type: 'vec3' },
            { name: 'speed', type: 'float' },
            { name: 'time', type: 'float' }
        ]
    });
    class FunctionOverloadingNode extends Node {
        static get type() {
            return 'FunctionOverloadingNode';
        }
        constructor(functionNodes = [], ...parametersNodes) {
            super();
            this.functionNodes = functionNodes;
            this.parametersNodes = parametersNodes;
            this._candidateFnCall = null;
            this.global = true;
        }
        getNodeType() {
            return this.functionNodes[0].shaderNode.layout.type;
        }
        setup(builder) {
            const params = this.parametersNodes;
            let candidateFnCall = this._candidateFnCall;
            if (candidateFnCall === null) {
                let candidateFn = null;
                let candidateScore = -1;
                for (const functionNode of this.functionNodes) {
                    const shaderNode = functionNode.shaderNode;
                    const layout = shaderNode.layout;
                    if (layout === null) {
                        throw new Error('FunctionOverloadingNode: FunctionNode must be a layout.');
                    }
                    const inputs = layout.inputs;
                    if (params.length === inputs.length) {
                        let score = 0;
                        for (let i = 0; i < params.length; i++) {
                            const param = params[i];
                            const input = inputs[i];
                            if (param.getNodeType(builder) === input.type) {
                                score++;
                            } else {
                                score = 0;
                            }
                        }
                        if (score > candidateScore) {
                            candidateFn = functionNode;
                            candidateScore = score;
                        }
                    }
                }
                this._candidateFnCall = candidateFnCall = candidateFn(...params);
            }
            return candidateFnCall;
        }
    }
    const overloadingBaseFn = /*@__PURE__*/ nodeProxy(FunctionOverloadingNode);
    const overloadingFn = (functionNodes) => (...params) => overloadingBaseFn(functionNodes, ...params);
    const time = /*@__PURE__*/ uniform(0).setGroup(renderGroup).onRenderUpdate((frame) => frame.time);
    const deltaTime = /*@__PURE__*/ uniform(0).setGroup(renderGroup).onRenderUpdate((frame) => frame.deltaTime);
    const frameId = /*@__PURE__*/ uniform(0, 'uint').setGroup(renderGroup).onRenderUpdate((frame) => frame.frameId);
    // Deprecated
    const timerLocal = (timeScale = 1) => { // @deprecated, r170
        console.warn('TSL: timerLocal() is deprecated. Use "time" instead.');
        return time.mul(timeScale);
    };
    const timerGlobal = (timeScale = 1) => { // @deprecated, r170
        console.warn('TSL: timerGlobal() is deprecated. Use "time" instead.');
        return time.mul(timeScale);
    };
    const timerDelta = (timeScale = 1) => { // @deprecated, r170
        console.warn('TSL: timerDelta() is deprecated. Use "deltaTime" instead.');
        return deltaTime.mul(timeScale);
    };
    const oscSine = (t = time) => t.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5);
    const oscSquare = (t = time) => t.fract().round();
    const oscTriangle = (t = time) => t.add(0.5).fract().mul(2).sub(1).abs();
    const oscSawtooth = (t = time) => t.fract();
    const rotateUV = /*@__PURE__*/ Fn(([uv, rotation, center = vec2(0.5)]) => {
        return rotate(uv.sub(center), rotation).add(center);
    });
    const spherizeUV = /*@__PURE__*/ Fn(([uv, strength, center = vec2(0.5)]) => {
        const delta = uv.sub(center);
        const delta2 = delta.dot(delta);
        const delta4 = delta2.mul(delta2);
        const deltaOffset = delta4.mul(strength);
        return uv.add(delta.mul(deltaOffset));
    });
    const billboarding = /*@__PURE__*/ Fn(({ position = null, horizontal = true, vertical = false }) => {
        let worldMatrix;
        if (position !== null) {
            worldMatrix = modelWorldMatrix.toVar();
            worldMatrix[3][0] = position.x;
            worldMatrix[3][1] = position.y;
            worldMatrix[3][2] = position.z;
        } else {
            worldMatrix = modelWorldMatrix;
        }
        const modelViewMatrix = cameraViewMatrix.mul(worldMatrix);
        if (defined(horizontal)) {
            modelViewMatrix[0][0] = modelWorldMatrix[0].length();
            modelViewMatrix[0][1] = 0;
            modelViewMatrix[0][2] = 0;
        }
        if (defined(vertical)) {
            modelViewMatrix[1][0] = 0;
            modelViewMatrix[1][1] = modelWorldMatrix[1].length();
            modelViewMatrix[1][2] = 0;
        }
        modelViewMatrix[2][0] = 0;
        modelViewMatrix[2][1] = 0;
        modelViewMatrix[2][2] = 1;
        return cameraProjectionMatrix.mul(modelViewMatrix).mul(positionLocal);
    });
    const viewportSafeUV = /*@__PURE__*/ Fn(([uv = null]) => {
        const depth = linearDepth();
        const depthDiff = linearDepth(viewportDepthTexture(uv)).sub(depth);
        const finalUV = depthDiff.lessThan(0).select(screenUV, uv);
        return finalUV;
    });
    class SpriteSheetUVNode extends Node {
        static get type() {
            return 'SpriteSheetUVNode';
        }
        constructor(countNode, uvNode = uv(), frameNode = float(0)) {
            super('vec2');
            this.countNode = countNode;
            this.uvNode = uvNode;
            this.frameNode = frameNode;
        }
        setup() {
            const { frameNode, uvNode, countNode } = this;
            const { width, height } = countNode;
            const frameNum = frameNode.mod(width.mul(height)).floor();
            const column = frameNum.mod(width);
            const row = height.sub(frameNum.add(1).div(width).ceil());
            const scale = countNode.reciprocal();
            const uvFrameOffset = vec2(column, row);
            return uvNode.add(uvFrameOffset).mul(scale);
        }
    }
    const spritesheetUV = /*@__PURE__*/ nodeProxy(SpriteSheetUVNode).setParameterLength(3);
    const triplanarTextures = /*@__PURE__*/ Fn(([textureXNode, textureYNode = null, textureZNode = null, scaleNode = float(1), positionNode = positionLocal, normalNode = normalLocal]) => {
        // Reference: https://github.com/keijiro/StandardTriplanar
        // Blending factor of triplanar mapping
        let bf = normalNode.abs().normalize();
        bf = bf.div(bf.dot(vec3(1.0)));
        // Triplanar mapping
        const tx = positionNode.yz.mul(scaleNode);
        const ty = positionNode.zx.mul(scaleNode);
        const tz = positionNode.xy.mul(scaleNode);
        // Base color
        const textureX = textureXNode.value;
        const textureY = textureYNode !== null ? textureYNode.value : textureX;
        const textureZ = textureZNode !== null ? textureZNode.value : textureX;
        const cx = texture(textureX, tx).mul(bf.x);
        const cy = texture(textureY, ty).mul(bf.y);
        const cz = texture(textureZ, tz).mul(bf.z);
        return add(cx, cy, cz);
    });
    const triplanarTexture = (...params) => triplanarTextures(...params);
    const _reflectorPlane = new Plane();
    const _normal$2 = new Vector3();
    const _reflectorWorldPosition = new Vector3();
    const _cameraWorldPosition = new Vector3();
    const _rotationMatrix = new Matrix4();
    const _lookAtPosition = new Vector3(0, 0, -1);
    const clipPlane = new Vector4();
    const _view = new Vector3();
    const _target$1 = new Vector3();
    const _q = new Vector4();
    const _size$2 = new Vector2();
    const _defaultRT = new RenderTarget();
    const _defaultUV = screenUV.flipX();
    _defaultRT.depthTexture = new DepthTexture(1, 1);
    let _inReflector = false;
    class ReflectorNode extends TextureNode {
        static get type() {
            return 'ReflectorNode';
        }
        constructor(parameters = {}) {
            super(parameters.defaultTexture || _defaultRT.texture, _defaultUV);
            this._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode(this, parameters);
            this._depthNode = null;
            this.setUpdateMatrix(false);
        }
        get reflector() {
            return this._reflectorBaseNode;
        }
        get target() {
            return this._reflectorBaseNode.target;
        }
        getDepthNode() {
            if (this._depthNode === null) {
                if (this._reflectorBaseNode.depth !== true) {
                    throw new Error('THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ');
                }
                this._depthNode = nodeObject(new ReflectorNode({
                    defaultTexture: _defaultRT.depthTexture,
                    reflector: this._reflectorBaseNode
                }));
            }
            return this._depthNode;
        }
        setup(builder) {
            // ignore if used in post-processing
            if (!builder.object.isQuadMesh) this._reflectorBaseNode.build(builder);
            return super.setup(builder);
        }
        clone() {
            const newNode = new this.constructor(this.reflectorNode);
            newNode.uvNode = this.uvNode;
            newNode.levelNode = this.levelNode;
            newNode.biasNode = this.biasNode;
            newNode.sampler = this.sampler;
            newNode.depthNode = this.depthNode;
            newNode.compareNode = this.compareNode;
            newNode.gradNode = this.gradNode;
            newNode._reflectorBaseNode = this._reflectorBaseNode;
            return newNode;
        }
        dispose() {
            super.dispose();
            this._reflectorBaseNode.dispose();
        }
    }
    class ReflectorBaseNode extends Node {
        static get type() {
            return 'ReflectorBaseNode';
        }
        constructor(textureNode, parameters = {}) {
            super();
            const {
                target = new Object3D(),
                resolution = 1,
                generateMipmaps = false,
                bounces = true,
                depth = false
            } = parameters;
            this.textureNode = textureNode;
            this.target = target;
            this.resolution = resolution;
            this.generateMipmaps = generateMipmaps;
            this.bounces = bounces;
            this.depth = depth;
            this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;
            this.virtualCameras = new WeakMap();
            this.renderTargets = new Map();
            this.forceUpdate = false;
            this.hasOutput = false;
        }
        _updateResolution(renderTarget, renderer) {
            const resolution = this.resolution;
            renderer.getDrawingBufferSize(_size$2);
            renderTarget.setSize(Math.round(_size$2.width * resolution), Math.round(_size$2.height * resolution));
        }
        setup(builder) {
            this._updateResolution(_defaultRT, builder.renderer);
            return super.setup(builder);
        }
        dispose() {
            super.dispose();
            for (const renderTarget of this.renderTargets.values()) {
                renderTarget.dispose();
            }
        }
        getVirtualCamera(camera) {
            let virtualCamera = this.virtualCameras.get(camera);
            if (virtualCamera === undefined) {
                virtualCamera = camera.clone();
                this.virtualCameras.set(camera, virtualCamera);
            }
            return virtualCamera;
        }
        getRenderTarget(camera) {
            let renderTarget = this.renderTargets.get(camera);
            if (renderTarget === undefined) {
                renderTarget = new RenderTarget(0, 0, { type: HalfFloatType });
                if (this.generateMipmaps === true) {
                    renderTarget.texture.minFilter = LinearMipMapLinearFilter;
                    renderTarget.texture.generateMipmaps = true;
                }
                if (this.depth === true) {
                    renderTarget.depthTexture = new DepthTexture();
                }
                this.renderTargets.set(camera, renderTarget);
            }
            return renderTarget;
        }
        updateBefore(frame) {
            if (this.bounces === false && _inReflector) return false;
            _inReflector = true;
            const { scene, camera, renderer, material } = frame;
            const { target } = this;
            const virtualCamera = this.getVirtualCamera(camera);
            const renderTarget = this.getRenderTarget(virtualCamera);
            renderer.getDrawingBufferSize(_size$2);
            this._updateResolution(renderTarget, renderer);
            //
            _reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);
            _cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
            _rotationMatrix.extractRotation(target.matrixWorld);
            _normal$2.set(0, 0, 1);
            _normal$2.applyMatrix4(_rotationMatrix);
            _view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);
            // Avoid rendering when reflector is facing away unless forcing an update
            const isFacingAway = _view.dot(_normal$2) > 0;
            let needsClear = false;
            if (isFacingAway === true && this.forceUpdate === false) {
                if (this.hasOutput === false) {
                    _inReflector = false;
                    return;
                }
                needsClear = true;
            }
            _view.reflect(_normal$2).negate();
            _view.add(_reflectorWorldPosition);
            _rotationMatrix.extractRotation(camera.matrixWorld);
            _lookAtPosition.set(0, 0, -1);
            _lookAtPosition.applyMatrix4(_rotationMatrix);
            _lookAtPosition.add(_cameraWorldPosition);
            _target$1.subVectors(_reflectorWorldPosition, _lookAtPosition);
            _target$1.reflect(_normal$2).negate();
            _target$1.add(_reflectorWorldPosition);
            //
            virtualCamera.coordinateSystem = camera.coordinateSystem;
            virtualCamera.position.copy(_view);
            virtualCamera.up.set(0, 1, 0);
            virtualCamera.up.applyMatrix4(_rotationMatrix);
            virtualCamera.up.reflect(_normal$2);
            virtualCamera.lookAt(_target$1);
            virtualCamera.near = camera.near;
            virtualCamera.far = camera.far;
            virtualCamera.updateMatrixWorld();
            virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
            // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
            // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
            _reflectorPlane.setFromNormalAndCoplanarPoint(_normal$2, _reflectorWorldPosition);
            _reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
            clipPlane.set(_reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant);
            const projectionMatrix = virtualCamera.projectionMatrix;
            _q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
            _q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
            _q.z = -1;
            _q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
            // Calculate the scaled plane vector
            clipPlane.multiplyScalar(1.0 / clipPlane.dot(_q));
            const clipBias = 0;
            // Replacing the third row of the projection matrix
            projectionMatrix.elements[2] = clipPlane.x;
            projectionMatrix.elements[6] = clipPlane.y;
            projectionMatrix.elements[10] = (renderer.coordinateSystem === WebGPUCoordinateSystem) ? (clipPlane.z - clipBias) : (clipPlane.z + 1.0 - clipBias);
            projectionMatrix.elements[14] = clipPlane.w;
            //
            this.textureNode.value = renderTarget.texture;
            if (this.depth === true) {
                this.textureNode.getDepthNode().value = renderTarget.depthTexture;
            }
            material.visible = false;
            const currentRenderTarget = renderer.getRenderTarget();
            const currentMRT = renderer.getMRT();
            const currentAutoClear = renderer.autoClear;
            renderer.setMRT(null);
            renderer.setRenderTarget(renderTarget);
            renderer.autoClear = true;
            if (needsClear) {
                renderer.clear();
                this.hasOutput = false;
            } else {
                renderer.render(scene, virtualCamera);
                this.hasOutput = true;
            }
            renderer.setMRT(currentMRT);
            renderer.setRenderTarget(currentRenderTarget);
            renderer.autoClear = currentAutoClear;
            material.visible = true;
            _inReflector = false;
            this.forceUpdate = false;
        }
    }
    const reflector = (parameters) => nodeObject(new ReflectorNode(parameters));
    const _camera$1 = /*@__PURE__*/ new OrthographicCamera(-1, 1, 1, -1, 0, 1);
    class QuadGeometry extends BufferGeometry {
        constructor(flipY = false) {
            super();
            const uv = flipY === false ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
            this.setAttribute('position', new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
            this.setAttribute('uv', new Float32BufferAttribute(uv, 2));
        }
    }
    const _geometry$1 = /*@__PURE__*/ new QuadGeometry();

    class QuadMesh extends Mesh {
        constructor(material = null) {
            super(_geometry$1, material);
            this.camera = _camera$1;
            this.isQuadMesh = true;
        }
        async renderAsync(renderer) {
            return renderer.renderAsync(this, _camera$1);
        }
        render(renderer) {
            renderer.render(this, _camera$1);
        }
    }
    const _size$1 = /*@__PURE__*/ new Vector2();
    class RTTNode extends TextureNode {
        static get type() {
            return 'RTTNode';
        }
        constructor(node, width = null, height = null, options = { type: HalfFloatType }) {
            const renderTarget = new RenderTarget(width, height, options);
            super(renderTarget.texture, uv());
            this.isRTTNode = true;
            this.node = node;
            this.width = width;
            this.height = height;
            this.pixelRatio = 1;
            this.renderTarget = renderTarget;
            this.textureNeedsUpdate = true;
            this.autoUpdate = true;
            this._rttNode = null;
            this._quadMesh = new QuadMesh(new NodeMaterial());
            this.updateBeforeType = NodeUpdateType.RENDER;
        }
        get autoResize() {
            return this.width === null;
        }
        setup(builder) {
            this._rttNode = this.node.context(builder.getSharedContext());
            this._quadMesh.material.name = 'RTT';
            this._quadMesh.material.needsUpdate = true;
            return super.setup(builder);
        }
        setSize(width, height) {
            this.width = width;
            this.height = height;
            const effectiveWidth = width * this.pixelRatio;
            const effectiveHeight = height * this.pixelRatio;
            this.renderTarget.setSize(effectiveWidth, effectiveHeight);
            this.textureNeedsUpdate = true;
        }
        setPixelRatio(pixelRatio) {
            this.pixelRatio = pixelRatio;
            this.setSize(this.width, this.height);
        }
        updateBefore({ renderer }) {
            if (this.textureNeedsUpdate === false && this.autoUpdate === false) return;
            this.textureNeedsUpdate = false;
            //
            if (this.autoResize === true) {
                const pixelRatio = renderer.getPixelRatio();
                const size = renderer.getSize(_size$1);
                const effectiveWidth = size.width * pixelRatio;
                const effectiveHeight = size.height * pixelRatio;
                if (effectiveWidth !== this.renderTarget.width || effectiveHeight !== this.renderTarget.height) {
                    this.renderTarget.setSize(effectiveWidth, effectiveHeight);
                    this.textureNeedsUpdate = true;
                }
            }
            //
            this._quadMesh.material.fragmentNode = this._rttNode;
            //
            const currentRenderTarget = renderer.getRenderTarget();
            renderer.setRenderTarget(this.renderTarget);
            this._quadMesh.render(renderer);
            renderer.setRenderTarget(currentRenderTarget);
        }
        clone() {
            const newNode = new TextureNode(this.value, this.uvNode, this.levelNode);
            newNode.sampler = this.sampler;
            newNode.referenceNode = this;
            return newNode;
        }
    }
    const rtt = (node, ...params) => nodeObject(new RTTNode(nodeObject(node), ...params));
    const convertToTexture = (node, ...params) => {
        if (node.isTextureNode) return node;
        if (node.isPassNode) return node.getTextureNode();
        return rtt(node, ...params);
    };
    const getViewPosition = /*@__PURE__*/ Fn(([screenPosition, depth, projectionMatrixInverse], builder) => {
        let clipSpacePosition;
        if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {
            screenPosition = vec2(screenPosition.x, screenPosition.y.oneMinus()).mul(2.0).sub(1.0);
            clipSpacePosition = vec4(vec3(screenPosition, depth), 1.0);
        } else {
            clipSpacePosition = vec4(vec3(screenPosition.x, screenPosition.y.oneMinus(), depth).mul(2.0).sub(1.0), 1.0);
        }
        const viewSpacePosition = vec4(projectionMatrixInverse.mul(clipSpacePosition));
        return viewSpacePosition.xyz.div(viewSpacePosition.w);
    });
    const getScreenPosition = /*@__PURE__*/ Fn(([viewPosition, projectionMatrix]) => {
        const sampleClipPos = projectionMatrix.mul(vec4(viewPosition, 1.0));
        const sampleUv = sampleClipPos.xy.div(sampleClipPos.w).mul(0.5).add(0.5).toVar();
        return vec2(sampleUv.x, sampleUv.y.oneMinus());
    });
    const getNormalFromDepth = /*@__PURE__*/ Fn(([uv, depthTexture, projectionMatrixInverse]) => {
        const size = textureSize(textureLoad(depthTexture));
        const p = ivec2(uv.mul(size)).toVar();
        const c0 = textureLoad(depthTexture, p).toVar();
        const l2 = textureLoad(depthTexture, p.sub(ivec2(2, 0))).toVar();
        const l1 = textureLoad(depthTexture, p.sub(ivec2(1, 0))).toVar();
        const r1 = textureLoad(depthTexture, p.add(ivec2(1, 0))).toVar();
        const r2 = textureLoad(depthTexture, p.add(ivec2(2, 0))).toVar();
        const b2 = textureLoad(depthTexture, p.add(ivec2(0, 2))).toVar();
        const b1 = textureLoad(depthTexture, p.add(ivec2(0, 1))).toVar();
        const t1 = textureLoad(depthTexture, p.sub(ivec2(0, 1))).toVar();
        const t2 = textureLoad(depthTexture, p.sub(ivec2(0, 2))).toVar();
        const dl = abs(sub(float(2).mul(l1).sub(l2), c0)).toVar();
        const dr = abs(sub(float(2).mul(r1).sub(r2), c0)).toVar();
        const db = abs(sub(float(2).mul(b1).sub(b2), c0)).toVar();
        const dt = abs(sub(float(2).mul(t1).sub(t2), c0)).toVar();
        const ce = getViewPosition(uv, c0, projectionMatrixInverse).toVar();
        const dpdx = dl.lessThan(dr).select(ce.sub(getViewPosition(uv.sub(vec2(float(1).div(size.x), 0)), l1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv.add(vec2(float(1).div(size.x), 0)), r1, projectionMatrixInverse)));
        const dpdy = db.lessThan(dt).select(ce.sub(getViewPosition(uv.add(vec2(0, float(1).div(size.y))), b1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv.sub(vec2(0, float(1).div(size.y))), t1, projectionMatrixInverse)));
        return normalize(cross(dpdx, dpdy));
    });
    class SampleNode extends Node {
        static get type() {
            return 'SampleNode';
        }
        constructor(callback) {
            super();
            this.callback = callback;
            this.isSampleNode = true;
        }
        setup() {
            return this.sample(uv());
        }
        sample(uv) {
            return this.callback(uv);
        }
    }
    const sample = (callback) => nodeObject(new SampleNode(callback));
    class EventNode extends Node {
        static get type() {
            return 'EventNode';
        }
        constructor(eventType, callback) {
            super('void');
            this.eventType = eventType;
            this.callback = callback;
            if (eventType === EventNode.OBJECT) {
                this.updateType = NodeUpdateType.OBJECT;
            } else if (eventType === EventNode.MATERIAL) {
                this.updateType = NodeUpdateType.RENDER;
            }
        }
        update(frame) {
            this.callback(frame);
        }
    }
    EventNode.OBJECT = 'object';
    EventNode.MATERIAL = 'material';
    const createEvent = (type, callback) => nodeObject(new EventNode(type, callback)).toStack();
    const OnObjectUpdate = (callback) => createEvent(EventNode.OBJECT, callback);
    const OnMaterialUpdate = (callback) => createEvent(EventNode.MATERIAL, callback);
    class StorageInstancedBufferAttribute extends InstancedBufferAttribute {
        constructor(count, itemSize, typeClass = Float32Array) {
            const array = ArrayBuffer.isView(count) ? count : new typeClass(count * itemSize);
            super(array, itemSize);
            this.isStorageInstancedBufferAttribute = true;
        }
    }
    class StorageBufferAttribute extends BufferAttribute {
        constructor(count, itemSize, typeClass = Float32Array) {
            const array = ArrayBuffer.isView(count) ? count : new typeClass(count * itemSize);
            super(array, itemSize);
            this.isStorageBufferAttribute = true;
        }
    }
    const attributeArray = (count, type = 'float') => {
        let itemSize, typedArray;
        if (type.isStruct === true) {
            itemSize = type.layout.getLength();
            typedArray = getTypedArrayFromType('float');
        } else {
            itemSize = getLengthFromType(type);
            typedArray = getTypedArrayFromType(type);
        }
        const buffer = new StorageBufferAttribute(count, itemSize, typedArray);
        const node = storage(buffer, type, count);
        return node;
    };
    const instancedArray = (count, type = 'float') => {
        let itemSize, typedArray;
        if (type.isStruct === true) {
            itemSize = type.layout.getLength();
            typedArray = getTypedArrayFromType('float');
        } else {
            itemSize = getLengthFromType(type);
            typedArray = getTypedArrayFromType(type);
        }
        const buffer = new StorageInstancedBufferAttribute(count, itemSize, typedArray);
        const node = storage(buffer, type, count);
        return node;
    };
    class PointUVNode extends Node {
        static get type() {
            return 'PointUVNode';
        }
        constructor() {
            super('vec2');
            this.isPointUVNode = true;
        }
        generate( /*builder*/) {
            return 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';
        }
    }
    const pointUV = /*@__PURE__*/ nodeImmutable(PointUVNode);
    const _e1 = /*@__PURE__*/ new Euler();
    const _m1$4 = /*@__PURE__*/ new Matrix4();
    class SceneNode extends Node {
        static get type() {
            return 'SceneNode';
        }
        constructor(scope = SceneNode.BACKGROUND_BLURRINESS, scene = null) {
            super();
            this.scope = scope;
            this.scene = scene;
        }
        setup(builder) {
            const scope = this.scope;
            const scene = this.scene !== null ? this.scene : builder.scene;
            let output;
            if (scope === SceneNode.BACKGROUND_BLURRINESS) {
                output = reference('backgroundBlurriness', 'float', scene);
            } else if (scope === SceneNode.BACKGROUND_INTENSITY) {
                output = reference('backgroundIntensity', 'float', scene);
            } else if (scope === SceneNode.BACKGROUND_ROTATION) {
                output = uniform('mat4').setName('backgroundRotation').setGroup(renderGroup).onRenderUpdate(() => {
                    const background = scene.background;
                    if (background !== null && background.isTexture && background.mapping !== UVMapping) {
                        _e1.copy(scene.backgroundRotation);
                        // accommodate left-handed frame
                        _e1.x *= -1; _e1.y *= -1; _e1.z *= -1;
                        _m1$4.makeRotationFromEuler(_e1);
                    } else {
                        _m1$4.identity();
                    }
                    return _m1$4;
                });
            } else {
                console.error('THREE.SceneNode: Unknown scope:', scope);
            }
            return output;
        }
    }
    SceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';
    SceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';
    SceneNode.BACKGROUND_ROTATION = 'backgroundRotation';
    const backgroundBlurriness = /*@__PURE__*/ nodeImmutable(SceneNode, SceneNode.BACKGROUND_BLURRINESS);
    const backgroundIntensity = /*@__PURE__*/ nodeImmutable(SceneNode, SceneNode.BACKGROUND_INTENSITY);
    const backgroundRotation = /*@__PURE__*/ nodeImmutable(SceneNode, SceneNode.BACKGROUND_ROTATION);
    class StorageTextureNode extends TextureNode {
        static get type() {
            return 'StorageTextureNode';
        }
        constructor(value, uvNode, storeNode = null) {
            super(value, uvNode);
            this.storeNode = storeNode;
            this.isStorageTextureNode = true;
            this.access = NodeAccess.WRITE_ONLY;
        }
        getInputType( /*builder*/) {
            return 'storageTexture';
        }
        setup(builder) {
            super.setup(builder);
            const properties = builder.getNodeProperties(this);
            properties.storeNode = this.storeNode;
            return properties;
        }
        setAccess(value) {
            this.access = value;
            return this;
        }
        generate(builder, output) {
            let snippet;
            if (this.storeNode !== null) {
                snippet = this.generateStore(builder);
            } else {
                snippet = super.generate(builder, output);
            }
            return snippet;
        }
        toReadWrite() {
            return this.setAccess(NodeAccess.READ_WRITE);
        }
        toReadOnly() {
            return this.setAccess(NodeAccess.READ_ONLY);
        }
        toWriteOnly() {
            return this.setAccess(NodeAccess.WRITE_ONLY);
        }
        generateStore(builder) {
            const properties = builder.getNodeProperties(this);
            const { uvNode, storeNode, depthNode } = properties;
            const textureProperty = super.generate(builder, 'property');
            const uvSnippet = uvNode.build(builder, this.value.is3DTexture === true ? 'uvec3' : 'uvec2');
            const storeSnippet = storeNode.build(builder, 'vec4');
            const depthSnippet = depthNode ? depthNode.build(builder, 'int') : null;
            const snippet = builder.generateTextureStore(builder, textureProperty, uvSnippet, depthSnippet, storeSnippet);
            builder.addLineFlowCode(snippet, this);
        }
        clone() {
            const newNode = super.clone();
            newNode.storeNode = this.storeNode;
            return newNode;
        }
    }
    const storageTexture = /*@__PURE__*/ nodeProxy(StorageTextureNode).setParameterLength(1, 3);

    const textureStore = (value, uvNode, storeNode) => {
        const node = storageTexture(value, uvNode, storeNode);
        if (storeNode !== null) node.toStack();
        return node;
    };
    const normal = Fn(({ texture, uv }) => {
        const epsilon = 0.0001;
        const ret = vec3().toVar();
        If(uv.x.lessThan(epsilon), () => {
            ret.assign(vec3(1, 0, 0));
        }).ElseIf(uv.y.lessThan(epsilon), () => {
            ret.assign(vec3(0, 1, 0));
        }).ElseIf(uv.z.lessThan(epsilon), () => {
            ret.assign(vec3(0, 0, 1));
        }).ElseIf(uv.x.greaterThan(1 - epsilon), () => {
            ret.assign(vec3(-1, 0, 0));
        }).ElseIf(uv.y.greaterThan(1 - epsilon), () => {
            ret.assign(vec3(0, -1, 0));
        }).ElseIf(uv.z.greaterThan(1 - epsilon), () => {
            ret.assign(vec3(0, 0, -1));
        }).Else(() => {
            const step = 0.01;
            const x = texture.sample(uv.add(vec3(- step, 0.0, 0.0))).r.sub(texture.sample(uv.add(vec3(step, 0.0, 0.0))).r);
            const y = texture.sample(uv.add(vec3(0.0, - step, 0.0))).r.sub(texture.sample(uv.add(vec3(0.0, step, 0.0))).r);
            const z = texture.sample(uv.add(vec3(0.0, 0.0, - step))).r.sub(texture.sample(uv.add(vec3(0.0, 0.0, step))).r);
            ret.assign(vec3(x, y, z));
        });
        return ret.normalize();
    });
    class Texture3DNode extends TextureNode {
        static get type() {
            return 'Texture3DNode';
        }
        constructor(value, uvNode = null, levelNode = null) {
            super(value, uvNode, levelNode);
            this.isTexture3DNode = true;
        }
        getInputType( /*builder*/) {
            return 'texture3D';
        }
        getDefaultUV() {
            return vec3(0.5, 0.5, 0.5);
        }
        setUpdateMatrix( /*value*/) { } // Ignore .updateMatrix for 3d TextureNode
        setupUV(builder, uvNode) {
            const texture = this.value;
            if (builder.isFlipY() && (texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true)) {
                if (this.sampler) {
                    uvNode = uvNode.flipY();
                } else {
                    uvNode = uvNode.setY(int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1));
                }
            }
            return uvNode;
        }
        generateUV(builder, uvNode) {
            return uvNode.build(builder, 'vec3');
        }
        normal(uvNode) {
            return normal({ texture: this, uv: uvNode });
        }
    }
    const texture3D = /*@__PURE__*/ nodeProxy(Texture3DNode).setParameterLength(1, 3);
    class UserDataNode extends ReferenceNode {
        static get type() {
            return 'UserDataNode';
        }
        constructor(property, inputType, userData = null) {
            super(property, inputType, userData);
            this.userData = userData;
        }
        updateReference(state) {
            this.reference = this.userData !== null ? this.userData : state.object.userData;
            return this.reference;
        }
    }
    const userData = (name, inputType, userData) => nodeObject(new UserDataNode(name, inputType, userData));
    const _objectData = new WeakMap();
    class VelocityNode extends TempNode {
        static get type() {
            return 'VelocityNode';
        }
        constructor() {
            super('vec2');
            this.projectionMatrix = null;
            this.updateType = NodeUpdateType.OBJECT;
            this.updateAfterType = NodeUpdateType.OBJECT;
            this.previousModelWorldMatrix = uniform(new Matrix4());
            this.previousProjectionMatrix = uniform(new Matrix4()).setGroup(renderGroup);
            this.previousCameraViewMatrix = uniform(new Matrix4());
        }
        setProjectionMatrix(projectionMatrix) {
            this.projectionMatrix = projectionMatrix;
        }
        update({ frameId, camera, object }) {
            const previousModelMatrix = getPreviousMatrix(object);
            this.previousModelWorldMatrix.value.copy(previousModelMatrix);
            //
            const cameraData = getData(camera);
            if (cameraData.frameId !== frameId) {
                cameraData.frameId = frameId;
                if (cameraData.previousProjectionMatrix === undefined) {
                    cameraData.previousProjectionMatrix = new Matrix4();
                    cameraData.previousCameraViewMatrix = new Matrix4();
                    cameraData.currentProjectionMatrix = new Matrix4();
                    cameraData.currentCameraViewMatrix = new Matrix4();
                    cameraData.previousProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);
                    cameraData.previousCameraViewMatrix.copy(camera.matrixWorldInverse);
                } else {
                    cameraData.previousProjectionMatrix.copy(cameraData.currentProjectionMatrix);
                    cameraData.previousCameraViewMatrix.copy(cameraData.currentCameraViewMatrix);
                }
                cameraData.currentProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);
                cameraData.currentCameraViewMatrix.copy(camera.matrixWorldInverse);
                this.previousProjectionMatrix.value.copy(cameraData.previousProjectionMatrix);
                this.previousCameraViewMatrix.value.copy(cameraData.previousCameraViewMatrix);
            }
        }
        updateAfter({ object }) {
            getPreviousMatrix(object).copy(object.matrixWorld);
        }
        setup( /*builder*/) {
            const projectionMatrix = (this.projectionMatrix === null) ? cameraProjectionMatrix : uniform(this.projectionMatrix);
            const previousModelViewMatrix = this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix);
            const clipPositionCurrent = projectionMatrix.mul(modelViewMatrix).mul(positionLocal);
            const clipPositionPrevious = this.previousProjectionMatrix.mul(previousModelViewMatrix).mul(positionPrevious);
            const ndcPositionCurrent = clipPositionCurrent.xy.div(clipPositionCurrent.w);
            const ndcPositionPrevious = clipPositionPrevious.xy.div(clipPositionPrevious.w);
            const velocity = sub(ndcPositionCurrent, ndcPositionPrevious);
            return velocity;
        }
    }
    function getData(object) {
        let objectData = _objectData.get(object);
        if (objectData === undefined) {
            objectData = {};
            _objectData.set(object, objectData);
        }
        return objectData;
    }
    function getPreviousMatrix(object, index = 0) {
        const objectData = getData(object);
        let matrix = objectData[index];
        if (matrix === undefined) {
            objectData[index] = matrix = new Matrix4();
            objectData[index].copy(object.matrixWorld);
        }
        return matrix;
    }
    const velocity = /*@__PURE__*/ nodeImmutable(VelocityNode);
    const grayscale = /*@__PURE__*/ Fn(([color]) => {
        return luminance(color.rgb);
    });
    const saturation = /*@__PURE__*/ Fn(([color, adjustment = float(1)]) => {
        return adjustment.mix(luminance(color.rgb), color.rgb);
    });
    const vibrance = /*@__PURE__*/ Fn(([color, adjustment = float(1)]) => {
        const average = add(color.r, color.g, color.b).div(3.0);
        const mx = color.r.max(color.g.max(color.b));
        const amt = mx.sub(average).mul(adjustment).mul(-3);
        return mix(color.rgb, mx, amt);
    });
    const hue = /*@__PURE__*/ Fn(([color, adjustment = float(1)]) => {
        const k = vec3(0.57735, 0.57735, 0.57735);
        const cosAngle = adjustment.cos();
        return vec3(color.rgb.mul(cosAngle).add(k.cross(color.rgb).mul(adjustment.sin()).add(k.mul(dot(k, color.rgb).mul(cosAngle.oneMinus())))));
    });
    const luminance = (
        color,
        luminanceCoefficients = vec3(ColorManagement.getLuminanceCoefficients(new Vector3()))
    ) => dot(color, luminanceCoefficients);
    const cdl = /*@__PURE__*/ Fn(([
        color,
        slope = vec3(1),
        offset = vec3(0),
        power = vec3(1),
        saturation = float(1),
        // ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.
        luminanceCoefficients = vec3(ColorManagement.getLuminanceCoefficients(new Vector3(), LinearSRGBColorSpace))
    ]) => {
        // NOTE: The ASC CDL v1.2 defines a [0, 1] clamp on the slope+offset term, and another on the
        // saturation term. Per the ACEScc specification and Filament, limits may be omitted to support
        // values outside [0, 1], requiring a workaround for negative values in the power expression.
        const luma = color.rgb.dot(vec3(luminanceCoefficients));
        const v = max$1(color.rgb.mul(slope).add(offset), 0.0).toVar();
        const pv = v.pow(power).toVar();
        If(v.r.greaterThan(0.0), () => { v.r.assign(pv.r); }); // eslint-disable-line
        If(v.g.greaterThan(0.0), () => { v.g.assign(pv.g); }); // eslint-disable-line
        If(v.b.greaterThan(0.0), () => { v.b.assign(pv.b); }); // eslint-disable-line
        v.assign(luma.add(v.sub(luma).mul(saturation)));
        return vec4(v.rgb, color.a);
    });
    class PosterizeNode extends TempNode {
        static get type() {
            return 'PosterizeNode';
        }
        constructor(sourceNode, stepsNode) {
            super();
            this.sourceNode = sourceNode;
            this.stepsNode = stepsNode;
        }
        setup() {
            const { sourceNode, stepsNode } = this;
            return sourceNode.mul(stepsNode).floor().div(stepsNode);
        }
    }
    const posterize = /*@__PURE__*/ nodeProxy(PosterizeNode).setParameterLength(2);
    const _size = /*@__PURE__*/ new Vector2();
    class PassTextureNode extends TextureNode {
        static get type() {
            return 'PassTextureNode';
        }
        constructor(passNode, texture) {
            super(texture);
            this.passNode = passNode;
            this.setUpdateMatrix(false);
        }
        setup(builder) {
            this.passNode.build(builder);
            return super.setup(builder);
        }
        clone() {
            return new this.constructor(this.passNode, this.value);
        }
    }
    class PassMultipleTextureNode extends PassTextureNode {
        static get type() {
            return 'PassMultipleTextureNode';
        }
        constructor(passNode, textureName, previousTexture = false) {
            // null is passed to the super call since this class does not
            // use an external texture for rendering pass data into. Instead
            // the texture is managed by the pass node itself
            super(passNode, null);
            this.textureName = textureName;
            this.previousTexture = previousTexture;
        }
        updateTexture() {
            this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);
        }
        setup(builder) {
            this.updateTexture();
            return super.setup(builder);
        }
        clone() {
            const newNode = new this.constructor(this.passNode, this.textureName, this.previousTexture);
            newNode.uvNode = this.uvNode;
            newNode.levelNode = this.levelNode;
            newNode.biasNode = this.biasNode;
            newNode.sampler = this.sampler;
            newNode.depthNode = this.depthNode;
            newNode.compareNode = this.compareNode;
            newNode.gradNode = this.gradNode;
            return newNode;
        }
    }
    class PassNode extends TempNode {
        static get type() {
            return 'PassNode';
        }
        constructor(scope, scene, camera, options = {}) {
            super('vec4');
            this.scope = scope;
            this.scene = scene;
            this.camera = camera;
            this.options = options;
            this._pixelRatio = 1;
            this._width = 1;
            this._height = 1;
            const depthTexture = new DepthTexture();
            depthTexture.isRenderTargetTexture = true;
            //depthTexture.type = FloatType;
            depthTexture.name = 'depth';
            const renderTarget = new RenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options, });
            renderTarget.texture.name = 'output';
            renderTarget.depthTexture = depthTexture;
            this.renderTarget = renderTarget;
            this._textures = {
                output: renderTarget.texture,
                depth: depthTexture
            };
            this._textureNodes = {};
            this._linearDepthNodes = {};
            this._viewZNodes = {};
            this._previousTextures = {};
            this._previousTextureNodes = {};
            this._cameraNear = uniform(0);
            this._cameraFar = uniform(0);
            this._mrt = null;
            this._layers = null;
            this._resolution = 1;
            this._viewport = null;
            this._scissor = null;
            this.isPassNode = true;
            this.updateBeforeType = NodeUpdateType.FRAME;
            this.global = true;
        }
        setResolution(resolution) {
            this._resolution = resolution;
            return this;
        }
        getResolution() {
            return this._resolution;
        }
        setLayers(layers) {
            this._layers = layers;
            return this;
        }
        getLayers() {
            return this._layers;
        }
        setMRT(mrt) {
            this._mrt = mrt;
            return this;
        }
        getMRT() {
            return this._mrt;
        }
        getTexture(name) {
            let texture = this._textures[name];
            if (texture === undefined) {
                const refTexture = this.renderTarget.texture;
                texture = refTexture.clone();
                texture.name = name;
                this._textures[name] = texture;
                this.renderTarget.textures.push(texture);
            }
            return texture;
        }
        getPreviousTexture(name) {
            let texture = this._previousTextures[name];
            if (texture === undefined) {
                texture = this.getTexture(name).clone();
                this._previousTextures[name] = texture;
            }
            return texture;
        }
        toggleTexture(name) {
            const prevTexture = this._previousTextures[name];
            if (prevTexture !== undefined) {
                const texture = this._textures[name];
                const index = this.renderTarget.textures.indexOf(texture);
                this.renderTarget.textures[index] = prevTexture;
                this._textures[name] = prevTexture;
                this._previousTextures[name] = texture;
                this._textureNodes[name].updateTexture();
                this._previousTextureNodes[name].updateTexture();
            }
        }
        getTextureNode(name = 'output') {
            let textureNode = this._textureNodes[name];
            if (textureNode === undefined) {
                textureNode = nodeObject(new PassMultipleTextureNode(this, name));
                textureNode.updateTexture();
                this._textureNodes[name] = textureNode;
            }
            return textureNode;
        }
        getPreviousTextureNode(name = 'output') {
            let textureNode = this._previousTextureNodes[name];
            if (textureNode === undefined) {
                if (this._textureNodes[name] === undefined) this.getTextureNode(name);
                textureNode = nodeObject(new PassMultipleTextureNode(this, name, true));
                textureNode.updateTexture();
                this._previousTextureNodes[name] = textureNode;
            }
            return textureNode;
        }
        getViewZNode(name = 'depth') {
            let viewZNode = this._viewZNodes[name];
            if (viewZNode === undefined) {
                const cameraNear = this._cameraNear;
                const cameraFar = this._cameraFar;
                this._viewZNodes[name] = viewZNode = perspectiveDepthToViewZ(this.getTextureNode(name), cameraNear, cameraFar);
            }
            return viewZNode;
        }
        getLinearDepthNode(name = 'depth') {
            let linearDepthNode = this._linearDepthNodes[name];
            if (linearDepthNode === undefined) {
                const cameraNear = this._cameraNear;
                const cameraFar = this._cameraFar;
                const viewZNode = this.getViewZNode(name);
                // TODO: just if ( builder.camera.isPerspectiveCamera )
                this._linearDepthNodes[name] = linearDepthNode = viewZToOrthographicDepth(viewZNode, cameraNear, cameraFar);
            }
            return linearDepthNode;
        }
        async compileAsync(renderer) {
            const currentRenderTarget = renderer.getRenderTarget();
            const currentMRT = renderer.getMRT();
            renderer.setRenderTarget(this.renderTarget);
            renderer.setMRT(this._mrt);
            await renderer.compileAsync(this.scene, this.camera);
            renderer.setRenderTarget(currentRenderTarget);
            renderer.setMRT(currentMRT);
        }
        setup({ renderer }) {
            this.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;
            this.renderTarget.texture.type = renderer.getColorBufferType();
            return this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();
        }
        updateBefore(frame) {
            const { renderer } = frame;
            const { scene } = this;
            let camera;
            let pixelRatio;
            const outputRenderTarget = renderer.getOutputRenderTarget();
            if (outputRenderTarget && outputRenderTarget.isXRRenderTarget === true) {
                pixelRatio = 1;
                camera = renderer.xr.getCamera();
                renderer.xr.updateCamera(camera);
                _size.set(outputRenderTarget.width, outputRenderTarget.height);
            } else {
                camera = this.camera;
                pixelRatio = renderer.getPixelRatio();
                renderer.getSize(_size);
            }
            this._pixelRatio = pixelRatio;
            this.setSize(_size.width, _size.height);
            const currentRenderTarget = renderer.getRenderTarget();
            const currentMRT = renderer.getMRT();
            const currentMask = camera.layers.mask;
            this._cameraNear.value = camera.near;
            this._cameraFar.value = camera.far;
            if (this._layers !== null) {
                camera.layers.mask = this._layers.mask;
            }
            for (const name in this._previousTextures) {
                this.toggleTexture(name);
            }
            renderer.setRenderTarget(this.renderTarget);
            renderer.setMRT(this._mrt);
            renderer.render(scene, camera);
            renderer.setRenderTarget(currentRenderTarget);
            renderer.setMRT(currentMRT);
            camera.layers.mask = currentMask;
        }
        setSize(width, height) {
            this._width = width;
            this._height = height;
            const effectiveWidth = this._width * this._pixelRatio * this._resolution;
            const effectiveHeight = this._height * this._pixelRatio * this._resolution;
            this.renderTarget.setSize(effectiveWidth, effectiveHeight);
            if (this._scissor !== null) this.renderTarget.scissor.copy(this._scissor);
            if (this._viewport !== null) this.renderTarget.viewport.copy(this._viewport);
        }
        setScissor(x, y, width, height) {
            if (x === null) {
                this._scissor = null;
            } else {
                if (this._scissor === null) this._scissor = new Vector4();
                if (x.isVector4) {
                    this._scissor.copy(x);
                } else {
                    this._scissor.set(x, y, width, height);
                }
                this._scissor.multiplyScalar(this._pixelRatio * this._resolution).floor();
            }
        }
        setViewport(x, y, width, height) {
            if (x === null) {
                this._viewport = null;
            } else {
                if (this._viewport === null) this._viewport = new Vector4();
                if (x.isVector4) {
                    this._viewport.copy(x);
                } else {
                    this._viewport.set(x, y, width, height);
                }
                this._viewport.multiplyScalar(this._pixelRatio * this._resolution).floor();
            }
        }
        setPixelRatio(pixelRatio) {
            this._pixelRatio = pixelRatio;
            this.setSize(this._width, this._height);
        }
        dispose() {
            this.renderTarget.dispose();
        }

    }
    PassNode.COLOR = 'color';
    PassNode.DEPTH = 'depth';
    const pass = (scene, camera, options) => nodeObject(new PassNode(PassNode.COLOR, scene, camera, options));
    const passTexture = (pass, texture) => nodeObject(new PassTextureNode(pass, texture));
    const depthPass = (scene, camera, options) => nodeObject(new PassNode(PassNode.DEPTH, scene, camera, options));
    class ToonOutlinePassNode extends PassNode {
        static get type() {
            return 'ToonOutlinePassNode';
        }
        constructor(scene, camera, colorNode, thicknessNode, alphaNode) {
            super(PassNode.COLOR, scene, camera);
            this.colorNode = colorNode;
            this.thicknessNode = thicknessNode;
            this.alphaNode = alphaNode;
            this._materialCache = new WeakMap();
        }
        updateBefore(frame) {
            const { renderer } = frame;
            const currentRenderObjectFunction = renderer.getRenderObjectFunction();
            renderer.setRenderObjectFunction((object, scene, camera, geometry, material, group, lightsNode, clippingContext) => {
                // only render outline for supported materials
                if (material.isMeshToonMaterial || material.isMeshToonNodeMaterial) {
                    if (material.wireframe === false) {
                        const outlineMaterial = this._getOutlineMaterial(material);
                        renderer.renderObject(object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext);
                    }
                }
                // default
                renderer.renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext);
            });
            super.updateBefore(frame);
            renderer.setRenderObjectFunction(currentRenderObjectFunction);
        }
        _createMaterial() {
            const material = new NodeMaterial();
            material.isMeshToonOutlineMaterial = true;
            material.name = 'Toon_Outline';
            material.side = BackSide;
            // vertex node
            const outlineNormal = normalLocal.negate();
            const mvp = cameraProjectionMatrix.mul(modelViewMatrix);
            const ratio = float(1.0); // TODO: support outline thickness ratio for each vertex
            const pos = mvp.mul(vec4(positionLocal, 1.0));
            const pos2 = mvp.mul(vec4(positionLocal.add(outlineNormal), 1.0));
            const norm = normalize(pos.sub(pos2)); // NOTE: subtract pos2 from pos because BackSide objectNormal is negative
            material.vertexNode = pos.add(norm.mul(this.thicknessNode).mul(pos.w).mul(ratio));
            // color node
            material.colorNode = vec4(this.colorNode, this.alphaNode);
            return material;
        }
        _getOutlineMaterial(originalMaterial) {
            let outlineMaterial = this._materialCache.get(originalMaterial);
            if (outlineMaterial === undefined) {
                outlineMaterial = this._createMaterial();
                this._materialCache.set(originalMaterial, outlineMaterial);
            }
            return outlineMaterial;
        }
    }
    const toonOutlinePass = (scene, camera, color = new Color(0, 0, 0), thickness = 0.003, alpha = 1) => nodeObject(new ToonOutlinePassNode(scene, camera, nodeObject(color), nodeObject(thickness), nodeObject(alpha)));
    const linearToneMapping = /*@__PURE__*/ Fn(([color, exposure]) => {
        return color.mul(exposure).clamp();
    }).setLayout({
        name: 'linearToneMapping',
        type: 'vec3',
        inputs: [
            { name: 'color', type: 'vec3' },
            { name: 'exposure', type: 'float' }
        ]
    });
    const reinhardToneMapping = /*@__PURE__*/ Fn(([color, exposure]) => {
        color = color.mul(exposure);
        return color.div(color.add(1.0)).clamp();
    }).setLayout({
        name: 'reinhardToneMapping',
        type: 'vec3',
        inputs: [
            { name: 'color', type: 'vec3' },
            { name: 'exposure', type: 'float' }
        ]
    });
    const cineonToneMapping = /*@__PURE__*/ Fn(([color, exposure]) => {
        // filmic operator by Jim Hejl and Richard Burgess-Dawson
        color = color.mul(exposure);
        color = color.sub(0.004).max(0.0);
        const a = color.mul(color.mul(6.2).add(0.5));
        const b = color.mul(color.mul(6.2).add(1.7)).add(0.06);
        return a.div(b).pow(2.2);
    }).setLayout({
        name: 'cineonToneMapping',
        type: 'vec3',
        inputs: [
            { name: 'color', type: 'vec3' },
            { name: 'exposure', type: 'float' }
        ]
    });
    // source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
    const RRTAndODTFit = /*@__PURE__*/ Fn(([color]) => {
        const a = color.mul(color.add(0.0245786)).sub(0.000090537);
        const b = color.mul(color.add(0.4329510).mul(0.983729)).add(0.238081);
        return a.div(b);
    });
    const acesFilmicToneMapping = /*@__PURE__*/ Fn(([color, exposure]) => {
        // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
        const ACESInputMat = mat3(
            0.59719, 0.35458, 0.04823,
            0.07600, 0.90834, 0.01566,
            0.02840, 0.13383, 0.83777
        );
        // ODT_SAT => XYZ => D60_2_D65 => sRGB
        const ACESOutputMat = mat3(
            1.60475, -0.53108, -0.07367,
            -0.10208, 1.10813, -605e-5,
            -327e-5, -0.07276, 1.07602
        );
        color = color.mul(exposure).div(0.6);
        color = ACESInputMat.mul(color);
        // Apply RRT and ODT
        color = RRTAndODTFit(color);
        color = ACESOutputMat.mul(color);
        // Clamp to [0, 1]
        return color.clamp();
    }).setLayout({
        name: 'acesFilmicToneMapping',
        type: 'vec3',
        inputs: [
            { name: 'color', type: 'vec3' },
            { name: 'exposure', type: 'float' }
        ]
    });
    const LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/ mat3(vec3(1.6605, -0.1246, -0.0182), vec3(-0.5876, 1.1329, -0.1006), vec3(-0.0728, -83e-4, 1.1187));
    const LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/ mat3(vec3(0.6274, 0.0691, 0.0164), vec3(0.3293, 0.9195, 0.0880), vec3(0.0433, 0.0113, 0.8956));
    const agxDefaultContrastApprox = /*@__PURE__*/ Fn(([x_immutable]) => {
        const x = vec3(x_immutable).toVar();
        const x2 = vec3(x.mul(x)).toVar();
        const x4 = vec3(x2.mul(x2)).toVar();
        return float(15.5).mul(x4.mul(x2)).sub(mul(40.14, x4.mul(x))).add(mul(31.96, x4).sub(mul(6.868, x2.mul(x))).add(mul(0.4298, x2).add(mul(0.1191, x).sub(0.00232))));
    });
    const agxToneMapping = /*@__PURE__*/ Fn(([color, exposure]) => {
        const colortone = vec3(color).toVar();
        const AgXInsetMatrix = mat3(vec3(0.856627153315983, 0.137318972929847, 0.11189821299995), vec3(0.0951212405381588, 0.761241990602591, 0.0767994186031903), vec3(0.0482516061458583, 0.101439036467562, 0.811302368396859));
        const AgXOutsetMatrix = mat3(vec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), vec3(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), vec3(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405));
        const AgxMinEv = float(-12.47393);
        const AgxMaxEv = float(4.026069);
        colortone.mulAssign(exposure);
        colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone));
        colortone.assign(AgXInsetMatrix.mul(colortone));
        colortone.assign(max$1(colortone, 1e-10));
        colortone.assign(log2(colortone));
        colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv)));
        colortone.assign(clamp(colortone, 0.0, 1.0));
        colortone.assign(agxDefaultContrastApprox(colortone));
        colortone.assign(AgXOutsetMatrix.mul(colortone));
        colortone.assign(pow(max$1(vec3(0.0), colortone), vec3(2.2)));
        colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone));
        colortone.assign(clamp(colortone, 0.0, 1.0));
        return colortone;
    }).setLayout({
        name: 'agxToneMapping',
        type: 'vec3',
        inputs: [
            { name: 'color', type: 'vec3' },
            { name: 'exposure', type: 'float' }
        ]
    });
    const neutralToneMapping = /*@__PURE__*/ Fn(([color, exposure]) => {
        const StartCompression = float(0.8 - 0.04);
        const Desaturation = float(0.15);
        color = color.mul(exposure);
        const x = min$1(color.r, min$1(color.g, color.b));
        const offset = select(x.lessThan(0.08), x.sub(mul(6.25, x.mul(x))), 0.04);
        color.subAssign(offset);
        const peak = max$1(color.r, max$1(color.g, color.b));
        If(peak.lessThan(StartCompression), () => {
            return color;
        });
        const d = sub(1, StartCompression);
        const newPeak = sub(1, d.mul(d).div(peak.add(d.sub(StartCompression))));
        color.mulAssign(newPeak.div(peak));
        const g = sub(1, div(1, Desaturation.mul(peak.sub(newPeak)).add(1)));
        return mix(color, vec3(newPeak), g);
    }).setLayout({
        name: 'neutralToneMapping',
        type: 'vec3',
        inputs: [
            { name: 'color', type: 'vec3' },
            { name: 'exposure', type: 'float' }
        ]
    });
    class CodeNode extends Node {
        static get type() {
            return 'CodeNode';
        }
        constructor(code = '', includes = [], language = '') {
            super('code');
            this.isCodeNode = true;
            this.global = true;
            this.code = code;
            this.includes = includes;
            this.language = language;
        }
        setIncludes(includes) {
            this.includes = includes;
            return this;
        }
        getIncludes( /*builder*/) {
            return this.includes;
        }
        generate(builder) {
            const includes = this.getIncludes(builder);
            for (const include of includes) {
                include.build(builder);
            }
            const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
            nodeCode.code = this.code;
            return nodeCode.code;
        }
        serialize(data) {
            super.serialize(data);
            data.code = this.code;
            data.language = this.language;
        }
        deserialize(data) {
            super.deserialize(data);
            this.code = data.code;
            this.language = data.language;
        }
    }
    const code = /*@__PURE__*/ nodeProxy(CodeNode).setParameterLength(1, 3);
    const js = (src, includes) => code(src, includes, 'js');
    const wgsl = (src, includes) => code(src, includes, 'wgsl');
    const glsl = (src, includes) => code(src, includes, 'glsl');
    class FunctionNode extends CodeNode {
        static get type() {
            return 'FunctionNode';
        }
        constructor(code = '', includes = [], language = '') {
            super(code, includes, language);
        }
        getNodeType(builder) {
            return this.getNodeFunction(builder).type;
        }
        getInputs(builder) {
            return this.getNodeFunction(builder).inputs;
        }
        getNodeFunction(builder) {
            const nodeData = builder.getDataFromNode(this);
            let nodeFunction = nodeData.nodeFunction;
            if (nodeFunction === undefined) {
                nodeFunction = builder.parser.parseFunction(this.code);
                nodeData.nodeFunction = nodeFunction;
            }
            return nodeFunction;
        }
        generate(builder, output) {
            super.generate(builder);
            const nodeFunction = this.getNodeFunction(builder);
            const name = nodeFunction.name;
            const type = nodeFunction.type;
            const nodeCode = builder.getCodeFromNode(this, type);
            if (name !== '') {
                // use a custom property name
                nodeCode.name = name;
            }
            const propertyName = builder.getPropertyName(nodeCode);
            const code = this.getNodeFunction(builder).getCode(propertyName);
            nodeCode.code = code + '\n';
            if (output === 'property') {
                return propertyName;
            } else {
                return builder.format(`${propertyName}()`, type, output);
            }
        }
    }
    const nativeFn = (code, includes = [], language = '') => {
        for (let i = 0; i < includes.length; i++) {
            const include = includes[i];
            // TSL Function: glslFn, wgslFn
            if (typeof include === 'function') {
                includes[i] = include.functionNode;
            }
        }
        const functionNode = nodeObject(new FunctionNode(code, includes, language));
        const fn = (...params) => functionNode.call(...params);
        fn.functionNode = functionNode;
        return fn;
    };
    const glslFn = (code, includes) => nativeFn(code, includes, 'glsl');
    const wgslFn = (code, includes) => nativeFn(code, includes, 'wgsl');
    class ScriptableValueNode extends Node {
        static get type() {
            return 'ScriptableValueNode';
        }
        constructor(value = null) {
            super();
            this._value = value;
            this._cache$2 = null;
            this.inputType = null;
            this.outputType = null;
            this.events = new EventDispatcher();
            this.isScriptableValueNode = true;
        }
        get isScriptableOutputNode() {
            return this.outputType !== null;
        }
        set value(val) {
            if (this._value === val) return;
            if (this._cache$2 && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer) {
                URL.revokeObjectURL(this._cache$2);
                this._cache$2 = null;
            }
            this._value = val;
            this.events.dispatchEvent({ type: 'change' });
            this.refresh();
        }
        get value() {
            return this._value;
        }
        refresh() {
            this.events.dispatchEvent({ type: 'refresh' });
        }
        getValue() {
            const value = this.value;
            if (value && this._cache$2 === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer) {
                this._cache$2 = URL.createObjectURL(new Blob([value.value]));
            } else if (value && value.value !== null && value.value !== undefined && (
                ((this.inputType === 'URL' || this.inputType === 'String') && typeof value.value === 'string') ||
                (this.inputType === 'Number' && typeof value.value === 'number') ||
                (this.inputType === 'Vector2' && value.value.isVector2) ||
                (this.inputType === 'Vector3' && value.value.isVector3) ||
                (this.inputType === 'Vector4' && value.value.isVector4) ||
                (this.inputType === 'Color' && value.value.isColor) ||
                (this.inputType === 'Matrix3' && value.value.isMatrix3) ||
                (this.inputType === 'Matrix4' && value.value.isMatrix4)
            )) {
                return value.value;
            }
            return this._cache$2 || value;
        }
        getNodeType(builder) {
            return this.value && this.value.isNode ? this.value.getNodeType(builder) : 'float';
        }
        setup() {
            return this.value && this.value.isNode ? this.value : float();
        }
        serialize(data) {
            super.serialize(data);
            if (this.value !== null) {
                if (this.inputType === 'ArrayBuffer') {
                    data.value = arrayBufferToBase64(this.value);
                } else {
                    data.value = this.value ? this.value.toJSON(data.meta).uuid : null;
                }
            } else {
                data.value = null;
            }
            data.inputType = this.inputType;
            data.outputType = this.outputType;
        }
        deserialize(data) {
            super.deserialize(data);
            let value = null;
            if (data.value !== null) {
                if (data.inputType === 'ArrayBuffer') {
                    value = base64ToArrayBuffer(data.value);
                } else if (data.inputType === 'Texture') {
                    value = data.meta.textures[data.value];
                } else {
                    value = data.meta.nodes[data.value] || null;
                }
            }
            this.value = value;
            this.inputType = data.inputType;
            this.outputType = data.outputType;
        }
    }
    const scriptableValue = /*@__PURE__*/ nodeProxy(ScriptableValueNode).setParameterLength(1);
    class Resources extends Map {
        get(key, callback = null, ...params) {
            if (this.has(key)) return super.get(key);
            if (callback !== null) {
                const value = callback(...params);
                this.set(key, value);
                return value;
            }
        }
    }
    class Parameters {
        constructor(scriptableNode) {
            this.scriptableNode = scriptableNode;
        }
        get parameters() {
            return this.scriptableNode.parameters;
        }
        get layout() {
            return this.scriptableNode.getLayout();
        }
        getInputLayout(id) {
            return this.scriptableNode.getInputLayout(id);
        }
        get(name) {
            const param = this.parameters[name];
            const value = param ? param.getValue() : null;
            return value;
        }
    }
    const ScriptableNodeResources = new Resources();
    class ScriptableNode extends Node {
        static get type() {
            return 'ScriptableNode';
        }
        constructor(codeNode = null, parameters = {}) {
            super();
            this.codeNode = codeNode;
            this.parameters = parameters;
            this._local = new Resources();
            this._output = scriptableValue(null);
            this._outputs = {};
            this._source = this.source;
            this._method = null;
            this._object = null;
            this._value = null;
            this._needsOutputUpdate = true;
            this.onRefresh = this.onRefresh.bind(this);
            this.isScriptableNode = true;
        }
        get source() {
            return this.codeNode ? this.codeNode.code : '';
        }
        setLocal(name, value) {
            return this._local.set(name, value);
        }
        getLocal(name) {
            return this._local.get(name);
        }
        onRefresh() {
            this._refresh();
        }
        getInputLayout(id) {
            for (const element of this.getLayout()) {
                if (element.inputType && (element.id === id || element.name === id)) {
                    return element;
                }
            }
        }
        getOutputLayout(id) {
            for (const element of this.getLayout()) {
                if (element.outputType && (element.id === id || element.name === id)) {
                    return element;
                }
            }
        }
        setOutput(name, value) {
            const outputs = this._outputs;
            if (outputs[name] === undefined) {
                outputs[name] = scriptableValue(value);
            } else {
                outputs[name].value = value;
            }
            return this;
        }
        getOutput(name) {
            return this._outputs[name];
        }
        getParameter(name) {
            return this.parameters[name];
        }
        setParameter(name, value) {
            const parameters = this.parameters;
            if (value && value.isScriptableNode) {
                this.deleteParameter(name);
                parameters[name] = value;
                parameters[name].getDefaultOutput().events.addEventListener('refresh', this.onRefresh);
            } else if (value && value.isScriptableValueNode) {
                this.deleteParameter(name);
                parameters[name] = value;
                parameters[name].events.addEventListener('refresh', this.onRefresh);
            } else if (parameters[name] === undefined) {
                parameters[name] = scriptableValue(value);
                parameters[name].events.addEventListener('refresh', this.onRefresh);
            } else {
                parameters[name].value = value;
            }
            return this;
        }
        getValue() {
            return this.getDefaultOutput().getValue();
        }
        deleteParameter(name) {
            let valueNode = this.parameters[name];
            if (valueNode) {
                if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
                valueNode.events.removeEventListener('refresh', this.onRefresh);
            }
            return this;
        }
        clearParameters() {
            for (const name of Object.keys(this.parameters)) {
                this.deleteParameter(name);
            }
            this.needsUpdate = true;
            return this;
        }
        call(name, ...params) {
            const object = this.getObject();
            const method = object[name];
            if (typeof method === 'function') {
                return method(...params);
            }
        }
        async callAsync(name, ...params) {
            const object = this.getObject();
            const method = object[name];
            if (typeof method === 'function') {
                return method.constructor.name === 'AsyncFunction' ? await method(...params) : method(...params);
            }
        }
        getNodeType(builder) {
            return this.getDefaultOutputNode().getNodeType(builder);
        }
        refresh(output = null) {
            if (output !== null) {
                this.getOutput(output).refresh();
            } else {
                this._refresh();
            }
        }
        getObject() {
            if (this.needsUpdate) this.dispose();
            if (this._object !== null) return this._object;
            //
            const refresh = () => this.refresh();
            const setOutput = (id, value) => this.setOutput(id, value);
            const parameters = new Parameters(this);
            const THREE = ScriptableNodeResources.get('THREE');
            const TSL = ScriptableNodeResources.get('TSL');
            const method = this.getMethod();
            const params = [parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE, TSL];
            this._object = method(...params);
            const layout = this._object.layout;
            if (layout) {
                if (layout.cache === false) {
                    this._local.clear();
                }
                // default output
                this._output.outputType = layout.outputType || null;
                if (Array.isArray(layout.elements)) {
                    for (const element of layout.elements) {
                        const id = element.id || element.name;
                        if (element.inputType) {
                            if (this.getParameter(id) === undefined) this.setParameter(id, null);
                            this.getParameter(id).inputType = element.inputType;
                        }
                        if (element.outputType) {
                            if (this.getOutput(id) === undefined) this.setOutput(id, null);
                            this.getOutput(id).outputType = element.outputType;
                        }
                    }
                }
            }
            return this._object;
        }
        deserialize(data) {
            super.deserialize(data);
            for (const name in this.parameters) {
                let valueNode = this.parameters[name];
                if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
                valueNode.events.addEventListener('refresh', this.onRefresh);
            }
        }
        getLayout() {
            return this.getObject().layout;
        }
        getDefaultOutputNode() {
            const output = this.getDefaultOutput().value;
            if (output && output.isNode) {
                return output;
            }
            return float();
        }
        getDefaultOutput() {
            return this._exec()._output;
        }
        getMethod() {
            if (this.needsUpdate) this.dispose();
            if (this._method !== null) return this._method;
            //
            const parametersProps = ['parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL'];
            const interfaceProps = ['layout', 'init', 'main', 'dispose'];
            const properties = interfaceProps.join(', ');
            const declarations = 'var ' + properties + '; var output = {};\n';
            const returns = '\nreturn { ...output, ' + properties + ' };';
            const code = declarations + this.codeNode.code + returns;
            //
            this._method = new Function(...parametersProps, code);
            return this._method;
        }
        dispose() {
            if (this._method === null) return;
            if (this._object && typeof this._object.dispose === 'function') {
                this._object.dispose();
            }
            this._method = null;
            this._object = null;
            this._source = null;
            this._value = null;
            this._needsOutputUpdate = true;
            this._output.value = null;
            this._outputs = {};
        }
        setup() {
            return this.getDefaultOutputNode();
        }
        getCacheKey(force) {
            const values = [hashString(this.source), this.getDefaultOutputNode().getCacheKey(force)];
            for (const param in this.parameters) {
                values.push(this.parameters[param].getCacheKey(force));
            }
            return hashArray(values);
        }
        set needsUpdate(value) {
            if (value === true) this.dispose();
        }
        get needsUpdate() {
            return this.source !== this._source;
        }
        _exec() {
            if (this.codeNode === null) return this;
            if (this._needsOutputUpdate === true) {
                this._value = this.call('main');
                this._needsOutputUpdate = false;
            }
            this._output.value = this._value;
            return this;
        }
        _refresh() {
            this.needsUpdate = true;
            this._exec();
            this._output.refresh();
        }
    }
    const scriptable = /*@__PURE__*/ nodeProxy(ScriptableNode).setParameterLength(1, 2);
    function getViewZNode(builder) {
        let viewZ;
        const getViewZ = builder.context.getViewZ;
        if (getViewZ !== undefined) {
            viewZ = getViewZ(this);
        }
        return (viewZ || positionView.z).negate();
    }
    const rangeFogFactor = Fn(([near, far], builder) => {
        const viewZ = getViewZNode(builder);
        return smoothstep(near, far, viewZ);
    });
    const densityFogFactor = Fn(([density], builder) => {
        const viewZ = getViewZNode(builder);
        return density.mul(density, viewZ, viewZ).negate().exp().oneMinus();
    });
    const fog = Fn(([color, factor]) => {
        return vec4(factor.toFloat().mix(output.rgb, color.toVec3()), output.a);
    });
    // Deprecated
    function rangeFog(color, near, far) { // @deprecated, r171
        console.warn('THREE.TSL: "rangeFog( color, near, far )" is deprecated. Use "fog( color, rangeFogFactor( near, far ) )" instead.');
        return fog(color, rangeFogFactor(near, far));
    }
    function densityFog(color, density) { // @deprecated, r171
        console.warn('THREE.TSL: "densityFog( color, density )" is deprecated. Use "fog( color, densityFogFactor( density ) )" instead.');
        return fog(color, densityFogFactor(density));
    }
    let min = null;
    let max = null;
    class RangeNode extends Node {
        static get type() {
            return 'RangeNode';
        }
        constructor(minNode = float(), maxNode = float()) {
            super();
            this.minNode = minNode;
            this.maxNode = maxNode;
        }
        getVectorLength(builder) {
            const minLength = builder.getTypeLength(getValueType(this.minNode.value));
            const maxLength = builder.getTypeLength(getValueType(this.maxNode.value));
            return minLength > maxLength ? minLength : maxLength;
        }
        getNodeType(builder) {
            return builder.object.count > 1 ? builder.getTypeFromLength(this.getVectorLength(builder)) : 'float';
        }
        setup(builder) {
            const object = builder.object;
            let output = null;
            if (object.count > 1) {
                const minValue = this.minNode.value;
                const maxValue = this.maxNode.value;
                const minLength = builder.getTypeLength(getValueType(minValue));
                const maxLength = builder.getTypeLength(getValueType(maxValue));
                min = min || new Vector4();
                max = max || new Vector4();
                min.setScalar(0);
                max.setScalar(0);
                if (minLength === 1) min.setScalar(minValue);
                else if (minValue.isColor) min.set(minValue.r, minValue.g, minValue.b, 1);
                else min.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);
                if (maxLength === 1) max.setScalar(maxValue);
                else if (maxValue.isColor) max.set(maxValue.r, maxValue.g, maxValue.b, 1);
                else max.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);
                const stride = 4;
                const length = stride * object.count;
                const array = new Float32Array(length);
                for (let i = 0; i < length; i++) {
                    const index = i % stride;
                    const minElementValue = min.getComponent(index);
                    const maxElementValue = max.getComponent(index);
                    array[i] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());
                }
                const nodeType = this.getNodeType(builder);
                if (object.count <= 4096) {
                    output = buffer(array, 'vec4', object.count).element(instanceIndex).convert(nodeType);
                } else {
                    // TODO: Improve anonymous buffer attribute creation removing this part
                    const bufferAttribute = new InstancedBufferAttribute(array, 4);
                    builder.geometry.setAttribute('__range' + this.id, bufferAttribute);
                    output = instancedBufferAttribute(bufferAttribute).convert(nodeType);
                }
            } else {
                output = float(0);
            }
            return output;
        }
    }
    const range = /*@__PURE__*/ nodeProxy(RangeNode).setParameterLength(2);
    class ComputeBuiltinNode extends Node {
        static get type() {
            return 'ComputeBuiltinNode';
        }
        constructor(builtinName, nodeType) {
            super(nodeType);
            this._builtinName = builtinName;
        }
        getHash(builder) {
            return this.getBuiltinName(builder);
        }
        getNodeType( /*builder*/) {
            return this.nodeType;
        }
        setBuiltinName(builtinName) {
            this._builtinName = builtinName;
            return this;
        }
        getBuiltinName( /*builder*/) {
            return this._builtinName;
        }
        hasBuiltin(builder) {
            return builder.hasBuiltin(this._builtinName);
        }
        generate(builder, output) {
            const builtinName = this.getBuiltinName(builder);
            const nodeType = this.getNodeType(builder);
            if (builder.shaderStage === 'compute') {
                return builder.format(builtinName, nodeType, output);
            } else {
                console.warn(`ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage`);
                return builder.generateConst(nodeType);
            }
        }
        serialize(data) {
            super.serialize(data);
            data.global = this.global;
            data._builtinName = this._builtinName;
        }
        deserialize(data) {
            super.deserialize(data);
            this.global = data.global;
            this._builtinName = data._builtinName;
        }
    }
    const computeBuiltin = (name, nodeType) => nodeObject(new ComputeBuiltinNode(name, nodeType));
    const numWorkgroups = /*@__PURE__*/ computeBuiltin('numWorkgroups', 'uvec3');
    const workgroupId = /*@__PURE__*/ computeBuiltin('workgroupId', 'uvec3');
    const globalId = /*@__PURE__*/ computeBuiltin('globalId', 'uvec3');
    const localId = /*@__PURE__*/ computeBuiltin('localId', 'uvec3');
    const subgroupSize = /*@__PURE__*/ computeBuiltin('subgroupSize', 'uint');
    class BarrierNode extends Node {
        constructor(scope) {
            super();
            this.scope = scope;
        }
        generate(builder) {
            const { scope } = this;
            const { renderer } = builder;
            if (renderer.backend.isWebGLBackend === true) {
                builder.addFlowCode(`\t// ${scope}Barrier \n`);
            } else {
                builder.addLineFlowCode(`${scope}Barrier()`, this);
            }
        }
    }
    const barrier = nodeProxy(BarrierNode);
    const workgroupBarrier = () => barrier('workgroup').toStack();
    const storageBarrier = () => barrier('storage').toStack();
    const textureBarrier = () => barrier('texture').toStack();
    class WorkgroupInfoElementNode extends ArrayElementNode {
        constructor(workgroupInfoNode, indexNode) {
            super(workgroupInfoNode, indexNode);
            this.isWorkgroupInfoElementNode = true;
        }
        generate(builder, output) {
            let snippet;
            const isAssignContext = builder.context.assign;
            snippet = super.generate(builder);
            if (isAssignContext !== true) {
                const type = this.getNodeType(builder);
                snippet = builder.format(snippet, type, output);
            }
            // TODO: Possibly activate clip distance index on index access rather than from clipping context
            return snippet;
        }
    }
    class WorkgroupInfoNode extends Node {
        constructor(scope, bufferType, bufferCount = 0) {
            super(bufferType);
            this.bufferType = bufferType;
            this.bufferCount = bufferCount;
            this.isWorkgroupInfoNode = true;
            this.elementType = bufferType;
            this.scope = scope;
            this.name = '';
        }
        setName(name) {
            this.name = name;
            return this;
        }
        label(name) {
            console.warn('THREE.TSL: "label()" has been deprecated. Use "setName()" instead.'); // @deprecated r179
            return this.setName(name);
        }
        setScope(scope) {
            this.scope = scope;
            return this;
        }

        getElementType() {
            return this.elementType;
        }
        getInputType( /*builder*/) {
            return `${this.scope}Array`;
        }
        element(indexNode) {
            return nodeObject(new WorkgroupInfoElementNode(this, indexNode));
        }
        generate(builder) {
            const name = (this.name !== '') ? this.name : `${this.scope}Array_${this.id}`;
            return builder.getScopedArray(name, this.scope.toLowerCase(), this.bufferType, this.bufferCount);
        }
    }
    const workgroupArray = (type, count) => nodeObject(new WorkgroupInfoNode('Workgroup', type, count));
    class AtomicFunctionNode extends Node {
        static get type() {
            return 'AtomicFunctionNode';
        }
        constructor(method, pointerNode, valueNode) {
            super('uint');
            this.method = method;
            this.pointerNode = pointerNode;
            this.valueNode = valueNode;
            this.parents = true;
        }
        getInputType(builder) {
            return this.pointerNode.getNodeType(builder);
        }
        getNodeType(builder) {
            return this.getInputType(builder);
        }
        generate(builder) {
            const properties = builder.getNodeProperties(this);
            const parents = properties.parents;
            const method = this.method;
            const type = this.getNodeType(builder);
            const inputType = this.getInputType(builder);
            const a = this.pointerNode;
            const b = this.valueNode;
            const params = [];
            params.push(`&${a.build(builder, inputType)}`);
            if (b !== null) {
                params.push(b.build(builder, inputType));

            }
            const methodSnippet = `${builder.getMethod(method, type)}( ${params.join(', ')} )`;
            const isVoid = parents ? (parents.length === 1 && parents[0].isStackNode === true) : false;
            if (isVoid) {
                builder.addLineFlowCode(methodSnippet, this);
            } else {
                if (properties.constNode === undefined) {
                    properties.constNode = expression(methodSnippet, type).toConst();
                }
                return properties.constNode.build(builder);
            }
        }
    }
    AtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';
    AtomicFunctionNode.ATOMIC_STORE = 'atomicStore';
    AtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';
    AtomicFunctionNode.ATOMIC_SUB = 'atomicSub';
    AtomicFunctionNode.ATOMIC_MAX = 'atomicMax';
    AtomicFunctionNode.ATOMIC_MIN = 'atomicMin';
    AtomicFunctionNode.ATOMIC_AND = 'atomicAnd';
    AtomicFunctionNode.ATOMIC_OR = 'atomicOr';
    AtomicFunctionNode.ATOMIC_XOR = 'atomicXor';
    const atomicNode = nodeProxy(AtomicFunctionNode);
    const atomicFunc = (method, pointerNode, valueNode) => {
        return atomicNode(method, pointerNode, valueNode).toStack();
    };
    const atomicLoad = (pointerNode) => atomicFunc(AtomicFunctionNode.ATOMIC_LOAD, pointerNode, null);
    const atomicStore = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode);
    const atomicAdd = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode);
    const atomicSub = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode);
    const atomicMax = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode);
    const atomicMin = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode);
    const atomicAnd = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode);
    const atomicOr = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode);
    const atomicXor = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode);
    let uniformsLib;
    function getLightData(light) {
        uniformsLib = uniformsLib || new WeakMap();
        let uniforms = uniformsLib.get(light);
        if (uniforms === undefined) uniformsLib.set(light, uniforms = {});
        return uniforms;
    }
    function lightShadowMatrix(light) {
        const data = getLightData(light);
        return data.shadowMatrix || (data.shadowMatrix = uniform('mat4').setGroup(renderGroup).onRenderUpdate((frame) => {
            if (light.castShadow !== true || frame.renderer.shadowMap.enabled === false) {
                light.shadow.updateMatrices(light);
            }
            return light.shadow.matrix;
        }));
    }
    function lightProjectionUV(light, position = positionWorld) {
        const spotLightCoord = lightShadowMatrix(light).mul(position);
        const projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);
        return projectionUV;
    }
    function lightPosition(light) {
        const data = getLightData(light);
        return data.position || (data.position = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_, self) => self.value.setFromMatrixPosition(light.matrixWorld)));
    }
    function lightTargetPosition(light) {
        const data = getLightData(light);
        return data.targetPosition || (data.targetPosition = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_, self) => self.value.setFromMatrixPosition(light.target.matrixWorld)));
    }
    function lightViewPosition(light) {
        const data = getLightData(light);
        return data.viewPosition || (data.viewPosition = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate(({ camera }, self) => {
            self.value = self.value || new Vector3();
            self.value.setFromMatrixPosition(light.matrixWorld);
            self.value.applyMatrix4(camera.matrixWorldInverse);
        }));
    }
    const lightTargetDirection = (light) => cameraViewMatrix.transformDirection(lightPosition(light).sub(lightTargetPosition(light)));
    const sortLights = (lights) => {
        return lights.sort((a, b) => a.id - b.id);
    };
    const getLightNodeById = (id, lightNodes) => {
        for (const lightNode of lightNodes) {
            if (lightNode.isAnalyticLightNode && lightNode.light.id === id) {
                return lightNode;
            }
        }
        return null;
    };
    const _lightsNodeRef = /*@__PURE__*/ new WeakMap();
    const _hashData = [];
    class LightsNode extends Node {
        static get type() {
            return 'LightsNode';
        }
        constructor() {
            super('vec3');
            this.totalDiffuseNode = property('vec3', 'totalDiffuse');
            this.totalSpecularNode = property('vec3', 'totalSpecular');
            this.outgoingLightNode = property('vec3', 'outgoingLight');
            this._lights = [];
            this._lightNodes = null;
            this._lightNodesHash = null;
            this.global = true;
        }
        customCacheKey() {
            const lights = this._lights;
            for (let i = 0; i < lights.length; i++) {
                const light = lights[i];
                _hashData.push(light.id);
                _hashData.push(light.castShadow ? 1 : 0);
                if (light.isSpotLight === true) {
                    const hashMap = (light.map !== null) ? light.map.id : -1;
                    const hashColorNode = (light.colorNode) ? light.colorNode.getCacheKey() : -1;
                    _hashData.push(hashMap, hashColorNode);
                }
            }
            const cacheKey = hashArray(_hashData);
            _hashData.length = 0;
            return cacheKey;
        }
        getHash(builder) {
            if (this._lightNodesHash === null) {
                if (this._lightNodes === null) this.setupLightsNode(builder);
                const hash = [];
                for (const lightNode of this._lightNodes) {
                    hash.push(lightNode.getSelf().getHash());
                }
                this._lightNodesHash = 'lights-' + hash.join(',');
            }
            return this._lightNodesHash;
        }
        analyze(builder) {
            const properties = builder.getNodeProperties(this);
            for (const node of properties.nodes) {
                node.build(builder);
            }
            properties.outputNode.build(builder);
        }
        setupLightsNode(builder) {
            const lightNodes = [];
            const previousLightNodes = this._lightNodes;
            const lights = sortLights(this._lights);
            const nodeLibrary = builder.renderer.library;
            for (const light of lights) {
                if (light.isNode) {
                    lightNodes.push(nodeObject(light));
                } else {
                    let lightNode = null;
                    if (previousLightNodes !== null) {
                        lightNode = getLightNodeById(light.id, previousLightNodes); // reuse existing light node
                    }
                    if (lightNode === null) {
                        // find the corresponding node type for a given light
                        const lightNodeClass = nodeLibrary.getLightNodeClass(light.constructor);
                        if (lightNodeClass === null) {
                            console.warn(`LightsNode.setupNodeLights: Light node not found for ${light.constructor.name}`);
                            continue;
                        }
                        let lightNode = null;
                        if (!_lightsNodeRef.has(light)) {
                            lightNode = nodeObject(new lightNodeClass(light));
                            _lightsNodeRef.set(light, lightNode);
                        } else {
                            lightNode = _lightsNodeRef.get(light);
                        }
                        lightNodes.push(lightNode);
                    }
                }
            }
            this._lightNodes = lightNodes;
        }
        setupDirectLight(builder, lightNode, lightData) {
            const { lightingModel, reflectedLight } = builder.context;
            lightingModel.direct({
                ...lightData,
                lightNode,
                reflectedLight
            }, builder);
        }
        setupDirectRectAreaLight(builder, lightNode, lightData) {
            const { lightingModel, reflectedLight } = builder.context;
            lightingModel.directRectArea({
                ...lightData,
                lightNode,
                reflectedLight
            }, builder);
        }
        setupLights(builder, lightNodes) {
            for (const lightNode of lightNodes) {
                lightNode.build(builder);
            }
        }
        getLightNodes(builder) {
            if (this._lightNodes === null) this.setupLightsNode(builder);
            return this._lightNodes;
        }
        setup(builder) {
            const currentLightsNode = builder.lightsNode;
            builder.lightsNode = this;
            //
            let outgoingLightNode = this.outgoingLightNode;
            const context = builder.context;
            const lightingModel = context.lightingModel;
            const properties = builder.getNodeProperties(this);
            if (lightingModel) {
                const { totalDiffuseNode, totalSpecularNode } = this;
                context.outgoingLight = outgoingLightNode;
                const stack = builder.addStack();
                //
                properties.nodes = stack.nodes;
                //
                lightingModel.start(builder);
                //
                const { backdrop, backdropAlpha } = context;
                const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context.reflectedLight;
                let totalDiffuse = directDiffuse.add(indirectDiffuse);
                if (backdrop !== null) {
                    if (backdropAlpha !== null) {
                        totalDiffuse = vec3(backdropAlpha.mix(totalDiffuse, backdrop));
                    } else {
                        totalDiffuse = vec3(backdrop);
                    }
                    context.material.transparent = true;
                }
                totalDiffuseNode.assign(totalDiffuse);
                totalSpecularNode.assign(directSpecular.add(indirectSpecular));
                outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));
                //
                lightingModel.finish(builder);
                //
                outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());
            } else {
                properties.nodes = [];
            }
            //
            builder.lightsNode = currentLightsNode;
            return outgoingLightNode;
        }
        setLights(lights) {
            this._lights = lights;
            this._lightNodes = null;
            this._lightNodesHash = null;
            return this;
        }
        getLights() {
            return this._lights;
        }
        get hasLights() {
            return this._lights.length > 0;
        }
    }
    const lights = (lights = []) => nodeObject(new LightsNode()).setLights(lights);
    class ShadowBaseNode extends Node {
        static get type() {
            return 'ShadowBaseNode';
        }
        constructor(light) {
            super();
            this.light = light;
            this.updateBeforeType = NodeUpdateType.RENDER;
            this.isShadowBaseNode = true;
        }
        setupShadowPosition({ context, material }) {
            // Use assign inside an Fn()
            shadowPositionWorld.assign(material.receivedShadowPositionNode || context.shadowPositionWorld || positionWorld);
        }
    }
    const shadowPositionWorld = /*@__PURE__*/ property('vec3', 'shadowPositionWorld');
    function saveRendererState(renderer, state = {}) {
        state.toneMapping = renderer.toneMapping;
        state.toneMappingExposure = renderer.toneMappingExposure;
        state.outputColorSpace = renderer.outputColorSpace;
        state.renderTarget = renderer.getRenderTarget();
        state.activeCubeFace = renderer.getActiveCubeFace();
        state.activeMipmapLevel = renderer.getActiveMipmapLevel();
        state.renderObjectFunction = renderer.getRenderObjectFunction();
        state.pixelRatio = renderer.getPixelRatio();
        state.mrt = renderer.getMRT();
        state.clearColor = renderer.getClearColor(state.clearColor || new Color());
        state.clearAlpha = renderer.getClearAlpha();
        state.autoClear = renderer.autoClear;
        state.scissorTest = renderer.getScissorTest();
        return state;
    }
    function resetRendererState(renderer, state) {
        state = saveRendererState(renderer, state);
        renderer.setMRT(null);
        renderer.setRenderObjectFunction(null);
        renderer.setClearColor(0x000000, 1);
        renderer.autoClear = true;
        return state;
    }
    function restoreRendererState(renderer, state) {
        renderer.toneMapping = state.toneMapping;
        renderer.toneMappingExposure = state.toneMappingExposure;
        renderer.outputColorSpace = state.outputColorSpace;
        renderer.setRenderTarget(state.renderTarget, state.activeCubeFace, state.activeMipmapLevel);
        renderer.setRenderObjectFunction(state.renderObjectFunction);
        renderer.setPixelRatio(state.pixelRatio);
        renderer.setMRT(state.mrt);
        renderer.setClearColor(state.clearColor, state.clearAlpha);
        renderer.autoClear = state.autoClear;
        renderer.setScissorTest(state.scissorTest);
    }
    function saveSceneState(scene, state = {}) {
        state.background = scene.background;
        state.backgroundNode = scene.backgroundNode;
        state.overrideMaterial = scene.overrideMaterial;
        return state;
    }
    function resetSceneState(scene, state) {
        state = saveSceneState(scene, state);
        scene.background = null;
        scene.backgroundNode = null;
        scene.overrideMaterial = null;
        return state;
    }
    function restoreSceneState(scene, state) {
        scene.background = state.background;
        scene.backgroundNode = state.backgroundNode;
        scene.overrideMaterial = state.overrideMaterial;
    }
    function saveRendererAndSceneState(renderer, scene, state = {}) {
        state = saveRendererState(renderer, state);
        state = saveSceneState(scene, state);
        return state;
    }
    function resetRendererAndSceneState(renderer, scene, state) {
        state = resetRendererState(renderer, state);
        state = resetSceneState(scene, state);
        return state;
    }
    function restoreRendererAndSceneState(renderer, scene, state) {
        restoreRendererState(renderer, state);
        restoreSceneState(scene, state);
    }
    var RendererUtils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        resetRendererAndSceneState: resetRendererAndSceneState,
        resetRendererState: resetRendererState,
        resetSceneState: resetSceneState,
        restoreRendererAndSceneState: restoreRendererAndSceneState,
        restoreRendererState: restoreRendererState,
        restoreSceneState: restoreSceneState,
        saveRendererAndSceneState: saveRendererAndSceneState,
        saveRendererState: saveRendererState,
        saveSceneState: saveSceneState
    });
    const shadowMaterialLib = /*@__PURE__*/ new WeakMap();
    const BasicShadowFilter = /*@__PURE__*/ Fn(({ depthTexture, shadowCoord, depthLayer }) => {
        let basic = texture(depthTexture, shadowCoord.xy).setName('t_basic');
        if (depthTexture.isArrayTexture) {
            basic = basic.depth(depthLayer);
        }
        return basic.compare(shadowCoord.z);
    });
    const PCFShadowFilter = /*@__PURE__*/ Fn(({ depthTexture, shadowCoord, shadow, depthLayer }) => {
        const depthCompare = (uv, compare) => {
            let depth = texture(depthTexture, uv);
            if (depthTexture.isArrayTexture) {
                depth = depth.depth(depthLayer);
            }
            return depth.compare(compare);
        };
        const mapSize = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);
        const radius = reference('radius', 'float', shadow).setGroup(renderGroup);
        const texelSize = vec2(1).div(mapSize);
        const dx0 = texelSize.x.negate().mul(radius);
        const dy0 = texelSize.y.negate().mul(radius);
        const dx1 = texelSize.x.mul(radius);
        const dy1 = texelSize.y.mul(radius);
        const dx2 = dx0.div(2);
        const dy2 = dy0.div(2);
        const dx3 = dx1.div(2);
        const dy3 = dy1.div(2);
        return add(
            depthCompare(shadowCoord.xy.add(vec2(dx0, dy0)), shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(0, dy0)), shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(dx1, dy0)), shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(dx2, dy2)), shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(0, dy2)), shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(dx3, dy2)), shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(dx0, 0)), shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(dx2, 0)), shadowCoord.z),
            depthCompare(shadowCoord.xy, shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(dx3, 0)), shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(dx1, 0)), shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(dx2, dy3)), shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(0, dy3)), shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(dx3, dy3)), shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(dx0, dy1)), shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(0, dy1)), shadowCoord.z),
            depthCompare(shadowCoord.xy.add(vec2(dx1, dy1)), shadowCoord.z)
        ).mul(1 / 17);
    });
    const PCFSoftShadowFilter = /*@__PURE__*/ Fn(({ depthTexture, shadowCoord, shadow, depthLayer }) => {
        const depthCompare = (uv, compare) => {
            let depth = texture(depthTexture, uv);
            if (depthTexture.isArrayTexture) {
                depth = depth.depth(depthLayer);
            }
            return depth.compare(compare);
        };

        const mapSize = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);
        const texelSize = vec2(1).div(mapSize);
        const dx = texelSize.x;
        const dy = texelSize.y;
        const uv = shadowCoord.xy;
        const f = fract(uv.mul(mapSize).add(0.5));
        uv.subAssign(f.mul(texelSize));
        return add(
            depthCompare(uv, shadowCoord.z),
            depthCompare(uv.add(vec2(dx, 0)), shadowCoord.z),
            depthCompare(uv.add(vec2(0, dy)), shadowCoord.z),
            depthCompare(uv.add(texelSize), shadowCoord.z),
            mix(
                depthCompare(uv.add(vec2(dx.negate(), 0)), shadowCoord.z),
                depthCompare(uv.add(vec2(dx.mul(2), 0)), shadowCoord.z),
                f.x
            ),
            mix(
                depthCompare(uv.add(vec2(dx.negate(), dy)), shadowCoord.z),
                depthCompare(uv.add(vec2(dx.mul(2), dy)), shadowCoord.z),
                f.x
            ),
            mix(
                depthCompare(uv.add(vec2(0, dy.negate())), shadowCoord.z),
                depthCompare(uv.add(vec2(0, dy.mul(2))), shadowCoord.z),
                f.y
            ),
            mix(
                depthCompare(uv.add(vec2(dx, dy.negate())), shadowCoord.z),
                depthCompare(uv.add(vec2(dx, dy.mul(2))), shadowCoord.z),
                f.y
            ),
            mix(
                mix(
                    depthCompare(uv.add(vec2(dx.negate(), dy.negate())), shadowCoord.z),
                    depthCompare(uv.add(vec2(dx.mul(2), dy.negate())), shadowCoord.z),
                    f.x
                ),
                mix(
                    depthCompare(uv.add(vec2(dx.negate(), dy.mul(2))), shadowCoord.z),
                    depthCompare(uv.add(vec2(dx.mul(2), dy.mul(2))), shadowCoord.z),
                    f.x
                ),
                f.y
            )
        ).mul(1 / 9);
    });
    const VSMShadowFilter = /*@__PURE__*/ Fn(({ depthTexture, shadowCoord, depthLayer }) => {
        const occlusion = float(1).toVar();
        let distribution = texture(depthTexture).sample(shadowCoord.xy);
        if (depthTexture.isArrayTexture) {
            distribution = distribution.depth(depthLayer);
        }
        distribution = distribution.rg;
        const hardShadow = step(shadowCoord.z, distribution.x);
        If(hardShadow.notEqual(float(1.0)), () => {
            const distance = shadowCoord.z.sub(distribution.x);
            const variance = max$1(0, distribution.y.mul(distribution.y));
            let softnessProbability = variance.div(variance.add(distance.mul(distance))); // Chebeyshevs inequality
            softnessProbability = clamp(sub(softnessProbability, 0.3).div(0.95 - 0.3));
            occlusion.assign(clamp(max$1(hardShadow, softnessProbability)));
        });
        return occlusion;
    });
    //
    const linearDistance = /*@__PURE__*/ Fn(([position, cameraNear, cameraFar]) => {
        let dist = positionWorld.sub(position).length();
        dist = dist.sub(cameraNear).div(cameraFar.sub(cameraNear));
        dist = dist.saturate(); // clamp to [ 0, 1 ]
        return dist;
    });
    const linearShadowDistance = (light) => {
        const camera = light.shadow.camera;
        const nearDistance = reference('near', 'float', camera).setGroup(renderGroup);
        const farDistance = reference('far', 'float', camera).setGroup(renderGroup);
        const referencePosition = objectPosition(light);
        return linearDistance(referencePosition, nearDistance, farDistance);
    };
    const getShadowMaterial = (light) => {
        let material = shadowMaterialLib.get(light);
        if (material === undefined) {
            const depthNode = light.isPointLight ? linearShadowDistance(light) : null;
            material = new NodeMaterial();
            material.colorNode = vec4(0, 0, 0, 1);
            material.depthNode = depthNode;
            material.isShadowPassMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode
            material.name = 'ShadowMaterial';
            material.fog = false;
            shadowMaterialLib.set(light, material);
        }
        return material;
    };
    //
    const _shadowRenderObjectLibrary = /*@__PURE__*/ new ChainMap();
    const _shadowRenderObjectKeys = [];
    const getShadowRenderObjectFunction = (renderer, shadow, shadowType, useVelocity) => {
        _shadowRenderObjectKeys[0] = renderer;
        _shadowRenderObjectKeys[1] = shadow;
        let renderObjectFunction = _shadowRenderObjectLibrary.get(_shadowRenderObjectKeys);
        if (renderObjectFunction === undefined || (renderObjectFunction.shadowType !== shadowType || renderObjectFunction.useVelocity !== useVelocity)) {
            renderObjectFunction = (object, scene, _camera$1, geometry, material, group, ...params) => {
                if (object.castShadow === true || (object.receiveShadow && shadowType === VSMShadowMap)) {
                    if (useVelocity) {
                        getDataFromObject(object).useVelocity = true;
                    }
                    object.onBeforeShadow(renderer, object, _camera$1, shadow.camera, geometry, scene.overrideMaterial, group);
                    renderer.renderObject(object, scene, _camera$1, geometry, material, group, ...params);
                    object.onAfterShadow(renderer, object, _camera$1, shadow.camera, geometry, scene.overrideMaterial, group);
                }
            };
            renderObjectFunction.shadowType = shadowType;
            renderObjectFunction.useVelocity = useVelocity;
            _shadowRenderObjectLibrary.set(_shadowRenderObjectKeys, renderObjectFunction);
        }
        _shadowRenderObjectKeys[0] = null;
        _shadowRenderObjectKeys[1] = null;
        return renderObjectFunction;
    };
    const VSMPassVertical = /*@__PURE__*/ Fn(({ samples, radius, size, shadowPass, depthLayer }) => {
        const mean = float(0).toVar('meanVertical');
        const squaredMean = float(0).toVar('squareMeanVertical');
        const uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));
        const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));
        Loop({ start: int(0), end: int(samples), type: 'int', condition: '<' }, ({ i }) => {
            const uvOffset = uvStart.add(float(i).mul(uvStride));
            let depth = shadowPass.sample(add(screenCoordinate.xy, vec2(0, uvOffset).mul(radius)).div(size));
            if (shadowPass.value.isArrayTexture) {
                depth = depth.depth(depthLayer);
            }
            depth = depth.x;
            mean.addAssign(depth);
            squaredMean.addAssign(depth.mul(depth));
        });
        mean.divAssign(samples);
        squaredMean.divAssign(samples);
        const std_dev = sqrt(squaredMean.sub(mean.mul(mean)));
        return vec2(mean, std_dev);
    });
    const VSMPassHorizontal = /*@__PURE__*/ Fn(({ samples, radius, size, shadowPass, depthLayer }) => {
        const mean = float(0).toVar('meanHorizontal');
        const squaredMean = float(0).toVar('squareMeanHorizontal');
        const uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));
        const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));
        Loop({ start: int(0), end: int(samples), type: 'int', condition: '<' }, ({ i }) => {
            const uvOffset = uvStart.add(float(i).mul(uvStride));
            let distribution = shadowPass.sample(add(screenCoordinate.xy, vec2(uvOffset, 0).mul(radius)).div(size));
            if (shadowPass.value.isArrayTexture) {
                distribution = distribution.depth(depthLayer);
            }
            mean.addAssign(distribution.x);
            squaredMean.addAssign(add(distribution.y.mul(distribution.y), distribution.x.mul(distribution.x)));
        });
        mean.divAssign(samples);
        squaredMean.divAssign(samples);
        const std_dev = sqrt(squaredMean.sub(mean.mul(mean)));
        return vec2(mean, std_dev);
    });
    const _shadowFilterLib = [BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter];
    //
    let _rendererState;
    const _quadMesh = /*@__PURE__*/ new QuadMesh();
    class ShadowNode extends ShadowBaseNode {
        static get type() {
            return 'ShadowNode';
        }
        constructor(light, shadow = null) {
            super(light);
            this.shadow = shadow || light.shadow;
            this.shadowMap = null;
            this.vsmShadowMapVertical = null;
            this.vsmShadowMapHorizontal = null;
            this.vsmMaterialVertical = null;
            this.vsmMaterialHorizontal = null;
            this._node = null;
            this._cameraFrameId = new WeakMap();
            this.isShadowNode = true;
            this.depthLayer = 0;
        }
        setupShadowFilter(builder, { filterFn, depthTexture, shadowCoord, shadow, depthLayer }) {
            const frustumTest = shadowCoord.x.greaterThanEqual(0)
                .and(shadowCoord.x.lessThanEqual(1))
                .and(shadowCoord.y.greaterThanEqual(0))
                .and(shadowCoord.y.lessThanEqual(1))
                .and(shadowCoord.z.lessThanEqual(1));
            const shadowNode = filterFn({ depthTexture, shadowCoord, shadow, depthLayer });
            return frustumTest.select(shadowNode, float(1));
        }
        setupShadowCoord(builder, shadowPosition) {
            const { shadow } = this;
            const { renderer } = builder;
            const bias = reference('bias', 'float', shadow).setGroup(renderGroup);
            let shadowCoord = shadowPosition;
            let coordZ;
            if (shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true) {
                shadowCoord = shadowCoord.xyz.div(shadowCoord.w);
                coordZ = shadowCoord.z;
                if (renderer.coordinateSystem === WebGPUCoordinateSystem) {
                    coordZ = coordZ.mul(2).sub(1); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]
                }
            } else {
                const w = shadowCoord.w;
                shadowCoord = shadowCoord.xy.div(w); // <-- Only divide X/Y coords since we don't need Z
                // The normally available "cameraNear" and "cameraFar" nodes cannot be used here because they do not get
                // updated to use the shadow camera. So, we have to declare our own "local" ones here.
                // TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?
                const cameraNearLocal = reference('near', 'float', shadow.camera).setGroup(renderGroup);
                const cameraFarLocal = reference('far', 'float', shadow.camera).setGroup(renderGroup);
                coordZ = viewZToLogarithmicDepth(w.negate(), cameraNearLocal, cameraFarLocal);
            }
            shadowCoord = vec3(
                shadowCoord.x,
                shadowCoord.y.oneMinus(), // follow webgpu standards
                coordZ.add(bias)
            );
            return shadowCoord;
        }
        getShadowFilterFn(type) {
            return _shadowFilterLib[type];
        }

        setupRenderTarget(shadow, builder) {
            const depthTexture = new DepthTexture(shadow.mapSize.width, shadow.mapSize.height);
            depthTexture.name = 'ShadowDepthTexture';
            depthTexture.compareFunction = LessCompare;
            const shadowMap = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height);
            shadowMap.texture.name = 'ShadowMap';
            shadowMap.texture.type = shadow.mapType;
            shadowMap.depthTexture = depthTexture;
            return { shadowMap, depthTexture };
        }
        setupShadow(builder) {
            const { renderer } = builder;
            const { light, shadow } = this;
            const shadowMapType = renderer.shadowMap.type;
            const { depthTexture, shadowMap } = this.setupRenderTarget(shadow, builder);
            shadow.camera.updateProjectionMatrix();
            // VSM
            if (shadowMapType === VSMShadowMap && shadow.isPointLightShadow !== true) {
                depthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()
                if (shadowMap.depth > 1) {
                    if (!shadowMap._vsmShadowMapVertical) {
                        shadowMap._vsmShadowMapVertical = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depth: shadowMap.depth, depthBuffer: false });
                        shadowMap._vsmShadowMapVertical.texture.name = 'VSMVertical';
                    }
                    this.vsmShadowMapVertical = shadowMap._vsmShadowMapVertical;
                    if (!shadowMap._vsmShadowMapHorizontal) {
                        shadowMap._vsmShadowMapHorizontal = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depth: shadowMap.depth, depthBuffer: false });
                        shadowMap._vsmShadowMapHorizontal.texture.name = 'VSMHorizontal';
                    }
                    this.vsmShadowMapHorizontal = shadowMap._vsmShadowMapHorizontal;
                } else {
                    this.vsmShadowMapVertical = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depthBuffer: false });
                    this.vsmShadowMapHorizontal = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depthBuffer: false });
                }

                let shadowPassVertical = texture(depthTexture);
                if (depthTexture.isArrayTexture) {
                    shadowPassVertical = shadowPassVertical.depth(this.depthLayer);
                }
                let shadowPassHorizontal = texture(this.vsmShadowMapVertical.texture);
                if (depthTexture.isArrayTexture) {
                    shadowPassHorizontal = shadowPassHorizontal.depth(this.depthLayer);
                }
                const samples = reference('blurSamples', 'float', shadow).setGroup(renderGroup);
                const radius = reference('radius', 'float', shadow).setGroup(renderGroup);
                const size = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);
                let material = this.vsmMaterialVertical || (this.vsmMaterialVertical = new NodeMaterial());
                material.fragmentNode = VSMPassVertical({ samples, radius, size, shadowPass: shadowPassVertical, depthLayer: this.depthLayer }).context(builder.getSharedContext());
                material.name = 'VSMVertical';
                material = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new NodeMaterial());
                material.fragmentNode = VSMPassHorizontal({ samples, radius, size, shadowPass: shadowPassHorizontal, depthLayer: this.depthLayer }).context(builder.getSharedContext());
                material.name = 'VSMHorizontal';
            }
            //
            const shadowIntensity = reference('intensity', 'float', shadow).setGroup(renderGroup);
            const normalBias = reference('normalBias', 'float', shadow).setGroup(renderGroup);
            const shadowPosition = lightShadowMatrix(light).mul(shadowPositionWorld.add(normalWorld.mul(normalBias)));
            const shadowCoord = this.setupShadowCoord(builder, shadowPosition);
            //
            const filterFn = shadow.filterNode || this.getShadowFilterFn(renderer.shadowMap.type) || null;
            if (filterFn === null) {
                throw new Error('THREE.WebGPURenderer: Shadow map type not supported yet.');
            }
            const shadowDepthTexture = (shadowMapType === VSMShadowMap && shadow.isPointLightShadow !== true) ? this.vsmShadowMapHorizontal.texture : depthTexture;
            const shadowNode = this.setupShadowFilter(builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow, depthLayer: this.depthLayer });
            let shadowColor = texture(shadowMap.texture, shadowCoord);
            if (depthTexture.isArrayTexture) {
                shadowColor = shadowColor.depth(this.depthLayer);
            }
            const shadowOutput = mix(1, shadowNode.rgb.mix(shadowColor, 1), shadowIntensity.mul(shadowColor.a)).toVar();
            this.shadowMap = shadowMap;
            this.shadow.map = shadowMap;
            return shadowOutput;
        }
        setup(builder) {
            if (builder.renderer.shadowMap.enabled === false) return;
            return Fn(() => {
                let node = this._node;
                this.setupShadowPosition(builder);
                if (node === null) {
                    this._node = node = this.setupShadow(builder);
                }
                if (builder.material.shadowNode) { // @deprecated, r171
                    console.warn('THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.');
                }
                if (builder.material.receivedShadowNode) {
                    node = builder.material.receivedShadowNode(node);
                }
                return node;
            })();
        }
        renderShadow(frame) {
            const { shadow, shadowMap, light } = this;
            const { renderer, scene } = frame;
            shadow.updateMatrices(light);
            shadowMap.setSize(shadow.mapSize.width, shadow.mapSize.height, shadowMap.depth);
            renderer.render(scene, shadow.camera);
        }
        updateShadow(frame) {
            const { shadowMap, light, shadow } = this;
            const { renderer, scene, camera } = frame;
            const shadowType = renderer.shadowMap.type;
            const depthVersion = shadowMap.depthTexture.version;
            this._depthVersionCached = depthVersion;
            const _shadowCameraLayer = shadow.camera.layers.mask;
            if ((shadow.camera.layers.mask & 0xFFFFFFFE) === 0) {
                shadow.camera.layers.mask = camera.layers.mask;
            }
            const currentRenderObjectFunction = renderer.getRenderObjectFunction();
            const currentMRT = renderer.getMRT();
            const useVelocity = currentMRT ? currentMRT.has('velocity') : false;
            _rendererState = resetRendererAndSceneState(renderer, scene, _rendererState);
            scene.overrideMaterial = getShadowMaterial(light);
            renderer.setRenderObjectFunction(getShadowRenderObjectFunction(renderer, shadow, shadowType, useVelocity));
            renderer.setClearColor(0x000000, 0);
            renderer.setRenderTarget(shadowMap);
            this.renderShadow(frame);
            renderer.setRenderObjectFunction(currentRenderObjectFunction);
            // vsm blur pass
            if (shadowType === VSMShadowMap && shadow.isPointLightShadow !== true) {
                this.vsmPass(renderer);
            }
            shadow.camera.layers.mask = _shadowCameraLayer;
            restoreRendererAndSceneState(renderer, scene, _rendererState);
        }
        vsmPass(renderer) {
            const { shadow } = this;
            const depth = this.shadowMap.depth;
            this.vsmShadowMapVertical.setSize(shadow.mapSize.width, shadow.mapSize.height, depth);
            this.vsmShadowMapHorizontal.setSize(shadow.mapSize.width, shadow.mapSize.height, depth);
            renderer.setRenderTarget(this.vsmShadowMapVertical);
            _quadMesh.material = this.vsmMaterialVertical;
            _quadMesh.render(renderer);
            renderer.setRenderTarget(this.vsmShadowMapHorizontal);
            _quadMesh.material = this.vsmMaterialHorizontal;
            _quadMesh.render(renderer);
        }
        dispose() {
            this.shadowMap.dispose();
            this.shadowMap = null;
            if (this.vsmShadowMapVertical !== null) {
                this.vsmShadowMapVertical.dispose();
                this.vsmShadowMapVertical = null;
                this.vsmMaterialVertical.dispose();
                this.vsmMaterialVertical = null;
            }
            if (this.vsmShadowMapHorizontal !== null) {
                this.vsmShadowMapHorizontal.dispose();
                this.vsmShadowMapHorizontal = null;
                this.vsmMaterialHorizontal.dispose();
                this.vsmMaterialHorizontal = null;
            }
            super.dispose();
        }
        updateBefore(frame) {
            const { shadow } = this;
            let needsUpdate = shadow.needsUpdate || shadow.autoUpdate;
            if (needsUpdate) {
                if (this._cameraFrameId[frame.camera] === frame.frameId) {
                    needsUpdate = false;
                }
                this._cameraFrameId[frame.camera] = frame.frameId;
            }
            if (needsUpdate) {
                this.updateShadow(frame);
                if (this.shadowMap.depthTexture.version === this._depthVersionCached) {
                    shadow.needsUpdate = false;
                }
            }
        }
    }
    const shadow = (light, shadow) => nodeObject(new ShadowNode(light, shadow));
    const _clearColor$1 = /*@__PURE__*/ new Color();
    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
    // vector suitable for 2D texture mapping. This code uses the following layout for the
    // 2D texture:
    //
    // xzXZ
    //  y Y
    //
    // Y - Positive y direction
    // y - Negative y direction
    // X - Positive x direction
    // x - Negative x direction
    // Z - Positive z direction
    // z - Negative z direction
    //
    // Source and test bed:
    // https://gist.github.com/tschw/da10c43c467ce8afd0c4
    const cubeToUV = /*@__PURE__*/ Fn(([pos, texelSizeY]) => {
        const v = pos.toVar();
        // Number of texels to avoid at the edge of each square
        const absV = abs(v);
        // Intersect unit cube
        const scaleToCube = div(1.0, max$1(absV.x, max$1(absV.y, absV.z)));
        absV.mulAssign(scaleToCube);
        // Apply scale to avoid seams
        // two texels less per square (one texel will do for NEAREST)
        v.mulAssign(scaleToCube.mul(texelSizeY.mul(2).oneMinus()));
        // Unwrap
        // space: -1 ... 1 range for each square
        //
        // #X##		dim    := ( 4 , 2 )
        //  # #		center := ( 1 , 1 )
        const planar = vec2(v.xy).toVar();
        const almostATexel = texelSizeY.mul(1.5);
        const almostOne = almostATexel.oneMinus();
        If(absV.z.greaterThanEqual(almostOne), () => {
            If(v.z.greaterThan(0.0), () => {
                planar.x.assign(sub(4.0, v.x));
            });
        }).ElseIf(absV.x.greaterThanEqual(almostOne), () => {
            const signX = sign(v.x);
            planar.x.assign(v.z.mul(signX).add(signX.mul(2.0)));
        }).ElseIf(absV.y.greaterThanEqual(almostOne), () => {
            const signY = sign(v.y);
            planar.x.assign(v.x.add(signY.mul(2.0)).add(2.0));
            planar.y.assign(v.z.mul(signY).sub(2.0));
        });
        // Transform to UV space
        // scale := 0.5 / dim
        // translate := ( center + 0.5 ) / dim
        return vec2(0.125, 0.25).mul(planar).add(vec2(0.375, 0.75)).flipY();
    }).setLayout({
        name: 'cubeToUV',
        type: 'vec2',
        inputs: [
            { name: 'pos', type: 'vec3' },
            { name: 'texelSizeY', type: 'float' }
        ]
    });
    const BasicPointShadowFilter = /*@__PURE__*/ Fn(({ depthTexture, bd3D, dp, texelSize }) => {
        return texture(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp);
    });
    const PointShadowFilter = /*@__PURE__*/ Fn(({ depthTexture, bd3D, dp, texelSize, shadow }) => {
        const radius = reference('radius', 'float', shadow).setGroup(renderGroup);
        const offset = vec2(-1, 1.0).mul(radius).mul(texelSize.y);
        return texture(depthTexture, cubeToUV(bd3D.add(offset.xyy), texelSize.y)).compare(dp)
            .add(texture(depthTexture, cubeToUV(bd3D.add(offset.yyy), texelSize.y)).compare(dp))
            .add(texture(depthTexture, cubeToUV(bd3D.add(offset.xyx), texelSize.y)).compare(dp))
            .add(texture(depthTexture, cubeToUV(bd3D.add(offset.yyx), texelSize.y)).compare(dp))
            .add(texture(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp))
            .add(texture(depthTexture, cubeToUV(bd3D.add(offset.xxy), texelSize.y)).compare(dp))
            .add(texture(depthTexture, cubeToUV(bd3D.add(offset.yxy), texelSize.y)).compare(dp))
            .add(texture(depthTexture, cubeToUV(bd3D.add(offset.xxx), texelSize.y)).compare(dp))
            .add(texture(depthTexture, cubeToUV(bd3D.add(offset.yxx), texelSize.y)).compare(dp))
            .mul(1.0 / 9.0);
    });
    const pointShadowFilter = /*@__PURE__*/ Fn(({ filterFn, depthTexture, shadowCoord, shadow }) => {
        // for point lights, the uniform @vShadowCoord is re-purposed to hold
        // the vector from the light to the world-space position of the fragment.
        const lightToPosition = shadowCoord.xyz.toVar();
        const lightToPositionLength = lightToPosition.length();
        const cameraNearLocal = uniform('float').setGroup(renderGroup).onRenderUpdate(() => shadow.camera.near);
        const cameraFarLocal = uniform('float').setGroup(renderGroup).onRenderUpdate(() => shadow.camera.far);
        const bias = reference('bias', 'float', shadow).setGroup(renderGroup);
        const mapSize = uniform(shadow.mapSize).setGroup(renderGroup);
        const result = float(1.0).toVar();
        If(lightToPositionLength.sub(cameraFarLocal).lessThanEqual(0.0).and(lightToPositionLength.sub(cameraNearLocal).greaterThanEqual(0.0)), () => {
            // dp = normalized distance from light to fragment position
            const dp = lightToPositionLength.sub(cameraNearLocal).div(cameraFarLocal.sub(cameraNearLocal)).toVar(); // need to clamp?
            dp.addAssign(bias);
            // bd3D = base direction 3D
            const bd3D = lightToPosition.normalize();
            const texelSize = vec2(1.0).div(mapSize.mul(vec2(4.0, 2.0)));
            // percentage-closer filtering
            result.assign(filterFn({ depthTexture, bd3D, dp, texelSize, shadow }));
        });
        return result;
    });
    const _viewport = /*@__PURE__*/ new Vector4();
    const _viewportSize = /*@__PURE__*/ new Vector2();
    const _shadowMapSize = /*@__PURE__*/ new Vector2();

    class PointShadowNode extends ShadowNode {
        static get type() {
            return 'PointShadowNode';
        }
        constructor(light, shadow = null) {
            super(light, shadow);
        }
        getShadowFilterFn(type) {
            return type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;
        }
        setupShadowCoord(builder, shadowPosition) {
            return shadowPosition;
        }
        setupShadowFilter(builder, { filterFn, shadowTexture, depthTexture, shadowCoord, shadow }) {
            return pointShadowFilter({ filterFn, shadowTexture, depthTexture, shadowCoord, shadow });
        }
        renderShadow(frame) {
            const { shadow, shadowMap, light } = this;
            const { renderer, scene } = frame;
            const shadowFrameExtents = shadow.getFrameExtents();
            _shadowMapSize.copy(shadow.mapSize);
            _shadowMapSize.multiply(shadowFrameExtents);
            shadowMap.setSize(_shadowMapSize.width, _shadowMapSize.height);
            _viewportSize.copy(shadow.mapSize);
            //
            const previousAutoClear = renderer.autoClear;
            const previousClearColor = renderer.getClearColor(_clearColor$1);
            const previousClearAlpha = renderer.getClearAlpha();
            renderer.autoClear = false;
            renderer.setClearColor(shadow.clearColor, shadow.clearAlpha);
            renderer.clear();
            const viewportCount = shadow.getViewportCount();
            for (let vp = 0; vp < viewportCount; vp++) {
                const viewport = shadow.getViewport(vp);
                const x = _viewportSize.x * viewport.x;
                const y = _shadowMapSize.y - _viewportSize.y - (_viewportSize.y * viewport.y);
                _viewport.set(
                    x,
                    y,
                    _viewportSize.x * viewport.z,
                    _viewportSize.y * viewport.w
                );
                shadowMap.viewport.copy(_viewport);
                shadow.updateMatrices(light, vp);
                renderer.render(scene, shadow.camera);
            }
            //
            renderer.autoClear = previousAutoClear;
            renderer.setClearColor(previousClearColor, previousClearAlpha);
        }
    }
    const pointShadow = (light, shadow) => nodeObject(new PointShadowNode(light, shadow));
    class AnalyticLightNode extends LightingNode {
        static get type() {
            return 'AnalyticLightNode';
        }
        constructor(light = null) {
            super();
            this.light = light;
            this.color = new Color();
            this.colorNode = (light && light.colorNode) || uniform(this.color).setGroup(renderGroup);
            this.baseColorNode = null;
            this.shadowNode = null;
            this.shadowColorNode = null;
            this.isAnalyticLightNode = true;
            this.updateType = NodeUpdateType.FRAME;
        }
        getHash() {
            return this.light.uuid;
        }
        getLightVector(builder) {
            return lightViewPosition(this.light).sub(builder.context.positionView || positionView);
        }
        setupDirect( /*builder*/) { }
        setupDirectRectArea( /*builder*/) { }
        setupShadowNode() {
            return shadow(this.light);
        }
        setupShadow(builder) {
            const { renderer } = builder;
            if (renderer.shadowMap.enabled === false) return;
            let shadowColorNode = this.shadowColorNode;
            if (shadowColorNode === null) {
                const customShadowNode = this.light.shadow.shadowNode;
                let shadowNode;
                if (customShadowNode !== undefined) {
                    shadowNode = nodeObject(customShadowNode);
                } else {
                    shadowNode = this.setupShadowNode();
                }
                this.shadowNode = shadowNode;
                this.shadowColorNode = shadowColorNode = this.colorNode.mul(shadowNode);
                this.baseColorNode = this.colorNode;
            }
            //
            this.colorNode = shadowColorNode;
        }
        setup(builder) {
            this.colorNode = this.baseColorNode || this.colorNode;
            if (this.light.castShadow) {
                if (builder.object.receiveShadow) {
                    this.setupShadow(builder);
                }
            } else if (this.shadowNode !== null) {
                this.shadowNode.dispose();
                this.shadowNode = null;
                this.shadowColorNode = null;
            }
            const directLightData = this.setupDirect(builder);
            const directRectAreaLightData = this.setupDirectRectArea(builder);
            if (directLightData) {
                builder.lightsNode.setupDirectLight(builder, this, directLightData);
            }
            if (directRectAreaLightData) {
                builder.lightsNode.setupDirectRectAreaLight(builder, this, directRectAreaLightData);
            }
        }
        update( /*frame*/) {
            const { light } = this;
            this.color.copy(light.color).multiplyScalar(light.intensity);
        }
    }
    const getDistanceAttenuation = /*@__PURE__*/ Fn(({ lightDistance, cutoffDistance, decayExponent }) => {
        // based upon Frostbite 3 Moving to Physically-based Rendering
        // page 32, equation 26: E[window1]
        // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
        const distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();
        return cutoffDistance.greaterThan(0).select(
            distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()),
            distanceFalloff
        );
    }); // validated
    const directPointLight = ({ color, lightVector, cutoffDistance, decayExponent }) => {
        const lightDirection = lightVector.normalize();
        const lightDistance = lightVector.length();
        const attenuation = getDistanceAttenuation({
            lightDistance,
            cutoffDistance,
            decayExponent
        });
        const lightColor = color.mul(attenuation);
        return { lightDirection, lightColor };
    };
    class PointLightNode extends AnalyticLightNode {
        static get type() {
            return 'PointLightNode';
        }
        constructor(light = null) {
            super(light);
            this.cutoffDistanceNode = uniform(0).setGroup(renderGroup);
            this.decayExponentNode = uniform(2).setGroup(renderGroup);
        }
        update(frame) {
            const { light } = this;
            super.update(frame);
            this.cutoffDistanceNode.value = light.distance;
            this.decayExponentNode.value = light.decay;
        }
        setupShadowNode() {
            return pointShadow(this.light);
        }
        setupDirect(builder) {
            return directPointLight({
                color: this.colorNode,
                lightVector: this.getLightVector(builder),
                cutoffDistance: this.cutoffDistanceNode,
                decayExponent: this.decayExponentNode
            });
        }
    }
    const checker = /*@__PURE__*/ Fn(([coord = uv()]) => {
        const uv = coord.mul(2.0);
        const cx = uv.x.floor();
        const cy = uv.y.floor();
        const result = cx.add(cy).mod(2.0);
        return result.sign();
    });
    const shapeCircle = Fn(([coord = uv()], { renderer, material }) => {
        const len2 = lengthSq(coord.mul(2).sub(1));
        let alpha;
        if (material.alphaToCoverage && renderer.samples > 1) {
            const dlen = float(len2.fwidth()).toVar();
            alpha = smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus();
        } else {
            alpha = select(len2.greaterThan(1.0), 0, 1);
        }
        return alpha;
    });
    // Three.js Transpiler
    // https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/libraries/stdlib/genglsl/lib/mx_noise.glsl

    const mx_select = /*@__PURE__*/ Fn(([b_immutable, t_immutable, f_immutable]) => {
        const f = float(f_immutable).toVar();
        const t = float(t_immutable).toVar();
        const b = bool(b_immutable).toVar();
        return select(b, t, f);
    }).setLayout({
        name: 'mx_select',
        type: 'float',
        inputs: [
            { name: 'b', type: 'bool' },
            { name: 't', type: 'float' },
            { name: 'f', type: 'float' }
        ]
    });
    const mx_negate_if = /*@__PURE__*/ Fn(([val_immutable, b_immutable]) => {
        const b = bool(b_immutable).toVar();
        const val = float(val_immutable).toVar();
        return select(b, val.negate(), val);
    }).setLayout({
        name: 'mx_negate_if',
        type: 'float',
        inputs: [
            { name: 'val', type: 'float' },
            { name: 'b', type: 'bool' }
        ]
    });
    const mx_floor = /*@__PURE__*/ Fn(([x_immutable]) => {
        const x = float(x_immutable).toVar();
        return int(floor(x));
    }).setLayout({
        name: 'mx_floor',
        type: 'int',
        inputs: [
            { name: 'x', type: 'float' }
        ]
    });
    const mx_floorfrac = /*@__PURE__*/ Fn(([x_immutable, i]) => {
        const x = float(x_immutable).toVar();
        i.assign(mx_floor(x));
        return x.sub(float(i));
    });
    const mx_bilerp_0 = /*@__PURE__*/ Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
        const t = float(t_immutable).toVar();
        const s = float(s_immutable).toVar();
        const v3 = float(v3_immutable).toVar();
        const v2 = float(v2_immutable).toVar();
        const v1 = float(v1_immutable).toVar();
        const v0 = float(v0_immutable).toVar();
        const s1 = float(sub(1.0, s)).toVar();
        return sub(1.0, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
    }).setLayout({
        name: 'mx_bilerp_0',
        type: 'float',
        inputs: [
            { name: 'v0', type: 'float' },
            { name: 'v1', type: 'float' },
            { name: 'v2', type: 'float' },
            { name: 'v3', type: 'float' },
            { name: 's', type: 'float' },
            { name: 't', type: 'float' }
        ]
    });
    const mx_bilerp_1 = /*@__PURE__*/ Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
        const t = float(t_immutable).toVar();
        const s = float(s_immutable).toVar();
        const v3 = vec3(v3_immutable).toVar();
        const v2 = vec3(v2_immutable).toVar();
        const v1 = vec3(v1_immutable).toVar();
        const v0 = vec3(v0_immutable).toVar();
        const s1 = float(sub(1.0, s)).toVar();
        return sub(1.0, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
    }).setLayout({
        name: 'mx_bilerp_1',
        type: 'vec3',
        inputs: [
            { name: 'v0', type: 'vec3' },
            { name: 'v1', type: 'vec3' },
            { name: 'v2', type: 'vec3' },
            { name: 'v3', type: 'vec3' },
            { name: 's', type: 'float' },
            { name: 't', type: 'float' }
        ]
    });
    const mx_bilerp = /*@__PURE__*/ overloadingFn([mx_bilerp_0, mx_bilerp_1]);
    const mx_trilerp_0 = /*@__PURE__*/ Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
        const r = float(r_immutable).toVar();
        const t = float(t_immutable).toVar();
        const s = float(s_immutable).toVar();
        const v7 = float(v7_immutable).toVar();
        const v6 = float(v6_immutable).toVar();
        const v5 = float(v5_immutable).toVar();
        const v4 = float(v4_immutable).toVar();
        const v3 = float(v3_immutable).toVar();
        const v2 = float(v2_immutable).toVar();
        const v1 = float(v1_immutable).toVar();
        const v0 = float(v0_immutable).toVar();
        const s1 = float(sub(1.0, s)).toVar();
        const t1 = float(sub(1.0, t)).toVar();
        const r1 = float(sub(1.0, r)).toVar();
        return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
    }).setLayout({
        name: 'mx_trilerp_0',
        type: 'float',
        inputs: [
            { name: 'v0', type: 'float' },
            { name: 'v1', type: 'float' },
            { name: 'v2', type: 'float' },
            { name: 'v3', type: 'float' },
            { name: 'v4', type: 'float' },
            { name: 'v5', type: 'float' },
            { name: 'v6', type: 'float' },
            { name: 'v7', type: 'float' },
            { name: 's', type: 'float' },
            { name: 't', type: 'float' },
            { name: 'r', type: 'float' }
        ]
    });
    const mx_trilerp_1 = /*@__PURE__*/ Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
        const r = float(r_immutable).toVar();
        const t = float(t_immutable).toVar();
        const s = float(s_immutable).toVar();
        const v7 = vec3(v7_immutable).toVar();
        const v6 = vec3(v6_immutable).toVar();
        const v5 = vec3(v5_immutable).toVar();
        const v4 = vec3(v4_immutable).toVar();
        const v3 = vec3(v3_immutable).toVar();
        const v2 = vec3(v2_immutable).toVar();
        const v1 = vec3(v1_immutable).toVar();
        const v0 = vec3(v0_immutable).toVar();
        const s1 = float(sub(1.0, s)).toVar();
        const t1 = float(sub(1.0, t)).toVar();
        const r1 = float(sub(1.0, r)).toVar();
        return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
    }).setLayout({
        name: 'mx_trilerp_1',
        type: 'vec3',
        inputs: [
            { name: 'v0', type: 'vec3' },
            { name: 'v1', type: 'vec3' },
            { name: 'v2', type: 'vec3' },
            { name: 'v3', type: 'vec3' },
            { name: 'v4', type: 'vec3' },
            { name: 'v5', type: 'vec3' },
            { name: 'v6', type: 'vec3' },
            { name: 'v7', type: 'vec3' },
            { name: 's', type: 'float' },
            { name: 't', type: 'float' },
            { name: 'r', type: 'float' }
        ]
    });
    const mx_trilerp = /*@__PURE__*/ overloadingFn([mx_trilerp_0, mx_trilerp_1]);
    const mx_gradient_float_0 = /*@__PURE__*/ Fn(([hash_immutable, x_immutable, y_immutable]) => {
        const y = float(y_immutable).toVar();
        const x = float(x_immutable).toVar();
        const hash = uint(hash_immutable).toVar();
        const h = uint(hash.bitAnd(uint(7))).toVar();
        const u = float(mx_select(h.lessThan(uint(4)), x, y)).toVar();
        const v = float(mul(2.0, mx_select(h.lessThan(uint(4)), y, x))).toVar();
        return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));
    }).setLayout({
        name: 'mx_gradient_float_0',
        type: 'float',
        inputs: [
            { name: 'hash', type: 'uint' },
            { name: 'x', type: 'float' },
            { name: 'y', type: 'float' }
        ]
    });
    const mx_gradient_float_1 = /*@__PURE__*/ Fn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
        const z = float(z_immutable).toVar();
        const y = float(y_immutable).toVar();
        const x = float(x_immutable).toVar();
        const hash = uint(hash_immutable).toVar();
        const h = uint(hash.bitAnd(uint(15))).toVar();
        const u = float(mx_select(h.lessThan(uint(8)), x, y)).toVar();
        const v = float(mx_select(h.lessThan(uint(4)), y, mx_select(h.equal(uint(12)).or(h.equal(uint(14))), x, z))).toVar();
        return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));
    }).setLayout({
        name: 'mx_gradient_float_1',
        type: 'float',
        inputs: [
            { name: 'hash', type: 'uint' },
            { name: 'x', type: 'float' },
            { name: 'y', type: 'float' },
            { name: 'z', type: 'float' }
        ]
    });
    const mx_gradient_float = /*@__PURE__*/ overloadingFn([mx_gradient_float_0, mx_gradient_float_1]);
    const mx_gradient_vec3_0 = /*@__PURE__*/ Fn(([hash_immutable, x_immutable, y_immutable]) => {
        const y = float(y_immutable).toVar();
        const x = float(x_immutable).toVar();
        const hash = uvec3(hash_immutable).toVar();
        return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));
    }).setLayout({
        name: 'mx_gradient_vec3_0',
        type: 'vec3',
        inputs: [
            { name: 'hash', type: 'uvec3' },
            { name: 'x', type: 'float' },
            { name: 'y', type: 'float' }
        ]
    });
    const mx_gradient_vec3_1 = /*@__PURE__*/ Fn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
        const z = float(z_immutable).toVar();
        const y = float(y_immutable).toVar();
        const x = float(x_immutable).toVar();
        const hash = uvec3(hash_immutable).toVar();
        return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));
    }).setLayout({
        name: 'mx_gradient_vec3_1',
        type: 'vec3',
        inputs: [
            { name: 'hash', type: 'uvec3' },
            { name: 'x', type: 'float' },
            { name: 'y', type: 'float' },
            { name: 'z', type: 'float' }
        ]
    });
    const mx_gradient_vec3 = /*@__PURE__*/ overloadingFn([mx_gradient_vec3_0, mx_gradient_vec3_1]);
    const mx_gradient_scale2d_0 = /*@__PURE__*/ Fn(([v_immutable]) => {
        const v = float(v_immutable).toVar();
        return mul(0.6616, v);
    }).setLayout({
        name: 'mx_gradient_scale2d_0',
        type: 'float',
        inputs: [
            { name: 'v', type: 'float' }
        ]
    });
    const mx_gradient_scale3d_0 = /*@__PURE__*/ Fn(([v_immutable]) => {
        const v = float(v_immutable).toVar();
        return mul(0.9820, v);
    }).setLayout({
        name: 'mx_gradient_scale3d_0',
        type: 'float',
        inputs: [
            { name: 'v', type: 'float' }
        ]
    });
    const mx_gradient_scale2d_1 = /*@__PURE__*/ Fn(([v_immutable]) => {
        const v = vec3(v_immutable).toVar();
        return mul(0.6616, v);
    }).setLayout({
        name: 'mx_gradient_scale2d_1',
        type: 'vec3',
        inputs: [
            { name: 'v', type: 'vec3' }
        ]
    });
    const mx_gradient_scale2d = /*@__PURE__*/ overloadingFn([mx_gradient_scale2d_0, mx_gradient_scale2d_1]);
    const mx_gradient_scale3d_1 = /*@__PURE__*/ Fn(([v_immutable]) => {
        const v = vec3(v_immutable).toVar();
        return mul(0.9820, v);
    }).setLayout({
        name: 'mx_gradient_scale3d_1',
        type: 'vec3',
        inputs: [
            { name: 'v', type: 'vec3' }
        ]
    });
    const mx_gradient_scale3d = /*@__PURE__*/ overloadingFn([mx_gradient_scale3d_0, mx_gradient_scale3d_1]);
    const mx_rotl32 = /*@__PURE__*/ Fn(([x_immutable, k_immutable]) => {
        const k = int(k_immutable).toVar();
        const x = uint(x_immutable).toVar();
        return x.shiftLeft(k).bitOr(x.shiftRight(int(32).sub(k)));
    }).setLayout({
        name: 'mx_rotl32',
        type: 'uint',
        inputs: [
            { name: 'x', type: 'uint' },
            { name: 'k', type: 'int' }
        ]
    });
    const mx_bjmix = /*@__PURE__*/ Fn(([a, b, c]) => {
        a.subAssign(c);
        a.bitXorAssign(mx_rotl32(c, int(4)));
        c.addAssign(b);
        b.subAssign(a);
        b.bitXorAssign(mx_rotl32(a, int(6)));
        a.addAssign(c);
        c.subAssign(b);
        c.bitXorAssign(mx_rotl32(b, int(8)));
        b.addAssign(a);
        a.subAssign(c);
        a.bitXorAssign(mx_rotl32(c, int(16)));
        c.addAssign(b);
        b.subAssign(a);
        b.bitXorAssign(mx_rotl32(a, int(19)));
        a.addAssign(c);
        c.subAssign(b);
        c.bitXorAssign(mx_rotl32(b, int(4)));
        b.addAssign(a);
    });
    const mx_bjfinal = /*@__PURE__*/ Fn(([a_immutable, b_immutable, c_immutable]) => {
        const c = uint(c_immutable).toVar();
        const b = uint(b_immutable).toVar();
        const a = uint(a_immutable).toVar();
        c.bitXorAssign(b);
        c.subAssign(mx_rotl32(b, int(14)));
        a.bitXorAssign(c);
        a.subAssign(mx_rotl32(c, int(11)));
        b.bitXorAssign(a);
        b.subAssign(mx_rotl32(a, int(25)));
        c.bitXorAssign(b);
        c.subAssign(mx_rotl32(b, int(16)));
        a.bitXorAssign(c);
        a.subAssign(mx_rotl32(c, int(4)));
        b.bitXorAssign(a);
        b.subAssign(mx_rotl32(a, int(14)));
        c.bitXorAssign(b);
        c.subAssign(mx_rotl32(b, int(24)));
        return c;
    }).setLayout({
        name: 'mx_bjfinal',
        type: 'uint',
        inputs: [
            { name: 'a', type: 'uint' },
            { name: 'b', type: 'uint' },
            { name: 'c', type: 'uint' }
        ]
    });
    const mx_bits_to_01 = /*@__PURE__*/ Fn(([bits_immutable]) => {
        const bits = uint(bits_immutable).toVar();
        return float(bits).div(float(uint(int(0xffffffff))));
    }).setLayout({
        name: 'mx_bits_to_01',
        type: 'float',
        inputs: [
            { name: 'bits', type: 'uint' }
        ]
    });
    const mx_fade = /*@__PURE__*/ Fn(([t_immutable]) => {
        const t = float(t_immutable).toVar();
        return t.mul(t).mul(t).mul(t.mul(t.mul(6.0).sub(15.0)).add(10.0));
    }).setLayout({
        name: 'mx_fade',
        type: 'float',
        inputs: [
            { name: 't', type: 'float' }
        ]
    });
    const mx_hash_int_0 = /*@__PURE__*/ Fn(([x_immutable]) => {
        const x = int(x_immutable).toVar();
        const len = uint(uint(1)).toVar();
        const seed = uint(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13))).toVar();
        return mx_bjfinal(seed.add(uint(x)), seed, seed);
    }).setLayout({
        name: 'mx_hash_int_0',
        type: 'uint',
        inputs: [
            { name: 'x', type: 'int' }
        ]
    });
    const mx_hash_int_1 = /*@__PURE__*/ Fn(([x_immutable, y_immutable]) => {
        const y = int(y_immutable).toVar();
        const x = int(x_immutable).toVar();
        const len = uint(uint(2)).toVar();
        const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
        a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));
        a.addAssign(uint(x));
        b.addAssign(uint(y));
        return mx_bjfinal(a, b, c);
    }).setLayout({
        name: 'mx_hash_int_1',
        type: 'uint',
        inputs: [
            { name: 'x', type: 'int' },
            { name: 'y', type: 'int' }
        ]
    });
    const mx_hash_int_2 = /*@__PURE__*/ Fn(([x_immutable, y_immutable, z_immutable]) => {
        const z = int(z_immutable).toVar();
        const y = int(y_immutable).toVar();
        const x = int(x_immutable).toVar();
        const len = uint(uint(3)).toVar();
        const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
        a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));
        a.addAssign(uint(x));
        b.addAssign(uint(y));
        c.addAssign(uint(z));
        return mx_bjfinal(a, b, c);
    }).setLayout({
        name: 'mx_hash_int_2',
        type: 'uint',
        inputs: [
            { name: 'x', type: 'int' },
            { name: 'y', type: 'int' },
            { name: 'z', type: 'int' }
        ]
    });
    const mx_hash_int_3 = /*@__PURE__*/ Fn(([x_immutable, y_immutable, z_immutable, xx_immutable]) => {
        const xx = int(xx_immutable).toVar();
        const z = int(z_immutable).toVar();
        const y = int(y_immutable).toVar();
        const x = int(x_immutable).toVar();
        const len = uint(uint(4)).toVar();
        const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
        a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));
        a.addAssign(uint(x));
        b.addAssign(uint(y));
        c.addAssign(uint(z));
        mx_bjmix(a, b, c);
        a.addAssign(uint(xx));
        return mx_bjfinal(a, b, c);
    }).setLayout({
        name: 'mx_hash_int_3',
        type: 'uint',
        inputs: [
            { name: 'x', type: 'int' },
            { name: 'y', type: 'int' },
            { name: 'z', type: 'int' },
            { name: 'xx', type: 'int' }
        ]
    });
    const mx_hash_int_4 = /*@__PURE__*/ Fn(([x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable]) => {
        const yy = int(yy_immutable).toVar();
        const xx = int(xx_immutable).toVar();
        const z = int(z_immutable).toVar();
        const y = int(y_immutable).toVar();
        const x = int(x_immutable).toVar();
        const len = uint(uint(5)).toVar();
        const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
        a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));
        a.addAssign(uint(x));
        b.addAssign(uint(y));
        c.addAssign(uint(z));
        mx_bjmix(a, b, c);
        a.addAssign(uint(xx));
        b.addAssign(uint(yy));
        return mx_bjfinal(a, b, c);
    }).setLayout({
        name: 'mx_hash_int_4',
        type: 'uint',
        inputs: [
            { name: 'x', type: 'int' },
            { name: 'y', type: 'int' },
            { name: 'z', type: 'int' },
            { name: 'xx', type: 'int' },
            { name: 'yy', type: 'int' }
        ]
    });
    const mx_hash_int = /*@__PURE__*/ overloadingFn([mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4]);
    const mx_hash_vec3_0 = /*@__PURE__*/ Fn(([x_immutable, y_immutable]) => {
        const y = int(y_immutable).toVar();
        const x = int(x_immutable).toVar();
        const h = uint(mx_hash_int(x, y)).toVar();
        const result = uvec3().toVar();
        result.x.assign(h.bitAnd(int(0xFF)));
        result.y.assign(h.shiftRight(int(8)).bitAnd(int(0xFF)));
        result.z.assign(h.shiftRight(int(16)).bitAnd(int(0xFF)));
        return result;
    }).setLayout({
        name: 'mx_hash_vec3_0',
        type: 'uvec3',
        inputs: [
            { name: 'x', type: 'int' },
            { name: 'y', type: 'int' }
        ]
    });
    const mx_hash_vec3_1 = /*@__PURE__*/ Fn(([x_immutable, y_immutable, z_immutable]) => {
        const z = int(z_immutable).toVar();
        const y = int(y_immutable).toVar();
        const x = int(x_immutable).toVar();
        const h = uint(mx_hash_int(x, y, z)).toVar();
        const result = uvec3().toVar();
        result.x.assign(h.bitAnd(int(0xFF)));
        result.y.assign(h.shiftRight(int(8)).bitAnd(int(0xFF)));
        result.z.assign(h.shiftRight(int(16)).bitAnd(int(0xFF)));
        return result;
    }).setLayout({
        name: 'mx_hash_vec3_1',
        type: 'uvec3',
        inputs: [
            { name: 'x', type: 'int' },
            { name: 'y', type: 'int' },
            { name: 'z', type: 'int' }
        ]
    });
    const mx_hash_vec3 = /*@__PURE__*/ overloadingFn([mx_hash_vec3_0, mx_hash_vec3_1]);
    const mx_perlin_noise_float_0 = /*@__PURE__*/ Fn(([p_immutable]) => {
        const p = vec2(p_immutable).toVar();
        const X = int().toVar(), Y = int().toVar();
        const fx = float(mx_floorfrac(p.x, X)).toVar();
        const fy = float(mx_floorfrac(p.y, Y)).toVar();
        const u = float(mx_fade(fx)).toVar();
        const v = float(mx_fade(fy)).toVar();
        const result = float(mx_bilerp(mx_gradient_float(mx_hash_int(X, Y), fx, fy), mx_gradient_float(mx_hash_int(X.add(int(1)), Y), fx.sub(1.0), fy), mx_gradient_float(mx_hash_int(X, Y.add(int(1))), fx, fy.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1))), fx.sub(1.0), fy.sub(1.0)), u, v)).toVar();
        return mx_gradient_scale2d(result);
    }).setLayout({
        name: 'mx_perlin_noise_float_0',
        type: 'float',
        inputs: [
            { name: 'p', type: 'vec2' }
        ]
    });
    const mx_perlin_noise_float_1 = /*@__PURE__*/ Fn(([p_immutable]) => {
        const p = vec3(p_immutable).toVar();
        const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
        const fx = float(mx_floorfrac(p.x, X)).toVar();
        const fy = float(mx_floorfrac(p.y, Y)).toVar();
        const fz = float(mx_floorfrac(p.z, Z)).toVar();
        const u = float(mx_fade(fx)).toVar();
        const v = float(mx_fade(fy)).toVar();
        const w = float(mx_fade(fz)).toVar();
        const result = float(mx_trilerp(mx_gradient_float(mx_hash_int(X, Y, Z), fx, fy, fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z), fx.sub(1.0), fy, fz), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z), fx, fy.sub(1.0), fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1.0), fy.sub(1.0), fz), mx_gradient_float(mx_hash_int(X, Y, Z.add(int(1))), fx, fy, fz.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1.0), fy, fz.sub(1.0)), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1.0), fz.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1.0), fy.sub(1.0), fz.sub(1.0)), u, v, w)).toVar();
        return mx_gradient_scale3d(result);
    }).setLayout({
        name: 'mx_perlin_noise_float_1',
        type: 'float',
        inputs: [
            { name: 'p', type: 'vec3' }
        ]
    });
    const mx_perlin_noise_float = /*@__PURE__*/ overloadingFn([mx_perlin_noise_float_0, mx_perlin_noise_float_1]);
    const mx_perlin_noise_vec3_0 = /*@__PURE__*/ Fn(([p_immutable]) => {
        const p = vec2(p_immutable).toVar();
        const X = int().toVar(), Y = int().toVar();
        const fx = float(mx_floorfrac(p.x, X)).toVar();
        const fy = float(mx_floorfrac(p.y, Y)).toVar();
        const u = float(mx_fade(fx)).toVar();
        const v = float(mx_fade(fy)).toVar();
        const result = vec3(mx_bilerp(mx_gradient_vec3(mx_hash_vec3(X, Y), fx, fy), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y), fx.sub(1.0), fy), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1))), fx, fy.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1))), fx.sub(1.0), fy.sub(1.0)), u, v)).toVar();
        return mx_gradient_scale2d(result);
    }).setLayout({
        name: 'mx_perlin_noise_vec3_0',
        type: 'vec3',
        inputs: [
            { name: 'p', type: 'vec2' }
        ]
    });
    const mx_perlin_noise_vec3_1 = /*@__PURE__*/ Fn(([p_immutable]) => {
        const p = vec3(p_immutable).toVar();
        const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
        const fx = float(mx_floorfrac(p.x, X)).toVar();
        const fy = float(mx_floorfrac(p.y, Y)).toVar();
        const fz = float(mx_floorfrac(p.z, Z)).toVar();
        const u = float(mx_fade(fx)).toVar();
        const v = float(mx_fade(fy)).toVar();
        const w = float(mx_fade(fz)).toVar();
        const result = vec3(mx_trilerp(mx_gradient_vec3(mx_hash_vec3(X, Y, Z), fx, fy, fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z), fx.sub(1.0), fy, fz), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z), fx, fy.sub(1.0), fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1.0), fy.sub(1.0), fz), mx_gradient_vec3(mx_hash_vec3(X, Y, Z.add(int(1))), fx, fy, fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1.0), fy, fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1.0), fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1.0), fy.sub(1.0), fz.sub(1.0)), u, v, w)).toVar();
        return mx_gradient_scale3d(result);
    }).setLayout({
        name: 'mx_perlin_noise_vec3_1',
        type: 'vec3',
        inputs: [
            { name: 'p', type: 'vec3' }
        ]
    });
    const mx_perlin_noise_vec3 = /*@__PURE__*/ overloadingFn([mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1]);
    const mx_cell_noise_float_0 = /*@__PURE__*/ Fn(([p_immutable]) => {
        const p = float(p_immutable).toVar();
        const ix = int(mx_floor(p)).toVar();
        return mx_bits_to_01(mx_hash_int(ix));
    }).setLayout({
        name: 'mx_cell_noise_float_0',
        type: 'float',
        inputs: [
            { name: 'p', type: 'float' }
        ]
    });
    const mx_cell_noise_float_1 = /*@__PURE__*/ Fn(([p_immutable]) => {
        const p = vec2(p_immutable).toVar();
        const ix = int(mx_floor(p.x)).toVar();
        const iy = int(mx_floor(p.y)).toVar();
        return mx_bits_to_01(mx_hash_int(ix, iy));
    }).setLayout({
        name: 'mx_cell_noise_float_1',
        type: 'float',
        inputs: [
            { name: 'p', type: 'vec2' }
        ]
    });
    const mx_cell_noise_float_2 = /*@__PURE__*/ Fn(([p_immutable]) => {
        const p = vec3(p_immutable).toVar();
        const ix = int(mx_floor(p.x)).toVar();
        const iy = int(mx_floor(p.y)).toVar();
        const iz = int(mx_floor(p.z)).toVar();
        return mx_bits_to_01(mx_hash_int(ix, iy, iz));
    }).setLayout({
        name: 'mx_cell_noise_float_2',
        type: 'float',
        inputs: [
            { name: 'p', type: 'vec3' }
        ]
    });
    const mx_cell_noise_float_3 = /*@__PURE__*/ Fn(([p_immutable]) => {
        const p = vec4(p_immutable).toVar();
        const ix = int(mx_floor(p.x)).toVar();
        const iy = int(mx_floor(p.y)).toVar();
        const iz = int(mx_floor(p.z)).toVar();
        const iw = int(mx_floor(p.w)).toVar();
        return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
    }).setLayout({
        name: 'mx_cell_noise_float_3',
        type: 'float',
        inputs: [
            { name: 'p', type: 'vec4' }
        ]
    });
    const mx_cell_noise_float$1 = /*@__PURE__*/ overloadingFn([mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3]);
    const mx_cell_noise_vec3_0 = /*@__PURE__*/ Fn(([p_immutable]) => {
        const p = float(p_immutable).toVar();
        const ix = int(mx_floor(p)).toVar();
        return vec3(mx_bits_to_01(mx_hash_int(ix, int(0))), mx_bits_to_01(mx_hash_int(ix, int(1))), mx_bits_to_01(mx_hash_int(ix, int(2))));
    }).setLayout({
        name: 'mx_cell_noise_vec3_0',
        type: 'vec3',
        inputs: [
            { name: 'p', type: 'float' }
        ]
    });
    const mx_cell_noise_vec3_1 = /*@__PURE__*/ Fn(([p_immutable]) => {
        const p = vec2(p_immutable).toVar();
        const ix = int(mx_floor(p.x)).toVar();
        const iy = int(mx_floor(p.y)).toVar();
        return vec3(mx_bits_to_01(mx_hash_int(ix, iy, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, int(2))));
    }).setLayout({
        name: 'mx_cell_noise_vec3_1',
        type: 'vec3',
        inputs: [
            { name: 'p', type: 'vec2' }
        ]
    });
    const mx_cell_noise_vec3_2 = /*@__PURE__*/ Fn(([p_immutable]) => {
        const p = vec3(p_immutable).toVar();
        const ix = int(mx_floor(p.x)).toVar();
        const iy = int(mx_floor(p.y)).toVar();
        const iz = int(mx_floor(p.z)).toVar();
        return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(2))));
    }).setLayout({
        name: 'mx_cell_noise_vec3_2',
        type: 'vec3',
        inputs: [
            { name: 'p', type: 'vec3' }
        ]
    });
    const mx_cell_noise_vec3_3 = /*@__PURE__*/ Fn(([p_immutable]) => {
        const p = vec4(p_immutable).toVar();
        const ix = int(mx_floor(p.x)).toVar();
        const iy = int(mx_floor(p.y)).toVar();
        const iz = int(mx_floor(p.z)).toVar();
        const iw = int(mx_floor(p.w)).toVar();
        return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(2))));
    }).setLayout({
        name: 'mx_cell_noise_vec3_3',
        type: 'vec3',
        inputs: [
            { name: 'p', type: 'vec4' }
        ]
    });
    const mx_cell_noise_vec3 = /*@__PURE__*/ overloadingFn([mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3]);
    const mx_fractal_noise_float$1 = /*@__PURE__*/ Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
        const diminish = float(diminish_immutable).toVar();
        const lacunarity = float(lacunarity_immutable).toVar();
        const octaves = int(octaves_immutable).toVar();
        const p = vec3(p_immutable).toVar();
        const result = float(0.0).toVar();
        const amplitude = float(1.0).toVar();
        Loop(octaves, () => {
            result.addAssign(amplitude.mul(mx_perlin_noise_float(p)));
            amplitude.mulAssign(diminish);
            p.mulAssign(lacunarity);
        });
        return result;
    }).setLayout({
        name: 'mx_fractal_noise_float',
        type: 'float',
        inputs: [
            { name: 'p', type: 'vec3' },
            { name: 'octaves', type: 'int' },
            { name: 'lacunarity', type: 'float' },
            { name: 'diminish', type: 'float' }
        ]
    });
    const mx_fractal_noise_vec3$1 = /*@__PURE__*/ Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
        const diminish = float(diminish_immutable).toVar();
        const lacunarity = float(lacunarity_immutable).toVar();
        const octaves = int(octaves_immutable).toVar();
        const p = vec3(p_immutable).toVar();
        const result = vec3(0.0).toVar();
        const amplitude = float(1.0).toVar();
        Loop(octaves, () => {
            result.addAssign(amplitude.mul(mx_perlin_noise_vec3(p)));
            amplitude.mulAssign(diminish);
            p.mulAssign(lacunarity);
        });
        return result;
    }).setLayout({
        name: 'mx_fractal_noise_vec3',
        type: 'vec3',
        inputs: [
            { name: 'p', type: 'vec3' },
            { name: 'octaves', type: 'int' },
            { name: 'lacunarity', type: 'float' },
            { name: 'diminish', type: 'float' }
        ]
    });
    const mx_fractal_noise_vec2$1 = /*@__PURE__*/ Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
        const diminish = float(diminish_immutable).toVar();
        const lacunarity = float(lacunarity_immutable).toVar();
        const octaves = int(octaves_immutable).toVar();
        const p = vec3(p_immutable).toVar();
        return vec2(mx_fractal_noise_float$1(p, octaves, lacunarity, diminish), mx_fractal_noise_float$1(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish));
    }).setLayout({
        name: 'mx_fractal_noise_vec2',
        type: 'vec2',
        inputs: [
            { name: 'p', type: 'vec3' },
            { name: 'octaves', type: 'int' },
            { name: 'lacunarity', type: 'float' },
            { name: 'diminish', type: 'float' }
        ]
    });
    const mx_fractal_noise_vec4$1 = /*@__PURE__*/ Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
        const diminish = float(diminish_immutable).toVar();
        const lacunarity = float(lacunarity_immutable).toVar();
        const octaves = int(octaves_immutable).toVar();
        const p = vec3(p_immutable).toVar();
        const c = vec3(mx_fractal_noise_vec3$1(p, octaves, lacunarity, diminish)).toVar();
        const f = float(mx_fractal_noise_float$1(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish)).toVar();
        return vec4(c, f);
    }).setLayout({
        name: 'mx_fractal_noise_vec4',
        type: 'vec4',
        inputs: [
            { name: 'p', type: 'vec3' },
            { name: 'octaves', type: 'int' },
            { name: 'lacunarity', type: 'float' },
            { name: 'diminish', type: 'float' }
        ]
    });
    const mx_worley_distance_0 = /*@__PURE__*/ Fn(([p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable]) => {
        const metric = int(metric_immutable).toVar();
        const jitter = float(jitter_immutable).toVar();
        const yoff = int(yoff_immutable).toVar();
        const xoff = int(xoff_immutable).toVar();
        const y = int(y_immutable).toVar();
        const x = int(x_immutable).toVar();
        const p = vec2(p_immutable).toVar();
        const tmp = vec3(mx_cell_noise_vec3(vec2(x.add(xoff), y.add(yoff)))).toVar();
        const off = vec2(tmp.x, tmp.y).toVar();
        off.subAssign(0.5);
        off.mulAssign(jitter);
        off.addAssign(0.5);
        const cellpos = vec2(vec2(float(x), float(y)).add(off)).toVar();
        const diff = vec2(cellpos.sub(p)).toVar();
        If(metric.equal(int(2)), () => {
            return abs(diff.x).add(abs(diff.y));
        });
        If(metric.equal(int(3)), () => {
            return max$1(abs(diff.x), abs(diff.y));
        });
        return dot(diff, diff);
    }).setLayout({
        name: 'mx_worley_distance_0',
        type: 'float',
        inputs: [
            { name: 'p', type: 'vec2' },
            { name: 'x', type: 'int' },
            { name: 'y', type: 'int' },
            { name: 'xoff', type: 'int' },
            { name: 'yoff', type: 'int' },
            { name: 'jitter', type: 'float' },
            { name: 'metric', type: 'int' }
        ]
    });
    const mx_worley_distance_1 = /*@__PURE__*/ Fn(([p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable]) => {
        const metric = int(metric_immutable).toVar();
        const jitter = float(jitter_immutable).toVar();
        const zoff = int(zoff_immutable).toVar();
        const yoff = int(yoff_immutable).toVar();
        const xoff = int(xoff_immutable).toVar();
        const z = int(z_immutable).toVar();
        const y = int(y_immutable).toVar();
        const x = int(x_immutable).toVar();
        const p = vec3(p_immutable).toVar();
        const off = vec3(mx_cell_noise_vec3(vec3(x.add(xoff), y.add(yoff), z.add(zoff)))).toVar();
        off.subAssign(0.5);
        off.mulAssign(jitter);
        off.addAssign(0.5);
        const cellpos = vec3(vec3(float(x), float(y), float(z)).add(off)).toVar();
        const diff = vec3(cellpos.sub(p)).toVar();
        If(metric.equal(int(2)), () => {
            return abs(diff.x).add(abs(diff.y)).add(abs(diff.z));
        });
        If(metric.equal(int(3)), () => {
            return max$1(abs(diff.x), abs(diff.y), abs(diff.z));
        });
        return dot(diff, diff);
    }).setLayout({
        name: 'mx_worley_distance_1',
        type: 'float',
        inputs: [
            { name: 'p', type: 'vec3' },
            { name: 'x', type: 'int' },
            { name: 'y', type: 'int' },
            { name: 'z', type: 'int' },
            { name: 'xoff', type: 'int' },
            { name: 'yoff', type: 'int' },
            { name: 'zoff', type: 'int' },
            { name: 'jitter', type: 'float' },
            { name: 'metric', type: 'int' }
        ]
    });
    const mx_worley_distance = /*@__PURE__*/ overloadingFn([mx_worley_distance_0, mx_worley_distance_1]);
    const mx_worley_noise_float_0 = /*@__PURE__*/ Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
        const metric = int(metric_immutable).toVar();
        const jitter = float(jitter_immutable).toVar();
        const p = vec2(p_immutable).toVar();
        const X = int().toVar(), Y = int().toVar();
        const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
        const sqdist = float(1e6).toVar();
        Loop({ start: -1, end: int(1), name: 'x', condition: '<=' }, ({ x }) => {
            Loop({ start: -1, end: int(1), name: 'y', condition: '<=' }, ({ y }) => {
                const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
                sqdist.assign(min$1(sqdist, dist));
            });
        });
        If(metric.equal(int(0)), () => {
            sqdist.assign(sqrt(sqdist));
        });
        return sqdist;
    }).setLayout({
        name: 'mx_worley_noise_float_0',
        type: 'float',
        inputs: [
            { name: 'p', type: 'vec2' },
            { name: 'jitter', type: 'float' },
            { name: 'metric', type: 'int' }
        ]
    });
    const mx_worley_noise_vec2_0 = /*@__PURE__*/ Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
        const metric = int(metric_immutable).toVar();
        const jitter = float(jitter_immutable).toVar();
        const p = vec2(p_immutable).toVar();
        const X = int().toVar(), Y = int().toVar();
        const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
        const sqdist = vec2(1e6, 1e6).toVar();
        Loop({ start: -1, end: int(1), name: 'x', condition: '<=' }, ({ x }) => {
            Loop({ start: -1, end: int(1), name: 'y', condition: '<=' }, ({ y }) => {
                const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
                If(dist.lessThan(sqdist.x), () => {
                    sqdist.y.assign(sqdist.x);
                    sqdist.x.assign(dist);
                }).ElseIf(dist.lessThan(sqdist.y), () => {
                    sqdist.y.assign(dist);
                });
            });
        });
        If(metric.equal(int(0)), () => {
            sqdist.assign(sqrt(sqdist));
        });
        return sqdist;
    }).setLayout({
        name: 'mx_worley_noise_vec2_0',
        type: 'vec2',
        inputs: [
            { name: 'p', type: 'vec2' },
            { name: 'jitter', type: 'float' },
            { name: 'metric', type: 'int' }
        ]
    });
    const mx_worley_noise_vec3_0 = /*@__PURE__*/ Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
        const metric = int(metric_immutable).toVar();
        const jitter = float(jitter_immutable).toVar();
        const p = vec2(p_immutable).toVar();
        const X = int().toVar(), Y = int().toVar();
        const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
        const sqdist = vec3(1e6, 1e6, 1e6).toVar();
        Loop({ start: -1, end: int(1), name: 'x', condition: '<=' }, ({ x }) => {
            Loop({ start: -1, end: int(1), name: 'y', condition: '<=' }, ({ y }) => {
                const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
                If(dist.lessThan(sqdist.x), () => {
                    sqdist.z.assign(sqdist.y);
                    sqdist.y.assign(sqdist.x);
                    sqdist.x.assign(dist);
                }).ElseIf(dist.lessThan(sqdist.y), () => {
                    sqdist.z.assign(sqdist.y);
                    sqdist.y.assign(dist);
                }).ElseIf(dist.lessThan(sqdist.z), () => {
                    sqdist.z.assign(dist);
                });
            });
        });
        If(metric.equal(int(0)), () => {
            sqdist.assign(sqrt(sqdist));
        });
        return sqdist;
    }).setLayout({
        name: 'mx_worley_noise_vec3_0',
        type: 'vec3',
        inputs: [
            { name: 'p', type: 'vec2' },
            { name: 'jitter', type: 'float' },
            { name: 'metric', type: 'int' }
        ]
    });
    const mx_worley_noise_float_1 = /*@__PURE__*/ Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
        const metric = int(metric_immutable).toVar();
        const jitter = float(jitter_immutable).toVar();
        const p = vec3(p_immutable).toVar();
        const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
        const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
        const sqdist = float(1e6).toVar();
        Loop({ start: -1, end: int(1), name: 'x', condition: '<=' }, ({ x }) => {
            Loop({ start: -1, end: int(1), name: 'y', condition: '<=' }, ({ y }) => {
                Loop({ start: -1, end: int(1), name: 'z', condition: '<=' }, ({ z }) => {
                    const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
                    sqdist.assign(min$1(sqdist, dist));
                });
            });
        });
        If(metric.equal(int(0)), () => {
            sqdist.assign(sqrt(sqdist));
        });
        return sqdist;
    }).setLayout({
        name: 'mx_worley_noise_float_1',
        type: 'float',
        inputs: [
            { name: 'p', type: 'vec3' },
            { name: 'jitter', type: 'float' },
            { name: 'metric', type: 'int' }
        ]
    });
    const mx_worley_noise_float$1 = /*@__PURE__*/ overloadingFn([mx_worley_noise_float_0, mx_worley_noise_float_1]);
    const mx_worley_noise_vec2_1 = /*@__PURE__*/ Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
        const metric = int(metric_immutable).toVar();
        const jitter = float(jitter_immutable).toVar();
        const p = vec3(p_immutable).toVar();
        const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
        const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
        const sqdist = vec2(1e6, 1e6).toVar();
        Loop({ start: -1, end: int(1), name: 'x', condition: '<=' }, ({ x }) => {
            Loop({ start: -1, end: int(1), name: 'y', condition: '<=' }, ({ y }) => {
                Loop({ start: -1, end: int(1), name: 'z', condition: '<=' }, ({ z }) => {
                    const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
                    If(dist.lessThan(sqdist.x), () => {
                        sqdist.y.assign(sqdist.x);
                        sqdist.x.assign(dist);
                    }).ElseIf(dist.lessThan(sqdist.y), () => {
                        sqdist.y.assign(dist);
                    });
                });
            });
        });
        If(metric.equal(int(0)), () => {
            sqdist.assign(sqrt(sqdist));
        });
        return sqdist;
    }).setLayout({
        name: 'mx_worley_noise_vec2_1',
        type: 'vec2',
        inputs: [
            { name: 'p', type: 'vec3' },
            { name: 'jitter', type: 'float' },
            { name: 'metric', type: 'int' }
        ]
    });
    const mx_worley_noise_vec2$1 = /*@__PURE__*/ overloadingFn([mx_worley_noise_vec2_0, mx_worley_noise_vec2_1]);
    const mx_worley_noise_vec3_1 = /*@__PURE__*/ Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
        const metric = int(metric_immutable).toVar();
        const jitter = float(jitter_immutable).toVar();
        const p = vec3(p_immutable).toVar();
        const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
        const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
        const sqdist = vec3(1e6, 1e6, 1e6).toVar();
        Loop({ start: -1, end: int(1), name: 'x', condition: '<=' }, ({ x }) => {
            Loop({ start: -1, end: int(1), name: 'y', condition: '<=' }, ({ y }) => {
                Loop({ start: -1, end: int(1), name: 'z', condition: '<=' }, ({ z }) => {
                    const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
                    If(dist.lessThan(sqdist.x), () => {
                        sqdist.z.assign(sqdist.y);
                        sqdist.y.assign(sqdist.x);
                        sqdist.x.assign(dist);
                    }).ElseIf(dist.lessThan(sqdist.y), () => {
                        sqdist.z.assign(sqdist.y);
                        sqdist.y.assign(dist);
                    }).ElseIf(dist.lessThan(sqdist.z), () => {
                        sqdist.z.assign(dist);
                    });
                });
            });
        });
        If(metric.equal(int(0)), () => {
            sqdist.assign(sqrt(sqdist));
        });
        return sqdist;
    }).setLayout({
        name: 'mx_worley_noise_vec3_1',
        type: 'vec3',
        inputs: [
            { name: 'p', type: 'vec3' },
            { name: 'jitter', type: 'float' },
            { name: 'metric', type: 'int' }
        ]
    });
    const mx_worley_noise_vec3$1 = /*@__PURE__*/ overloadingFn([mx_worley_noise_vec3_0, mx_worley_noise_vec3_1]);
    // Unified Noise 2D
    const mx_unifiednoise2d$1 = /*@__PURE__*/ Fn(([
        noiseType_immutable, texcoord_immutable, freq_immutable, offset_immutable,
        jitter_immutable, outmin_immutable, outmax_immutable, clampoutput_immutable,
        octaves_immutable, lacunarity_immutable, diminish_immutable
    ]) => {
        const noiseType = int(noiseType_immutable).toVar();
        const texcoord = vec2(texcoord_immutable).toVar();
        const freq = vec2(freq_immutable).toVar();
        const offset = vec2(offset_immutable).toVar();
        const jitter = float(jitter_immutable).toVar();
        const outmin = float(outmin_immutable).toVar();
        const outmax = float(outmax_immutable).toVar();
        const clampoutput = bool(clampoutput_immutable).toVar();
        const octaves = int(octaves_immutable).toVar();
        const lacunarity = float(lacunarity_immutable).toVar();
        const diminish = float(diminish_immutable).toVar();
        // Compute input position
        const p = texcoord.mul(freq).add(offset);
        const result = float(0.0).toVar();
        // Perlin
        If(noiseType.equal(int(0)), () => {
            result.assign(mx_perlin_noise_vec3(p));
        });
        // Cell
        If(noiseType.equal(int(1)), () => {
            result.assign(mx_cell_noise_vec3(p));
        });
        // Worley (metric=0 = euclidean)
        If(noiseType.equal(int(2)), () => {
            result.assign(mx_worley_noise_vec3$1(p, jitter, int(0)));
        });
        // Fractal (use vec3(p, 0.0) for 2D input)
        If(noiseType.equal(int(3)), () => {
            result.assign(mx_fractal_noise_vec3$1(vec3(p, 0.0), octaves, lacunarity, diminish));
        });
        // Remap output to [outmin, outmax]
        result.assign(result.mul(outmax.sub(outmin)).add(outmin));
        // Clamp if requested
        If(clampoutput, () => {
            result.assign(clamp(result, outmin, outmax));
        });
        return result;
    }).setLayout({
        name: 'mx_unifiednoise2d',
        type: 'float',
        inputs: [
            { name: 'noiseType', type: 'int' },
            { name: 'texcoord', type: 'vec2' },
            { name: 'freq', type: 'vec2' },
            { name: 'offset', type: 'vec2' },
            { name: 'jitter', type: 'float' },
            { name: 'outmin', type: 'float' },
            { name: 'outmax', type: 'float' },
            { name: 'clampoutput', type: 'bool' },
            { name: 'octaves', type: 'int' },
            { name: 'lacunarity', type: 'float' },
            { name: 'diminish', type: 'float' }
        ]
    });
    // Unified Noise 3D
    const mx_unifiednoise3d$1 = /*@__PURE__*/ Fn(([
        noiseType_immutable, position_immutable, freq_immutable, offset_immutable,
        jitter_immutable, outmin_immutable, outmax_immutable, clampoutput_immutable,
        octaves_immutable, lacunarity_immutable, diminish_immutable
    ]) => {
        const noiseType = int(noiseType_immutable).toVar();
        const position = vec3(position_immutable).toVar();
        const freq = vec3(freq_immutable).toVar();
        const offset = vec3(offset_immutable).toVar();
        const jitter = float(jitter_immutable).toVar();
        const outmin = float(outmin_immutable).toVar();
        const outmax = float(outmax_immutable).toVar();
        const clampoutput = bool(clampoutput_immutable).toVar();
        const octaves = int(octaves_immutable).toVar();
        const lacunarity = float(lacunarity_immutable).toVar();
        const diminish = float(diminish_immutable).toVar();
        // Compute input position
        const p = position.mul(freq).add(offset);
        const result = float(0.0).toVar();
        // Perlin
        If(noiseType.equal(int(0)), () => {
            result.assign(mx_perlin_noise_vec3(p));
        });
        // Cell
        If(noiseType.equal(int(1)), () => {
            result.assign(mx_cell_noise_vec3(p));
        });
        // Worley (metric=0 = euclidean)
        If(noiseType.equal(int(2)), () => {
            result.assign(mx_worley_noise_vec3$1(p, jitter, int(0)));
        });
        // Fractal
        If(noiseType.equal(int(3)), () => {
            result.assign(mx_fractal_noise_vec3$1(p, octaves, lacunarity, diminish));
        });
        // Remap output to [outmin, outmax]
        result.assign(result.mul(outmax.sub(outmin)).add(outmin));
        // Clamp if requested
        If(clampoutput, () => {
            result.assign(clamp(result, outmin, outmax));
        });
        return result;
    }).setLayout({
        name: 'mx_unifiednoise3d',
        type: 'float',
        inputs: [
            { name: 'noiseType', type: 'int' },
            { name: 'position', type: 'vec3' },
            { name: 'freq', type: 'vec3' },
            { name: 'offset', type: 'vec3' },
            { name: 'jitter', type: 'float' },
            { name: 'outmin', type: 'float' },
            { name: 'outmax', type: 'float' },
            { name: 'clampoutput', type: 'bool' },
            { name: 'octaves', type: 'int' },
            { name: 'lacunarity', type: 'float' },
            { name: 'diminish', type: 'float' }
        ]
    });
    // Three.js Transpiler
    // https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl

    const mx_hsvtorgb = /*@__PURE__*/ Fn(([hsv]) => {
        const s = hsv.y;
        const v = hsv.z;
        const result = vec3().toVar();
        If(s.lessThan(0.0001), () => {
            result.assign(vec3(v, v, v));
        }).Else(() => {
            let h = hsv.x;
            h = h.sub(floor(h)).mul(6.0).toVar(); // TODO: check what .toVar() is needed in node system cache
            const hi = int(trunc(h));
            const f = h.sub(float(hi));
            const p = v.mul(s.oneMinus());
            const q = v.mul(s.mul(f).oneMinus());
            const t = v.mul(s.mul(f.oneMinus()).oneMinus());
            If(hi.equal(int(0)), () => {
                result.assign(vec3(v, t, p));
            }).ElseIf(hi.equal(int(1)), () => {
                result.assign(vec3(q, v, p));
            }).ElseIf(hi.equal(int(2)), () => {
                result.assign(vec3(p, v, t));
            }).ElseIf(hi.equal(int(3)), () => {
                result.assign(vec3(p, q, v));
            }).ElseIf(hi.equal(int(4)), () => {
                result.assign(vec3(t, p, v));
            }).Else(() => {
                result.assign(vec3(v, p, q));
            });
        });
        return result;
    }).setLayout({
        name: 'mx_hsvtorgb',
        type: 'vec3',
        inputs: [
            { name: 'hsv', type: 'vec3' }
        ]
    });
    const mx_rgbtohsv = /*@__PURE__*/ Fn(([c_immutable]) => {
        const c = vec3(c_immutable).toVar();
        const r = float(c.x).toVar();
        const g = float(c.y).toVar();
        const b = float(c.z).toVar();
        const mincomp = float(min$1(r, min$1(g, b))).toVar();
        const maxcomp = float(max$1(r, max$1(g, b))).toVar();
        const delta = float(maxcomp.sub(mincomp)).toVar();
        const h = float().toVar(), s = float().toVar(), v = float().toVar();
        v.assign(maxcomp);
        If(maxcomp.greaterThan(0.0), () => {
            s.assign(delta.div(maxcomp));
        }).Else(() => {
            s.assign(0.0);
        });
        If(s.lessThanEqual(0.0), () => {
            h.assign(0.0);
        }).Else(() => {
            If(r.greaterThanEqual(maxcomp), () => {
                h.assign(g.sub(b).div(delta));
            }).ElseIf(g.greaterThanEqual(maxcomp), () => {
                h.assign(add(2.0, b.sub(r).div(delta)));
            }).Else(() => {
                h.assign(add(4.0, r.sub(g).div(delta)));
            });
            h.mulAssign(1.0 / 6.0);
            If(h.lessThan(0.0), () => {
                h.addAssign(1.0);
            });
        });
        return vec3(h, s, v);
    }).setLayout({
        name: 'mx_rgbtohsv',
        type: 'vec3',
        inputs: [
            { name: 'c', type: 'vec3' }
        ]
    });
    // Three.js Transpiler
    // https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl

    const mx_srgb_texture_to_lin_rec709 = /*@__PURE__*/ Fn(([color_immutable]) => {
        const color = vec3(color_immutable).toVar();
        const isAbove = bvec3(greaterThan(color, vec3(0.04045))).toVar();
        const linSeg = vec3(color.div(12.92)).toVar();
        const powSeg = vec3(pow(max$1(color.add(vec3(0.055)), vec3(0.0)).div(1.055), vec3(2.4))).toVar();
        return mix(linSeg, powSeg, isAbove);
    }).setLayout({
        name: 'mx_srgb_texture_to_lin_rec709',
        type: 'vec3',
        inputs: [
            { name: 'color', type: 'vec3' }
        ]
    });
    const mx_aastep = (threshold, value) => {
        threshold = float(threshold);
        value = float(value);
        const afwidth = vec2(value.dFdx(), value.dFdy()).length().mul(0.70710678118654757);
        return smoothstep(threshold.sub(afwidth), threshold.add(afwidth), value);
    };
    const _ramp = (a, b, uv, p) => mix(a, b, uv[p].clamp());
    const mx_ramplr = (valuel, valuer, texcoord = uv()) => _ramp(valuel, valuer, texcoord, 'x');
    const mx_ramptb = (valuet, valueb, texcoord = uv()) => _ramp(valuet, valueb, texcoord, 'y');
    // Bilinear ramp: interpolate between four corners (tl, tr, bl, br) using texcoord.x and texcoord.y
    const mx_ramp4 = (
        valuetl, valuetr, valuebl, valuebr, texcoord = uv()
    ) => {
        const u = texcoord.x.clamp();
        const v = texcoord.y.clamp();
        const top = mix(valuetl, valuetr, u);
        const bottom = mix(valuebl, valuebr, u);
        return mix(top, bottom, v);
    };
    const _split = (a, b, center, uv, p) => mix(a, b, mx_aastep(center, uv[p]));
    const mx_splitlr = (valuel, valuer, center, texcoord = uv()) => _split(valuel, valuer, center, texcoord, 'x');
    const mx_splittb = (valuet, valueb, center, texcoord = uv()) => _split(valuet, valueb, center, texcoord, 'y');
    const mx_transform_uv = (uv_scale = 1, uv_offset = 0, uv_geo = uv()) => uv_geo.mul(uv_scale).add(uv_offset);
    const mx_safepower = (in1, in2 = 1) => {
        in1 = float(in1);
        return in1.abs().pow(in2).mul(in1.sign());
    };
    const mx_contrast = (input, amount = 1, pivot = .5) => float(input).sub(pivot).mul(amount).add(pivot);
    const mx_noise_float = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_float(texcoord.convert('vec2|vec3')).mul(amplitude).add(pivot);
    //export const mx_noise_vec2 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );
    const mx_noise_vec3 = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_vec3(texcoord.convert('vec2|vec3')).mul(amplitude).add(pivot);
    const mx_noise_vec4 = (texcoord = uv(), amplitude = 1, pivot = 0) => {
        texcoord = texcoord.convert('vec2|vec3'); // overloading type
        const noise_vec4 = vec4(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(texcoord.add(vec2(19, 73))));
        return noise_vec4.mul(amplitude).add(pivot);
    };
    const mx_unifiednoise2d = (noiseType, texcoord = uv(), freq = vec2(1, 1), offset = vec2(0, 0), jitter = 1, outmin = 0, outmax = 1, clampoutput = false, octaves = 1, lacunarity = 2, diminish = .5) => mx_unifiednoise2d$1(noiseType, texcoord.convert('vec2|vec3'), freq, offset, jitter, outmin, outmax, clampoutput, octaves, lacunarity, diminish);
    const mx_unifiednoise3d = (noiseType, texcoord = uv(), freq = vec2(1, 1), offset = vec2(0, 0), jitter = 1, outmin = 0, outmax = 1, clampoutput = false, octaves = 1, lacunarity = 2, diminish = .5) => mx_unifiednoise3d$1(noiseType, texcoord.convert('vec2|vec3'), freq, offset, jitter, outmin, outmax, clampoutput, octaves, lacunarity, diminish);
    const mx_worley_noise_float = (texcoord = uv(), jitter = 1) => mx_worley_noise_float$1(texcoord.convert('vec2|vec3'), jitter, int(1));
    const mx_worley_noise_vec2 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec2$1(texcoord.convert('vec2|vec3'), jitter, int(1));
    const mx_worley_noise_vec3 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec3$1(texcoord.convert('vec2|vec3'), jitter, int(1));
    const mx_cell_noise_float = (texcoord = uv()) => mx_cell_noise_float$1(texcoord.convert('vec2|vec3'));
    const mx_fractal_noise_float = (position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_float$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
    const mx_fractal_noise_vec2 = (position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_vec2$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
    const mx_fractal_noise_vec3 = (position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_vec3$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
    const mx_fractal_noise_vec4 = (position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_vec4$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
    // === Moved from MaterialXLoader.js ===
    // Math ops
    const mx_add = (in1, in2 = float(0)) => add(in1, in2);
    const mx_subtract = (in1, in2 = float(0)) => sub(in1, in2);
    const mx_multiply = (in1, in2 = float(1)) => mul(in1, in2);
    const mx_divide = (in1, in2 = float(1)) => div(in1, in2);
    const mx_modulo = (in1, in2 = float(1)) => mod(in1, in2);
    const mx_power = (in1, in2 = float(1)) => pow(in1, in2);
    const mx_atan2 = (in1 = float(0), in2 = float(1)) => atan(in1, in2);
    const mx_timer = () => time;
    const mx_frame = () => frameId;
    const mx_invert = (in1, amount = float(1)) => sub(amount, in1);
    const mx_ifgreater = (value1, value2, in1, in2) => value1.greaterThan(value2).mix(in1, in2);
    const mx_ifgreatereq = (value1, value2, in1, in2) => value1.greaterThanEqual(value2).mix(in1, in2);
    const mx_ifequal = (value1, value2, in1, in2) => value1.equal(value2).mix(in1, in2);
    // Enhanced separate node to support multi-output referencing (outx, outy, outz, outw)
    const mx_separate = (in1, channelOrOut = null) => {
        if (typeof channelOrOut === 'string') {
            const map = { x: 0, r: 0, y: 1, g: 1, z: 2, b: 2, w: 3, a: 3 };
            const c = channelOrOut.replace(/^out/, '').toLowerCase();
            if (map[c] !== undefined) return in1.element(map[c]);
        }
        if (typeof channelOrOut === 'number') {
            return in1.element(channelOrOut);
        }
        if (typeof channelOrOut === 'string' && channelOrOut.length === 1) {
            const map = { x: 0, r: 0, y: 1, g: 1, z: 2, b: 2, w: 3, a: 3 };
            if (map[channelOrOut] !== undefined) return in1.element(map[channelOrOut]);
        }
        return in1;
    };
    const mx_place2d = (
        texcoord, pivot = vec2(0.5, 0.5), scale = vec2(1, 1), rotate = float(0), offset = vec2(0, 0)/*, operationorder = int( 0 )*/
    ) => {
        let uv = texcoord;
        if (pivot) uv = uv.sub(pivot);
        if (scale) uv = uv.mul(scale);
        if (rotate) {
            const rad = rotate.mul(Math.PI / 180.0);
            const cosR = rad.cos();
            const sinR = rad.sin();
            uv = vec2(
                uv.x.mul(cosR).sub(uv.y.mul(sinR)),
                uv.x.mul(sinR).add(uv.y.mul(cosR))
            );
        }
        if (pivot) uv = uv.add(pivot);
        if (offset) uv = uv.add(offset);
        return uv;
    };
    const mx_rotate2d = (input, amount) => {
        input = vec2(input);
        amount = float(amount);
        const radians = amount.mul(Math.PI / 180.0);
        return rotate(input, radians);
    };
    const mx_rotate3d = (input, amount, axis) => {
        input = vec3(input);
        amount = float(amount);
        axis = vec3(axis);

        const radians = amount.mul(Math.PI / 180.0);
        const nAxis = axis.normalize();
        const cosA = radians.cos();
        const sinA = radians.sin();
        const oneMinusCosA = float(1).sub(cosA);
        const rot =
            input.mul(cosA)
                .add(nAxis.cross(input).mul(sinA))
                .add(nAxis.mul(nAxis.dot(input)).mul(oneMinusCosA));
        return rot;
    };
    const mx_heighttonormal = (input, scale/*, texcoord*/) => {
        input = vec3(input);
        scale = float(scale);
        return bumpMap(input, scale);
    };
    const getParallaxCorrectNormal = /*@__PURE__*/ Fn(([normal, cubeSize, cubePos]) => {
        const nDir = normalize(normal).toVar();
        const rbmax = sub(float(0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar();
        const rbmin = sub(float(-0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar();
        const rbminmax = vec3().toVar();
        rbminmax.x = nDir.x.greaterThan(float(0)).select(rbmax.x, rbmin.x);
        rbminmax.y = nDir.y.greaterThan(float(0)).select(rbmax.y, rbmin.y);
        rbminmax.z = nDir.z.greaterThan(float(0)).select(rbmax.z, rbmin.z);
        const correction = min$1(rbminmax.x, rbminmax.y, rbminmax.z).toVar();
        const boxIntersection = positionWorld.add(nDir.mul(correction)).toVar();
        return boxIntersection.sub(cubePos);
    });
    const getShIrradianceAt = /*@__PURE__*/ Fn(([normal, shCoefficients]) => {
        // normal is assumed to have unit length
        const x = normal.x, y = normal.y, z = normal.z;
        // band 0
        let result = shCoefficients.element(0).mul(0.886227);
        // band 1
        result = result.add(shCoefficients.element(1).mul(2.0 * 0.511664).mul(y));
        result = result.add(shCoefficients.element(2).mul(2.0 * 0.511664).mul(z));
        result = result.add(shCoefficients.element(3).mul(2.0 * 0.511664).mul(x));
        // band 2
        result = result.add(shCoefficients.element(4).mul(2.0 * 0.429043).mul(x).mul(y));
        result = result.add(shCoefficients.element(5).mul(2.0 * 0.429043).mul(y).mul(z));
        result = result.add(shCoefficients.element(6).mul(z.mul(z).mul(0.743125).sub(0.247708)));
        result = result.add(shCoefficients.element(7).mul(2.0 * 0.429043).mul(x).mul(z));
        result = result.add(shCoefficients.element(8).mul(0.429043).mul(mul(x, x).sub(mul(y, y))));
        return result;
    });
    // constants
    var TSL = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BRDF_GGX: BRDF_GGX,
        BRDF_Lambert: BRDF_Lambert,
        BasicPointShadowFilter: BasicPointShadowFilter,
        BasicShadowFilter: BasicShadowFilter,
        Break: Break,
        Const: Const,
        Continue: Continue,
        DFGApprox: DFGApprox,
        D_GGX: D_GGX,
        Discard: Discard,
        EPSILON: EPSILON,
        F_Schlick: F_Schlick,
        Fn: Fn,
        INFINITY: INFINITY,
        If: If,
        Loop: Loop,
        NodeAccess: NodeAccess,
        NodeShaderStage: NodeShaderStage,
        NodeType: NodeType,
        NodeUpdateType: NodeUpdateType,
        OnMaterialUpdate: OnMaterialUpdate,
        OnObjectUpdate: OnObjectUpdate,
        PCFShadowFilter: PCFShadowFilter,
        PCFSoftShadowFilter: PCFSoftShadowFilter,
        PI: PI,
        PI2: PI2,
        PointShadowFilter: PointShadowFilter,
        Return: Return,
        Schlick_to_F0: Schlick_to_F0,
        ScriptableNodeResources: ScriptableNodeResources,
        ShaderNode: ShaderNode,
        Stack: Stack,
        Switch: Switch,
        TBNViewMatrix: TBNViewMatrix,
        VSMShadowFilter: VSMShadowFilter,
        V_GGX_SmithCorrelated: V_GGX_SmithCorrelated,
        Var: Var,
        VarIntent: VarIntent,
        abs: abs,
        acesFilmicToneMapping: acesFilmicToneMapping,
        acos: acos,
        add: add,
        addMethodChaining: addMethodChaining,
        addNodeElement: addNodeElement,
        agxToneMapping: agxToneMapping,
        all: all,
        alphaT: alphaT,
        and: and,
        anisotropy: anisotropy,
        anisotropyB: anisotropyB,
        anisotropyT: anisotropyT,
        any: any,
        append: append,
        array: array,
        arrayBuffer: arrayBuffer,
        asin: asin,
        assign: assign,
        atan: atan,
        atan2: atan2,
        atomicAdd: atomicAdd,
        atomicAnd: atomicAnd,
        atomicFunc: atomicFunc,
        atomicLoad: atomicLoad,
        atomicMax: atomicMax,
        atomicMin: atomicMin,
        atomicOr: atomicOr,
        atomicStore: atomicStore,
        atomicSub: atomicSub,
        atomicXor: atomicXor,
        attenuationColor: attenuationColor,
        attenuationDistance: attenuationDistance,
        attribute: attribute,
        attributeArray: attributeArray,
        backgroundBlurriness: backgroundBlurriness,
        backgroundIntensity: backgroundIntensity,
        backgroundRotation: backgroundRotation,
        batch: batch,
        bentNormalView: bentNormalView,
        billboarding: billboarding,
        bitAnd: bitAnd,
        bitNot: bitNot,
        bitOr: bitOr,
        bitXor: bitXor,
        bitangentGeometry: bitangentGeometry,
        bitangentLocal: bitangentLocal,
        bitangentView: bitangentView,
        bitangentWorld: bitangentWorld,
        bitcast: bitcast,
        blendBurn: blendBurn,
        blendColor: blendColor,
        blendDodge: blendDodge,
        blendOverlay: blendOverlay,
        blendScreen: blendScreen,
        blur: blur,
        bool: bool,
        buffer: buffer,
        bufferAttribute: bufferAttribute,
        bumpMap: bumpMap,
        burn: burn,
        bvec2: bvec2,
        bvec3: bvec3,
        bvec4: bvec4,
        bypass: bypass,
        cache: cache,
        call: call,
        cameraFar: cameraFar,
        cameraIndex: cameraIndex,
        cameraNear: cameraNear,
        cameraNormalMatrix: cameraNormalMatrix,
        cameraPosition: cameraPosition,
        cameraProjectionMatrix: cameraProjectionMatrix,
        cameraProjectionMatrixInverse: cameraProjectionMatrixInverse,
        cameraViewMatrix: cameraViewMatrix,
        cameraWorldMatrix: cameraWorldMatrix,
        cbrt: cbrt,
        cdl: cdl,
        ceil: ceil,
        checker: checker,
        cineonToneMapping: cineonToneMapping,
        clamp: clamp,
        clearcoat: clearcoat,
        clearcoatNormalView: clearcoatNormalView,
        clearcoatRoughness: clearcoatRoughness,
        code: code,
        color: color,
        colorSpaceToWorking: colorSpaceToWorking,
        colorToDirection: colorToDirection,
        compute: compute,
        computeKernel: computeKernel,
        computeSkinning: computeSkinning,
        context: context,
        convert: convert,
        convertColorSpace: convertColorSpace,
        convertToTexture: convertToTexture,
        cos: cos,
        cross: cross,
        cubeTexture: cubeTexture,
        cubeTextureBase: cubeTextureBase,
        cubeToUV: cubeToUV,
        dFdx: dFdx,
        dFdy: dFdy,
        dashSize: dashSize,
        debug: debug,
        decrement: decrement,
        decrementBefore: decrementBefore,
        defaultBuildStages: defaultBuildStages,
        defaultShaderStages: defaultShaderStages,
        defined: defined,
        degrees: degrees,
        deltaTime: deltaTime,
        densityFog: densityFog,
        densityFogFactor: densityFogFactor,
        depth: depth,
        depthPass: depthPass,
        determinant: determinant,
        difference: difference,
        diffuseColor: diffuseColor,
        directPointLight: directPointLight,
        directionToColor: directionToColor,
        directionToFaceDirection: directionToFaceDirection,
        dispersion: dispersion,
        distance: distance,
        div: div,
        dodge: dodge,
        dot: dot,
        drawIndex: drawIndex,
        dynamicBufferAttribute: dynamicBufferAttribute,
        element: element,
        emissive: emissive,
        equal: equal,
        equals: equals,
        equirectUV: equirectUV,
        exp: exp,
        exp2: exp2,
        expression: expression,
        faceDirection: faceDirection,
        faceForward: faceForward,
        faceforward: faceforward,
        float: float,
        floor: floor,
        fog: fog,
        fract: fract,
        frameGroup: frameGroup,
        frameId: frameId,
        frontFacing: frontFacing,
        fwidth: fwidth,
        gain: gain,
        gapSize: gapSize,
        getConstNodeType: getConstNodeType,
        getCurrentStack: getCurrentStack,
        getDirection: getDirection,
        getDistanceAttenuation: getDistanceAttenuation,
        getGeometryRoughness: getGeometryRoughness,
        getNormalFromDepth: getNormalFromDepth,
        getParallaxCorrectNormal: getParallaxCorrectNormal,
        getRoughness: getRoughness,
        getScreenPosition: getScreenPosition,
        getShIrradianceAt: getShIrradianceAt,
        getShadowMaterial: getShadowMaterial,
        getShadowRenderObjectFunction: getShadowRenderObjectFunction,
        getTextureIndex: getTextureIndex,
        getViewPosition: getViewPosition,
        globalId: globalId,
        glsl: glsl,
        glslFn: glslFn,
        grayscale: grayscale,
        greaterThan: greaterThan,
        greaterThanEqual: greaterThanEqual,
        hash: hash,
        highpModelNormalViewMatrix: highpModelNormalViewMatrix,
        highpModelViewMatrix: highpModelViewMatrix,
        hue: hue,
        increment: increment,
        incrementBefore: incrementBefore,
        instance: instance,
        instanceIndex: instanceIndex,
        instancedArray: instancedArray,
        instancedBufferAttribute: instancedBufferAttribute,
        instancedDynamicBufferAttribute: instancedDynamicBufferAttribute,
        instancedMesh: instancedMesh,
        int: int,
        inverse: inverse,
        inverseSqrt: inverseSqrt,
        inversesqrt: inversesqrt,
        invocationLocalIndex: invocationLocalIndex,
        invocationSubgroupIndex: invocationSubgroupIndex,
        ior: ior,
        iridescence: iridescence,
        iridescenceIOR: iridescenceIOR,
        iridescenceThickness: iridescenceThickness,
        ivec2: ivec2,
        ivec3: ivec3,
        ivec4: ivec4,
        js: js,
        label: label,
        length: length,
        lengthSq: lengthSq,
        lessThan: lessThan,
        lessThanEqual: lessThanEqual,
        lightPosition: lightPosition,
        lightProjectionUV: lightProjectionUV,
        lightShadowMatrix: lightShadowMatrix,
        lightTargetDirection: lightTargetDirection,
        lightTargetPosition: lightTargetPosition,
        lightViewPosition: lightViewPosition,
        lightingContext: lightingContext,
        lights: lights,
        linearDepth: linearDepth,
        linearToneMapping: linearToneMapping,
        localId: localId,
        log: log,
        log2: log2,
        logarithmicDepthToViewZ: logarithmicDepthToViewZ,
        luminance: luminance,
        mat2: mat2,
        mat3: mat3,
        mat4: mat4,
        matcapUV: matcapUV,
        materialAO: materialAO,
        materialAlphaTest: materialAlphaTest,
        materialAnisotropy: materialAnisotropy,
        materialAnisotropyVector: materialAnisotropyVector,
        materialAttenuationColor: materialAttenuationColor,
        materialAttenuationDistance: materialAttenuationDistance,
        materialClearcoat: materialClearcoat,
        materialClearcoatNormal: materialClearcoatNormal,
        materialClearcoatRoughness: materialClearcoatRoughness,
        materialColor: materialColor,
        materialDispersion: materialDispersion,
        materialEmissive: materialEmissive,
        materialEnvIntensity: materialEnvIntensity,
        materialEnvRotation: materialEnvRotation,
        materialIOR: materialIOR,
        materialIridescence: materialIridescence,
        materialIridescenceIOR: materialIridescenceIOR,
        materialIridescenceThickness: materialIridescenceThickness,
        materialLightMap: materialLightMap,
        materialLineDashOffset: materialLineDashOffset,
        materialLineDashSize: materialLineDashSize,
        materialLineGapSize: materialLineGapSize,
        materialLineScale: materialLineScale,
        materialLineWidth: materialLineWidth,
        materialMetalness: materialMetalness,
        materialNormal: materialNormal,
        materialOpacity: materialOpacity,
        materialPointSize: materialPointSize,
        materialReference: materialReference,
        materialReflectivity: materialReflectivity,
        materialRefractionRatio: materialRefractionRatio,
        materialRotation: materialRotation,
        materialRoughness: materialRoughness,
        materialSheen: materialSheen,
        materialSheenRoughness: materialSheenRoughness,
        materialShininess: materialShininess,
        materialSpecular: materialSpecular,
        materialSpecularColor: materialSpecularColor,
        materialSpecularIntensity: materialSpecularIntensity,
        materialSpecularStrength: materialSpecularStrength,
        materialThickness: materialThickness,
        materialTransmission: materialTransmission,
        max: max$1,
        maxMipLevel: maxMipLevel,
        mediumpModelViewMatrix: mediumpModelViewMatrix,
        metalness: metalness,
        min: min$1,
        mix: mix,
        mixElement: mixElement,
        mod: mod,
        modInt: modInt,
        modelDirection: modelDirection,
        modelNormalMatrix: modelNormalMatrix,
        modelPosition: modelPosition,
        modelRadius: modelRadius,
        modelScale: modelScale,
        modelViewMatrix: modelViewMatrix,
        modelViewPosition: modelViewPosition,
        modelViewProjection: modelViewProjection,
        modelWorldMatrix: modelWorldMatrix,
        modelWorldMatrixInverse: modelWorldMatrixInverse,
        morphReference: morphReference,
        mrt: mrt,
        mul: mul,
        mx_aastep: mx_aastep,
        mx_add: mx_add,
        mx_atan2: mx_atan2,
        mx_cell_noise_float: mx_cell_noise_float,
        mx_contrast: mx_contrast,
        mx_divide: mx_divide,
        mx_fractal_noise_float: mx_fractal_noise_float,
        mx_fractal_noise_vec2: mx_fractal_noise_vec2,
        mx_fractal_noise_vec3: mx_fractal_noise_vec3,
        mx_fractal_noise_vec4: mx_fractal_noise_vec4,
        mx_frame: mx_frame,
        mx_heighttonormal: mx_heighttonormal,
        mx_hsvtorgb: mx_hsvtorgb,
        mx_ifequal: mx_ifequal,
        mx_ifgreater: mx_ifgreater,
        mx_ifgreatereq: mx_ifgreatereq,
        mx_invert: mx_invert,
        mx_modulo: mx_modulo,
        mx_multiply: mx_multiply,
        mx_noise_float: mx_noise_float,
        mx_noise_vec3: mx_noise_vec3,
        mx_noise_vec4: mx_noise_vec4,
        mx_place2d: mx_place2d,
        mx_power: mx_power,
        mx_ramp4: mx_ramp4,
        mx_ramplr: mx_ramplr,
        mx_ramptb: mx_ramptb,
        mx_rgbtohsv: mx_rgbtohsv,
        mx_rotate2d: mx_rotate2d,
        mx_rotate3d: mx_rotate3d,
        mx_safepower: mx_safepower,
        mx_separate: mx_separate,
        mx_splitlr: mx_splitlr,
        mx_splittb: mx_splittb,
        mx_srgb_texture_to_lin_rec709: mx_srgb_texture_to_lin_rec709,
        mx_subtract: mx_subtract,
        mx_timer: mx_timer,
        mx_transform_uv: mx_transform_uv,
        mx_unifiednoise2d: mx_unifiednoise2d,
        mx_unifiednoise3d: mx_unifiednoise3d,
        mx_worley_noise_float: mx_worley_noise_float,
        mx_worley_noise_vec2: mx_worley_noise_vec2,
        mx_worley_noise_vec3: mx_worley_noise_vec3,
        negate: negate,
        neutralToneMapping: neutralToneMapping,
        nodeArray: nodeArray,
        nodeImmutable: nodeImmutable,
        nodeObject: nodeObject,
        nodeObjectIntent: nodeObjectIntent,
        nodeObjects: nodeObjects,
        nodeProxy: nodeProxy,
        nodeProxyIntent: nodeProxyIntent,
        normalFlat: normalFlat,
        normalGeometry: normalGeometry,
        normalLocal: normalLocal,
        normalMap: normalMap,
        normalView: normalView,
        normalViewGeometry: normalViewGeometry,
        normalWorld: normalWorld,
        normalWorldGeometry: normalWorldGeometry,
        normalize: normalize,
        not: not,
        notEqual: notEqual,
        numWorkgroups: numWorkgroups,
        objectDirection: objectDirection,
        objectGroup: objectGroup,
        objectPosition: objectPosition,
        objectRadius: objectRadius,
        objectScale: objectScale,
        objectViewPosition: objectViewPosition,
        objectWorldMatrix: objectWorldMatrix,
        oneMinus: oneMinus,
        or: or,
        orthographicDepthToViewZ: orthographicDepthToViewZ,
        oscSawtooth: oscSawtooth,
        oscSine: oscSine,
        oscSquare: oscSquare,
        oscTriangle: oscTriangle,
        output: output,
        outputStruct: outputStruct,
        overlay: overlay,
        overloadingFn: overloadingFn,
        parabola: parabola,
        parallaxDirection: parallaxDirection,
        parallaxUV: parallaxUV,
        parameter: parameter,
        pass: pass,
        passTexture: passTexture,
        pcurve: pcurve,
        perspectiveDepthToViewZ: perspectiveDepthToViewZ,
        pmremTexture: pmremTexture,
        pointShadow: pointShadow,
        pointUV: pointUV,
        pointWidth: pointWidth,
        positionGeometry: positionGeometry,
        positionLocal: positionLocal,
        positionPrevious: positionPrevious,
        positionView: positionView,
        positionViewDirection: positionViewDirection,
        positionWorld: positionWorld,
        positionWorldDirection: positionWorldDirection,
        posterize: posterize,
        pow: pow,
        pow2: pow2,
        pow3: pow3,
        pow4: pow4,
        premultiplyAlpha: premultiplyAlpha,
        property: property,
        radians: radians,
        rand: rand,
        range: range,
        rangeFog: rangeFog,
        rangeFogFactor: rangeFogFactor,
        reciprocal: reciprocal,
        reference: reference,
        referenceBuffer: referenceBuffer,
        reflect: reflect,
        reflectVector: reflectVector,
        reflectView: reflectView,
        reflector: reflector,
        refract: refract,
        refractVector: refractVector,
        refractView: refractView,
        reinhardToneMapping: reinhardToneMapping,
        remap: remap,
        remapClamp: remapClamp,
        renderGroup: renderGroup,
        renderOutput: renderOutput,
        rendererReference: rendererReference,
        rotate: rotate,
        rotateUV: rotateUV,
        roughness: roughness,
        round: round,
        rtt: rtt,
        sRGBTransferEOTF: sRGBTransferEOTF,
        sRGBTransferOETF: sRGBTransferOETF,
        sample: sample,
        sampler: sampler,
        samplerComparison: samplerComparison,
        saturate: saturate,
        saturation: saturation,
        screen: screen,
        screenCoordinate: screenCoordinate,
        screenSize: screenSize,
        screenUV: screenUV,
        scriptable: scriptable,
        scriptableValue: scriptableValue,
        select: select,
        setCurrentStack: setCurrentStack,
        setName: setName,
        shaderStages: shaderStages,
        shadow: shadow,
        shadowPositionWorld: shadowPositionWorld,
        shapeCircle: shapeCircle,
        sharedUniformGroup: sharedUniformGroup,
        sheen: sheen,
        sheenRoughness: sheenRoughness,
        shiftLeft: shiftLeft,
        shiftRight: shiftRight,
        shininess: shininess,
        sign: sign,
        sin: sin,
        sinc: sinc,
        skinning: skinning,
        smoothstep: smoothstep,
        smoothstepElement: smoothstepElement,
        specularColor: specularColor,
        specularF90: specularF90,
        spherizeUV: spherizeUV,
        split: split,
        spritesheetUV: spritesheetUV,
        sqrt: sqrt,
        stack: stack,
        step: step,
        stepElement: stepElement,
        storage: storage,
        storageBarrier: storageBarrier,
        storageObject: storageObject,
        storageTexture: storageTexture,
        string: string,
        struct: struct,
        sub: sub,
        subBuild: subBuild,
        subgroupIndex: subgroupIndex,
        subgroupSize: subgroupSize,
        tan: tan,
        tangentGeometry: tangentGeometry,
        tangentLocal: tangentLocal,
        tangentView: tangentView,
        tangentWorld: tangentWorld,
        temp: temp,
        texture: texture,
        texture3D: texture3D,
        textureBarrier: textureBarrier,
        textureBicubic: textureBicubic,
        textureBicubicLevel: textureBicubicLevel,
        textureCubeUV: textureCubeUV,
        textureLoad: textureLoad,
        textureSize: textureSize,
        textureStore: textureStore,
        thickness: thickness,
        time: time,
        timerDelta: timerDelta,
        timerGlobal: timerGlobal,
        timerLocal: timerLocal,
        toneMapping: toneMapping,
        toneMappingExposure: toneMappingExposure,
        toonOutlinePass: toonOutlinePass,
        transformDirection: transformDirection,
        transformNormal: transformNormal,
        transformNormalToView: transformNormalToView,
        transformedClearcoatNormalView: transformedClearcoatNormalView,
        transformedNormalView: transformedNormalView,
        transformedNormalWorld: transformedNormalWorld,
        transmission: transmission,
        transpose: transpose,
        triNoise3D: triNoise3D,
        triplanarTexture: triplanarTexture,
        triplanarTextures: triplanarTextures,
        trunc: trunc,
        uint: uint,
        uniform: uniform,
        uniformArray: uniformArray,
        uniformCubeTexture: uniformCubeTexture,
        uniformGroup: uniformGroup,
        uniformTexture: uniformTexture,
        unpremultiplyAlpha: unpremultiplyAlpha,
        userData: userData,
        uv: uv,
        uvec2: uvec2,
        uvec3: uvec3,
        uvec4: uvec4,
        varying: varying,
        varyingProperty: varyingProperty,
        vec2: vec2,
        vec3: vec3,
        vec4: vec4,
        vectorComponents: vectorComponents,
        velocity: velocity,
        vertexColor: vertexColor,
        vertexIndex: vertexIndex,
        vertexStage: vertexStage,
        vibrance: vibrance,
        viewZToLogarithmicDepth: viewZToLogarithmicDepth,
        viewZToOrthographicDepth: viewZToOrthographicDepth,
        viewZToPerspectiveDepth: viewZToPerspectiveDepth,
        viewport: viewport,
        viewportCoordinate: viewportCoordinate,
        viewportDepthTexture: viewportDepthTexture,
        viewportLinearDepth: viewportLinearDepth,
        viewportMipTexture: viewportMipTexture,
        viewportResolution: viewportResolution,
        viewportSafeUV: viewportSafeUV,
        viewportSharedTexture: viewportSharedTexture,
        viewportSize: viewportSize,
        viewportTexture: viewportTexture,
        viewportUV: viewportUV,
        wgsl: wgsl,
        wgslFn: wgslFn,
        workgroupArray: workgroupArray,
        workgroupBarrier: workgroupBarrier,
        workgroupId: workgroupId,
        workingToColorSpace: workingToColorSpace,
        xor: xor
    });
    const _clearColor = /*@__PURE__*/ new Color4();
    class Background extends DataMap {
        constructor(renderer, nodes) {
            super();
            this.renderer = renderer;
            this.nodes = nodes;
        }
        update(scene, renderList, renderContext) {
            const renderer = this.renderer;
            const background = this.nodes.getBackgroundNode(scene) || scene.background;
            let forceClear = false;
            if (background === null) {
                // no background settings, use clear color configuration from the renderer
                renderer._clearColor.getRGB(_clearColor);
                _clearColor.a = renderer._clearColor.a;
            } else if (background.isColor === true) {
                // background is an opaque color
                background.getRGB(_clearColor);
                _clearColor.a = 1;
                forceClear = true;
            } else if (background.isNode === true) {
                const sceneData = this.get(scene);
                const backgroundNode = background;
                _clearColor.copy(renderer._clearColor);
                let backgroundMesh = sceneData.backgroundMesh;
                if (backgroundMesh === undefined) {
                    const backgroundMeshNode = context(vec4(backgroundNode).mul(backgroundIntensity), {
                        // @TODO: Add Texture2D support using node context
                        getUV: () => backgroundRotation.mul(normalWorldGeometry),
                        getTextureLevel: () => backgroundBlurriness
                    });
                    let viewProj = modelViewProjection;
                    viewProj = viewProj.setZ(viewProj.w);
                    const nodeMaterial = new NodeMaterial();
                    nodeMaterial.name = 'Background.material';
                    nodeMaterial.side = BackSide;
                    nodeMaterial.depthTest = false;
                    nodeMaterial.depthWrite = false;
                    nodeMaterial.allowOverride = false;
                    nodeMaterial.fog = false;
                    nodeMaterial.lights = false;
                    nodeMaterial.vertexNode = viewProj;
                    nodeMaterial.colorNode = backgroundMeshNode;
                    sceneData.backgroundMeshNode = backgroundMeshNode;
                    sceneData.backgroundMesh = backgroundMesh = new Mesh(new SphereGeometry(1, 32, 32), nodeMaterial);
                    backgroundMesh.frustumCulled = false;
                    backgroundMesh.name = 'Background.mesh';
                    backgroundMesh.onBeforeRender = function (renderer, scene, camera) {
                        this.matrixWorld.copyPosition(camera.matrixWorld);
                    };
                    function onBackgroundDispose() {
                        background.removeEventListener('dispose', onBackgroundDispose);
                        backgroundMesh.material.dispose();
                        backgroundMesh.geometry.dispose();
                    }
                    background.addEventListener('dispose', onBackgroundDispose);
                }
                const backgroundCacheKey = backgroundNode.getCacheKey();
                if (sceneData.backgroundCacheKey !== backgroundCacheKey) {
                    sceneData.backgroundMeshNode.node = vec4(backgroundNode).mul(backgroundIntensity);
                    sceneData.backgroundMeshNode.needsUpdate = true;
                    backgroundMesh.material.needsUpdate = true;
                    sceneData.backgroundCacheKey = backgroundCacheKey;
                }
                renderList.unshift(backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null);
            } else {
                console.error('THREE.Renderer: Unsupported background configuration.', background);
            }
            //
            const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
            if (environmentBlendMode === 'additive') {
                _clearColor.set(0, 0, 0, 1);
            } else if (environmentBlendMode === 'alpha-blend') {
                _clearColor.set(0, 0, 0, 0);
            }
            //
            if (renderer.autoClear === true || forceClear === true) {
                const clearColorValue = renderContext.clearColorValue;
                clearColorValue.r = _clearColor.r;
                clearColorValue.g = _clearColor.g;
                clearColorValue.b = _clearColor.b;
                clearColorValue.a = _clearColor.a;
                // premultiply alpha
                if (renderer.backend.isWebGLBackend === true || renderer.alpha === true) {
                    clearColorValue.r *= clearColorValue.a;
                    clearColorValue.g *= clearColorValue.a;
                    clearColorValue.b *= clearColorValue.a;
                }
                //
                renderContext.depthClearValue = renderer._clearDepth;
                renderContext.stencilClearValue = renderer._clearStencil;
                renderContext.clearColor = renderer.autoClearColor === true;
                renderContext.clearDepth = renderer.autoClearDepth === true;
                renderContext.clearStencil = renderer.autoClearStencil === true;
            } else {
                renderContext.clearColor = false;
                renderContext.clearDepth = false;
                renderContext.clearStencil = false;
            }
        }
    }
    let _id$6 = 0;
    class BindGroup {
        constructor(name = '', bindings = [], index = 0, bindingsReference = []) {
            this.name = name;
            this.bindings = bindings;
            this.index = index;
            this.bindingsReference = bindingsReference;
            this.id = _id$6++;
        }
    }
    class NodeBuilderState {
        constructor(vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, observer, transforms = []) {
            this.vertexShader = vertexShader;
            this.fragmentShader = fragmentShader;
            this.computeShader = computeShader;
            this.transforms = transforms;
            this.nodeAttributes = nodeAttributes;
            this.bindings = bindings;
            this.updateNodes = updateNodes;
            this.updateBeforeNodes = updateBeforeNodes;
            this.updateAfterNodes = updateAfterNodes;
            this.observer = observer;
            this.usedTimes = 0;
        }
        createBindings() {
            const bindings = [];
            for (const instanceGroup of this.bindings) {
                const shared = instanceGroup.bindings[0].groupNode.shared; // All bindings in the group must have the same groupNode.
                if (shared !== true) {
                    const bindingsGroup = new BindGroup(instanceGroup.name, [], instanceGroup.index, instanceGroup);
                    bindings.push(bindingsGroup);
                    for (const instanceBinding of instanceGroup.bindings) {
                        bindingsGroup.bindings.push(instanceBinding.clone());
                    }
                } else {
                    bindings.push(instanceGroup);
                }
            }
            return bindings;
        }
    }
    class NodeAttribute {
        constructor(name, type, node = null) {
            this.isNodeAttribute = true;
            this.name = name;
            this.type = type;
            this.node = node;
        }
    }
    class NodeUniform {
        constructor(name, type, node) {
            this.isNodeUniform = true;
            this.name = name;
            this.type = type;
            this.node = node.getSelf();
        }
        get value() {
            return this.node.value;
        }
        set value(val) {
            this.node.value = val;
        }
        get id() {
            return this.node.id;
        }
        get groupNode() {
            return this.node.groupNode;
        }
    }
    class NodeVar {
        constructor(name, type, readOnly = false, count = null) {
            this.isNodeVar = true;
            this.name = name;
            this.type = type;
            this.readOnly = readOnly;
            this.count = count;
        }
    }
    class NodeVarying extends NodeVar {
        constructor(name, type, interpolationType = null, interpolationSampling = null) {
            super(name, type);
            this.needsInterpolation = false;
            this.isNodeVarying = true;
            this.interpolationType = interpolationType;
            this.interpolationSampling = interpolationSampling;
        }
    }
    class NodeCode {
        constructor(name, type, code = '') {
            this.name = name;
            this.type = type;
            this.code = code;
            Object.defineProperty(this, 'isNodeCode', { value: true });
        }
    }
    let _id$5 = 0;
    class NodeCache {
        constructor(parent = null) {
            this.id = _id$5++;
            this.nodesData = new WeakMap();
            this.parent = parent;
        }
        getData(node) {
            let data = this.nodesData.get(node);
            if (data === undefined && this.parent !== null) {
                data = this.parent.getData(node);
            }
            return data;
        }
        setData(node, data) {
            this.nodesData.set(node, data);
        }
    }
    class StructType {
        constructor(name, members) {
            this.name = name;
            this.members = members;
            this.output = false;
        }
    }
    class Uniform {
        constructor(name, value) {
            this.name = name;
            this.value = value;
            this.boundary = 0;
            this.itemSize = 0;
            this.offset = 0;
        }
        setValue(value) {
            this.value = value;
        }
        getValue() {
            return this.value;
        }
    }
    class NumberUniform extends Uniform {
        constructor(name, value = 0) {
            super(name, value);
            this.isNumberUniform = true;
            this.boundary = 4;
            this.itemSize = 1;
        }
    }
    class Vector2Uniform extends Uniform {
        constructor(name, value = new Vector2()) {
            super(name, value);
            this.isVector2Uniform = true;
            this.boundary = 8;
            this.itemSize = 2;
        }
    }
    class Vector3Uniform extends Uniform {
        constructor(name, value = new Vector3()) {
            super(name, value);
            this.isVector3Uniform = true;
            this.boundary = 16;
            this.itemSize = 3;
        }
    }
    class Vector4Uniform extends Uniform {
        constructor(name, value = new Vector4()) {
            super(name, value);
            this.isVector4Uniform = true;
            this.boundary = 16;
            this.itemSize = 4;
        }
    }
    class ColorUniform extends Uniform {
        constructor(name, value = new Color()) {
            super(name, value);
            this.isColorUniform = true;
            this.boundary = 16;
            this.itemSize = 3;
        }
    }
    class Matrix2Uniform extends Uniform {
        constructor(name, value = new Matrix2()) {
            super(name, value);
            this.isMatrix2Uniform = true;
            this.boundary = 8;
            this.itemSize = 4;
        }
    }

    class Matrix3Uniform extends Uniform {
        constructor(name, value = new Matrix3()) {
            super(name, value);
            this.isMatrix3Uniform = true;
            this.boundary = 48;
            this.itemSize = 12;
        }
    }
    class Matrix4Uniform extends Uniform {
        constructor(name, value = new Matrix4()) {
            super(name, value);
            this.isMatrix4Uniform = true;
            this.boundary = 64;
            this.itemSize = 16;
        }
    }
    class NumberNodeUniform extends NumberUniform {
        constructor(nodeUniform) {
            super(nodeUniform.name, nodeUniform.value);
            this.nodeUniform = nodeUniform;
        }
        getValue() {
            return this.nodeUniform.value;
        }
        getType() {
            return this.nodeUniform.type;
        }
    }
    class Vector2NodeUniform extends Vector2Uniform {
        constructor(nodeUniform) {
            super(nodeUniform.name, nodeUniform.value);
            this.nodeUniform = nodeUniform;
        }
        getValue() {
            return this.nodeUniform.value;
        }
        getType() {
            return this.nodeUniform.type;
        }
    }
    class Vector3NodeUniform extends Vector3Uniform {
        constructor(nodeUniform) {
            super(nodeUniform.name, nodeUniform.value);
            this.nodeUniform = nodeUniform;
        }
        getValue() {
            return this.nodeUniform.value;
        }
        getType() {
            return this.nodeUniform.type;
        }
    }
    class Vector4NodeUniform extends Vector4Uniform {
        constructor(nodeUniform) {
            super(nodeUniform.name, nodeUniform.value);
            this.nodeUniform = nodeUniform;
        }
        getValue() {
            return this.nodeUniform.value;
        }
        getType() {
            return this.nodeUniform.type;
        }
    }
    class ColorNodeUniform extends ColorUniform {
        constructor(nodeUniform) {
            super(nodeUniform.name, nodeUniform.value);
            this.nodeUniform = nodeUniform;
        }
        getValue() {
            return this.nodeUniform.value;
        }
        getType() {
            return this.nodeUniform.type;
        }
    }

    class Matrix2NodeUniform extends Matrix2Uniform {
        constructor(nodeUniform) {
            super(nodeUniform.name, nodeUniform.value);
            this.nodeUniform = nodeUniform;
        }
        getValue() {
            return this.nodeUniform.value;
        }
        getType() {
            return this.nodeUniform.type;
        }
    }
    class Matrix3NodeUniform extends Matrix3Uniform {
        constructor(nodeUniform) {
            super(nodeUniform.name, nodeUniform.value);
            this.nodeUniform = nodeUniform;
        }
        getValue() {
            return this.nodeUniform.value;
        }
        getType() {
            return this.nodeUniform.type;
        }
    }
    class Matrix4NodeUniform extends Matrix4Uniform {
        constructor(nodeUniform) {
            super(nodeUniform.name, nodeUniform.value);
            this.nodeUniform = nodeUniform;
        }
        getValue() {
            return this.nodeUniform.value;
        }
        getType() {
            return this.nodeUniform.type;
        }
    }
    const rendererCache = new WeakMap();
    const typeFromArray = new Map([
        [Int8Array, 'int'],
        [Int16Array, 'int'],
        [Int32Array, 'int'],
        [Uint8Array, 'uint'],
        [Uint16Array, 'uint'],
        [Uint32Array, 'uint'],
        [Float32Array, 'float']
    ]);
    const toFloat = (value) => {
        if (/e/g.test(value)) {
            return String(value).replace(/\+/g, '');
        } else {
            value = Number(value);
            return value + (value % 1 ? '' : '.0');
        }
    };
    class NodeBuilder {
        constructor(object, renderer, parser) {
            this.object = object;
            this.material = (object && object.material) || null;
            this.geometry = (object && object.geometry) || null;
            this.renderer = renderer;
            this.parser = parser;
            this.scene = null;
            this.camera = null;
            this.nodes = [];
            this.sequentialNodes = [];
            this.updateNodes = [];
            this.updateBeforeNodes = [];
            this.updateAfterNodes = [];
            this.hashNodes = {};
            this.observer = null;
            this.lightsNode = null;
            this.environmentNode = null;
            this.fogNode = null;
            this.clippingContext = null;
            this.vertexShader = null;
            this.fragmentShader = null;
            this.computeShader = null;
            this.flowNodes = { vertex: [], fragment: [], compute: [] };
            this.flowCode = { vertex: '', fragment: '', compute: '' };
            this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
            this.structs = { vertex: [], fragment: [], compute: [], index: 0 };
            this.bindings = { vertex: {}, fragment: {}, compute: {} };
            this.bindingsIndexes = {};
            this.bindGroups = null;
            this.attributes = [];
            this.bufferAttributes = [];
            this.varyings = [];
            this.codes = {};
            this.vars = {};
            this.declarations = {};
            this.flow = { code: '' };
            this.chaining = [];
            this.stack = stack();
            this.stacks = [];
            this.tab = '\t';
            this.currentFunctionNode = null;
            this.context = {
                material: this.material
            };
            this.cache = new NodeCache();
            this.globalCache = this.cache;
            this.flowsData = new WeakMap();
            this.shaderStage = null;
            this.buildStage = null;
            this.subBuildLayers = [];
            this.currentStack = null;
            this.subBuildFn = null;
        }
        getBindGroupsCache() {
            let bindGroupsCache = rendererCache.get(this.renderer);
            if (bindGroupsCache === undefined) {
                bindGroupsCache = new ChainMap();
                rendererCache.set(this.renderer, bindGroupsCache);
            }
            return bindGroupsCache;
        }
        createRenderTarget(width, height, options) {
            return new RenderTarget(width, height, options);
        }
        createCubeRenderTarget(size, options) {
            return new CubeRenderTarget(size, options);
        }
        includes(node) {
            return this.nodes.includes(node);
        }
        getOutputStructName() { }
        _getBindGroup(groupName, bindings) {
            const bindGroupsCache = this.getBindGroupsCache();
            //
            const bindingsArray = [];
            let sharedGroup = true;
            for (const binding of bindings) {
                bindingsArray.push(binding);
                sharedGroup = sharedGroup && binding.groupNode.shared !== true;
            }
            //
            let bindGroup;
            if (sharedGroup) {
                bindGroup = bindGroupsCache.get(bindingsArray);
                if (bindGroup === undefined) {
                    bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);
                    bindGroupsCache.set(bindingsArray, bindGroup);
                }
            } else {
                bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);
            }
            return bindGroup;
        }
        getBindGroupArray(groupName, shaderStage) {
            const bindings = this.bindings[shaderStage];
            let bindGroup = bindings[groupName];
            if (bindGroup === undefined) {
                if (this.bindingsIndexes[groupName] === undefined) {
                    this.bindingsIndexes[groupName] = { binding: 0, group: Object.keys(this.bindingsIndexes).length };
                }
                bindings[groupName] = bindGroup = [];
            }
            return bindGroup;
        }
        getBindings() {
            let bindingsGroups = this.bindGroups;
            if (bindingsGroups === null) {
                const groups = {};
                const bindings = this.bindings;
                for (const shaderStage of shaderStages) {
                    for (const groupName in bindings[shaderStage]) {
                        const uniforms = bindings[shaderStage][groupName];
                        const groupUniforms = groups[groupName] || (groups[groupName] = []);
                        groupUniforms.push(...uniforms);
                    }
                }
                bindingsGroups = [];
                for (const groupName in groups) {
                    const group = groups[groupName];
                    const bindingsGroup = this._getBindGroup(groupName, group);
                    bindingsGroups.push(bindingsGroup);
                }
                this.bindGroups = bindingsGroups;
            }
            return bindingsGroups;
        }
        sortBindingGroups() {
            const bindingsGroups = this.getBindings();
            bindingsGroups.sort((a, b) => (a.bindings[0].groupNode.order - b.bindings[0].groupNode.order));
            for (let i = 0; i < bindingsGroups.length; i++) {
                const bindingGroup = bindingsGroups[i];
                this.bindingsIndexes[bindingGroup.name].group = i;
                bindingGroup.index = i;
            }
        }
        setHashNode(node, hash) {
            this.hashNodes[hash] = node;
        }
        addNode(node) {
            if (this.nodes.includes(node) === false) {
                this.nodes.push(node);
                this.setHashNode(node, node.getHash(this));
            }
        }
        addSequentialNode(node) {
            if (this.sequentialNodes.includes(node) === false) {
                this.sequentialNodes.push(node);
            }
        }
        buildUpdateNodes() {
            for (const node of this.nodes) {
                const updateType = node.getUpdateType();
                if (updateType !== NodeUpdateType.NONE) {
                    this.updateNodes.push(node.getSelf());
                }
            }
            for (const node of this.sequentialNodes) {
                const updateBeforeType = node.getUpdateBeforeType();
                const updateAfterType = node.getUpdateAfterType();
                if (updateBeforeType !== NodeUpdateType.NONE) {
                    this.updateBeforeNodes.push(node.getSelf());
                }
                if (updateAfterType !== NodeUpdateType.NONE) {
                    this.updateAfterNodes.push(node.getSelf());
                }
            }
        }
        get currentNode() {
            return this.chaining[this.chaining.length - 1];
        }
        isFilteredTexture(texture) {
            return (texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||
                texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter);
        }
        addChain(node) {
            /*
            if ( this.chaining.indexOf( node ) !== - 1 ) {
                console.warn( 'Recursive node: ', node );
            }
            */
            this.chaining.push(node);
        }
        removeChain(node) {
            const lastChain = this.chaining.pop();
            if (lastChain !== node) {
                throw new Error('NodeBuilder: Invalid node chaining!');
            }
        }
        getMethod(method) {
            return method;
        }
        getNodeFromHash(hash) {
            return this.hashNodes[hash];
        }
        addFlow(shaderStage, node) {
            this.flowNodes[shaderStage].push(node);
            return node;
        }
        setContext(context) {
            this.context = context;
        }
        getContext() {
            return this.context;
        }
        getSharedContext() {
            ({ ...this.context });
            return this.context;
        }
        setCache(cache) {
            this.cache = cache;
        }
        getCache() {
            return this.cache;
        }
        getCacheFromNode(node, parent = true) {
            const data = this.getDataFromNode(node);
            if (data.cache === undefined) data.cache = new NodeCache(parent ? this.getCache() : null);
            return data.cache;
        }
        isAvailable( /*name*/) {
            return false;
        }
        getVertexIndex() {
            console.warn('Abstract function.');
        }
        getInstanceIndex() {
            console.warn('Abstract function.');
        }
        getDrawIndex() {
            console.warn('Abstract function.');
        }
        getFrontFacing() {
            console.warn('Abstract function.');
        }
        getFragCoord() {
            console.warn('Abstract function.');
        }
        isFlipY() {
            return false;
        }
        increaseUsage(node) {
            const nodeData = this.getDataFromNode(node);
            nodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;
            return nodeData.usageCount;
        }
        generateTexture( /* texture, textureProperty, uvSnippet */) {
            console.warn('Abstract function.');
        }
        generateTextureLod( /* texture, textureProperty, uvSnippet, depthSnippet, levelSnippet */) {
            console.warn('Abstract function.');
        }
        generateArrayDeclaration(type, count) {
            return this.getType(type) + '[ ' + count + ' ]';
        }
        generateArray(type, count, values = null) {
            let snippet = this.generateArrayDeclaration(type, count) + '( ';
            for (let i = 0; i < count; i++) {
                const value = values ? values[i] : null;
                if (value !== null) {
                    snippet += value.build(this, type);
                } else {
                    snippet += this.generateConst(type);
                }
                if (i < count - 1) snippet += ', ';
            }
            snippet += ' )';
            return snippet;
        }
        generateStruct(type, membersLayout, values = null) {
            const snippets = [];
            for (const member of membersLayout) {
                const { name, type } = member;
                if (values && values[name] && values[name].isNode) {
                    snippets.push(values[name].build(this, type));
                } else {
                    snippets.push(this.generateConst(type));
                }
            }
            return type + '( ' + snippets.join(', ') + ' )';
        }

        generateConst(type, value = null) {
            if (value === null) {
                if (type === 'float' || type === 'int' || type === 'uint') value = 0;
                else if (type === 'bool') value = false;
                else if (type === 'color') value = new Color();
                else if (type === 'vec2') value = new Vector2();
                else if (type === 'vec3') value = new Vector3();
                else if (type === 'vec4') value = new Vector4();
            }
            if (type === 'float') return toFloat(value);
            if (type === 'int') return `${Math.round(value)}`;
            if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';
            if (type === 'bool') return value ? 'true' : 'false';
            if (type === 'color') return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
            const typeLength = this.getTypeLength(type);
            const componentType = this.getComponentType(type);
            const generateConst = value => this.generateConst(componentType, value);
            if (typeLength === 2) {
                return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;
            } else if (typeLength === 3) {
                return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;
            } else if (typeLength === 4 && type !== 'mat2') {
                return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;
            } else if (typeLength >= 4 && value && (value.isMatrix2 || value.isMatrix3 || value.isMatrix4)) {
                return `${this.getType(type)}( ${value.elements.map(generateConst).join(', ')} )`;
            } else if (typeLength > 4) {
                return `${this.getType(type)}()`;
            }
            throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);
        }
        getType(type) {
            if (type === 'color') return 'vec3';
            return type;
        }
        hasGeometryAttribute(name) {
            return this.geometry && this.geometry.getAttribute(name) !== undefined;
        }
        getAttribute(name, type) {
            const attributes = this.attributes;
            // find attribute
            for (const attribute of attributes) {
                if (attribute.name === name) {
                    return attribute;
                }
            }
            // create a new if no exist
            const attribute = new NodeAttribute(name, type);
            this.registerDeclaration(attribute);
            attributes.push(attribute);
            return attribute;
        }
        getPropertyName(node/*, shaderStage*/) {
            return node.name;
        }
        isVector(type) {
            return /vec\d/.test(type);
        }
        isMatrix(type) {
            return /mat\d/.test(type);
        }
        isReference(type) {
            return type === 'void' || type === 'property' || type === 'sampler' || type === 'samplerComparison' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';
        }
        needsToWorkingColorSpace( /*texture*/) {
            return false;
        }
        getComponentTypeFromTexture(texture) {
            const type = texture.type;
            if (texture.isDataTexture) {
                if (type === IntType) return 'int';
                if (type === UnsignedIntType) return 'uint';
            }
            return 'float';
        }
        getElementType(type) {
            if (type === 'mat2') return 'vec2';
            if (type === 'mat3') return 'vec3';
            if (type === 'mat4') return 'vec4';
            return this.getComponentType(type);
        }
        getComponentType(type) {
            type = this.getVectorType(type);
            if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;
            const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);
            if (componentType === null) return null;
            if (componentType[1] === 'b') return 'bool';
            if (componentType[1] === 'i') return 'int';
            if (componentType[1] === 'u') return 'uint';
            return 'float';
        }
        getVectorType(type) {
            if (type === 'color') return 'vec3';
            if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') return 'vec4';
            return type;
        }
        getTypeFromLength(length, componentType = 'float') {
            if (length === 1) return componentType;
            let baseType = getTypeFromLength(length);
            const prefix = componentType === 'float' ? '' : componentType[0];
            // fix edge case for mat2x2 being same size as vec4
            if (/mat2/.test(componentType) === true) {
                baseType = baseType.replace('vec', 'mat');
            }
            return prefix + baseType;
        }
        getTypeFromArray(array) {
            return typeFromArray.get(array.constructor);
        }
        isInteger(type) {
            return /int|uint|(i|u)vec/.test(type);
        }
        getTypeFromAttribute(attribute) {
            let dataAttribute = attribute;
            if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;
            const array = dataAttribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            let arrayType;
            if (!(attribute instanceof Float16BufferAttribute) && normalized !== true) {
                arrayType = this.getTypeFromArray(array);
            }
            return this.getTypeFromLength(itemSize, arrayType);
        }
        getTypeLength(type) {
            const vecType = this.getVectorType(type);
            const vecNum = /vec([2-4])/.exec(vecType);
            if (vecNum !== null) return Number(vecNum[1]);
            if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;
            if (/mat2/.test(type) === true) return 4;
            if (/mat3/.test(type) === true) return 9;
            if (/mat4/.test(type) === true) return 16;
            return 0;
        }
        getVectorFromMatrix(type) {
            return type.replace('mat', 'vec');
        }
        changeComponentType(type, newComponentType) {
            return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
        }
        getIntegerType(type) {
            const componentType = this.getComponentType(type);
            if (componentType === 'int' || componentType === 'uint') return type;
            return this.changeComponentType(type, 'int');
        }
        addStack() {
            this.stack = stack(this.stack);
            this.stacks.push(getCurrentStack() || this.stack);
            setCurrentStack(this.stack);
            return this.stack;
        }
        removeStack() {
            const lastStack = this.stack;
            this.stack = lastStack.parent;
            setCurrentStack(this.stacks.pop());
            return lastStack;
        }
        getDataFromNode(node, shaderStage = this.shaderStage, cache = null) {
            cache = cache === null ? (node.isGlobal(this) ? this.globalCache : this.cache) : cache;
            let nodeData = cache.getData(node);
            if (nodeData === undefined) {
                nodeData = {};
                cache.setData(node, nodeData);
            }
            if (nodeData[shaderStage] === undefined) nodeData[shaderStage] = {};
            //
            let data = nodeData[shaderStage];
            const subBuilds = nodeData.any ? nodeData.any.subBuilds : null;
            const subBuild = this.getClosestSubBuild(subBuilds);
            if (subBuild) {
                if (data.subBuildsCache === undefined) data.subBuildsCache = {};
                data = data.subBuildsCache[subBuild] || (data.subBuildsCache[subBuild] = {});
                data.subBuilds = subBuilds;
            }
            return data;
        }
        getNodeProperties(node, shaderStage = 'any') {
            const nodeData = this.getDataFromNode(node, shaderStage);
            return nodeData.properties || (nodeData.properties = { outputNode: null });
        }
        getBufferAttributeFromNode(node, type) {
            const nodeData = this.getDataFromNode(node);
            let bufferAttribute = nodeData.bufferAttribute;
            if (bufferAttribute === undefined) {
                const index = this.uniforms.index++;
                bufferAttribute = new NodeAttribute('nodeAttribute' + index, type, node);
                this.bufferAttributes.push(bufferAttribute);
                nodeData.bufferAttribute = bufferAttribute;
            }
            return bufferAttribute;
        }
        getStructTypeFromNode(node, membersLayout, name = null, shaderStage = this.shaderStage) {
            const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
            let structType = nodeData.structType;
            if (structType === undefined) {
                const index = this.structs.index++;
                if (name === null) name = 'StructType' + index;
                structType = new StructType(name, membersLayout);
                this.structs[shaderStage].push(structType);
                nodeData.structType = structType;
            }
            return structType;
        }
        getOutputStructTypeFromNode(node, membersLayout) {
            const structType = this.getStructTypeFromNode(node, membersLayout, 'OutputType', 'fragment');
            structType.output = true;
            return structType;
        }
        getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {
            const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
            let nodeUniform = nodeData.uniform;
            if (nodeUniform === undefined) {
                const index = this.uniforms.index++;
                nodeUniform = new NodeUniform(name || ('nodeUniform' + index), type, node);
                this.uniforms[shaderStage].push(nodeUniform);
                this.registerDeclaration(nodeUniform);
                nodeData.uniform = nodeUniform;
            }
            return nodeUniform;
        }
        getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage, readOnly = false) {
            const nodeData = this.getDataFromNode(node, shaderStage);
            const subBuildVariable = this.getSubBuildProperty('variable', nodeData.subBuilds);
            let nodeVar = nodeData[subBuildVariable];
            if (nodeVar === undefined) {
                const idNS = readOnly ? '_const' : '_var';
                const vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);
                const id = this.vars[idNS] || (this.vars[idNS] = 0);
                if (name === null) {
                    name = (readOnly ? 'nodeConst' : 'nodeVar') + id;
                    this.vars[idNS]++;
                }
                //
                if (subBuildVariable !== 'variable') {
                    name = this.getSubBuildProperty(name, nodeData.subBuilds);
                }
                //
                const count = node.getArrayCount(this);
                nodeVar = new NodeVar(name, type, readOnly, count);
                if (!readOnly) {
                    vars.push(nodeVar);
                }
                this.registerDeclaration(nodeVar);
                nodeData[subBuildVariable] = nodeVar;
            }
            return nodeVar;
        }
        isDeterministic(node) {
            if (node.isMathNode) {
                return this.isDeterministic(node.aNode) &&
                    (node.bNode ? this.isDeterministic(node.bNode) : true) &&
                    (node.cNode ? this.isDeterministic(node.cNode) : true);
            } else if (node.isOperatorNode) {
                return this.isDeterministic(node.aNode) &&
                    (node.bNode ? this.isDeterministic(node.bNode) : true);
            } else if (node.isArrayNode) {
                if (node.values !== null) {
                    for (const n of node.values) {
                        if (!this.isDeterministic(n)) {
                            return false;
                        }
                    }
                }
                return true;
            } else if (node.isConstNode) {
                return true;
            }
            return false;
        }
        getVaryingFromNode(node, name = null, type = node.getNodeType(this), interpolationType = null, interpolationSampling = null) {
            const nodeData = this.getDataFromNode(node, 'any');
            const subBuildVarying = this.getSubBuildProperty('varying', nodeData.subBuilds);
            let nodeVarying = nodeData[subBuildVarying];
            if (nodeVarying === undefined) {
                const varyings = this.varyings;
                const index = varyings.length;
                if (name === null) name = 'nodeVarying' + index;
                //
                if (subBuildVarying !== 'varying') {
                    name = this.getSubBuildProperty(name, nodeData.subBuilds);
                }
                //
                nodeVarying = new NodeVarying(name, type, interpolationType, interpolationSampling);
                varyings.push(nodeVarying);
                this.registerDeclaration(nodeVarying);
                nodeData[subBuildVarying] = nodeVarying;
            }
            return nodeVarying;
        }
        registerDeclaration(node) {
            const shaderStage = this.shaderStage;
            const declarations = this.declarations[shaderStage] || (this.declarations[shaderStage] = {});
            const property = this.getPropertyName(node);
            let index = 1;
            let name = property;
            // Automatically renames the property if the name is already in use.
            while (declarations[name] !== undefined) {
                name = property + '_' + index++;
            }
            if (index > 1) {
                node.name = name;
                console.warn(`THREE.TSL: Declaration name '${property}' of '${node.type}' already in use. Renamed to '${name}'.`);
            }
            declarations[name] = node;
        }
        getCodeFromNode(node, type, shaderStage = this.shaderStage) {
            const nodeData = this.getDataFromNode(node);
            let nodeCode = nodeData.code;
            if (nodeCode === undefined) {
                const codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);
                const index = codes.length;
                nodeCode = new NodeCode('nodeCode' + index, type);
                codes.push(nodeCode);
                nodeData.code = nodeCode;
            }
            return nodeCode;
        }
        addFlowCodeHierarchy(node, nodeBlock) {
            const { flowCodes, flowCodeBlock } = this.getDataFromNode(node);
            let needsFlowCode = true;
            let nodeBlockHierarchy = nodeBlock;
            while (nodeBlockHierarchy) {
                if (flowCodeBlock.get(nodeBlockHierarchy) === true) {
                    needsFlowCode = false;
                    break;
                }
                nodeBlockHierarchy = this.getDataFromNode(nodeBlockHierarchy).parentNodeBlock;
            }
            if (needsFlowCode) {
                for (const flowCode of flowCodes) {
                    this.addLineFlowCode(flowCode);
                }
            }
        }
        addLineFlowCodeBlock(node, code, nodeBlock) {
            const nodeData = this.getDataFromNode(node);
            const flowCodes = nodeData.flowCodes || (nodeData.flowCodes = []);
            const codeBlock = nodeData.flowCodeBlock || (nodeData.flowCodeBlock = new WeakMap());
            flowCodes.push(code);
            codeBlock.set(nodeBlock, true);
        }
        addLineFlowCode(code, node = null) {
            if (code === '') return this;
            if (node !== null && this.context.nodeBlock) {
                this.addLineFlowCodeBlock(node, code, this.context.nodeBlock);
            }
            code = this.tab + code;
            if (! /;\s*$/.test(code)) {
                code = code + ';\n';
            }
            this.flow.code += code;
            return this;
        }
        addFlowCode(code) {
            this.flow.code += code;
            return this;
        }
        addFlowTab() {
            this.tab += '\t';
            return this;
        }
        removeFlowTab() {
            this.tab = this.tab.slice(0, -1);
            return this;
        }
        getFlowData(node/*, shaderStage*/) {
            return this.flowsData.get(node);
        }
        flowNode(node) {
            const output = node.getNodeType(this);
            const flowData = this.flowChildNode(node, output);
            this.flowsData.set(node, flowData);
            return flowData;
        }
        addInclude(node) {
            if (this.currentFunctionNode !== null) {
                this.currentFunctionNode.includes.push(node);
            }
        }
        buildFunctionNode(shaderNode) {
            const fn = new FunctionNode();
            const previous = this.currentFunctionNode;
            this.currentFunctionNode = fn;
            fn.code = this.buildFunctionCode(shaderNode);
            this.currentFunctionNode = previous;
            return fn;
        }
        flowShaderNode(shaderNode) {
            const layout = shaderNode.layout;
            const inputs = {
                [Symbol.iterator]() {
                    let index = 0;
                    const values = Object.values(this);
                    return {
                        next: () => ({
                            value: values[index],
                            done: index++ >= values.length
                        })
                    };
                }
            };
            for (const input of layout.inputs) {
                inputs[input.name] = new ParameterNode(input.type, input.name);
            }
            //
            shaderNode.layout = null;
            const callNode = shaderNode.call(inputs);
            const flowData = this.flowStagesNode(callNode, layout.type);
            shaderNode.layout = layout;
            return flowData;
        }
        flowBuildStage(node, buildStage, output = null) {
            const previousBuildStage = this.getBuildStage();
            this.setBuildStage(buildStage);
            const result = node.build(this, output);
            this.setBuildStage(previousBuildStage);
            return result;
        }
        flowStagesNode(node, output = null) {
            const previousFlow = this.flow;
            const previousVars = this.vars;
            const previousDeclarations = this.declarations;
            const previousCache = this.cache;
            const previousBuildStage = this.buildStage;
            const previousStack = this.stack;
            const flow = {
                code: ''
            };
            this.flow = flow;
            this.vars = {};
            this.declarations = {};
            this.cache = new NodeCache();
            this.stack = stack();
            for (const buildStage of defaultBuildStages) {
                this.setBuildStage(buildStage);
                flow.result = node.build(this, output);
            }
            flow.vars = this.getVars(this.shaderStage);
            this.flow = previousFlow;
            this.vars = previousVars;
            this.declarations = previousDeclarations;
            this.cache = previousCache;
            this.stack = previousStack;
            this.setBuildStage(previousBuildStage);
            return flow;
        }
        getFunctionOperator( /* op */) {
            return null;
        }
        buildFunctionCode( /* shaderNode */) {
            console.warn('Abstract function.');
        }
        flowChildNode(node, output = null) {
            const previousFlow = this.flow;
            const flow = {
                code: ''
            };
            this.flow = flow;
            flow.result = node.build(this, output);
            this.flow = previousFlow;
            return flow;
        }
        flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {
            const previousTab = this.tab;
            const previousCache = this.cache;
            const previousShaderStage = this.shaderStage;
            const previousContext = this.context;
            this.setShaderStage(shaderStage);
            const context = { ...this.context };
            delete context.nodeBlock;
            this.cache = this.globalCache;
            this.tab = '\t';
            this.context = context;
            let result = null;
            if (this.buildStage === 'generate') {
                const flowData = this.flowChildNode(node, output);
                if (propertyName !== null) {
                    flowData.code += `${this.tab + propertyName} = ${flowData.result};\n`;
                }
                this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;
                result = flowData;
            } else {
                result = node.build(this);
            }
            this.setShaderStage(previousShaderStage);
            this.cache = previousCache;
            this.tab = previousTab;
            this.context = previousContext;
            return result;
        }
        getAttributesArray() {
            return this.attributes.concat(this.bufferAttributes);
        }
        getAttributes( /*shaderStage*/) {
            console.warn('Abstract function.');
        }
        getVaryings( /*shaderStage*/) {
            console.warn('Abstract function.');
        }
        getVar(type, name, count = null) {
            return `${count !== null ? this.generateArrayDeclaration(type, count) : this.getType(type)} ${name}`;
        }
        getVars(shaderStage) {
            let snippet = '';
            const vars = this.vars[shaderStage];
            if (vars !== undefined) {
                for (const variable of vars) {
                    snippet += `${this.getVar(variable.type, variable.name)}; `;
                }
            }
            return snippet;
        }
        getUniforms( /*shaderStage*/) {
            console.warn('Abstract function.');
        }
        getCodes(shaderStage) {
            const codes = this.codes[shaderStage];
            let code = '';
            if (codes !== undefined) {
                for (const nodeCode of codes) {
                    code += nodeCode.code + '\n';
                }
            }
            return code;
        }
        getHash() {
            return this.vertexShader + this.fragmentShader + this.computeShader;
        }
        setShaderStage(shaderStage) {
            this.shaderStage = shaderStage;
        }
        getShaderStage() {
            return this.shaderStage;
        }
        setBuildStage(buildStage) {
            this.buildStage = buildStage;
        }
        getBuildStage() {
            return this.buildStage;
        }
        buildCode() {
            console.warn('Abstract function.');
        }
        get subBuild() {
            return this.subBuildLayers[this.subBuildLayers.length - 1] || null;
        }
        addSubBuild(subBuild) {
            this.subBuildLayers.push(subBuild);
        }
        removeSubBuild() {
            return this.subBuildLayers.pop();
        }
        getClosestSubBuild(data) {
            let subBuilds;
            if (data && data.isNode) {
                if (data.isShaderCallNodeInternal) {
                    subBuilds = data.shaderNode.subBuilds;
                } else if (data.isStackNode) {
                    subBuilds = [data.subBuild];
                } else {
                    subBuilds = this.getDataFromNode(data, 'any').subBuilds;
                }
            } else if (data instanceof Set) {
                subBuilds = [...data];
            } else {
                subBuilds = data;
            }
            if (!subBuilds) return null;
            const subBuildLayers = this.subBuildLayers;
            for (let i = subBuilds.length - 1; i >= 0; i--) {
                const subBuild = subBuilds[i];
                if (subBuildLayers.includes(subBuild)) {
                    return subBuild;
                }
            }
            return null;
        }

        getSubBuildOutput(node) {
            return this.getSubBuildProperty('outputNode', node);
        }
        getSubBuildProperty(property = '', node = null) {
            let subBuild;
            if (node !== null) {
                subBuild = this.getClosestSubBuild(node);
            } else {
                subBuild = this.subBuildFn;
            }
            let result;
            if (subBuild) {
                result = property ? (subBuild + '_' + property) : subBuild;
            } else {
                result = property;
            }
            return result;
        }
        build() {
            const { object, material, renderer } = this;
            if (material !== null) {
                let nodeMaterial = renderer.library.fromMaterial(material);
                if (nodeMaterial === null) {
                    console.error(`NodeMaterial: Material "${material.type}" is not compatible.`);
                    nodeMaterial = new NodeMaterial();
                }
                nodeMaterial.build(this);
            } else {
                this.addFlow('compute', object);
            }
            // setup() -> stage 1: create possible new nodes and/or return an output reference node
            // analyze()   -> stage 2: analyze nodes to possible optimization and validation
            // generate()  -> stage 3: generate shader
            for (const buildStage of defaultBuildStages) {
                this.setBuildStage(buildStage);
                if (this.context.vertex && this.context.vertex.isNode) {
                    this.flowNodeFromShaderStage('vertex', this.context.vertex);
                }
                for (const shaderStage of shaderStages) {
                    this.setShaderStage(shaderStage);
                    const flowNodes = this.flowNodes[shaderStage];
                    for (const node of flowNodes) {
                        if (buildStage === 'generate') {
                            this.flowNode(node);
                        } else {
                            node.build(this);
                        }
                    }
                }
            }
            this.setBuildStage(null);
            this.setShaderStage(null);
            // stage 4: build code for a specific output
            this.buildCode();
            this.buildUpdateNodes();
            return this;
        }
        getNodeUniform(uniformNode, type) {
            if (type === 'float' || type === 'int' || type === 'uint') return new NumberNodeUniform(uniformNode);
            if (type === 'vec2' || type === 'ivec2' || type === 'uvec2') return new Vector2NodeUniform(uniformNode);
            if (type === 'vec3' || type === 'ivec3' || type === 'uvec3') return new Vector3NodeUniform(uniformNode);
            if (type === 'vec4' || type === 'ivec4' || type === 'uvec4') return new Vector4NodeUniform(uniformNode);
            if (type === 'color') return new ColorNodeUniform(uniformNode);
            if (type === 'mat2') return new Matrix2NodeUniform(uniformNode);
            if (type === 'mat3') return new Matrix3NodeUniform(uniformNode);
            if (type === 'mat4') return new Matrix4NodeUniform(uniformNode);
            throw new Error(`Uniform "${type}" not declared.`);
        }
        format(snippet, fromType, toType) {
            fromType = this.getVectorType(fromType);
            toType = this.getVectorType(toType);
            if (fromType === toType || toType === null || this.isReference(toType)) {
                return snippet;
            }
            const fromTypeLength = this.getTypeLength(fromType);
            const toTypeLength = this.getTypeLength(toType);
            if (fromTypeLength === 16 && toTypeLength === 9) {
                return `${this.getType(toType)}( ${snippet}[ 0 ].xyz, ${snippet}[ 1 ].xyz, ${snippet}[ 2 ].xyz )`;
            }
            if (fromTypeLength === 9 && toTypeLength === 4) {
                return `${this.getType(toType)}( ${snippet}[ 0 ].xy, ${snippet}[ 1 ].xy )`;
            }

            if (fromTypeLength > 4) { // fromType is matrix-like
                // @TODO: ignore for now
                return snippet;
            }
            if (toTypeLength > 4 || toTypeLength === 0) { // toType is matrix-like or unknown
                // @TODO: ignore for now
                return snippet;
            }
            if (fromTypeLength === toTypeLength) {
                return `${this.getType(toType)}( ${snippet} )`;
            }
            if (fromTypeLength > toTypeLength) {
                snippet = toType === 'bool' ? `all( ${snippet} )` : `${snippet}.${'xyz'.slice(0, toTypeLength)}`;
                return this.format(snippet, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);
            }
            if (toTypeLength === 4 && fromTypeLength > 1) { // toType is vec4-like
                return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;
            }
            if (fromTypeLength === 2) { // fromType is vec2-like and toType is vec3-like
                return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;
            }
            if (fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType(toType)) { // fromType is float-like
                // convert a number value to vector type, e.g:
                // vec3( 1u ) -> vec3( float( 1u ) )
                snippet = `${this.getType(this.getComponentType(toType))}( ${snippet} )`;
            }
            return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like
        }
        getSignature() {
            return `// Three.js r${REVISION} - Node System\n`;
        }
        *[Symbol.iterator]() { }
    }
    class NodeFrame {
        constructor() {
            this.time = 0;
            this.deltaTime = 0;
            this.frameId = 0;
            this.renderId = 0;
            this.updateMap = new WeakMap();
            this.updateBeforeMap = new WeakMap();
            this.updateAfterMap = new WeakMap();
            this.renderer = null;
            this.material = null;
            this.camera = null;
            this.object = null;
            this.scene = null;
        }
        _getMaps(referenceMap, nodeRef) {
            let maps = referenceMap.get(nodeRef);
            if (maps === undefined) {
                maps = {
                    renderMap: new WeakMap(),
                    frameMap: new WeakMap()
                };
                referenceMap.set(nodeRef, maps);
            }
            return maps;
        }
        updateBeforeNode(node) {
            const updateType = node.getUpdateBeforeType();
            const reference = node.updateReference(this);
            if (updateType === NodeUpdateType.FRAME) {
                const { frameMap } = this._getMaps(this.updateBeforeMap, reference);
                if (frameMap.get(reference) !== this.frameId) {
                    if (node.updateBefore(this) !== false) {
                        frameMap.set(reference, this.frameId);
                    }
                }
            } else if (updateType === NodeUpdateType.RENDER) {
                const { renderMap } = this._getMaps(this.updateBeforeMap, reference);
                if (renderMap.get(reference) !== this.renderId) {
                    if (node.updateBefore(this) !== false) {
                        renderMap.set(reference, this.renderId);
                    }
                }
            } else if (updateType === NodeUpdateType.OBJECT) {
                node.updateBefore(this);
            }
        }
        updateAfterNode(node) {
            const updateType = node.getUpdateAfterType();
            const reference = node.updateReference(this);
            if (updateType === NodeUpdateType.FRAME) {
                const { frameMap } = this._getMaps(this.updateAfterMap, reference);
                if (frameMap.get(reference) !== this.frameId) {
                    if (node.updateAfter(this) !== false) {
                        frameMap.set(reference, this.frameId);
                    }
                }
            } else if (updateType === NodeUpdateType.RENDER) {
                const { renderMap } = this._getMaps(this.updateAfterMap, reference);
                if (renderMap.get(reference) !== this.renderId) {
                    if (node.updateAfter(this) !== false) {
                        renderMap.set(reference, this.renderId);
                    }
                }
            } else if (updateType === NodeUpdateType.OBJECT) {
                node.updateAfter(this);
            }
        }
        updateNode(node) {
            const updateType = node.getUpdateType();
            const reference = node.updateReference(this);
            if (updateType === NodeUpdateType.FRAME) {
                const { frameMap } = this._getMaps(this.updateMap, reference);
                if (frameMap.get(reference) !== this.frameId) {
                    if (node.update(this) !== false) {
                        frameMap.set(reference, this.frameId);
                    }
                }
            } else if (updateType === NodeUpdateType.RENDER) {
                const { renderMap } = this._getMaps(this.updateMap, reference);
                if (renderMap.get(reference) !== this.renderId) {
                    if (node.update(this) !== false) {
                        renderMap.set(reference, this.renderId);
                    }
                }
            } else if (updateType === NodeUpdateType.OBJECT) {
                node.update(this);
            }
        }
        update() {
            this.frameId++;
            if (this.lastTime === undefined) this.lastTime = performance.now();
            this.deltaTime = (performance.now() - this.lastTime) / 1000;
            this.lastTime = performance.now();
            this.time += this.deltaTime;
        }
    }
    class NodeFunctionInput {
        constructor(type, name, count = null, qualifier = '', isConst = false) {
            this.type = type;
            this.name = name;
            this.count = count;
            this.qualifier = qualifier;
            this.isConst = isConst;
        }
    }
    NodeFunctionInput.isNodeFunctionInput = true;
    class DirectionalLightNode extends AnalyticLightNode {
        static get type() {
            return 'DirectionalLightNode';
        }
        constructor(light = null) {
            super(light);
        }
        setupDirect() {
            const lightColor = this.colorNode;
            const lightDirection = lightTargetDirection(this.light);
            return { lightDirection, lightColor };
        }
    }
    const _matrix41 = /*@__PURE__*/ new Matrix4();
    const _matrix42 = /*@__PURE__*/ new Matrix4();
    let _ltcLib = null;
    class RectAreaLightNode extends AnalyticLightNode {
        static get type() {
            return 'RectAreaLightNode';
        }
        constructor(light = null) {
            super(light);
            this.halfHeight = uniform(new Vector3()).setGroup(renderGroup);
            this.halfWidth = uniform(new Vector3()).setGroup(renderGroup);
            this.updateType = NodeUpdateType.RENDER;
        }
        update(frame) {
            super.update(frame);
            const { light } = this;
            const viewMatrix = frame.camera.matrixWorldInverse;
            _matrix42.identity();
            _matrix41.copy(light.matrixWorld);
            _matrix41.premultiply(viewMatrix);
            _matrix42.extractRotation(_matrix41);
            this.halfWidth.value.set(light.width * 0.5, 0.0, 0.0);
            this.halfHeight.value.set(0.0, light.height * 0.5, 0.0);
            this.halfWidth.value.applyMatrix4(_matrix42);
            this.halfHeight.value.applyMatrix4(_matrix42);
        }
        setupDirectRectArea(builder) {
            let ltc_1, ltc_2;
            if (builder.isAvailable('float32Filterable')) {
                ltc_1 = texture(_ltcLib.LTC_FLOAT_1);
                ltc_2 = texture(_ltcLib.LTC_FLOAT_2);
            } else {
                ltc_1 = texture(_ltcLib.LTC_HALF_1);
                ltc_2 = texture(_ltcLib.LTC_HALF_2);
            }
            const { colorNode, light } = this;
            const lightPosition = lightViewPosition(light);
            return {
                lightColor: colorNode,
                lightPosition,
                halfWidth: this.halfWidth,
                halfHeight: this.halfHeight,
                ltc_1,
                ltc_2
            };
        }
        static setLTC(ltc) {
            _ltcLib = ltc;
        }
    }
    class SpotLightNode extends AnalyticLightNode {
        static get type() {
            return 'SpotLightNode';
        }
        constructor(light = null) {
            super(light);
            this.coneCosNode = uniform(0).setGroup(renderGroup);
            this.penumbraCosNode = uniform(0).setGroup(renderGroup);
            this.cutoffDistanceNode = uniform(0).setGroup(renderGroup);
            this.decayExponentNode = uniform(0).setGroup(renderGroup);
            this.colorNode = uniform(this.color).setGroup(renderGroup);
        }
        update(frame) {
            super.update(frame);
            const { light } = this;
            this.coneCosNode.value = Math.cos(light.angle);
            this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));
            this.cutoffDistanceNode.value = light.distance;
            this.decayExponentNode.value = light.decay;
        }
        getSpotAttenuation(builder, angleCosine) {
            const { coneCosNode, penumbraCosNode } = this;
            return smoothstep(coneCosNode, penumbraCosNode, angleCosine);
        }
        getLightCoord(builder) {
            const properties = builder.getNodeProperties(this);
            let projectionUV = properties.projectionUV;
            if (projectionUV === undefined) {
                projectionUV = lightProjectionUV(this.light, builder.context.positionWorld);
                properties.projectionUV = projectionUV;
            }
            return projectionUV;
        }
        setupDirect(builder) {
            const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
            const lightVector = this.getLightVector(builder);
            const lightDirection = lightVector.normalize();
            const angleCos = lightDirection.dot(lightTargetDirection(light));
            const spotAttenuation = this.getSpotAttenuation(builder, angleCos);
            const lightDistance = lightVector.length();
            const lightAttenuation = getDistanceAttenuation({
                lightDistance,
                cutoffDistance: cutoffDistanceNode,
                decayExponent: decayExponentNode
            });
            let lightColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);
            let projected, lightCoord;
            if (light.colorNode) {
                lightCoord = this.getLightCoord(builder);
                projected = light.colorNode(lightCoord);
            } else if (light.map) {
                lightCoord = this.getLightCoord(builder);
                projected = texture(light.map, lightCoord.xy).onRenderUpdate(() => light.map);
            }
            if (projected) {
                const inSpotLightMap = lightCoord.mul(2.).sub(1.).abs().lessThan(1.).all();
                lightColor = inSpotLightMap.select(lightColor.mul(projected), lightColor);
            }
            return { lightColor, lightDirection };
        }
    }
    class IESSpotLightNode extends SpotLightNode {
        static get type() {
            return 'IESSpotLightNode';
        }
        getSpotAttenuation(builder, angleCosine) {
            const iesMap = this.light.iesMap;
            let spotAttenuation = null;
            if (iesMap && iesMap.isTexture === true) {
                const angle = angleCosine.acos().mul(1.0 / Math.PI);
                spotAttenuation = texture(iesMap, vec2(angle, 0), 0).r;
            } else {
                spotAttenuation = super.getSpotAttenuation(angleCosine);
            }
            return spotAttenuation;
        }
    }
    const sdBox = /*@__PURE__*/ Fn(([p, b]) => {
        const d = p.abs().sub(b);
        return length(max$1(d, 0.0)).add(min$1(max$1(d.x, d.y), 0.0));
    });
    class ProjectorLightNode extends SpotLightNode {
        static get type() {
            return 'ProjectorLightNode';
        }
        update(frame) {
            super.update(frame);
            const light = this.light;
            this.penumbraCosNode.value = Math.min(Math.cos(light.angle * (1 - light.penumbra)), .99999);
            if (light.aspect === null) {
                let aspect = 1;
                if (light.map !== null) {
                    aspect = light.map.width / light.map.height;
                }
                light.shadow.aspect = aspect;
            } else {
                light.shadow.aspect = light.aspect;
            }
        }
        getSpotAttenuation(builder) {
            const attenuation = float(0);
            const penumbraCos = this.penumbraCosNode;
            // compute the fragment's position in the light's clip space
            const spotLightCoord = lightShadowMatrix(this.light).mul(builder.context.positionWorld || positionWorld);
            // the sign of w determines whether the current fragment is in front or behind the light.
            // to avoid a back-projection, it's important to only compute an attenuation if w is positive
            If(spotLightCoord.w.greaterThan(0), () => {
                const projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);
                const boxDist = sdBox(projectionUV.xy.sub(vec2(0.5)), vec2(0.5));
                const angleFactor = div(-1, sub(1.0, acos(penumbraCos)).sub(1.0));
                attenuation.assign(saturate(boxDist.mul(-2).mul(angleFactor)));
            });
            return attenuation;
        }
    }
    class AmbientLightNode extends AnalyticLightNode {
        static get type() {
            return 'AmbientLightNode';
        }
        constructor(light = null) {
            super(light);
        }
        setup({ context }) {
            context.irradiance.addAssign(this.colorNode);
        }
    }
    class HemisphereLightNode extends AnalyticLightNode {
        static get type() {
            return 'HemisphereLightNode';
        }
        constructor(light = null) {
            super(light);
            this.lightPositionNode = lightPosition(light);
            this.lightDirectionNode = this.lightPositionNode.normalize();
            this.groundColorNode = uniform(new Color()).setGroup(renderGroup);
        }
        update(frame) {
            const { light } = this;
            super.update(frame);
            this.lightPositionNode.object3d = light;
            this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);
        }
        setup(builder) {
            const { colorNode, groundColorNode, lightDirectionNode } = this;
            const dotNL = normalWorld.dot(lightDirectionNode);
            const hemiDiffuseWeight = dotNL.mul(0.5).add(0.5);
            const irradiance = mix(groundColorNode, colorNode, hemiDiffuseWeight);
            builder.context.irradiance.addAssign(irradiance);
        }
    }
    class LightProbeNode extends AnalyticLightNode {
        static get type() {
            return 'LightProbeNode';
        }
        constructor(light = null) {
            super(light);
            const array = [];
            for (let i = 0; i < 9; i++) array.push(new Vector3());
            this.lightProbe = uniformArray(array);
        }
        update(frame) {
            const { light } = this;
            super.update(frame);
            //
            for (let i = 0; i < 9; i++) {
                this.lightProbe.array[i].copy(light.sh.coefficients[i]).multiplyScalar(light.intensity);
            }
        }
        setup(builder) {
            const irradiance = getShIrradianceAt(normalWorld, this.lightProbe);
            builder.context.irradiance.addAssign(irradiance);
        }
    }
    class NodeParser {
        parseFunction( /*source*/) {
            console.warn('Abstract function.');
        }
    }
    class NodeFunction {
        constructor(type, inputs, name = '', precision = '') {
            this.type = type;
            this.inputs = inputs;
            this.name = name;
            this.precision = precision;
        }
        getCode( /*name = this.name*/) {
            console.warn('Abstract function.');
        }
    }
    NodeFunction.isNodeFunction = true;
    const declarationRegexp$1 = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
    const propertiesRegexp$1 = /[a-z_0-9]+/ig;
    const pragmaMain = '#pragma main';
    const parse$1 = (source) => {
        source = source.trim();
        const pragmaMainIndex = source.indexOf(pragmaMain);
        const mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;
        const declaration = mainCode.match(declarationRegexp$1);
        if (declaration !== null && declaration.length === 5) {
            // tokenizer
            const inputsCode = declaration[4];
            const propsMatches = [];
            let nameMatch = null;
            while ((nameMatch = propertiesRegexp$1.exec(inputsCode)) !== null) {
                propsMatches.push(nameMatch);
            }
            // parser
            const inputs = [];
            let i = 0;
            while (i < propsMatches.length) {
                const isConst = propsMatches[i][0] === 'const';
                if (isConst === true) {
                    i++;
                }
                let qualifier = propsMatches[i][0];
                if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {
                    i++;
                } else {
                    qualifier = '';
                }
                const type = propsMatches[i++][0];
                let count = Number.parseInt(propsMatches[i][0]);
                if (Number.isNaN(count) === false) i++;
                else count = null;
                const name = propsMatches[i++][0];
                inputs.push(new NodeFunctionInput(type, name, count, qualifier, isConst));
            }
            //
            const blockCode = mainCode.substring(declaration[0].length);
            const name = declaration[3] !== undefined ? declaration[3] : '';
            const type = declaration[2];
            const precision = declaration[1] !== undefined ? declaration[1] : '';
            const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : '';
            return {
                type,
                inputs,
                name,
                precision,
                inputsCode,
                blockCode,
                headerCode
            };
        } else {
            throw new Error('FunctionNode: Function is not a GLSL code.');
        }
    };
    class GLSLNodeFunction extends NodeFunction {
        constructor(source) {
            const { type, inputs, name, precision, inputsCode, blockCode, headerCode } = parse$1(source);
            super(type, inputs, name, precision);
            this.inputsCode = inputsCode;
            this.blockCode = blockCode;
            this.headerCode = headerCode;
        }
        getCode(name = this.name) {
            let code;
            const blockCode = this.blockCode;
            if (blockCode !== '') {
                const { type, inputsCode, headerCode, precision } = this;
                let declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;
                if (precision !== '') {
                    declarationCode = `${precision} ${declarationCode}`;
                }
                code = headerCode + declarationCode + blockCode;
            } else {
                // interface function
                code = '';
            }
            return code;
        }
    }
    class GLSLNodeParser extends NodeParser {
        parseFunction(source) {
            return new GLSLNodeFunction(source);
        }
    }
    const _outputNodeMap = new WeakMap();
    const _chainKeys$2 = [];
    const _cacheKeyValues = [];
    class Nodes extends DataMap {
        constructor(renderer, backend) {
            super();
            this.renderer = renderer;
            this.backend = backend;
            this.nodeFrame = new NodeFrame();
            this.nodeBuilderCache = new Map();
            this.callHashCache = new ChainMap();
            this.groupsData = new ChainMap();
            this.cacheLib = {};
        }
        updateGroup(nodeUniformsGroup) {
            const groupNode = nodeUniformsGroup.groupNode;
            const name = groupNode.name;
            // objectGroup is always updated
            if (name === objectGroup.name) return true;
            // renderGroup is updated once per render/compute call
            if (name === renderGroup.name) {
                const uniformsGroupData = this.get(nodeUniformsGroup);
                const renderId = this.nodeFrame.renderId;
                if (uniformsGroupData.renderId !== renderId) {
                    uniformsGroupData.renderId = renderId;
                    return true;
                }
                return false;
            }
            // frameGroup is updated once per frame
            if (name === frameGroup.name) {
                const uniformsGroupData = this.get(nodeUniformsGroup);
                const frameId = this.nodeFrame.frameId;
                if (uniformsGroupData.frameId !== frameId) {
                    uniformsGroupData.frameId = frameId;
                    return true;
                }
                return false;
            }
            // other groups are updated just when groupNode.needsUpdate is true
            _chainKeys$2[0] = groupNode;
            _chainKeys$2[1] = nodeUniformsGroup;
            let groupData = this.groupsData.get(_chainKeys$2);
            if (groupData === undefined) this.groupsData.set(_chainKeys$2, groupData = {});
            _chainKeys$2.length = 0;
            if (groupData.version !== groupNode.version) {
                groupData.version = groupNode.version;
                return true;
            }
            return false;
        }
        getForRenderCacheKey(renderObject) {
            return renderObject.initialCacheKey;
        }
        getForRender(renderObject) {
            const renderObjectData = this.get(renderObject);
            let nodeBuilderState = renderObjectData.nodeBuilderState;
            if (nodeBuilderState === undefined) {
                const { nodeBuilderCache } = this;
                const cacheKey = this.getForRenderCacheKey(renderObject);
                nodeBuilderState = nodeBuilderCache.get(cacheKey);
                if (nodeBuilderState === undefined) {
                    const nodeBuilder = this.backend.createNodeBuilder(renderObject.object, this.renderer);
                    nodeBuilder.scene = renderObject.scene;
                    nodeBuilder.material = renderObject.material;
                    nodeBuilder.camera = renderObject.camera;
                    nodeBuilder.context.material = renderObject.material;
                    nodeBuilder.lightsNode = renderObject.lightsNode;
                    nodeBuilder.environmentNode = this.getEnvironmentNode(renderObject.scene);
                    nodeBuilder.fogNode = this.getFogNode(renderObject.scene);
                    nodeBuilder.clippingContext = renderObject.clippingContext;
                    if (this.renderer.getOutputRenderTarget() ? this.renderer.getOutputRenderTarget().multiview : false) {
                        nodeBuilder.enableMultiview();
                    }
                    nodeBuilder.build();
                    nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
                    nodeBuilderCache.set(cacheKey, nodeBuilderState);
                }
                nodeBuilderState.usedTimes++;
                renderObjectData.nodeBuilderState = nodeBuilderState;
            }
            return nodeBuilderState;
        }
        delete(object) {
            if (object.isRenderObject) {
                const nodeBuilderState = this.get(object).nodeBuilderState;
                nodeBuilderState.usedTimes--;
                if (nodeBuilderState.usedTimes === 0) {
                    this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));
                }
            }
            return super.delete(object);
        }
        getForCompute(computeNode) {
            const computeData = this.get(computeNode);
            let nodeBuilderState = computeData.nodeBuilderState;
            if (nodeBuilderState === undefined) {
                const nodeBuilder = this.backend.createNodeBuilder(computeNode, this.renderer);
                nodeBuilder.build();
                nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
                computeData.nodeBuilderState = nodeBuilderState;
            }
            return nodeBuilderState;
        }
        _createNodeBuilderState(nodeBuilder) {
            return new NodeBuilderState(
                nodeBuilder.vertexShader,
                nodeBuilder.fragmentShader,
                nodeBuilder.computeShader,
                nodeBuilder.getAttributesArray(),
                nodeBuilder.getBindings(),
                nodeBuilder.updateNodes,
                nodeBuilder.updateBeforeNodes,
                nodeBuilder.updateAfterNodes,
                nodeBuilder.observer,
                nodeBuilder.transforms
            );
        }
        getEnvironmentNode(scene) {
            this.updateEnvironment(scene);
            let environmentNode = null;
            if (scene.environmentNode && scene.environmentNode.isNode) {
                environmentNode = scene.environmentNode;
            } else {
                const sceneData = this.get(scene);
                if (sceneData.environmentNode) {
                    environmentNode = sceneData.environmentNode;
                }
            }
            return environmentNode;
        }
        getBackgroundNode(scene) {
            this.updateBackground(scene);
            let backgroundNode = null;
            if (scene.backgroundNode && scene.backgroundNode.isNode) {
                backgroundNode = scene.backgroundNode;
            } else {
                const sceneData = this.get(scene);
                if (sceneData.backgroundNode) {
                    backgroundNode = sceneData.backgroundNode;
                }
            }
            return backgroundNode;
        }
        getFogNode(scene) {
            this.updateFog(scene);
            return scene.fogNode || this.get(scene).fogNode || null;
        }
        getCacheKey(scene, lightsNode) {
            _chainKeys$2[0] = scene;
            _chainKeys$2[1] = lightsNode;
            const callId = this.renderer.info.calls;
            const cacheKeyData = this.callHashCache.get(_chainKeys$2) || {};
            if (cacheKeyData.callId !== callId) {
                const environmentNode = this.getEnvironmentNode(scene);
                const fogNode = this.getFogNode(scene);
                if (lightsNode) _cacheKeyValues.push(lightsNode.getCacheKey(true));
                if (environmentNode) _cacheKeyValues.push(environmentNode.getCacheKey());
                if (fogNode) _cacheKeyValues.push(fogNode.getCacheKey());
                _cacheKeyValues.push(this.renderer.getOutputRenderTarget() && this.renderer.getOutputRenderTarget().multiview ? 1 : 0);
                _cacheKeyValues.push(this.renderer.shadowMap.enabled ? 1 : 0);
                cacheKeyData.callId = callId;
                cacheKeyData.cacheKey = hashArray(_cacheKeyValues);
                this.callHashCache.set(_chainKeys$2, cacheKeyData);
                _cacheKeyValues.length = 0;
            }
            _chainKeys$2.length = 0;
            return cacheKeyData.cacheKey;
        }
        get isToneMappingState() {
            return this.renderer.getRenderTarget() ? false : true;
        }
        updateBackground(scene) {
            const sceneData = this.get(scene);
            const background = scene.background;
            if (background) {
                const forceUpdate = (scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0) || (scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0);
                if (sceneData.background !== background || forceUpdate) {
                    const backgroundNode = this.getCacheNode('background', background, () => {
                        if (background.isCubeTexture === true || (background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping)) {
                            if (scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping) {
                                return pmremTexture(background);
                            } else {
                                let envMap;
                                if (background.isCubeTexture === true) {
                                    envMap = cubeTexture(background);
                                } else {
                                    envMap = texture(background);
                                }
                                return cubeMapNode(envMap);
                            }
                        } else if (background.isTexture === true) {
                            return texture(background, screenUV.flipY()).setUpdateMatrix(true);
                        } else if (background.isColor !== true) {
                            console.error('WebGPUNodes: Unsupported background configuration.', background);
                        }
                    }, forceUpdate);
                    sceneData.backgroundNode = backgroundNode;
                    sceneData.background = background;
                    sceneData.backgroundBlurriness = scene.backgroundBlurriness;
                }
            } else if (sceneData.backgroundNode) {
                delete sceneData.backgroundNode;
                delete sceneData.background;
            }
        }
        getCacheNode(type, object, callback, forceUpdate = false) {
            const nodeCache = this.cacheLib[type] || (this.cacheLib[type] = new WeakMap());
            let node = nodeCache.get(object);
            if (node === undefined || forceUpdate) {
                node = callback();
                nodeCache.set(object, node);
            }
            return node;
        }
        updateFog(scene) {
            const sceneData = this.get(scene);
            const sceneFog = scene.fog;
            if (sceneFog) {
                if (sceneData.fog !== sceneFog) {
                    const fogNode = this.getCacheNode('fog', sceneFog, () => {
                        if (sceneFog.isFogExp2) {
                            const color = reference('color', 'color', sceneFog).setGroup(renderGroup);
                            const density = reference('density', 'float', sceneFog).setGroup(renderGroup);
                            return fog(color, densityFogFactor(density));
                        } else if (sceneFog.isFog) {
                            const color = reference('color', 'color', sceneFog).setGroup(renderGroup);
                            const near = reference('near', 'float', sceneFog).setGroup(renderGroup);
                            const far = reference('far', 'float', sceneFog).setGroup(renderGroup);
                            return fog(color, rangeFogFactor(near, far));
                        } else {
                            console.error('THREE.Renderer: Unsupported fog configuration.', sceneFog);
                        }
                    });
                    sceneData.fogNode = fogNode;
                    sceneData.fog = sceneFog;
                }
            } else {
                delete sceneData.fogNode;
                delete sceneData.fog;
            }
        }
        updateEnvironment(scene) {
            const sceneData = this.get(scene);
            const environment = scene.environment;
            if (environment) {
                if (sceneData.environment !== environment) {
                    const environmentNode = this.getCacheNode('environment', environment, () => {
                        if (environment.isCubeTexture === true) {
                            return cubeTexture(environment);
                        } else if (environment.isTexture === true) {
                            return texture(environment);
                        } else {
                            console.error('Nodes: Unsupported environment configuration.', environment);
                        }
                    });
                    sceneData.environmentNode = environmentNode;
                    sceneData.environment = environment;
                }
            } else if (sceneData.environmentNode) {
                delete sceneData.environmentNode;
                delete sceneData.environment;
            }
        }
        getNodeFrame(renderer = this.renderer, scene = null, object = null, camera = null, material = null) {
            const nodeFrame = this.nodeFrame;
            nodeFrame.renderer = renderer;
            nodeFrame.scene = scene;
            nodeFrame.object = object;
            nodeFrame.camera = camera;
            nodeFrame.material = material;
            return nodeFrame;
        }
        getNodeFrameForRender(renderObject) {
            return this.getNodeFrame(renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material);
        }
        getOutputCacheKey() {
            const renderer = this.renderer;
            return renderer.toneMapping + ',' + renderer.currentColorSpace + ',' + renderer.xr.isPresenting;
        }
        hasOutputChange(outputTarget) {
            const cacheKey = _outputNodeMap.get(outputTarget);
            return cacheKey !== this.getOutputCacheKey();
        }
        getOutputNode(outputTarget) {
            const renderer = this.renderer;
            const cacheKey = this.getOutputCacheKey();
            const output = outputTarget.isArrayTexture ?
                texture3D(outputTarget, vec3(screenUV, builtin('gl_ViewID_OVR'))).renderOutput(renderer.toneMapping, renderer.currentColorSpace) :
                texture(outputTarget, screenUV).renderOutput(renderer.toneMapping, renderer.currentColorSpace);
            _outputNodeMap.set(outputTarget, cacheKey);
            return output;
        }
        updateBefore(renderObject) {
            const nodeBuilder = renderObject.getNodeBuilderState();
            for (const node of nodeBuilder.updateBeforeNodes) {
                // update frame state for each node
                this.getNodeFrameForRender(renderObject).updateBeforeNode(node);
            }
        }
        updateAfter(renderObject) {
            const nodeBuilder = renderObject.getNodeBuilderState();
            for (const node of nodeBuilder.updateAfterNodes) {
                // update frame state for each node
                this.getNodeFrameForRender(renderObject).updateAfterNode(node);
            }
        }
        updateForCompute(computeNode) {
            const nodeFrame = this.getNodeFrame();
            const nodeBuilder = this.getForCompute(computeNode);
            for (const node of nodeBuilder.updateNodes) {
                nodeFrame.updateNode(node);
            }
        }
        updateForRender(renderObject) {
            const nodeFrame = this.getNodeFrameForRender(renderObject);
            const nodeBuilder = renderObject.getNodeBuilderState();
            for (const node of nodeBuilder.updateNodes) {
                nodeFrame.updateNode(node);
            }
        }
        needsRefresh(renderObject) {
            const nodeFrame = this.getNodeFrameForRender(renderObject);
            const monitor = renderObject.getMonitor();
            return monitor.needsRefresh(renderObject, nodeFrame);
        }
        dispose() {
            super.dispose();
            this.nodeFrame = new NodeFrame();
            this.nodeBuilderCache = new Map();
            this.cacheLib = {};
        }
    }
    const _plane = /*@__PURE__*/ new Plane();
    class ClippingContext {
        constructor(parentContext = null) {
            this.version = 0;
            this.clipIntersection = null;
            this.cacheKey = '';
            this.shadowPass = false;
            this.viewNormalMatrix = new Matrix3();
            this.clippingGroupContexts = new WeakMap();
            this.intersectionPlanes = [];
            this.unionPlanes = [];
            this.parentVersion = null;
            if (parentContext !== null) {
                this.viewNormalMatrix = parentContext.viewNormalMatrix;
                this.clippingGroupContexts = parentContext.clippingGroupContexts;
                this.shadowPass = parentContext.shadowPass;
                this.viewMatrix = parentContext.viewMatrix;
            }
        }
        projectPlanes(source, destination, offset) {
            const l = source.length;
            for (let i = 0; i < l; i++) {
                _plane.copy(source[i]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
                const v = destination[offset + i];
                const normal = _plane.normal;
                v.x = - normal.x;
                v.y = - normal.y;
                v.z = - normal.z;
                v.w = _plane.constant;
            }
        }
        updateGlobal(scene, camera) {
            this.shadowPass = (scene.overrideMaterial !== null && scene.overrideMaterial.isShadowPassMaterial);
            this.viewMatrix = camera.matrixWorldInverse;
            this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
        }
        update(parentContext, clippingGroup) {
            let update = false;
            if (parentContext.version !== this.parentVersion) {
                this.intersectionPlanes = Array.from(parentContext.intersectionPlanes);
                this.unionPlanes = Array.from(parentContext.unionPlanes);
                this.parentVersion = parentContext.version;
            }
            if (this.clipIntersection !== clippingGroup.clipIntersection) {
                this.clipIntersection = clippingGroup.clipIntersection;
                if (this.clipIntersection) {
                    this.unionPlanes.length = parentContext.unionPlanes.length;
                } else {
                    this.intersectionPlanes.length = parentContext.intersectionPlanes.length;
                }
            }
            const srcClippingPlanes = clippingGroup.clippingPlanes;
            const l = srcClippingPlanes.length;
            let dstClippingPlanes;
            let offset;
            if (this.clipIntersection) {
                dstClippingPlanes = this.intersectionPlanes;
                offset = parentContext.intersectionPlanes.length;
            } else {
                dstClippingPlanes = this.unionPlanes;
                offset = parentContext.unionPlanes.length;
            }
            if (dstClippingPlanes.length !== offset + l) {
                dstClippingPlanes.length = offset + l;
                for (let i = 0; i < l; i++) {
                    dstClippingPlanes[offset + i] = new Vector4();
                }
                update = true;
            }
            this.projectPlanes(srcClippingPlanes, dstClippingPlanes, offset);
            if (update) {
                this.version++;
                this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`;
            }
        }
        getGroupContext(clippingGroup) {
            if (this.shadowPass && !clippingGroup.clipShadows) return this;
            let context = this.clippingGroupContexts.get(clippingGroup);
            if (context === undefined) {
                context = new ClippingContext(this);
                this.clippingGroupContexts.set(clippingGroup, context);
            }
            context.update(this, clippingGroup);
            return context;
        }
        get unionClippingCount() {
            return this.unionPlanes.length;
        }
    }
    class RenderBundle {
        constructor(bundleGroup, camera) {
            this.bundleGroup = bundleGroup;
            this.camera = camera;
        }
    }
    const _chainKeys$1 = [];
    class RenderBundles {
        constructor() {
            this.bundles = new ChainMap();
        }
        get(bundleGroup, camera) {
            const bundles = this.bundles;
            _chainKeys$1[0] = bundleGroup;
            _chainKeys$1[1] = camera;
            let bundle = bundles.get(_chainKeys$1);
            if (bundle === undefined) {
                bundle = new RenderBundle(bundleGroup, camera);
                bundles.set(_chainKeys$1, bundle);
            }
            _chainKeys$1.length = 0;
            return bundle;
        }
        dispose() {
            this.bundles = new ChainMap();
        }
    }
    class NodeLibrary {
        constructor() {
            this.lightNodes = new WeakMap();
            this.materialNodes = new Map();
            this.toneMappingNodes = new Map();
        }
        fromMaterial(material) {
            if (material.isNodeMaterial) return material;
            let nodeMaterial = null;
            const nodeMaterialClass = this.getMaterialNodeClass(material.type);
            if (nodeMaterialClass !== null) {
                nodeMaterial = new nodeMaterialClass();
                for (const key in material) {
                    nodeMaterial[key] = material[key];
                }
            }
            return nodeMaterial;
        }
        addToneMapping(toneMappingNode, toneMapping) {
            this.addType(toneMappingNode, toneMapping, this.toneMappingNodes);
        }
        getToneMappingFunction(toneMapping) {
            return this.toneMappingNodes.get(toneMapping) || null;
        }
        getMaterialNodeClass(materialType) {
            return this.materialNodes.get(materialType) || null;
        }
        addMaterial(materialNodeClass, materialClassType) {
            this.addType(materialNodeClass, materialClassType, this.materialNodes);
        }
        getLightNodeClass(light) {
            return this.lightNodes.get(light) || null;
        }
        addLight(lightNodeClass, lightClass) {
            this.addClass(lightNodeClass, lightClass, this.lightNodes);
        }
        addType(nodeClass, type, library) {
            if (library.has(type)) {
                console.warn(`Redefinition of node ${type}`);
                return;
            }
            if (typeof nodeClass !== 'function') throw new Error(`Node class ${nodeClass.name} is not a class.`);
            if (typeof type === 'function' || typeof type === 'object') throw new Error(`Base class ${type} is not a class.`);
            library.set(type, nodeClass);
        }
        addClass(nodeClass, baseClass, library) {
            if (library.has(baseClass)) {
                console.warn(`Redefinition of node ${baseClass.name}`);
                return;
            }
            if (typeof nodeClass !== 'function') throw new Error(`Node class ${nodeClass.name} is not a class.`);
            if (typeof baseClass !== 'function') throw new Error(`Base class ${baseClass.name} is not a class.`);
            library.set(baseClass, nodeClass);
        }
    }
    const _defaultLights = /*@__PURE__*/ new LightsNode();
    const _chainKeys = [];
    class Lighting extends ChainMap {
        constructor() {
            super();
        }
        createNode(lights = []) {
            return new LightsNode().setLights(lights);
        }
        getNode(scene, camera) {
            // ignore post-processing
            if (scene.isQuadMesh) return _defaultLights;
            _chainKeys[0] = scene;
            _chainKeys[1] = camera;
            let node = this.get(_chainKeys);
            if (node === undefined) {
                node = this.createNode();
                this.set(_chainKeys, node);
            }
            _chainKeys.length = 0;
            return node;
        }
    }
    class XRRenderTarget extends RenderTarget {
        constructor(width = 1, height = 1, options = {}) {
            super(width, height, options);
            this.isXRRenderTarget = true;
            this._hasExternalTextures = false;
            this._autoAllocateDepthBuffer = true;
            this._isOpaqueFramebuffer = false;
        }
        copy(source) {
            super.copy(source);
            this._hasExternalTextures = source._hasExternalTextures;
            this._autoAllocateDepthBuffer = source._autoAllocateDepthBuffer;
            this._isOpaqueFramebuffer = source._isOpaqueFramebuffer;
            return this;
        }

    }
    const _cameraLPos = /*@__PURE__*/ new Vector3();
    const _cameraRPos = /*@__PURE__*/ new Vector3();
    class XRManager extends EventDispatcher {
        constructor(renderer, multiview = false) {
            super();
            this.enabled = false;
            this.isPresenting = false;
            this.cameraAutoUpdate = true;
            this._renderer = renderer;
            // camera
            this._cameraL = new PerspectiveCamera();
            this._cameraL.viewport = new Vector4();
            this._cameraR = new PerspectiveCamera();
            this._cameraR.viewport = new Vector4();
            this._cameras = [this._cameraL, this._cameraR];
            this._cameraXR = new ArrayCamera();
            this._currentDepthNear = null;
            this._currentDepthFar = null;
            this._controllers = [];
            this._controllerInputSources = [];
            this._xrRenderTarget = null;
            this._layers = [];
            this._supportsLayers = false;
            this._supportsGlBinding = typeof XRWebGLBinding !== 'undefined';
            this._frameBufferTargets = null;
            this._createXRLayer = createXRLayer.bind(this);
            this._gl = null;
            this._currentAnimationContext = null;
            this._currentAnimationLoop = null;
            this._currentPixelRatio = null;
            this._currentSize = new Vector2();
            this._onSessionEvent = onSessionEvent.bind(this);
            this._onSessionEnd = onSessionEnd.bind(this);
            this._onInputSourcesChange = onInputSourcesChange.bind(this);
            this._onAnimationFrame = onAnimationFrame.bind(this);
            this._referenceSpace = null;
            this._referenceSpaceType = 'local-floor';
            this._customReferenceSpace = null;
            this._framebufferScaleFactor = 1;
            this._foveation = 1.0;
            this._session = null;
            this._glBaseLayer = null;
            this._glBinding = null;
            this._glProjLayer = null;
            this._xrFrame = null;
            this._useLayers = (this._supportsGlBinding && 'createProjectionLayer' in XRWebGLBinding.prototype); // eslint-disable-line compat/compat
            this._useMultiviewIfPossible = multiview;
            this._useMultiview = false;
        }
        getController(index) {
            const controller = this._getController(index);
            return controller.getTargetRaySpace();
        }
        getControllerGrip(index) {
            const controller = this._getController(index);
            return controller.getGripSpace();
        }
        getHand(index) {
            const controller = this._getController(index);
            return controller.getHandSpace();
        }
        getFoveation() {
            if (this._glProjLayer === null && this._glBaseLayer === null) {
                return undefined;
            }
            return this._foveation;
        }
        setFoveation(foveation) {
            this._foveation = foveation;
            if (this._glProjLayer !== null) {
                this._glProjLayer.fixedFoveation = foveation;
            }
            if (this._glBaseLayer !== null && this._glBaseLayer.fixedFoveation !== undefined) {
                this._glBaseLayer.fixedFoveation = foveation;
            }
        }
        getFramebufferScaleFactor() {
            return this._framebufferScaleFactor;
        }
        setFramebufferScaleFactor(factor) {
            this._framebufferScaleFactor = factor;
            if (this.isPresenting === true) {
                console.warn('THREE.XRManager: Cannot change framebuffer scale while presenting.');
            }
        }
        getReferenceSpaceType() {
            return this._referenceSpaceType;
        }
        setReferenceSpaceType(type) {
            this._referenceSpaceType = type;
            if (this.isPresenting === true) {
                console.warn('THREE.XRManager: Cannot change reference space type while presenting.');
            }
        }
        getReferenceSpace() {
            return this._customReferenceSpace || this._referenceSpace;
        }
        setReferenceSpace(space) {
            this._customReferenceSpace = space;
        }
        getCamera() {
            return this._cameraXR;
        }
        getEnvironmentBlendMode() {
            if (this._session !== null) {
                return this._session.environmentBlendMode;
            }
        }
        getFrame() {
            return this._xrFrame;
        }
        useMultiview() {
            return this._useMultiview;
        }
        createQuadLayer(width, height, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = {}) {
            const geometry = new PlaneGeometry(width, height);
            const renderTarget = new XRRenderTarget(
                pixelwidth,
                pixelheight,
                {
                    format: RGBAFormat,
                    type: UnsignedByteType,
                    depthTexture: new DepthTexture(
                        pixelwidth,
                        pixelheight,
                        attributes.stencil ? UnsignedInt248Type : UnsignedIntType,
                        undefined,
                        undefined,
                        undefined,
                        undefined,
                        undefined,
                        undefined,
                        attributes.stencil ? DepthStencilFormat : DepthFormat
                    ),
                    stencilBuffer: attributes.stencil,
                    resolveDepthBuffer: false,
                    resolveStencilBuffer: false
                });
            renderTarget._autoAllocateDepthBuffer = true;
            const material = new MeshBasicMaterial({ color: 0xffffff, side: FrontSide });
            material.map = renderTarget.texture;
            material.map.offset.y = 1;
            material.map.repeat.y = -1;
            const plane = new Mesh(geometry, material);
            plane.position.copy(translation);
            plane.quaternion.copy(quaternion);
            const layer = {
                type: 'quad',
                width: width,
                height: height,
                translation: translation,
                quaternion: quaternion,
                pixelwidth: pixelwidth,
                pixelheight: pixelheight,
                plane: plane,
                material: material,
                rendercall: rendercall,
                renderTarget: renderTarget
            };
            this._layers.push(layer);
            if (this._session !== null) {
                layer.plane.material = new MeshBasicMaterial({ color: 0xffffff, side: FrontSide });
                layer.plane.material.blending = CustomBlending;
                layer.plane.material.blendEquation = AddEquation;
                layer.plane.material.blendSrc = ZeroFactor;
                layer.plane.material.blendDst = ZeroFactor;
                layer.xrlayer = this._createXRLayer(layer);
                const xrlayers = this._session.renderState.layers;
                xrlayers.unshift(layer.xrlayer);
                this._session.updateRenderState({ layers: xrlayers });
            } else {
                renderTarget.isXRRenderTarget = false;
            }
            return plane;
        }
        createCylinderLayer(radius, centralAngle, aspectratio, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = {}) {
            const geometry = new CylinderGeometry(radius, radius, radius * centralAngle / aspectratio, 64, 64, true, Math.PI - centralAngle / 2, centralAngle);
            const renderTarget = new XRRenderTarget(
                pixelwidth,
                pixelheight,
                {
                    format: RGBAFormat,
                    type: UnsignedByteType,
                    depthTexture: new DepthTexture(
                        pixelwidth,
                        pixelheight,
                        attributes.stencil ? UnsignedInt248Type : UnsignedIntType,
                        undefined,
                        undefined,
                        undefined,
                        undefined,
                        undefined,
                        undefined,
                        attributes.stencil ? DepthStencilFormat : DepthFormat
                    ),
                    stencilBuffer: attributes.stencil,
                    resolveDepthBuffer: false,
                    resolveStencilBuffer: false
                });
            renderTarget._autoAllocateDepthBuffer = true;
            const material = new MeshBasicMaterial({ color: 0xffffff, side: BackSide });
            material.map = renderTarget.texture;
            material.map.offset.y = 1;
            material.map.repeat.y = -1;
            const plane = new Mesh(geometry, material);
            plane.position.copy(translation);
            plane.quaternion.copy(quaternion);
            const layer = {
                type: 'cylinder',
                radius: radius,
                centralAngle: centralAngle,
                aspectratio: aspectratio,
                translation: translation,
                quaternion: quaternion,
                pixelwidth: pixelwidth,
                pixelheight: pixelheight,
                plane: plane,
                material: material,
                rendercall: rendercall,
                renderTarget: renderTarget
            };
            this._layers.push(layer);
            if (this._session !== null) {
                layer.plane.material = new MeshBasicMaterial({ color: 0xffffff, side: BackSide });
                layer.plane.material.blending = CustomBlending;
                layer.plane.material.blendEquation = AddEquation;
                layer.plane.material.blendSrc = ZeroFactor;
                layer.plane.material.blendDst = ZeroFactor;
                layer.xrlayer = this._createXRLayer(layer);
                const xrlayers = this._session.renderState.layers;
                xrlayers.unshift(layer.xrlayer);
                this._session.updateRenderState({ layers: xrlayers });
            } else {
                renderTarget.isXRRenderTarget = false;
            }
            return plane;
        }
        renderLayers() {
            const translationObject = new Vector3();
            const quaternionObject = new Quaternion();
            const renderer = this._renderer;
            const wasPresenting = this.isPresenting;
            const rendererOutputTarget = renderer.getOutputRenderTarget();
            const rendererFramebufferTarget = renderer._frameBufferTarget;
            this.isPresenting = false;
            const rendererSize = new Vector2();
            renderer.getSize(rendererSize);
            const rendererQuad = renderer._quad;
            for (const layer of this._layers) {
                layer.renderTarget.isXRRenderTarget = this._session !== null;
                layer.renderTarget._hasExternalTextures = layer.renderTarget.isXRRenderTarget;
                if (layer.renderTarget.isXRRenderTarget && this._supportsLayers) {
                    layer.xrlayer.transform = new XRRigidTransform(layer.plane.getWorldPosition(translationObject), layer.plane.getWorldQuaternion(quaternionObject));
                    const glSubImage = this._glBinding.getSubImage(layer.xrlayer, this._xrFrame);
                    renderer.backend.setXRRenderTargetTextures(
                        layer.renderTarget,
                        glSubImage.colorTexture,
                        undefined);
                    renderer._setXRLayerSize(layer.renderTarget.width, layer.renderTarget.height);
                    renderer.setOutputRenderTarget(layer.renderTarget);
                    renderer.setRenderTarget(null);
                    renderer._frameBufferTarget = null;
                    this._frameBufferTargets || (this._frameBufferTargets = new WeakMap());
                    const { frameBufferTarget, quad } = this._frameBufferTargets.get(layer.renderTarget) || { frameBufferTarget: null, quad: null };
                    if (!frameBufferTarget) {
                        renderer._quad = new QuadMesh(new NodeMaterial());
                        this._frameBufferTargets.set(layer.renderTarget, { frameBufferTarget: renderer._getFrameBufferTarget(), quad: renderer._quad });
                    } else {
                        renderer._frameBufferTarget = frameBufferTarget;
                        renderer._quad = quad;
                    }
                    layer.rendercall();
                    renderer._frameBufferTarget = null;
                } else {
                    renderer.setRenderTarget(layer.renderTarget);
                    layer.rendercall();
                }
            }
            renderer.setRenderTarget(null);
            renderer.setOutputRenderTarget(rendererOutputTarget);
            renderer._frameBufferTarget = rendererFramebufferTarget;
            renderer._setXRLayerSize(rendererSize.x, rendererSize.y);
            renderer._quad = rendererQuad;
            this.isPresenting = wasPresenting;
        }

        getSession() {
            return this._session;
        }
        async setSession(session) {
            const renderer = this._renderer;
            const backend = renderer.backend;
            this._gl = renderer.getContext();
            const gl = this._gl;
            const attributes = gl.getContextAttributes();
            this._session = session;
            if (session !== null) {
                if (backend.isWebGPUBackend === true) throw new Error('THREE.XRManager: XR is currently not supported with a WebGPU backend. Use WebGL by passing "{ forceWebGL: true }" to the constructor of the renderer.');
                session.addEventListener('select', this._onSessionEvent);
                session.addEventListener('selectstart', this._onSessionEvent);
                session.addEventListener('selectend', this._onSessionEvent);
                session.addEventListener('squeeze', this._onSessionEvent);
                session.addEventListener('squeezestart', this._onSessionEvent);
                session.addEventListener('squeezeend', this._onSessionEvent);
                session.addEventListener('end', this._onSessionEnd);
                session.addEventListener('inputsourceschange', this._onInputSourcesChange);
                await backend.makeXRCompatible();
                this._currentPixelRatio = renderer.getPixelRatio();
                renderer.getSize(this._currentSize);
                this._currentAnimationContext = renderer._animation.getContext();
                this._currentAnimationLoop = renderer._animation.getAnimationLoop();
                renderer._animation.stop();
                //
                if (this._supportsGlBinding) {
                    const glBinding = new XRWebGLBinding(session, gl);
                    this._glBinding = glBinding;
                }
                //
                if (this._useLayers === true) {
                    // default path using XRProjectionLayer
                    let depthFormat = null;
                    let depthType = null;
                    let glDepthFormat = null;
                    if (renderer.depth) {
                        glDepthFormat = renderer.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
                        depthFormat = renderer.stencil ? DepthStencilFormat : DepthFormat;
                        depthType = renderer.stencil ? UnsignedInt248Type : UnsignedIntType;
                    }
                    const projectionlayerInit = {
                        colorFormat: gl.RGBA8,
                        depthFormat: glDepthFormat,
                        scaleFactor: this._framebufferScaleFactor,
                        clearOnAccess: false
                    };
                    if (this._useMultiviewIfPossible && renderer.hasFeature('OVR_multiview2')) {
                        projectionlayerInit.textureType = 'texture-array';
                        this._useMultiview = true;
                    }
                    const glProjLayer = this._glBinding.createProjectionLayer(projectionlayerInit);
                    const layersArray = [glProjLayer];
                    this._glProjLayer = glProjLayer;
                    renderer.setPixelRatio(1);
                    renderer._setXRLayerSize(glProjLayer.textureWidth, glProjLayer.textureHeight);
                    const depth = this._useMultiview ? 2 : 1;
                    const depthTexture = new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat, depth);
                    this._xrRenderTarget = new XRRenderTarget(
                        glProjLayer.textureWidth,
                        glProjLayer.textureHeight,
                        {
                            format: RGBAFormat,
                            type: UnsignedByteType,
                            colorSpace: renderer.outputColorSpace,
                            depthTexture: depthTexture,
                            stencilBuffer: renderer.stencil,
                            samples: attributes.antialias ? 4 : 0,
                            resolveDepthBuffer: (glProjLayer.ignoreDepthValues === false),
                            resolveStencilBuffer: (glProjLayer.ignoreDepthValues === false),
                            depth: this._useMultiview ? 2 : 1,
                            multiview: this._useMultiview
                        });
                    this._xrRenderTarget._hasExternalTextures = true;
                    this._xrRenderTarget.depth = this._useMultiview ? 2 : 1;
                    this._supportsLayers = session.enabledFeatures.includes('layers');
                    this._referenceSpace = await session.requestReferenceSpace(this.getReferenceSpaceType());
                    if (this._supportsLayers) {
                        // switch layers to native
                        for (const layer of this._layers) {
                            // change material so it "punches" out a hole to show the XR Layer.
                            layer.plane.material = new MeshBasicMaterial({ color: 0xffffff, side: layer.type === 'cylinder' ? BackSide : FrontSide });
                            layer.plane.material.blending = CustomBlending;
                            layer.plane.material.blendEquation = AddEquation;
                            layer.plane.material.blendSrc = ZeroFactor;
                            layer.plane.material.blendDst = ZeroFactor;
                            layer.xrlayer = this._createXRLayer(layer);
                            layersArray.unshift(layer.xrlayer);
                        }
                    }
                    session.updateRenderState({ layers: layersArray });
                } else {
                    // fallback to XRWebGLLayer
                    const layerInit = {
                        antialias: renderer.samples > 0,
                        alpha: true,
                        depth: renderer.depth,
                        stencil: renderer.stencil,
                        framebufferScaleFactor: this.getFramebufferScaleFactor()
                    };
                    const glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                    this._glBaseLayer = glBaseLayer;
                    session.updateRenderState({ baseLayer: glBaseLayer });
                    renderer.setPixelRatio(1);
                    renderer._setXRLayerSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight);
                    this._xrRenderTarget = new XRRenderTarget(
                        glBaseLayer.framebufferWidth,
                        glBaseLayer.framebufferHeight,
                        {
                            format: RGBAFormat,
                            type: UnsignedByteType,
                            colorSpace: renderer.outputColorSpace,
                            stencilBuffer: renderer.stencil,
                            resolveDepthBuffer: (glBaseLayer.ignoreDepthValues === false),
                            resolveStencilBuffer: (glBaseLayer.ignoreDepthValues === false),
                        }
                    );
                    this._xrRenderTarget._isOpaqueFramebuffer = true;
                    this._referenceSpace = await session.requestReferenceSpace(this.getReferenceSpaceType());
                }
                //
                this.setFoveation(this.getFoveation());
                renderer._animation.setAnimationLoop(this._onAnimationFrame);
                renderer._animation.setContext(session);
                renderer._animation.start();
                this.isPresenting = true;
                this.dispatchEvent({ type: 'sessionstart' });
            }
        }
        updateCamera(camera) {
            const session = this._session;
            if (session === null) return;
            const depthNear = camera.near;
            const depthFar = camera.far;
            const cameraXR = this._cameraXR;
            const cameraL = this._cameraL;
            const cameraR = this._cameraR;
            cameraXR.near = cameraR.near = cameraL.near = depthNear;
            cameraXR.far = cameraR.far = cameraL.far = depthFar;
            cameraXR.isMultiViewCamera = this._useMultiview;
            if (this._currentDepthNear !== cameraXR.near || this._currentDepthFar !== cameraXR.far) {
                // Note that the new renderState won't apply until the next frame. See #18320
                session.updateRenderState({
                    depthNear: cameraXR.near,
                    depthFar: cameraXR.far
                });
                this._currentDepthNear = cameraXR.near;
                this._currentDepthFar = cameraXR.far;
            }
            // inherit camera layers and enable eye layers (1 = left, 2 = right)
            cameraXR.layers.mask = camera.layers.mask | 0b110;
            cameraL.layers.mask = cameraXR.layers.mask & 0b011;
            cameraR.layers.mask = cameraXR.layers.mask & 0b101;

            const parent = camera.parent;
            const cameras = cameraXR.cameras;
            updateCamera(cameraXR, parent);
            for (let i = 0; i < cameras.length; i++) {
                updateCamera(cameras[i], parent);
            }
            // update projection matrix for proper view frustum culling
            if (cameras.length === 2) {
                setProjectionFromUnion(cameraXR, cameraL, cameraR);
            } else {
                // assume single camera setup (AR)
                cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
            }
            // update user camera and its children
            updateUserCamera(camera, cameraXR, parent);

        }
        _getController(index) {
            let controller = this._controllers[index];
            if (controller === undefined) {
                controller = new WebXRController();
                this._controllers[index] = controller;
            }
            return controller;
        }
    }
    function setProjectionFromUnion(camera, cameraL, cameraR) {
        _cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
        _cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
        const ipd = _cameraLPos.distanceTo(_cameraRPos);
        const projL = cameraL.projectionMatrix.elements;
        const projR = cameraR.projectionMatrix.elements;
        // VR systems will have identical far and near planes, and
        // most likely identical top and bottom frustum extents.
        // Use the left camera for these values.
        const near = projL[14] / (projL[10] - 1);
        const far = projL[14] / (projL[10] + 1);
        const topFov = (projL[9] + 1) / projL[5];
        const bottomFov = (projL[9] - 1) / projL[5];
        const leftFov = (projL[8] - 1) / projL[0];
        const rightFov = (projR[8] + 1) / projR[0];
        const left = near * leftFov;
        const right = near * rightFov;
        // Calculate the new camera's position offset from the
        // left camera. xOffset should be roughly half `ipd`.
        const zOffset = ipd / (- leftFov + rightFov);
        const xOffset = zOffset * - leftFov;
        // TODO: Better way to apply this offset?
        cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
        camera.translateX(xOffset);
        camera.translateZ(zOffset);
        camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
        // Check if the projection uses an infinite far plane.
        if (projL[10] === -1) {
            // Use the projection matrix from the left eye.
            // The camera offset is sufficient to include the view volumes
            // of both eyes (assuming symmetric projections).
            camera.projectionMatrix.copy(cameraL.projectionMatrix);
            camera.projectionMatrixInverse.copy(cameraL.projectionMatrixInverse);
        } else {
            // Find the union of the frustum values of the cameras and scale
            // the values so that the near plane's position does not change in world space,
            // although must now be relative to the new union camera.
            const near2 = near + zOffset;
            const far2 = far + zOffset;
            const left2 = left - xOffset;
            const right2 = right + (ipd - xOffset);
            const top2 = topFov * far / far2 * near2;
            const bottom2 = bottomFov * far / far2 * near2;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
            camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
        }
    }
    function updateCamera(camera, parent) {
        if (parent === null) {
            camera.matrixWorld.copy(camera.matrix);
        } else {
            camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
        }
        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    function updateUserCamera(camera, cameraXR, parent) {
        if (parent === null) {
            camera.matrix.copy(cameraXR.matrixWorld);
        } else {
            camera.matrix.copy(parent.matrixWorld);
            camera.matrix.invert();
            camera.matrix.multiply(cameraXR.matrixWorld);
        }
        camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
        camera.updateMatrixWorld(true);
        camera.projectionMatrix.copy(cameraXR.projectionMatrix);
        camera.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse);
        if (camera.isPerspectiveCamera) {
            camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
            camera.zoom = 1;
        }
    }
    function onSessionEvent(event) {
        const controllerIndex = this._controllerInputSources.indexOf(event.inputSource);
        if (controllerIndex === -1) {
            return;
        }
        const controller = this._controllers[controllerIndex];
        if (controller !== undefined) {
            const referenceSpace = this.getReferenceSpace();
            controller.update(event.inputSource, event.frame, referenceSpace);
            controller.dispatchEvent({ type: event.type, data: event.inputSource });
        }
    }
    function onSessionEnd() {
        const session = this._session;
        const renderer = this._renderer;
        session.removeEventListener('select', this._onSessionEvent);
        session.removeEventListener('selectstart', this._onSessionEvent);
        session.removeEventListener('selectend', this._onSessionEvent);
        session.removeEventListener('squeeze', this._onSessionEvent);
        session.removeEventListener('squeezestart', this._onSessionEvent);
        session.removeEventListener('squeezeend', this._onSessionEvent);
        session.removeEventListener('end', this._onSessionEnd);
        session.removeEventListener('inputsourceschange', this._onInputSourcesChange);
        for (let i = 0; i < this._controllers.length; i++) {
            const inputSource = this._controllerInputSources[i];
            if (inputSource === null) continue;
            this._controllerInputSources[i] = null;
            this._controllers[i].disconnect(inputSource);
        }
        this._currentDepthNear = null;
        this._currentDepthFar = null;
        // restore framebuffer/rendering state
        renderer._resetXRState();
        this._session = null;
        this._xrRenderTarget = null;
        // switch layers back to emulated
        if (this._supportsLayers === true) {
            for (const layer of this._layers) {
                // Recreate layer render target to reset state
                layer.renderTarget = new XRRenderTarget(
                    layer.pixelwidth,
                    layer.pixelheight,
                    {
                        format: RGBAFormat,
                        type: UnsignedByteType,
                        depthTexture: new DepthTexture(
                            layer.pixelwidth,
                            layer.pixelheight,
                            layer.stencilBuffer ? UnsignedInt248Type : UnsignedIntType,
                            undefined,
                            undefined,
                            undefined,
                            undefined,
                            undefined,
                            undefined,
                            layer.stencilBuffer ? DepthStencilFormat : DepthFormat
                        ),
                        stencilBuffer: layer.stencilBuffer,
                        resolveDepthBuffer: false,
                        resolveStencilBuffer: false
                    });
                layer.renderTarget.isXRRenderTarget = false;
                layer.plane.material = layer.material;
                layer.material.map = layer.renderTarget.texture;
                layer.material.map.offset.y = 1;
                layer.material.map.repeat.y = -1;
                delete layer.xrlayer;
            }
        }
        //
        this.isPresenting = false;
        this._useMultiview = false;
        renderer._animation.stop();
        renderer._animation.setAnimationLoop(this._currentAnimationLoop);
        renderer._animation.setContext(this._currentAnimationContext);
        renderer._animation.start();
        renderer.setPixelRatio(this._currentPixelRatio);
        renderer.setSize(this._currentSize.width, this._currentSize.height, false);
        this.dispatchEvent({ type: 'sessionend' });
    }
    function onInputSourcesChange(event) {
        const controllers = this._controllers;
        const controllerInputSources = this._controllerInputSources;
        // Notify disconnected
        for (let i = 0; i < event.removed.length; i++) {
            const inputSource = event.removed[i];
            const index = controllerInputSources.indexOf(inputSource);
            if (index >= 0) {
                controllerInputSources[index] = null;
                controllers[index].disconnect(inputSource);
            }
        }
        // Notify connected
        for (let i = 0; i < event.added.length; i++) {
            const inputSource = event.added[i];
            let controllerIndex = controllerInputSources.indexOf(inputSource);
            if (controllerIndex === -1) {
                // Assign input source a controller that currently has no input source
                for (let i = 0; i < controllers.length; i++) {
                    if (i >= controllerInputSources.length) {
                        controllerInputSources.push(inputSource);
                        controllerIndex = i;
                        break;
                    } else if (controllerInputSources[i] === null) {
                        controllerInputSources[i] = inputSource;
                        controllerIndex = i;
                        break;
                    }
                }
                // If all controllers do currently receive input we ignore new ones
                if (controllerIndex === -1) break;
            }
            const controller = controllers[controllerIndex];
            if (controller) {
                controller.connect(inputSource);
            }
        }
    }
    // Creation method for native WebXR layers
    function createXRLayer(layer) {
        if (layer.type === 'quad') {
            return this._glBinding.createQuadLayer({
                transform: new XRRigidTransform(layer.translation, layer.quaternion),
                width: layer.width / 2,
                height: layer.height / 2,
                space: this._referenceSpace,
                viewPixelWidth: layer.pixelwidth,
                viewPixelHeight: layer.pixelheight,
                clearOnAccess: false
            });
        } else {
            return this._glBinding.createCylinderLayer({
                transform: new XRRigidTransform(layer.translation, layer.quaternion),
                radius: layer.radius,
                centralAngle: layer.centralAngle,
                aspectRatio: layer.aspectRatio,
                space: this._referenceSpace,
                viewPixelWidth: layer.pixelwidth,
                viewPixelHeight: layer.pixelheight,
                clearOnAccess: false
            });
        }
    }
    // Animation Loop
    function onAnimationFrame(time, frame) {
        if (frame === undefined) return;
        const cameraXR = this._cameraXR;
        const renderer = this._renderer;
        const backend = renderer.backend;
        const glBaseLayer = this._glBaseLayer;
        const referenceSpace = this.getReferenceSpace();
        const pose = frame.getViewerPose(referenceSpace);
        this._xrFrame = frame;
        if (pose !== null) {
            const views = pose.views;
            if (this._glBaseLayer !== null) {
                backend.setXRTarget(glBaseLayer.framebuffer);
            }
            let cameraXRNeedsUpdate = false;
            // check if it's necessary to rebuild cameraXR's camera list
            if (views.length !== cameraXR.cameras.length) {
                cameraXR.cameras.length = 0;
                cameraXRNeedsUpdate = true;
            }
            for (let i = 0; i < views.length; i++) {
                const view = views[i];
                let viewport;
                if (this._useLayers === true) {
                    const glSubImage = this._glBinding.getViewSubImage(this._glProjLayer, view);
                    viewport = glSubImage.viewport;
                    // For side-by-side projection, we only produce a single texture for both eyes.
                    if (i === 0) {
                        backend.setXRRenderTargetTextures(
                            this._xrRenderTarget,
                            glSubImage.colorTexture,
                            (this._glProjLayer.ignoreDepthValues && !this._useMultiview) ? undefined : glSubImage.depthStencilTexture
                        );
                    }
                } else {
                    viewport = glBaseLayer.getViewport(view);
                }
                let camera = this._cameras[i];
                if (camera === undefined) {
                    camera = new PerspectiveCamera();
                    camera.layers.enable(i);
                    camera.viewport = new Vector4();
                    this._cameras[i] = camera;
                }
                camera.matrix.fromArray(view.transform.matrix);
                camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i === 0) {
                    cameraXR.matrix.copy(camera.matrix);
                    cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
                }
                if (cameraXRNeedsUpdate === true) {
                    cameraXR.cameras.push(camera);
                }
            }
            renderer.setOutputRenderTarget(this._xrRenderTarget);
        }
        //
        for (let i = 0; i < this._controllers.length; i++) {
            const inputSource = this._controllerInputSources[i];
            const controller = this._controllers[i];
            if (inputSource !== null && controller !== undefined) {
                controller.update(inputSource, frame, referenceSpace);
            }
        }
        if (this._currentAnimationLoop) this._currentAnimationLoop(time, frame);
        if (frame.detectedPlanes) {
            this.dispatchEvent({ type: 'planesdetected', data: frame });
        }
        this._xrFrame = null;
    }
    const _scene = /*@__PURE__*/ new Scene();
    const _drawingBufferSize = /*@__PURE__*/ new Vector2();
    const _screen = /*@__PURE__*/ new Vector4();
    const _frustum$2 = /*@__PURE__*/ new Frustum();
    const _frustumArray$1 = /*@__PURE__*/ new FrustumArray();
    const _projScreenMatrix$3 = /*@__PURE__*/ new Matrix4();
    const _vector4 = /*@__PURE__*/ new Vector4();
    class Renderer {

        constructor(backend, parameters = {}) {
            this.isRenderer = true;
            //
            const {
                logarithmicDepthBuffer = false,
                alpha = true,
                depth = true,
                stencil = false,
                antialias = false,
                samples = 0,
                getFallback = null,
                colorBufferType = HalfFloatType,
                multiview = false
            } = parameters;
            this.domElement = backend.getDomElement();
            this.backend = backend;
            this.samples = samples || (antialias === true) ? 4 : 0;
            this.autoClear = true;
            this.autoClearColor = true;
            this.autoClearDepth = true;
            this.autoClearStencil = true;
            this.alpha = alpha;
            this.logarithmicDepthBuffer = logarithmicDepthBuffer;
            this.outputColorSpace = SRGBColorSpace;
            this.toneMapping = NoToneMapping;
            this.toneMappingExposure = 1.0;
            this.sortObjects = true;
            this.depth = depth;
            this.stencil = stencil;
            this.info = new Info();
            this.overrideNodes = {
                modelViewMatrix: null,
                modelNormalViewMatrix: null
            };
            this.library = new NodeLibrary();
            this.lighting = new Lighting();
            // internals
            this._getFallback = getFallback;
            this._pixelRatio = 1;
            this._width = this.domElement.width;
            this._height = this.domElement.height;
            this._viewport = new Vector4(0, 0, this._width, this._height);
            this._scissor = new Vector4(0, 0, this._width, this._height);
            this._scissorTest = false;
            this._attributes = null;
            this._geometries = null;
            this._nodes = null;
            this._animation = null;
            this._bindings = null;
            this._objects = null;
            this._pipelines = null;
            this._bundles = null;
            this._renderLists = null;
            this._renderContexts = null;
            this._textures = null;
            this._background = null;
            this._quad = new QuadMesh(new NodeMaterial());
            this._quad.material.name = 'Renderer_output';
            this._currentRenderContext = null;
            this._opaqueSort = null;
            this._transparentSort = null;
            this._frameBufferTarget = null;
            const alphaClear = this.alpha === true ? 0 : 1;
            this._clearColor = new Color4(0, 0, 0, alphaClear);
            this._clearDepth = 1;
            this._clearStencil = 0;
            this._renderTarget = null;
            this._activeCubeFace = 0;
            this._activeMipmapLevel = 0;
            this._outputRenderTarget = null;
            this._mrt = null;
            this._renderObjectFunction = null;
            this._currentRenderObjectFunction = null;
            this._currentRenderBundle = null;
            this._handleObjectFunction = this._renderObjectDirect;
            this._isDeviceLost = false;
            this.onDeviceLost = this._onDeviceLost;
            this._colorBufferType = colorBufferType;
            this._initialized = false;
            this._initPromise = null;
            this._compilationPromises = null;
            this.transparent = true;
            this.opaque = true;

            this.shadowMap = {
                enabled: false,
                type: PCFShadowMap
            };

            this.xr = new XRManager(this, multiview);

            this.debug = {
                checkShaderErrors: true,
                onShaderError: null,
                getShaderAsync: async (scene, camera, object) => {
                    await this.compileAsync(scene, camera);
                    const renderList = this._renderLists.get(scene, camera);
                    const renderContext = this._renderContexts.get(scene, camera, this._renderTarget);
                    const material = scene.overrideMaterial || object.material;
                    const renderObject = this._objects.get(object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext);
                    const { fragmentShader, vertexShader } = renderObject.getNodeBuilderState();
                    return { fragmentShader, vertexShader };
                }
            };
        }
        async init() {
            if (this._initialized) {
                throw new Error('Renderer: Backend has already been initialized.');
            }
            if (this._initPromise !== null) {
                return this._initPromise;
            }
            this._initPromise = new Promise(async (resolve, reject) => {
                let backend = this.backend;
                try {
                    await backend.init(this);
                } catch (error) {
                    if (this._getFallback !== null) {
                        // try the fallback
                        try {
                            this.backend = backend = this._getFallback(error);
                            await backend.init(this);
                        } catch (error) {
                            reject(error);
                            return;
                        }
                    } else {
                        reject(error);
                        return;
                    }
                }
                this._nodes = new Nodes(this, backend);
                this._animation = new Animation(this._nodes, this.info);
                this._attributes = new Attributes(backend);
                this._background = new Background(this, this._nodes);
                this._geometries = new Geometries(this._attributes, this.info);
                this._textures = new Textures(this, backend, this.info);
                this._pipelines = new Pipelines(backend, this._nodes);
                this._bindings = new Bindings(backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info);
                this._objects = new RenderObjects(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info);
                this._renderLists = new RenderLists(this.lighting);
                this._bundles = new RenderBundles();
                this._renderContexts = new RenderContexts();
                //
                this._animation.start();
                this._initialized = true;
                resolve(this);
            });
            return this._initPromise;
        }
        get coordinateSystem() {
            return this.backend.coordinateSystem;
        }
        async compileAsync(scene, camera, targetScene = null) {
            if (this._isDeviceLost === true) return;
            if (this._initialized === false) await this.init();
            // preserve render tree
            const nodeFrame = this._nodes.nodeFrame;
            const previousRenderId = nodeFrame.renderId;
            const previousRenderContext = this._currentRenderContext;
            const previousRenderObjectFunction = this._currentRenderObjectFunction;
            const previousCompilationPromises = this._compilationPromises;
            //
            const sceneRef = (scene.isScene === true) ? scene : _scene;
            if (targetScene === null) targetScene = scene;
            const renderTarget = this._renderTarget;
            const renderContext = this._renderContexts.get(targetScene, camera, renderTarget);
            const activeMipmapLevel = this._activeMipmapLevel;
            const compilationPromises = [];
            this._currentRenderContext = renderContext;
            this._currentRenderObjectFunction = this.renderObject;
            this._handleObjectFunction = this._createObjectPipeline;
            this._compilationPromises = compilationPromises;
            nodeFrame.renderId++;
            //
            nodeFrame.update();
            //
            renderContext.depth = this.depth;
            renderContext.stencil = this.stencil;
            if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();
            renderContext.clippingContext.updateGlobal(sceneRef, camera);
            //
            sceneRef.onBeforeRender(this, scene, camera, renderTarget);
            //
            const renderList = this._renderLists.get(scene, camera);
            renderList.begin();
            this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);
            // include lights from target scene
            if (targetScene !== scene) {
                targetScene.traverseVisible(function (object) {
                    if (object.isLight && object.layers.test(camera.layers)) {
                        renderList.pushLight(object);
                    }
                });
            }
            renderList.finish();
            //
            if (renderTarget !== null) {
                this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
                const renderTargetData = this._textures.get(renderTarget);
                renderContext.textures = renderTargetData.textures;
                renderContext.depthTexture = renderTargetData.depthTexture;
            } else {
                renderContext.textures = null;
                renderContext.depthTexture = null;
            }
            //
            this._background.update(sceneRef, renderList, renderContext);
            // process render lists
            const opaqueObjects = renderList.opaque;
            const transparentObjects = renderList.transparent;
            const transparentDoublePassObjects = renderList.transparentDoublePass;
            const lightsNode = renderList.lightsNode;
            if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);
            if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);
            // restore render tree
            nodeFrame.renderId = previousRenderId;
            this._currentRenderContext = previousRenderContext;
            this._currentRenderObjectFunction = previousRenderObjectFunction;
            this._compilationPromises = previousCompilationPromises;
            this._handleObjectFunction = this._renderObjectDirect;
            // wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete
            await Promise.all(compilationPromises);
        }
        async renderAsync(scene, camera) {
            if (this._initialized === false) await this.init();
            this._renderScene(scene, camera);
        }
        async waitForGPU() {
            await this.backend.waitForGPU();
        }
        set highPrecision(value) {
            if (value === true) {
                this.overrideNodes.modelViewMatrix = highpModelViewMatrix;
                this.overrideNodes.modelNormalViewMatrix = highpModelNormalViewMatrix;
            } else if (this.highPrecision) {
                this.overrideNodes.modelViewMatrix = null;
                this.overrideNodes.modelNormalViewMatrix = null;
            }
        }
        get highPrecision() {
            return this.overrideNodes.modelViewMatrix === highpModelViewMatrix && this.overrideNodes.modelNormalViewMatrix === highpModelNormalViewMatrix;
        }
        setMRT(mrt) {
            this._mrt = mrt;
            return this;
        }
        getMRT() {
            return this._mrt;
        }
        getColorBufferType() {
            return this._colorBufferType;
        }
        _onDeviceLost(info) {
            let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\n\nMessage: ${info.message}`;
            if (info.reason) {
                errorMessage += `\nReason: ${info.reason}`;
            }
            console.error(errorMessage);
            this._isDeviceLost = true;
        }
        _renderBundle(bundle, sceneRef, lightsNode) {
            const { bundleGroup, camera, renderList } = bundle;
            const renderContext = this._currentRenderContext;
            //
            const renderBundle = this._bundles.get(bundleGroup, camera);
            const renderBundleData = this.backend.get(renderBundle);
            if (renderBundleData.renderContexts === undefined) renderBundleData.renderContexts = new Set();
            //
            const needsUpdate = bundleGroup.version !== renderBundleData.version;
            const renderBundleNeedsUpdate = renderBundleData.renderContexts.has(renderContext) === false || needsUpdate;
            renderBundleData.renderContexts.add(renderContext);
            if (renderBundleNeedsUpdate) {
                this.backend.beginBundle(renderContext);
                if (renderBundleData.renderObjects === undefined || needsUpdate) {
                    renderBundleData.renderObjects = [];
                }
                this._currentRenderBundle = renderBundle;
                const {
                    transparentDoublePass: transparentDoublePassObjects,
                    transparent: transparentObjects,
                    opaque: opaqueObjects
                } = renderList;
                if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);
                if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);
                this._currentRenderBundle = null;
                //
                this.backend.finishBundle(renderContext, renderBundle);
                renderBundleData.version = bundleGroup.version;
            } else {
                const { renderObjects } = renderBundleData;
                for (let i = 0, l = renderObjects.length; i < l; i++) {
                    const renderObject = renderObjects[i];
                    if (this._nodes.needsRefresh(renderObject)) {
                        this._nodes.updateBefore(renderObject);
                        this._nodes.updateForRender(renderObject);
                        this._bindings.updateForRender(renderObject);
                        this._nodes.updateAfter(renderObject);
                    }
                }
            }
            this.backend.addBundle(renderContext, renderBundle);
        }
        render(scene, camera) {
            if (this._initialized === false) {
                console.warn('THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.');
                return this.renderAsync(scene, camera);
            }
            this._renderScene(scene, camera);
        }
        _getFrameBufferTarget() {
            const { currentToneMapping, currentColorSpace } = this;
            const useToneMapping = currentToneMapping !== NoToneMapping;
            const useColorSpace = currentColorSpace !== ColorManagement.workingColorSpace;
            if (useToneMapping === false && useColorSpace === false) return null;
            const { width, height } = this.getDrawingBufferSize(_drawingBufferSize);
            const { depth, stencil } = this;
            let frameBufferTarget = this._frameBufferTarget;
            if (frameBufferTarget === null) {
                frameBufferTarget = new RenderTarget(width, height, {
                    depthBuffer: depth,
                    stencilBuffer: stencil,
                    type: this._colorBufferType,
                    format: RGBAFormat,
                    colorSpace: ColorManagement.workingColorSpace,
                    generateMipmaps: false,
                    minFilter: LinearFilter,
                    magFilter: LinearFilter,
                    samples: this.samples
                });
                frameBufferTarget.isPostProcessingRenderTarget = true;
                this._frameBufferTarget = frameBufferTarget;
            }
            const outputRenderTarget = this.getOutputRenderTarget();
            frameBufferTarget.depthBuffer = depth;
            frameBufferTarget.stencilBuffer = stencil;
            if (outputRenderTarget !== null) {
                frameBufferTarget.setSize(outputRenderTarget.width, outputRenderTarget.height, outputRenderTarget.depth);
            } else {
                frameBufferTarget.setSize(width, height, 1);
            }
            frameBufferTarget.viewport.copy(this._viewport);
            frameBufferTarget.scissor.copy(this._scissor);
            frameBufferTarget.viewport.multiplyScalar(this._pixelRatio);
            frameBufferTarget.scissor.multiplyScalar(this._pixelRatio);
            frameBufferTarget.scissorTest = this._scissorTest;
            frameBufferTarget.multiview = outputRenderTarget !== null ? outputRenderTarget.multiview : false;
            frameBufferTarget.resolveDepthBuffer = outputRenderTarget !== null ? outputRenderTarget.resolveDepthBuffer : true;
            frameBufferTarget._autoAllocateDepthBuffer = outputRenderTarget !== null ? outputRenderTarget._autoAllocateDepthBuffer : false;
            return frameBufferTarget;
        }
        _renderScene(scene, camera, useFrameBufferTarget = true) {
            if (this._isDeviceLost === true) return;
            const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;
            // preserve render tree
            const nodeFrame = this._nodes.nodeFrame;
            const previousRenderId = nodeFrame.renderId;
            const previousRenderContext = this._currentRenderContext;
            const previousRenderObjectFunction = this._currentRenderObjectFunction;
            //
            const sceneRef = (scene.isScene === true) ? scene : _scene;
            const outputRenderTarget = this._renderTarget || this._outputRenderTarget;
            const activeCubeFace = this._activeCubeFace;
            const activeMipmapLevel = this._activeMipmapLevel;
            //
            let renderTarget;
            if (frameBufferTarget !== null) {
                renderTarget = frameBufferTarget;
                this.setRenderTarget(renderTarget);
            } else {
                renderTarget = outputRenderTarget;
            }
            //
            const renderContext = this._renderContexts.get(scene, camera, renderTarget);
            this._currentRenderContext = renderContext;
            this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;
            //
            this.info.calls++;
            this.info.render.calls++;
            this.info.render.frameCalls++;
            nodeFrame.renderId = this.info.calls;
            //
            const coordinateSystem = this.coordinateSystem;
            const xr = this.xr;
            if (camera.coordinateSystem !== coordinateSystem && xr.isPresenting === false) {
                camera.coordinateSystem = coordinateSystem;
                camera.updateProjectionMatrix();
                if (camera.isArrayCamera) {
                    for (const subCamera of camera.cameras) {
                        subCamera.coordinateSystem = coordinateSystem;
                        subCamera.updateProjectionMatrix();
                    }
                }
            }
            //
            if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
            if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
            if (xr.enabled === true && xr.isPresenting === true) {
                if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
                camera = xr.getCamera(); // use XR camera for rendering
            }
            //
            let viewport = this._viewport;
            let scissor = this._scissor;
            let pixelRatio = this._pixelRatio;
            if (renderTarget !== null) {
                viewport = renderTarget.viewport;
                scissor = renderTarget.scissor;
                pixelRatio = 1;
            }
            this.getDrawingBufferSize(_drawingBufferSize);
            _screen.set(0, 0, _drawingBufferSize.width, _drawingBufferSize.height);
            const minDepth = (viewport.minDepth === undefined) ? 0 : viewport.minDepth;
            const maxDepth = (viewport.maxDepth === undefined) ? 1 : viewport.maxDepth;
            renderContext.viewportValue.copy(viewport).multiplyScalar(pixelRatio).floor();
            renderContext.viewportValue.width >>= activeMipmapLevel;
            renderContext.viewportValue.height >>= activeMipmapLevel;
            renderContext.viewportValue.minDepth = minDepth;
            renderContext.viewportValue.maxDepth = maxDepth;
            renderContext.viewport = renderContext.viewportValue.equals(_screen) === false;
            renderContext.scissorValue.copy(scissor).multiplyScalar(pixelRatio).floor();
            renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals(_screen) === false;
            renderContext.scissorValue.width >>= activeMipmapLevel;
            renderContext.scissorValue.height >>= activeMipmapLevel;
            if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();
            renderContext.clippingContext.updateGlobal(sceneRef, camera);
            //
            sceneRef.onBeforeRender(this, scene, camera, renderTarget);
            //
            const frustum = camera.isArrayCamera ? _frustumArray$1 : _frustum$2;
            if (!camera.isArrayCamera) {
                _projScreenMatrix$3.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                frustum.setFromProjectionMatrix(_projScreenMatrix$3, camera.coordinateSystem, camera.reversedDepth);
            }
            const renderList = this._renderLists.get(scene, camera);
            renderList.begin();
            this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);
            renderList.finish();
            if (this.sortObjects === true) {
                renderList.sort(this._opaqueSort, this._transparentSort);
            }
            //
            if (renderTarget !== null) {
                this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
                const renderTargetData = this._textures.get(renderTarget);
                renderContext.textures = renderTargetData.textures;
                renderContext.depthTexture = renderTargetData.depthTexture;
                renderContext.width = renderTargetData.width;
                renderContext.height = renderTargetData.height;
                renderContext.renderTarget = renderTarget;
                renderContext.depth = renderTarget.depthBuffer;
                renderContext.stencil = renderTarget.stencilBuffer;
            } else {
                renderContext.textures = null;
                renderContext.depthTexture = null;
                renderContext.width = this.domElement.width;
                renderContext.height = this.domElement.height;
                renderContext.depth = this.depth;
                renderContext.stencil = this.stencil;
            }
            renderContext.width >>= activeMipmapLevel;
            renderContext.height >>= activeMipmapLevel;
            renderContext.activeCubeFace = activeCubeFace;
            renderContext.activeMipmapLevel = activeMipmapLevel;
            renderContext.occlusionQueryCount = renderList.occlusionQueryCount;
            //
            this._background.update(sceneRef, renderList, renderContext);
            //
            renderContext.camera = camera;
            this.backend.beginRender(renderContext);
            // process render lists
            const {
                bundles,
                lightsNode,
                transparentDoublePass: transparentDoublePassObjects,
                transparent: transparentObjects,
                opaque: opaqueObjects
            } = renderList;
            if (bundles.length > 0) this._renderBundles(bundles, sceneRef, lightsNode);
            if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);
            if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);
            // finish render pass
            this.backend.finishRender(renderContext);
            // restore render tree
            nodeFrame.renderId = previousRenderId;
            this._currentRenderContext = previousRenderContext;
            this._currentRenderObjectFunction = previousRenderObjectFunction;
            //
            if (frameBufferTarget !== null) {
                this.setRenderTarget(outputRenderTarget, activeCubeFace, activeMipmapLevel);
                this._renderOutput(renderTarget);
            }
            //
            sceneRef.onAfterRender(this, scene, camera, renderTarget);
            //
            return renderContext;
        }
        _setXRLayerSize(width, height) {
            this._width = width;
            this._height = height;
            this.setViewport(0, 0, width, height);
        }
        _renderOutput(renderTarget) {
            const quad = this._quad;
            if (this._nodes.hasOutputChange(renderTarget.texture)) {
                quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
                quad.material.needsUpdate = true;
            }
            // a clear operation clears the intermediate renderTarget texture, but should not update the screen canvas.
            const currentAutoClear = this.autoClear;
            const currentXR = this.xr.enabled;
            this.autoClear = false;
            this.xr.enabled = false;
            this._renderScene(quad, quad.camera, false);
            this.autoClear = currentAutoClear;
            this.xr.enabled = currentXR;

        }
        getMaxAnisotropy() {
            return this.backend.getMaxAnisotropy();
        }
        getActiveCubeFace() {
            return this._activeCubeFace;
        }
        getActiveMipmapLevel() {
            return this._activeMipmapLevel;
        }
        async setAnimationLoop(callback) {
            if (this._initialized === false) await this.init();
            this._animation.setAnimationLoop(callback);
        }
        async getArrayBufferAsync(attribute) {
            return await this.backend.getArrayBufferAsync(attribute);
        }
        getContext() {
            return this.backend.getContext();
        }
        getPixelRatio() {
            return this._pixelRatio;
        }
        getDrawingBufferSize(target) {
            return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
        }
        getSize(target) {
            return target.set(this._width, this._height);
        }
        setPixelRatio(value = 1) {
            if (this._pixelRatio === value) return;
            this._pixelRatio = value;
            this.setSize(this._width, this._height, false);
        }
        setDrawingBufferSize(width, height, pixelRatio) {
            // Renderer can't be resized while presenting in XR.
            if (this.xr && this.xr.isPresenting) return;
            this._width = width;
            this._height = height;
            this._pixelRatio = pixelRatio;
            this.domElement.width = Math.floor(width * pixelRatio);
            this.domElement.height = Math.floor(height * pixelRatio);
            this.setViewport(0, 0, width, height);
            if (this._initialized) this.backend.updateSize();
        }
        setSize(width, height, updateStyle = true) {
            // Renderer can't be resized while presenting in XR.
            if (this.xr && this.xr.isPresenting) return;
            this._width = width;
            this._height = height;
            this.domElement.width = Math.floor(width * this._pixelRatio);
            this.domElement.height = Math.floor(height * this._pixelRatio);
            if (updateStyle === true) {
                this.domElement.style.width = width + 'px';
                this.domElement.style.height = height + 'px';
            }
            this.setViewport(0, 0, width, height);
            if (this._initialized) this.backend.updateSize();
        }
        setOpaqueSort(method) {
            this._opaqueSort = method;
        }
        setTransparentSort(method) {
            this._transparentSort = method;
        }
        getScissor(target) {
            const scissor = this._scissor;
            target.x = scissor.x;
            target.y = scissor.y;
            target.width = scissor.width;
            target.height = scissor.height;
            return target;
        }
        setScissor(x, y, width, height) {
            const scissor = this._scissor;
            if (x.isVector4) {
                scissor.copy(x);
            } else {
                scissor.set(x, y, width, height);
            }
        }
        getScissorTest() {
            return this._scissorTest;
        }
        setScissorTest(boolean) {
            this._scissorTest = boolean;
            this.backend.setScissorTest(boolean);
        }
        getViewport(target) {
            return target.copy(this._viewport);
        }
        setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
            const viewport = this._viewport;
            if (x.isVector4) {
                viewport.copy(x);
            } else {
                viewport.set(x, y, width, height);
            }
            viewport.minDepth = minDepth;
            viewport.maxDepth = maxDepth;
        }
        getClearColor(target) {
            return target.copy(this._clearColor);
        }
        setClearColor(color, alpha = 1) {
            this._clearColor.set(color);
            this._clearColor.a = alpha;
        }
        getClearAlpha() {
            return this._clearColor.a;
        }
        setClearAlpha(alpha) {
            this._clearColor.a = alpha;
        }
        getClearDepth() {
            return this._clearDepth;
        }
        setClearDepth(depth) {
            this._clearDepth = depth;
        }
        getClearStencil() {
            return this._clearStencil;
        }
        setClearStencil(stencil) {
            this._clearStencil = stencil;
        }
        isOccluded(object) {
            const renderContext = this._currentRenderContext;
            return renderContext && this.backend.isOccluded(renderContext, object);
        }
        clear(color = true, depth = true, stencil = true) {
            if (this._initialized === false) {
                console.warn('THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.');
                return this.clearAsync(color, depth, stencil);
            }
            const renderTarget = this._renderTarget || this._getFrameBufferTarget();
            let renderContext = null;
            if (renderTarget !== null) {
                this._textures.updateRenderTarget(renderTarget);
                const renderTargetData = this._textures.get(renderTarget);
                renderContext = this._renderContexts.getForClear(renderTarget);
                renderContext.textures = renderTargetData.textures;
                renderContext.depthTexture = renderTargetData.depthTexture;
                renderContext.width = renderTargetData.width;
                renderContext.height = renderTargetData.height;
                renderContext.renderTarget = renderTarget;
                renderContext.depth = renderTarget.depthBuffer;
                renderContext.stencil = renderTarget.stencilBuffer;
                // #30329
                renderContext.clearColorValue = this.backend.getClearColor();
                renderContext.activeCubeFace = this.getActiveCubeFace();
                renderContext.activeMipmapLevel = this.getActiveMipmapLevel();
            }
            this.backend.clear(color, depth, stencil, renderContext);
            if (renderTarget !== null && this._renderTarget === null) {
                this._renderOutput(renderTarget);
            }
        }
        clearColor() {
            return this.clear(true, false, false);
        }
        clearDepth() {
            return this.clear(false, true, false);
        }
        clearStencil() {
            return this.clear(false, false, true);
        }
        async clearAsync(color = true, depth = true, stencil = true) {
            if (this._initialized === false) await this.init();
            this.clear(color, depth, stencil);
        }
        async clearColorAsync() {
            this.clearAsync(true, false, false);
        }
        async clearDepthAsync() {
            this.clearAsync(false, true, false);
        }
        async clearStencilAsync() {
            this.clearAsync(false, false, true);
        }
        get currentToneMapping() {
            return this.isOutputTarget ? this.toneMapping : NoToneMapping;
        }
        get currentColorSpace() {
            return this.isOutputTarget ? this.outputColorSpace : ColorManagement.workingColorSpace;
        }
        get isOutputTarget() {
            return this._renderTarget === this._outputRenderTarget || this._renderTarget === null;
        }
        dispose() {
            this.info.dispose();
            this.backend.dispose();
            this._animation.dispose();
            this._objects.dispose();
            this._pipelines.dispose();
            this._nodes.dispose();
            this._bindings.dispose();
            this._renderLists.dispose();
            this._renderContexts.dispose();
            this._textures.dispose();
            if (this._frameBufferTarget !== null) this._frameBufferTarget.dispose();
            Object.values(this.backend.timestampQueryPool).forEach(queryPool => {
                if (queryPool !== null) queryPool.dispose();
            });
            this.setRenderTarget(null);
            this.setAnimationLoop(null);
        }
        setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
            this._renderTarget = renderTarget;
            this._activeCubeFace = activeCubeFace;
            this._activeMipmapLevel = activeMipmapLevel;
        }
        getRenderTarget() {
            return this._renderTarget;
        }
        setOutputRenderTarget(renderTarget) {
            this._outputRenderTarget = renderTarget;
        }
        getOutputRenderTarget() {
            return this._outputRenderTarget;
        }
        _resetXRState() {
            this.backend.setXRTarget(null);
            this.setOutputRenderTarget(null);
            this.setRenderTarget(null);
            this._frameBufferTarget.dispose();
            this._frameBufferTarget = null;
        }

        setRenderObjectFunction(renderObjectFunction) {
            this._renderObjectFunction = renderObjectFunction;
        }
        getRenderObjectFunction() {
            return this._renderObjectFunction;
        }
        compute(computeNodes, dispatchSizeOrCount = null) {
            if (this._isDeviceLost === true) return;
            if (this._initialized === false) {
                console.warn('THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.');
                return this.computeAsync(computeNodes);
            }
            //
            const nodeFrame = this._nodes.nodeFrame;
            const previousRenderId = nodeFrame.renderId;
            //
            this.info.calls++;
            this.info.compute.calls++;
            this.info.compute.frameCalls++;
            nodeFrame.renderId = this.info.calls;
            //
            const backend = this.backend;
            const pipelines = this._pipelines;
            const bindings = this._bindings;
            const nodes = this._nodes;
            const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];
            if (computeList[0] === undefined || computeList[0].isComputeNode !== true) {
                throw new Error('THREE.Renderer: .compute() expects a ComputeNode.');
            }
            backend.beginCompute(computeNodes);
            for (const computeNode of computeList) {
                // onInit
                if (pipelines.has(computeNode) === false) {
                    const dispose = () => {
                        computeNode.removeEventListener('dispose', dispose);
                        pipelines.delete(computeNode);
                        bindings.delete(computeNode);
                        nodes.delete(computeNode);
                    };
                    computeNode.addEventListener('dispose', dispose);
                    //
                    const onInitFn = computeNode.onInitFunction;
                    if (onInitFn !== null) {
                        onInitFn.call(computeNode, { renderer: this });
                    }
                }
                nodes.updateForCompute(computeNode);
                bindings.updateForCompute(computeNode);
                const computeBindings = bindings.getForCompute(computeNode);
                const computePipeline = pipelines.getForCompute(computeNode, computeBindings);
                backend.compute(computeNodes, computeNode, computeBindings, computePipeline, dispatchSizeOrCount);
            }
            backend.finishCompute(computeNodes);
            //
            nodeFrame.renderId = previousRenderId;
        }
        async computeAsync(computeNodes, dispatchSizeOrCount = null) {
            if (this._initialized === false) await this.init();
            this.compute(computeNodes, dispatchSizeOrCount);
        }
        async hasFeatureAsync(name) {
            if (this._initialized === false) await this.init();
            return this.backend.hasFeature(name);
        }
        async resolveTimestampsAsync(type = 'render') {
            if (this._initialized === false) await this.init();
            return this.backend.resolveTimestampsAsync(type);
        }
        hasFeature(name) {
            if (this._initialized === false) {
                console.warn('THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.');
                return false;
            }
            return this.backend.hasFeature(name);
        }
        hasInitialized() {
            return this._initialized;
        }
        async initTextureAsync(texture) {
            if (this._initialized === false) await this.init();
            this._textures.updateTexture(texture);
        }
        initTexture(texture) {
            if (this._initialized === false) {
                console.warn('THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.');
            }
            this._textures.updateTexture(texture);
        }
        copyFramebufferToTexture(framebufferTexture, rectangle = null) {
            if (rectangle !== null) {
                if (rectangle.isVector2) {
                    rectangle = _vector4.set(rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height).floor();
                } else if (rectangle.isVector4) {
                    rectangle = _vector4.copy(rectangle).floor();
                } else {
                    console.error('THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.');
                    return;
                }
            } else {
                rectangle = _vector4.set(0, 0, framebufferTexture.image.width, framebufferTexture.image.height);
            }
            //
            let renderContext = this._currentRenderContext;
            let renderTarget;
            if (renderContext !== null) {
                renderTarget = renderContext.renderTarget;
            } else {
                renderTarget = this._renderTarget || this._getFrameBufferTarget();
                if (renderTarget !== null) {
                    this._textures.updateRenderTarget(renderTarget);
                    renderContext = this._textures.get(renderTarget);
                }
            }
            //
            this._textures.updateTexture(framebufferTexture, { renderTarget });
            this.backend.copyFramebufferToTexture(framebufferTexture, renderContext, rectangle);
        }
        copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
            this._textures.updateTexture(srcTexture);
            this._textures.updateTexture(dstTexture);
            this.backend.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, srcLevel, dstLevel);
        }
        async readRenderTargetPixelsAsync(renderTarget, x, y, width, height, textureIndex = 0, faceIndex = 0) {
            return this.backend.copyTextureToBuffer(renderTarget.textures[textureIndex], x, y, width, height, faceIndex);
        }
        _projectObject(object, camera, groupOrder, renderList, clippingContext) {
            if (object.visible === false) return;
            const visible = object.layers.test(camera.layers);
            if (visible) {
                if (object.isGroup) {
                    groupOrder = object.renderOrder;
                    if (object.isClippingGroup && object.enabled) clippingContext = clippingContext.getGroupContext(object);
                } else if (object.isLOD) {
                    if (object.autoUpdate === true) object.update(camera);
                } else if (object.isLight) {
                    renderList.pushLight(object);
                } else if (object.isSprite) {
                    const frustum = camera.isArrayCamera ? _frustumArray$1 : _frustum$2;
                    if (!object.frustumCulled || frustum.intersectsSprite(object, camera)) {
                        if (this.sortObjects === true) {
                            _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix$3);
                        }
                        const { geometry, material } = object;
                        if (material.visible) {
                            renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);
                        }
                    }
                } else if (object.isLineLoop) {
                    console.error('THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.');
                } else if (object.isMesh || object.isLine || object.isPoints) {
                    const frustum = camera.isArrayCamera ? _frustumArray$1 : _frustum$2;
                    if (!object.frustumCulled || frustum.intersectsObject(object, camera)) {
                        const { geometry, material } = object;
                        if (this.sortObjects === true) {
                            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                            _vector4
                                .copy(geometry.boundingSphere.center)
                                .applyMatrix4(object.matrixWorld)
                                .applyMatrix4(_projScreenMatrix$3);
                        }
                        if (Array.isArray(material)) {
                            const groups = geometry.groups;
                            for (let i = 0, l = groups.length; i < l; i++) {
                                const group = groups[i];
                                const groupMaterial = material[group.materialIndex];
                                if (groupMaterial && groupMaterial.visible) {
                                    renderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext);
                                }
                            }
                        } else if (material.visible) {
                            renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);
                        }
                    }
                }
            }
            if (object.isBundleGroup === true && this.backend.beginBundle !== undefined) {
                const baseRenderList = renderList;
                // replace render list
                renderList = this._renderLists.get(object, camera);
                renderList.begin();
                baseRenderList.pushBundle({
                    bundleGroup: object,
                    camera,
                    renderList,
                });
                renderList.finish();
            }
            const children = object.children;
            for (let i = 0, l = children.length; i < l; i++) {
                this._projectObject(children[i], camera, groupOrder, renderList, clippingContext);
            }
        }
        _renderBundles(bundles, sceneRef, lightsNode) {
            for (const bundle of bundles) {
                this._renderBundle(bundle, sceneRef, lightsNode);
            }
        }
        _renderTransparents(renderList, doublePassList, camera, scene, lightsNode) {
            if (doublePassList.length > 0) {
                // render back side
                for (const { material } of doublePassList) {
                    material.side = BackSide;
                }
                this._renderObjects(doublePassList, camera, scene, lightsNode, 'backSide');
                // render front side
                for (const { material } of doublePassList) {
                    material.side = FrontSide;
                }
                this._renderObjects(renderList, camera, scene, lightsNode);
                // restore
                for (const { material } of doublePassList) {
                    material.side = DoubleSide;
                }
            } else {
                this._renderObjects(renderList, camera, scene, lightsNode);
            }
        }
        _renderObjects(renderList, camera, scene, lightsNode, passId = null) {
            for (let i = 0, il = renderList.length; i < il; i++) {
                const { object, geometry, material, group, clippingContext } = renderList[i];
                this._currentRenderObjectFunction(object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId);
            }
        }
        renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null) {
            let overridePositionNode;
            let overrideColorNode;
            let overrideDepthNode;
            //
            object.onBeforeRender(this, scene, camera, geometry, material, group);
            //
            if (material.allowOverride === true && scene.overrideMaterial !== null) {
                const overrideMaterial = scene.overrideMaterial;
                if (material.positionNode && material.positionNode.isNode) {
                    overridePositionNode = overrideMaterial.positionNode;
                    overrideMaterial.positionNode = material.positionNode;
                }
                overrideMaterial.alphaTest = material.alphaTest;
                overrideMaterial.alphaMap = material.alphaMap;
                overrideMaterial.transparent = material.transparent || material.transmission > 0;
                if (overrideMaterial.isShadowPassMaterial) {
                    overrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;
                    if (material.depthNode && material.depthNode.isNode) {
                        overrideDepthNode = overrideMaterial.depthNode;
                        overrideMaterial.depthNode = material.depthNode;
                    }
                    if (material.castShadowNode && material.castShadowNode.isNode) {
                        overrideColorNode = overrideMaterial.colorNode;
                        overrideMaterial.colorNode = material.castShadowNode;
                    }
                    if (material.castShadowPositionNode && material.castShadowPositionNode.isNode) {
                        overridePositionNode = overrideMaterial.positionNode;
                        overrideMaterial.positionNode = material.castShadowPositionNode;
                    }
                }
                material = overrideMaterial;
            }
            //
            if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
                material.side = BackSide;
                this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, 'backSide'); // create backSide pass id
                material.side = FrontSide;
                this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, passId); // use default pass id
                material.side = DoubleSide;
            } else {
                this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, passId);
            }
            //
            if (overridePositionNode !== undefined) {
                scene.overrideMaterial.positionNode = overridePositionNode;
            }
            if (overrideDepthNode !== undefined) {
                scene.overrideMaterial.depthNode = overrideDepthNode;
            }
            if (overrideColorNode !== undefined) {
                scene.overrideMaterial.colorNode = overrideColorNode;
            }
            //
            object.onAfterRender(this, scene, camera, geometry, material, group);
        }
        _renderObjectDirect(object, material, scene, camera, lightsNode, group, clippingContext, passId) {
            const renderObject = this._objects.get(object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId);
            renderObject.drawRange = object.geometry.drawRange;
            renderObject.group = group;
            //
            const needsRefresh = this._nodes.needsRefresh(renderObject);
            if (needsRefresh) {
                this._nodes.updateBefore(renderObject);
                this._geometries.updateForRender(renderObject);
                this._nodes.updateForRender(renderObject);
                this._bindings.updateForRender(renderObject);
            }
            this._pipelines.updateForRender(renderObject);
            //
            if (this._currentRenderBundle !== null) {
                const renderBundleData = this.backend.get(this._currentRenderBundle);
                renderBundleData.renderObjects.push(renderObject);
                renderObject.bundle = this._currentRenderBundle.bundleGroup;
            }
            this.backend.draw(renderObject, this.info);
            if (needsRefresh) this._nodes.updateAfter(renderObject);
        }
        _createObjectPipeline(object, material, scene, camera, lightsNode, group, clippingContext, passId) {
            const renderObject = this._objects.get(object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId);
            renderObject.drawRange = object.geometry.drawRange;
            renderObject.group = group;
            //
            this._nodes.updateBefore(renderObject);
            this._geometries.updateForRender(renderObject);
            this._nodes.updateForRender(renderObject);
            this._bindings.updateForRender(renderObject);
            this._pipelines.getForRender(renderObject, this._compilationPromises);
            this._nodes.updateAfter(renderObject);
        }
        get compile() {
            return this.compileAsync;
        }
    }
    class Binding {
        constructor(name = '') {
            this.name = name;
            this.visibility = 0;
        }
        setVisibility(visibility) {
            this.visibility |= visibility;
        }
        clone() {
            return Object.assign(new this.constructor(), this);
        }
    }
    function getFloatLength(floatLength) {
        // ensure chunk size alignment (STD140 layout)
        return floatLength + ((GPU_CHUNK_BYTES - (floatLength % GPU_CHUNK_BYTES)) % GPU_CHUNK_BYTES);
    }
    class Buffer extends Binding {
        constructor(name, buffer = null) {
            super(name);
            this.isBuffer = true;
            this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;
            this._buffer = buffer;
        }
        get byteLength() {
            return getFloatLength(this._buffer.byteLength);
        }
        get buffer() {
            return this._buffer;
        }
        update() {
            return true;
        }
    }
    class UniformBuffer extends Buffer {
        constructor(name, buffer = null) {
            super(name, buffer);
            this.isUniformBuffer = true;
        }
    }
    let _id$4 = 0;
    class NodeUniformBuffer extends UniformBuffer {
        constructor(nodeUniform, groupNode) {
            super('UniformBuffer_' + _id$4++, nodeUniform ? nodeUniform.value : null);
            this.nodeUniform = nodeUniform;
            this.groupNode = groupNode;
        }
        get buffer() {
            return this.nodeUniform.value;
        }
    }
    class UniformsGroup extends UniformBuffer {
        constructor(name) {
            super(name);
            this.isUniformsGroup = true;
            this._values = null;
            this.uniforms = [];
        }
        addUniform(uniform) {
            this.uniforms.push(uniform);
            return this;
        }
        removeUniform(uniform) {
            const index = this.uniforms.indexOf(uniform);
            if (index !== -1) {
                this.uniforms.splice(index, 1);
            }
            return this;
        }
        get values() {
            if (this._values === null) {
                this._values = Array.from(this.buffer);
            }
            return this._values;
        }
        get buffer() {
            let buffer = this._buffer;
            if (buffer === null) {
                const byteLength = this.byteLength;
                buffer = new Float32Array(new ArrayBuffer(byteLength));
                this._buffer = buffer;
            }
            return buffer;
        }
        get byteLength() {
            const bytesPerElement = this.bytesPerElement;
            let offset = 0; // global buffer offset in bytes
            for (let i = 0, l = this.uniforms.length; i < l; i++) {
                const uniform = this.uniforms[i];
                const boundary = uniform.boundary;
                const itemSize = uniform.itemSize * bytesPerElement; // size of the uniform in bytes
                const chunkOffset = offset % GPU_CHUNK_BYTES; // offset in the current chunk
                const chunkPadding = chunkOffset % boundary; // required padding to match boundary
                const chunkStart = chunkOffset + chunkPadding; // start position in the current chunk for the data
                offset += chunkPadding;
                // Check for chunk overflow
                if (chunkStart !== 0 && (GPU_CHUNK_BYTES - chunkStart) < itemSize) {
                    // Add padding to the end of the chunk
                    offset += (GPU_CHUNK_BYTES - chunkStart);
                }
                uniform.offset = offset / bytesPerElement;
                offset += itemSize;
            }
            return Math.ceil(offset / GPU_CHUNK_BYTES) * GPU_CHUNK_BYTES;
        }
        update() {
            let updated = false;
            for (const uniform of this.uniforms) {
                if (this.updateByType(uniform) === true) {
                    updated = true;
                }
            }
            return updated;
        }
        updateByType(uniform) {
            if (uniform.isNumberUniform) return this.updateNumber(uniform);
            if (uniform.isVector2Uniform) return this.updateVector2(uniform);
            if (uniform.isVector3Uniform) return this.updateVector3(uniform);
            if (uniform.isVector4Uniform) return this.updateVector4(uniform);
            if (uniform.isColorUniform) return this.updateColor(uniform);
            if (uniform.isMatrix3Uniform) return this.updateMatrix3(uniform);
            if (uniform.isMatrix4Uniform) return this.updateMatrix4(uniform);
            console.error('THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform);
        }
        updateNumber(uniform) {
            let updated = false;
            const a = this.values;
            const v = uniform.getValue();
            const offset = uniform.offset;
            const type = uniform.getType();
            if (a[offset] !== v) {
                const b = this._getBufferForType(type);
                b[offset] = a[offset] = v;
                updated = true;
            }
            return updated;
        }
        updateVector2(uniform) {
            let updated = false;
            const a = this.values;
            const v = uniform.getValue();
            const offset = uniform.offset;
            const type = uniform.getType();
            if (a[offset + 0] !== v.x || a[offset + 1] !== v.y) {
                const b = this._getBufferForType(type);
                b[offset + 0] = a[offset + 0] = v.x;
                b[offset + 1] = a[offset + 1] = v.y;
                updated = true;
            }
            return updated;
        }
        updateVector3(uniform) {
            let updated = false;
            const a = this.values;
            const v = uniform.getValue();
            const offset = uniform.offset;
            const type = uniform.getType();
            if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z) {
                const b = this._getBufferForType(type);
                b[offset + 0] = a[offset + 0] = v.x;
                b[offset + 1] = a[offset + 1] = v.y;
                b[offset + 2] = a[offset + 2] = v.z;
                updated = true;
            }
            return updated;
        }
        updateVector4(uniform) {
            let updated = false;
            const a = this.values;
            const v = uniform.getValue();
            const offset = uniform.offset;
            const type = uniform.getType();
            if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z || a[offset + 4] !== v.w) {
                const b = this._getBufferForType(type);
                b[offset + 0] = a[offset + 0] = v.x;
                b[offset + 1] = a[offset + 1] = v.y;
                b[offset + 2] = a[offset + 2] = v.z;
                b[offset + 3] = a[offset + 3] = v.w;
                updated = true;
            }
            return updated;
        }
        updateColor(uniform) {
            let updated = false;
            const a = this.values;
            const c = uniform.getValue();
            const offset = uniform.offset;
            if (a[offset + 0] !== c.r || a[offset + 1] !== c.g || a[offset + 2] !== c.b) {
                const b = this.buffer;
                b[offset + 0] = a[offset + 0] = c.r;
                b[offset + 1] = a[offset + 1] = c.g;
                b[offset + 2] = a[offset + 2] = c.b;
                updated = true;
            }
            return updated;
        }
        updateMatrix3(uniform) {
            let updated = false;
            const a = this.values;
            const e = uniform.getValue().elements;
            const offset = uniform.offset;
            if (a[offset + 0] !== e[0] || a[offset + 1] !== e[1] || a[offset + 2] !== e[2] ||
                a[offset + 4] !== e[3] || a[offset + 5] !== e[4] || a[offset + 6] !== e[5] ||
                a[offset + 8] !== e[6] || a[offset + 9] !== e[7] || a[offset + 10] !== e[8]) {
                const b = this.buffer;
                b[offset + 0] = a[offset + 0] = e[0];
                b[offset + 1] = a[offset + 1] = e[1];
                b[offset + 2] = a[offset + 2] = e[2];
                b[offset + 4] = a[offset + 4] = e[3];
                b[offset + 5] = a[offset + 5] = e[4];
                b[offset + 6] = a[offset + 6] = e[5];
                b[offset + 8] = a[offset + 8] = e[6];
                b[offset + 9] = a[offset + 9] = e[7];
                b[offset + 10] = a[offset + 10] = e[8];
                updated = true;
            }
            return updated;
        }
        updateMatrix4(uniform) {
            let updated = false;
            const a = this.values;
            const e = uniform.getValue().elements;
            const offset = uniform.offset;
            if (arraysEqual(a, e, offset) === false) {
                const b = this.buffer;
                b.set(e, offset);
                setArray(a, e, offset);
                updated = true;
            }
            return updated;
        }
        _getBufferForType(type) {
            if (type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4') return new Int32Array(this.buffer.buffer);
            if (type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4') return new Uint32Array(this.buffer.buffer);
            return this.buffer;
        }
    }
    function setArray(a, b, offset) {
        for (let i = 0, l = b.length; i < l; i++) {
            a[offset + i] = b[i];
        }
    }
    function arraysEqual(a, b, offset) {
        for (let i = 0, l = b.length; i < l; i++) {
            if (a[offset + i] !== b[i]) return false;
        }
        return true;
    }
    let _id$3 = 0;
    class NodeUniformsGroup extends UniformsGroup {
        constructor(name, groupNode) {
            super(name);
            this.id = _id$3++;
            this.groupNode = groupNode;
            this.isNodeUniformsGroup = true;
        }
    }
    class Sampler extends Binding {
        constructor(name, texture) {
            super(name);
            this._onDisposeTexture = () => {
                this.texture = null;
            };
            this.texture = texture;
            this.version = texture ? texture.version : 0;
            this.generation = null;
            this.isSampler = true;
        }
        set texture(value) {
            if (this._texture === value) return;
            if (this._texture) {
                this._texture.removeEventListener('dispose', this._onDisposeTexture);
            }
            this._texture = value;
            this.generation = null;
            this.version = 0;
            if (this._texture) {
                this._texture.addEventListener('dispose', this._onDisposeTexture);
            }
        }
        get texture() {
            return this._texture;
        }
        update() {
            const { texture, version } = this;
            if (version !== texture.version) {
                this.version = texture.version;
                return true;
            }
            return false;
        }
    }
    let _id$10 = 0;
    class SampledTexture extends Sampler {
        constructor(name, texture) {
            super(name, texture);
            this.id = _id$10++;
            this.store = false;
            this.isSampledTexture = true;
        }
    }
    class NodeSampledTexture extends SampledTexture {
        constructor(name, textureNode, groupNode, access = null) {
            super(name, textureNode ? textureNode.value : null);
            this.textureNode = textureNode;
            this.groupNode = groupNode;
            this.access = access;
        }
        update() {
            const { textureNode } = this;
            if (this.texture !== textureNode.value) {
                this.texture = textureNode.value;
                return true;
            }
            return super.update();
        }
    }
    class NodeSampledCubeTexture extends NodeSampledTexture {
        constructor(name, textureNode, groupNode, access = null) {
            super(name, textureNode, groupNode, access);
            this.isSampledCubeTexture = true;
        }
    }
    class NodeSampledTexture3D extends NodeSampledTexture {
        constructor(name, textureNode, groupNode, access = null) {
            super(name, textureNode, groupNode, access);
            this.isSampledTexture3D = true;
        }
    }
    const glslMethods = {
        textureDimensions: 'textureSize',
        equals: 'equal'
    };
    const precisionLib = {
        low: 'lowp',
        medium: 'mediump',
        high: 'highp'
    };
    const supports$1 = {
        swizzleAssign: true,
        storageBuffer: false
    };
    const interpolationTypeMap = {
        perspective: 'smooth',
        linear: 'noperspective'
    };
    const interpolationModeMap = {
        'centroid': 'centroid'
    };
    const defaultPrecisions = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;
precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;
precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;
precision lowp sampler2DShadow;
precision lowp sampler2DArrayShadow;
precision lowp samplerCubeShadow;
`;
    class GLSLNodeBuilder extends NodeBuilder {
        constructor(object, renderer) {
            super(object, renderer, new GLSLNodeParser());
            this.uniformGroups = {};
            this.transforms = [];
            this.extensions = {};
            this.builtins = { vertex: [], fragment: [], compute: [] };
        }
        needsToWorkingColorSpace(texture) {
            return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;
        }
        getMethod(method) {
            return glslMethods[method] || method;
        }
        getOutputStructName() {
            return '';
        }
        buildFunctionCode(shaderNode) {
            const layout = shaderNode.layout;
            const flowData = this.flowShaderNode(shaderNode);
            const parameters = [];
            for (const input of layout.inputs) {
                parameters.push(this.getType(input.type) + ' ' + input.name);
            }
            //
            const code = `${this.getType(layout.type)} ${layout.name}( ${parameters.join(', ')} ) {
	${flowData.vars}
${flowData.code}
	return ${flowData.result};
}`;
            //
            return code;
        }
        setupPBO(storageBufferNode) {
            const attribute = storageBufferNode.value;
            if (attribute.pbo === undefined) {
                const originalArray = attribute.array;
                const numElements = attribute.count * attribute.itemSize;
                const { itemSize } = attribute;
                const isInteger = attribute.array.constructor.name.toLowerCase().includes('int');
                let format = isInteger ? RedIntegerFormat : RedFormat;
                if (itemSize === 2) {
                    format = isInteger ? RGIntegerFormat : RGFormat;
                } else if (itemSize === 3) {
                    format = isInteger ? RGBIntegerFormat : RGBFormat;
                } else if (itemSize === 4) {
                    format = isInteger ? RGBAIntegerFormat : RGBAFormat;
                }
                const typeMap = {
                    Float32Array: FloatType,
                    Uint8Array: UnsignedByteType,
                    Uint16Array: UnsignedShortType,
                    Uint32Array: UnsignedIntType,
                    Int8Array: ByteType,
                    Int16Array: ShortType,
                    Int32Array: IntType,
                    Uint8ClampedArray: UnsignedByteType,
                };
                const width = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(numElements / itemSize))));
                let height = Math.ceil((numElements / itemSize) / width);
                if (width * height * itemSize < numElements) height++; // Ensure enough space
                const newSize = width * height * itemSize;
                const newArray = new originalArray.constructor(newSize);
                newArray.set(originalArray, 0);
                attribute.array = newArray;
                const pboTexture = new DataTexture(attribute.array, width, height, format, typeMap[attribute.array.constructor.name] || FloatType);
                pboTexture.needsUpdate = true;
                pboTexture.isPBOTexture = true;
                const pbo = new TextureNode(pboTexture, null, null);
                pbo.setPrecision('high');
                attribute.pboNode = pbo;
                attribute.pbo = pbo.value;
                this.getUniformFromNode(attribute.pboNode, 'texture', this.shaderStage, this.context.nodeName);
            }
        }
        getPropertyName(node, shaderStage = this.shaderStage) {
            if (node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true) {
                return shaderStage.charAt(0) + '_' + node.name;
            }
            return super.getPropertyName(node, shaderStage);
        }
        generatePBO(storageArrayElementNode) {
            const { node, indexNode } = storageArrayElementNode;
            const attribute = node.value;
            if (this.renderer.backend.has(attribute)) {
                const attributeData = this.renderer.backend.get(attribute);
                attributeData.pbo = attribute.pbo;
            }
            const nodeUniform = this.getUniformFromNode(attribute.pboNode, 'texture', this.shaderStage, this.context.nodeName);
            const textureName = this.getPropertyName(nodeUniform);
            this.increaseUsage(indexNode); // force cache generate to be used as index in x,y
            const indexSnippet = indexNode.build(this, 'uint');
            const elementNodeData = this.getDataFromNode(storageArrayElementNode);
            let propertyName = elementNodeData.propertyName;
            if (propertyName === undefined) {
                // property element
                const nodeVar = this.getVarFromNode(storageArrayElementNode);
                propertyName = this.getPropertyName(nodeVar);
                // property size
                const bufferNodeData = this.getDataFromNode(node);
                let propertySizeName = bufferNodeData.propertySizeName;
                if (propertySizeName === undefined) {
                    propertySizeName = propertyName + 'Size';
                    this.getVarFromNode(node, propertySizeName, 'uint');
                    this.addLineFlowCode(`${propertySizeName} = uint( textureSize( ${textureName}, 0 ).x )`, storageArrayElementNode);
                    bufferNodeData.propertySizeName = propertySizeName;
                }
                //
                const { itemSize } = attribute;
                const channel = '.' + vectorComponents.join('').slice(0, itemSize);
                const uvSnippet = `ivec2(${indexSnippet} % ${propertySizeName}, ${indexSnippet} / ${propertySizeName})`;
                const snippet = this.generateTextureLoad(null, textureName, uvSnippet, null, '0');
                //

                let prefix = 'vec4';
                if (attribute.pbo.type === UnsignedIntType) {
                    prefix = 'uvec4';
                } else if (attribute.pbo.type === IntType) {
                    prefix = 'ivec4';
                }
                this.addLineFlowCode(`${propertyName} = ${prefix}(${snippet})${channel}`, storageArrayElementNode);
                elementNodeData.propertyName = propertyName;
            }
            return propertyName;
        }
        generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0') {
            if (depthSnippet) {
                return `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`;
            } else {
                return `texelFetch( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;
            }
        }
        generateTexture(texture, textureProperty, uvSnippet, depthSnippet) {
            if (texture.isDepthTexture) {
                if (depthSnippet) uvSnippet = `vec4( ${uvSnippet}, ${depthSnippet} )`;
                return `texture( ${textureProperty}, ${uvSnippet} ).x`;
            } else {
                if (depthSnippet) uvSnippet = `vec3( ${uvSnippet}, ${depthSnippet} )`;
                return `texture( ${textureProperty}, ${uvSnippet} )`;
            }
        }
        generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet) {
            return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;
        }
        generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet) {
            return `texture( ${textureProperty}, ${uvSnippet}, ${biasSnippet} )`;
        }
        generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet) {
            return `textureGrad( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]} )`;
        }
        generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage) {
            if (shaderStage === 'fragment') {
                if (depthSnippet) {
                    return `texture( ${textureProperty}, vec4( ${uvSnippet}, ${depthSnippet}, ${compareSnippet} ) )`;
                }
                return `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;
            } else {
                console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
            }
        }
        getVars(shaderStage) {
            const snippets = [];
            const vars = this.vars[shaderStage];
            if (vars !== undefined) {
                for (const variable of vars) {
                    snippets.push(`${this.getVar(variable.type, variable.name, variable.count)};`);
                }
            }
            return snippets.join('\n\t');
        }
        getUniforms(shaderStage) {
            const uniforms = this.uniforms[shaderStage];
            const bindingSnippets = [];
            const uniformGroups = {};
            for (const uniform of uniforms) {
                let snippet = null;
                let group = false;
                if (uniform.type === 'texture' || uniform.type === 'texture3D') {
                    const texture = uniform.node.value;
                    let typePrefix = '';
                    if (texture.isDataTexture === true || texture.isData3DTexture === true) {
                        if (texture.type === UnsignedIntType) {
                            typePrefix = 'u';
                        } else if (texture.type === IntType) {
                            typePrefix = 'i';
                        }
                    }
                    if (uniform.type === 'texture3D' && texture.isArrayTexture === false) {
                        snippet = `${typePrefix}sampler3D ${uniform.name};`;
                    } else if (texture.compareFunction) {
                        if (texture.isArrayTexture === true) {
                            snippet = `sampler2DArrayShadow ${uniform.name};`;
                        } else {
                            snippet = `sampler2DShadow ${uniform.name};`;
                        }
                    } else if (texture.isArrayTexture === true || texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true) {
                        snippet = `${typePrefix}sampler2DArray ${uniform.name};`;
                    } else {
                        snippet = `${typePrefix}sampler2D ${uniform.name};`;
                    }
                } else if (uniform.type === 'cubeTexture') {
                    snippet = `samplerCube ${uniform.name};`;
                } else if (uniform.type === 'buffer') {
                    const bufferNode = uniform.node;
                    const bufferType = this.getType(bufferNode.bufferType);
                    const bufferCount = bufferNode.bufferCount;
                    const bufferCountSnippet = bufferCount > 0 ? bufferCount : '';
                    snippet = `${bufferNode.name} {\n\t${bufferType} ${uniform.name}[${bufferCountSnippet}];\n};\n`;
                } else {
                    const vectorType = this.getVectorType(uniform.type);
                    snippet = `${vectorType} ${this.getPropertyName(uniform, shaderStage)};`;
                    group = true;
                }
                const precision = uniform.node.precision;
                if (precision !== null) {
                    snippet = precisionLib[precision] + ' ' + snippet;
                }
                if (group) {
                    snippet = '\t' + snippet;
                    const groupName = uniform.groupNode.name;
                    const groupSnippets = uniformGroups[groupName] || (uniformGroups[groupName] = []);
                    groupSnippets.push(snippet);
                } else {
                    snippet = 'uniform ' + snippet;
                    bindingSnippets.push(snippet);
                }
            }
            let output = '';
            for (const name in uniformGroups) {
                const groupSnippets = uniformGroups[name];
                output += this._getGLSLUniformStruct(shaderStage + '_' + name, groupSnippets.join('\n')) + '\n';
            }
            output += bindingSnippets.join('\n');
            return output;
        }
        getTypeFromAttribute(attribute) {
            let nodeType = super.getTypeFromAttribute(attribute);
            if (/^[iu]/.test(nodeType) && attribute.gpuType !== IntType) {
                let dataAttribute = attribute;
                if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;
                const array = dataAttribute.array;
                if ((array instanceof Uint32Array || array instanceof Int32Array) === false) {
                    nodeType = nodeType.slice(1);
                }
            }
            return nodeType;
        }
        getAttributes(shaderStage) {
            let snippet = '';
            if (shaderStage === 'vertex' || shaderStage === 'compute') {
                const attributes = this.getAttributesArray();
                let location = 0;
                for (const attribute of attributes) {
                    snippet += `layout( location = ${location++} ) in ${attribute.type} ${attribute.name};\n`;
                }
            }
            return snippet;
        }
        getStructMembers(struct) {
            const snippets = [];
            for (const member of struct.members) {
                snippets.push(`\t${member.type} ${member.name};`);
            }
            return snippets.join('\n');
        }
        getStructs(shaderStage) {
            const snippets = [];
            const structs = this.structs[shaderStage];
            const outputSnippet = [];
            for (const struct of structs) {
                if (struct.output) {
                    for (const member of struct.members) {
                        outputSnippet.push(`layout( location = ${member.index} ) out ${member.type} ${member.name};`);
                    }
                } else {
                    let snippet = 'struct ' + struct.name + ' {\n';
                    snippet += this.getStructMembers(struct);
                    snippet += '\n};\n';
                    snippets.push(snippet);
                }
            }
            if (outputSnippet.length === 0) {
                outputSnippet.push('layout( location = 0 ) out vec4 fragColor;');
            }
            return '\n' + outputSnippet.join('\n') + '\n\n' + snippets.join('\n');
        }
        getVaryings(shaderStage) {
            let snippet = '';
            const varyings = this.varyings;
            if (shaderStage === 'vertex' || shaderStage === 'compute') {
                for (const varying of varyings) {
                    if (shaderStage === 'compute') varying.needsInterpolation = true;
                    const type = this.getType(varying.type);
                    if (varying.needsInterpolation) {
                        if (varying.interpolationType) {
                            const interpolationType = interpolationTypeMap[varying.interpolationType] || varying.interpolationType;
                            const sampling = interpolationModeMap[varying.interpolationSampling] || '';
                            snippet += `${interpolationType} ${sampling} out ${type} ${varying.name};\n`;
                        } else {
                            const flat = type.includes('int') || type.includes('uv') || type.includes('iv') ? 'flat ' : '';
                            snippet += `${flat}out ${type} ${varying.name};\n`;
                        }
                    } else {
                        snippet += `${type} ${varying.name};\n`; // generate variable (no varying required)
                    }
                }
            } else if (shaderStage === 'fragment') {
                for (const varying of varyings) {
                    if (varying.needsInterpolation) {
                        const type = this.getType(varying.type);
                        if (varying.interpolationType) {
                            const interpolationType = interpolationTypeMap[varying.interpolationType] || varying.interpolationType;
                            const sampling = interpolationModeMap[varying.interpolationSampling] || '';
                            snippet += `${interpolationType} ${sampling} in ${type} ${varying.name};\n`;

                        } else {
                            const flat = type.includes('int') || type.includes('uv') || type.includes('iv') ? 'flat ' : '';
                            snippet += `${flat}in ${type} ${varying.name};\n`;
                        }
                    }
                }
            }
            for (const builtin of this.builtins[shaderStage]) {
                snippet += `${builtin};\n`;
            }
            return snippet;
        }
        getVertexIndex() {
            return 'uint( gl_VertexID )';
        }
        getInstanceIndex() {
            return 'uint( gl_InstanceID )';
        }
        getInvocationLocalIndex() {
            const workgroupSize = this.object.workgroupSize;
            const size = workgroupSize.reduce((acc, curr) => acc * curr, 1);
            return `uint( gl_InstanceID ) % ${size}u`;
        }
        getDrawIndex() {
            const extensions = this.renderer.backend.extensions;
            if (extensions.has('WEBGL_multi_draw')) {
                return 'uint( gl_DrawID )';
            }
            return null;
        }
        getFrontFacing() {
            return 'gl_FrontFacing';
        }
        getFragCoord() {
            return 'gl_FragCoord.xy';
        }
        getFragDepth() {
            return 'gl_FragDepth';
        }
        enableExtension(name, behavior, shaderStage = this.shaderStage) {
            const map = this.extensions[shaderStage] || (this.extensions[shaderStage] = new Map());
            if (map.has(name) === false) {
                map.set(name, {
                    name,
                    behavior
                });
            }
        }
        getExtensions(shaderStage) {
            const snippets = [];
            if (shaderStage === 'vertex') {
                const ext = this.renderer.backend.extensions;
                const isBatchedMesh = this.object.isBatchedMesh;
                if (isBatchedMesh && ext.has('WEBGL_multi_draw')) {
                    this.enableExtension('GL_ANGLE_multi_draw', 'require', shaderStage);
                }
            }
            const extensions = this.extensions[shaderStage];
            if (extensions !== undefined) {
                for (const { name, behavior } of extensions.values()) {
                    snippets.push(`#extension ${name} : ${behavior}`);
                }
            }
            return snippets.join('\n');
        }
        getClipDistance() {
            return 'gl_ClipDistance';
        }
        isAvailable(name) {
            let result = supports$1[name];
            if (result === undefined) {
                let extensionName;
                result = false;
                switch (name) {
                    case 'float32Filterable':
                        extensionName = 'OES_texture_float_linear';
                        break;
                    case 'clipDistance':
                        extensionName = 'WEBGL_clip_cull_distance';
                        break;
                }
                if (extensionName !== undefined) {
                    const extensions = this.renderer.backend.extensions;
                    if (extensions.has(extensionName)) {
                        extensions.get(extensionName);
                        result = true;
                    }
                }
                supports$1[name] = result;
            }
            return result;
        }
        isFlipY() {
            return true;
        }
        enableHardwareClipping(planeCount) {
            this.enableExtension('GL_ANGLE_clip_cull_distance', 'require');
            this.builtins['vertex'].push(`out float gl_ClipDistance[ ${planeCount} ]`);
        }
        enableMultiview() {
            this.enableExtension('GL_OVR_multiview2', 'require', 'fragment');
            this.enableExtension('GL_OVR_multiview2', 'require', 'vertex');
            this.builtins['vertex'].push('layout(num_views = 2) in');
        }
        registerTransform(varyingName, attributeNode) {
            this.transforms.push({ varyingName, attributeNode });
        }
        getTransforms( /* shaderStage  */) {
            const transforms = this.transforms;
            let snippet = '';
            for (let i = 0; i < transforms.length; i++) {
                const transform = transforms[i];
                const attributeName = this.getPropertyName(transform.attributeNode);
                if (attributeName) snippet += `${transform.varyingName} = ${attributeName};\n\t`;
            }
            return snippet;
        }
        _getGLSLUniformStruct(name, vars) {
            return `
layout( std140 ) uniform ${name} {
${vars}
};`;
        }
        _getGLSLVertexCode(shaderData) {
            return `#version 300 es
${this.getSignature()}
// extensions
${shaderData.extensions}
// precision
${defaultPrecisions}
// uniforms
${shaderData.uniforms}
// varyings
${shaderData.varyings}
// attributes
${shaderData.attributes}
// codes
${shaderData.codes}
void main() {
	// vars
	${shaderData.vars}
	// transforms
	${shaderData.transforms}
	// flow
	${shaderData.flow}
	gl_PointSize = 1.0;
}
`;
        }
        _getGLSLFragmentCode(shaderData) {
            return `#version 300 es
${this.getSignature()}
// extensions
${shaderData.extensions}
// precision
${defaultPrecisions}
// uniforms
${shaderData.uniforms}
// varyings
${shaderData.varyings}
// codes
${shaderData.codes}
// structs
${shaderData.structs}
void main() {
	// vars
	${shaderData.vars}
	// flow
	${shaderData.flow}
}
`;
        }
        buildCode() {
            const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
            this.sortBindingGroups();
            for (const shaderStage in shadersData) {
                let flow = '// code\n\n';
                flow += this.flowCode[shaderStage];
                const flowNodes = this.flowNodes[shaderStage];
                const mainNode = flowNodes[flowNodes.length - 1];
                for (const node of flowNodes) {
                    const flowSlotData = this.getFlowData(node/*, shaderStage*/);
                    const slotName = node.name;
                    if (slotName) {
                        if (flow.length > 0) flow += '\n';
                        flow += `\t// flow -> ${slotName}\n\t`;
                    }
                    flow += `${flowSlotData.code}\n\t`;
                    if (node === mainNode && shaderStage !== 'compute') {
                        flow += '// result\n\t';
                        if (shaderStage === 'vertex') {
                            flow += 'gl_Position = ';
                            flow += `${flowSlotData.result};`;
                        } else if (shaderStage === 'fragment') {
                            if (!node.outputNode.isOutputStructNode) {
                                flow += 'fragColor = ';
                                flow += `${flowSlotData.result};`;
                            }
                        }
                    }
                }
                const stageData = shadersData[shaderStage];
                stageData.extensions = this.getExtensions(shaderStage);
                stageData.uniforms = this.getUniforms(shaderStage);
                stageData.attributes = this.getAttributes(shaderStage);
                stageData.varyings = this.getVaryings(shaderStage);
                stageData.vars = this.getVars(shaderStage);
                stageData.structs = this.getStructs(shaderStage);
                stageData.codes = this.getCodes(shaderStage);
                stageData.transforms = this.getTransforms(shaderStage);
                stageData.flow = flow;
            }
            if (this.material !== null) {
                this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);
                this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);
            } else {
                this.computeShader = this._getGLSLVertexCode(shadersData.compute);
            }
        }
        getUniformFromNode(node, type, shaderStage, name = null) {
            const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
            const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
            let uniformGPU = nodeData.uniformGPU;
            if (uniformGPU === undefined) {
                const group = node.groupNode;
                const groupName = group.name;
                const bindings = this.getBindGroupArray(groupName, shaderStage);
                if (type === 'texture') {
                    uniformGPU = new NodeSampledTexture(uniformNode.name, uniformNode.node, group);
                    bindings.push(uniformGPU);
                } else if (type === 'cubeTexture') {
                    uniformGPU = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group);
                    bindings.push(uniformGPU);
                } else if (type === 'texture3D') {
                    uniformGPU = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group);
                    bindings.push(uniformGPU);
                } else if (type === 'buffer') {
                    node.name = `NodeBuffer_${node.id}`;
                    uniformNode.name = `buffer${node.id}`;
                    const buffer = new NodeUniformBuffer(node, group);
                    buffer.name = node.name;
                    bindings.push(buffer);
                    uniformGPU = buffer;
                } else {
                    const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});
                    let uniformsGroup = uniformsStage[groupName];
                    if (uniformsGroup === undefined) {
                        uniformsGroup = new NodeUniformsGroup(shaderStage + '_' + groupName, group);
                        //uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );
                        uniformsStage[groupName] = uniformsGroup;
                        bindings.push(uniformsGroup);
                    }
                    uniformGPU = this.getNodeUniform(uniformNode, type);
                    uniformsGroup.addUniform(uniformGPU);
                }
                nodeData.uniformGPU = uniformGPU;
            }
            return uniformNode;
        }
    }
    let _vector2$2 = null;
    let _color4 = null;
    class Backend {
        constructor(parameters = {}) {
            this.parameters = Object.assign({}, parameters);
            this.data = new WeakMap();
            this.renderer = null;
            this.domElement = null;
            this.timestampQueryPool = {
                'render': null,
                'compute': null
            };
            this.trackTimestamp = (parameters.trackTimestamp === true);
        }
        async init(renderer) {
            this.renderer = renderer;
        }
        get coordinateSystem() { }
        // render context
        beginRender( /*renderContext*/) { }
        finishRender( /*renderContext*/) { }
        beginCompute( /*computeGroup*/) { }
        finishCompute( /*computeGroup*/) { }
        // render object
        draw( /*renderObject, info*/) { }
        // compute node
        compute( /*computeGroup, computeNode, computeBindings, computePipeline*/) { }
        // program
        createProgram( /*program*/) { }
        destroyProgram( /*program*/) { }
        // bindings
        createBindings( /*bindGroup, bindings, cacheIndex, version*/) { }
        updateBindings( /*bindGroup, bindings, cacheIndex, version*/) { }
        updateBinding( /*binding*/) { }
        // pipeline
        createRenderPipeline( /*renderObject, promises*/) { }
        createComputePipeline( /*computePipeline, bindings*/) { }
        // cache key
        needsRenderUpdate( /*renderObject*/) { }
        getRenderCacheKey( /*renderObject*/) { }
        // node builder
        createNodeBuilder( /*renderObject, renderer*/) { }
        // textures
        createSampler( /*texture*/) { }
        destroySampler( /*texture*/) { }
        createDefaultTexture( /*texture*/) { }
        createTexture( /*texture, options={}*/) { }
        updateTexture( /*texture, options = {}*/) { }
        generateMipmaps( /*texture*/) { }
        destroyTexture( /*texture*/) { }
        async copyTextureToBuffer( /*texture, x, y, width, height, faceIndex*/) { }
        copyTextureToTexture( /*srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0*/) { }
        copyFramebufferToTexture( /*texture, renderContext, rectangle*/) { }
        // attributes
        createAttribute( /*attribute*/) { }
        createIndexAttribute( /*attribute*/) { }
        createStorageAttribute( /*attribute*/) { }
        updateAttribute( /*attribute*/) { }
        destroyAttribute( /*attribute*/) { }
        // canvas
        getContext() { }
        updateSize() { }
        updateViewport( /*renderContext*/) { }
        // utils
        isOccluded( /*renderContext, object*/) { }
        async resolveTimestampsAsync(type = 'render') {
            if (!this.trackTimestamp) {
                warnOnce('WebGPURenderer: Timestamp tracking is disabled.');
                return;
            }
            const queryPool = this.timestampQueryPool[type];
            if (!queryPool) {
                warnOnce(`WebGPURenderer: No timestamp query pool for type '${type}' found.`);
                return;
            }
            const duration = await queryPool.resolveQueriesAsync();
            this.renderer.info[type].timestamp = duration;
            return duration;
        }
        async waitForGPU() { }
        async getArrayBufferAsync( /* attribute */) { }
        async hasFeatureAsync( /*name*/) { }
        hasFeature( /*name*/) { }
        getMaxAnisotropy() { }
        getDrawingBufferSize() {
            _vector2$2 = _vector2$2 || new Vector2();
            return this.renderer.getDrawingBufferSize(_vector2$2);
        }
        setScissorTest( /*boolean*/) { }
        getClearColor() {
            const renderer = this.renderer;
            _color4 = _color4 || new Color4();
            renderer.getClearColor(_color4);
            _color4.getRGB(_color4);
            return _color4;
        }
        getDomElement() {
            let domElement = this.domElement;
            if (domElement === null) {
                domElement = (this.parameters.canvas !== undefined) ? this.parameters.canvas : createCanvasElement();
                // OffscreenCanvas does not have setAttribute, see #22811
                if ('setAttribute' in domElement) domElement.setAttribute('data-engine', `three.js r${REVISION} webgpu`);
                this.domElement = domElement;
            }
            return domElement;
        }
        set(object, value) {
            this.data.set(object, value);
        }
        get(object) {
            let map = this.data.get(object);
            if (map === undefined) {
                map = {};
                this.data.set(object, map);
            }
            return map;
        }
        has(object) {
            return this.data.has(object);
        }
        delete(object) {
            this.data.delete(object);
        }
        dispose() { }
    }
    let _id$11 = 0;
    class DualAttributeData {
        constructor(attributeData, dualBuffer) {
            this.buffers = [attributeData.bufferGPU, dualBuffer];
            this.type = attributeData.type;
            this.bufferType = attributeData.bufferType;
            this.pbo = attributeData.pbo;
            this.byteLength = attributeData.byteLength;
            this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;
            this.version = attributeData.version;
            this.isInteger = attributeData.isInteger;
            this.activeBufferIndex = 0;
            this.baseId = attributeData.id;
        }

        get id() {
            return `${this.baseId}|${this.activeBufferIndex}`;
        }
        get bufferGPU() {
            return this.buffers[this.activeBufferIndex];
        }
        get transformBuffer() {
            return this.buffers[this.activeBufferIndex ^ 1];
        }
        switchBuffers() {
            this.activeBufferIndex ^= 1;
        }
    }
    class WebGLAttributeUtils {
        constructor(backend) {
            this.backend = backend;
        }
        createAttribute(attribute, bufferType) {
            const backend = this.backend;
            const { gl } = backend;
            const array = attribute.array;
            const usage = attribute.usage || gl.STATIC_DRAW;
            const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
            const bufferData = backend.get(bufferAttribute);
            let bufferGPU = bufferData.bufferGPU;
            if (bufferGPU === undefined) {
                bufferGPU = this._createBuffer(gl, bufferType, array, usage);
                bufferData.bufferGPU = bufferGPU;
                bufferData.bufferType = bufferType;
                bufferData.version = bufferAttribute.version;
            }
            //attribute.onUploadCallback();
            let type;
            if (array instanceof Float32Array) {
                type = gl.FLOAT;
            } else if (typeof Float16Array !== 'undefined' && array instanceof Float16Array) {
                type = gl.HALF_FLOAT;
            } else if (array instanceof Uint16Array) {
                if (attribute.isFloat16BufferAttribute) {
                    type = gl.HALF_FLOAT;
                } else {
                    type = gl.UNSIGNED_SHORT;
                }
            } else if (array instanceof Int16Array) {
                type = gl.SHORT;
            } else if (array instanceof Uint32Array) {
                type = gl.UNSIGNED_INT;
            } else if (array instanceof Int32Array) {
                type = gl.INT;
            } else if (array instanceof Int8Array) {
                type = gl.BYTE;
            } else if (array instanceof Uint8Array) {
                type = gl.UNSIGNED_BYTE;
            } else if (array instanceof Uint8ClampedArray) {
                type = gl.UNSIGNED_BYTE;
            } else {
                throw new Error('THREE.WebGLBackend: Unsupported buffer data format: ' + array);
            }
            let attributeData = {
                bufferGPU,
                bufferType,
                type,
                byteLength: array.byteLength,
                bytesPerElement: array.BYTES_PER_ELEMENT,
                version: attribute.version,
                pbo: attribute.pbo,
                isInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,
                id: _id$11++
            };
            if (attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute) {
                // create buffer for transform feedback use
                const bufferGPUDual = this._createBuffer(gl, bufferType, array, usage);
                attributeData = new DualAttributeData(attributeData, bufferGPUDual);
            }
            backend.set(attribute, attributeData);
        }
        updateAttribute(attribute) {
            const backend = this.backend;
            const { gl } = backend;
            const array = attribute.array;
            const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
            const bufferData = backend.get(bufferAttribute);
            const bufferType = bufferData.bufferType;
            const updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;
            gl.bindBuffer(bufferType, bufferData.bufferGPU);
            if (updateRanges.length === 0) {
                // Not using update ranges
                gl.bufferSubData(bufferType, 0, array);
            } else {
                for (let i = 0, l = updateRanges.length; i < l; i++) {
                    const range = updateRanges[i];
                    gl.bufferSubData(bufferType, range.start * array.BYTES_PER_ELEMENT,
                        array, range.start, range.count);
                }
                bufferAttribute.clearUpdateRanges();
            }
            gl.bindBuffer(bufferType, null);
            bufferData.version = bufferAttribute.version;
        }
        destroyAttribute(attribute) {
            const backend = this.backend;
            const { gl } = backend;
            if (attribute.isInterleavedBufferAttribute) {
                backend.delete(attribute.data);
            }
            const attributeData = backend.get(attribute);
            gl.deleteBuffer(attributeData.bufferGPU);
            backend.delete(attribute);
        }
        async getArrayBufferAsync(attribute) {
            const backend = this.backend;
            const { gl } = backend;
            const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
            const { bufferGPU } = backend.get(bufferAttribute);
            const array = attribute.array;
            const byteLength = array.byteLength;
            gl.bindBuffer(gl.COPY_READ_BUFFER, bufferGPU);
            const writeBuffer = gl.createBuffer();
            gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);
            gl.bufferData(gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ);
            gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength);
            await backend.utils._clientWaitAsync();
            const dstBuffer = new attribute.array.constructor(array.length);
            // Ensure the buffer is bound before reading
            gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);
            gl.getBufferSubData(gl.COPY_WRITE_BUFFER, 0, dstBuffer);
            gl.deleteBuffer(writeBuffer);
            gl.bindBuffer(gl.COPY_READ_BUFFER, null);
            gl.bindBuffer(gl.COPY_WRITE_BUFFER, null);
            return dstBuffer.buffer;
        }
        _createBuffer(gl, bufferType, array, usage) {
            const bufferGPU = gl.createBuffer();
            gl.bindBuffer(bufferType, bufferGPU);
            gl.bufferData(bufferType, array, usage);
            gl.bindBuffer(bufferType, null);
            return bufferGPU;
        }
    }
    let equationToGL, factorToGL;
    class WebGLState {
        constructor(backend) {
            this.backend = backend;
            this.gl = this.backend.gl;
            // Below properties are intended to cache
            // the WebGL state and are not explicitly
            // documented for convenience reasons.
            this.enabled = {};
            this.currentFlipSided = null;
            this.currentCullFace = null;
            this.currentProgram = null;
            this.currentBlendingEnabled = false;
            this.currentBlending = null;
            this.currentBlendSrc = null;
            this.currentBlendDst = null;
            this.currentBlendSrcAlpha = null;
            this.currentBlendDstAlpha = null;
            this.currentPremultipledAlpha = null;
            this.currentPolygonOffsetFactor = null;
            this.currentPolygonOffsetUnits = null;
            this.currentColorMask = null;
            this.currentDepthFunc = null;
            this.currentDepthMask = null;
            this.currentStencilFunc = null;
            this.currentStencilRef = null;
            this.currentStencilFuncMask = null;
            this.currentStencilFail = null;
            this.currentStencilZFail = null;
            this.currentStencilZPass = null;
            this.currentStencilMask = null;
            this.currentLineWidth = null;
            this.currentClippingPlanes = 0;
            this.currentVAO = null;
            this.currentIndex = null;
            this.currentBoundFramebuffers = {};
            this.currentDrawbuffers = new WeakMap();
            this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
            this.currentTextureSlot = null;
            this.currentBoundTextures = {};
            this.currentBoundBufferBases = {};

            this._init();
        }
        _init() {
            const gl = this.gl;
            // Store only WebGL constants here.
            equationToGL = {
                [AddEquation]: gl.FUNC_ADD,
                [SubtractEquation]: gl.FUNC_SUBTRACT,
                [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
            };
            factorToGL = {
                [ZeroFactor]: gl.ZERO,
                [OneFactor]: gl.ONE,
                [SrcColorFactor]: gl.SRC_COLOR,
                [SrcAlphaFactor]: gl.SRC_ALPHA,
                [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
                [DstColorFactor]: gl.DST_COLOR,
                [DstAlphaFactor]: gl.DST_ALPHA,
                [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
                [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
                [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
                [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
            };
            const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
            const viewportParam = gl.getParameter(gl.VIEWPORT);
            this.currentScissor = new Vector4().fromArray(scissorParam);
            this.currentViewport = new Vector4().fromArray(viewportParam);
            this._tempVec4 = new Vector4();
        }
        enable(id) {
            const { enabled } = this;
            if (enabled[id] !== true) {
                this.gl.enable(id);
                enabled[id] = true;
            }
        }
        disable(id) {
            const { enabled } = this;
            if (enabled[id] !== false) {
                this.gl.disable(id);
                enabled[id] = false;
            }
        }
        setFlipSided(flipSided) {
            if (this.currentFlipSided !== flipSided) {
                const { gl } = this;
                if (flipSided) {
                    gl.frontFace(gl.CW);
                } else {
                    gl.frontFace(gl.CCW);
                }
                this.currentFlipSided = flipSided;
            }
        }
        setCullFace(cullFace) {
            const { gl } = this;
            if (cullFace !== CullFaceNone) {
                this.enable(gl.CULL_FACE);
                if (cullFace !== this.currentCullFace) {
                    if (cullFace === CullFaceBack) {
                        gl.cullFace(gl.BACK);
                    } else if (cullFace === CullFaceFront) {
                        gl.cullFace(gl.FRONT);
                    } else {
                        gl.cullFace(gl.FRONT_AND_BACK);
                    }
                }
            } else {
                this.disable(gl.CULL_FACE);
            }
            this.currentCullFace = cullFace;
        }
        setLineWidth(width) {
            const { currentLineWidth, gl } = this;
            if (width !== currentLineWidth) {
                gl.lineWidth(width);
                this.currentLineWidth = width;
            }
        }
        setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
            const { gl } = this;
            if (blending === NoBlending) {
                if (this.currentBlendingEnabled === true) {
                    this.disable(gl.BLEND);
                    this.currentBlendingEnabled = false;
                }
                return;
            }
            if (this.currentBlendingEnabled === false) {
                this.enable(gl.BLEND);
                this.currentBlendingEnabled = true;
            }
            if (blending !== CustomBlending) {
                if (blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha) {
                    if (this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation) {
                        gl.blendEquation(gl.FUNC_ADD);
                        this.currentBlendEquation = AddEquation;
                        this.currentBlendEquationAlpha = AddEquation;
                    }
                    if (premultipliedAlpha) {
                        switch (blending) {
                            case NormalBlending:
                                gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                                break;
                            case AdditiveBlending:
                                gl.blendFunc(gl.ONE, gl.ONE);
                                break;
                            case SubtractiveBlending:
                                gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
                                break;
                            case MultiplyBlending:
                                gl.blendFuncSeparate(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);
                                break;
                            default:
                                console.error('THREE.WebGLState: Invalid blending: ', blending);
                                break;
                        }
                    } else {
                        switch (blending) {
                            case NormalBlending:
                                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                                break;
                            case AdditiveBlending:
                                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE);
                                break;
                            case SubtractiveBlending:
                                console.error('THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true');
                                break;
                            case MultiplyBlending:
                                console.error('THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true');
                                break;
                            default:
                                console.error('THREE.WebGLState: Invalid blending: ', blending);
                                break;
                        }
                    }
                    this.currentBlendSrc = null;
                    this.currentBlendDst = null;
                    this.currentBlendSrcAlpha = null;
                    this.currentBlendDstAlpha = null;
                    this.currentBlending = blending;
                    this.currentPremultipledAlpha = premultipliedAlpha;
                }
                return;
            }
            // custom blending
            blendEquationAlpha = blendEquationAlpha || blendEquation;
            blendSrcAlpha = blendSrcAlpha || blendSrc;
            blendDstAlpha = blendDstAlpha || blendDst;
            if (blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha) {
                gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
                this.currentBlendEquation = blendEquation;
                this.currentBlendEquationAlpha = blendEquationAlpha;
            }
            if (blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha) {
                gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
                this.currentBlendSrc = blendSrc;
                this.currentBlendDst = blendDst;
                this.currentBlendSrcAlpha = blendSrcAlpha;
                this.currentBlendDstAlpha = blendDstAlpha;
            }
            this.currentBlending = blending;
            this.currentPremultipledAlpha = false;
        }
        setColorMask(colorMask) {
            if (this.currentColorMask !== colorMask) {
                this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                this.currentColorMask = colorMask;
            }
        }
        setDepthTest(depthTest) {
            const { gl } = this;
            if (depthTest) {
                this.enable(gl.DEPTH_TEST);
            } else {
                this.disable(gl.DEPTH_TEST);
            }
        }
        setDepthMask(depthMask) {
            if (this.currentDepthMask !== depthMask) {
                this.gl.depthMask(depthMask);
                this.currentDepthMask = depthMask;
            }
        }
        setDepthFunc(depthFunc) {
            if (this.currentDepthFunc !== depthFunc) {
                const { gl } = this;
                switch (depthFunc) {
                    case NeverDepth:
                        gl.depthFunc(gl.NEVER);
                        break;
                    case AlwaysDepth:
                        gl.depthFunc(gl.ALWAYS);
                        break;
                    case LessDepth:
                        gl.depthFunc(gl.LESS);
                        break;
                    case LessEqualDepth:
                        gl.depthFunc(gl.LEQUAL);
                        break;
                    case EqualDepth:
                        gl.depthFunc(gl.EQUAL);
                        break;
                    case GreaterEqualDepth:
                        gl.depthFunc(gl.GEQUAL);
                        break;
                    case GreaterDepth:
                        gl.depthFunc(gl.GREATER);
                        break;
                    case NotEqualDepth:
                        gl.depthFunc(gl.NOTEQUAL);
                        break;
                    default:
                        gl.depthFunc(gl.LEQUAL);
                }
                this.currentDepthFunc = depthFunc;
            }
        }
        scissor(x, y, width, height) {
            const scissor = this._tempVec4.set(x, y, width, height);
            if (this.currentScissor.equals(scissor) === false) {
                const { gl } = this;
                gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
                this.currentScissor.copy(scissor);
            }
        }
        viewport(x, y, width, height) {
            const viewport = this._tempVec4.set(x, y, width, height);
            if (this.currentViewport.equals(viewport) === false) {
                const { gl } = this;
                gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
                this.currentViewport.copy(viewport);
            }
        }
        setScissorTest(boolean) {
            const gl = this.gl;
            if (boolean) {
                gl.enable(gl.SCISSOR_TEST);
            } else {
                gl.disable(gl.SCISSOR_TEST);
            }
        }
        setStencilTest(stencilTest) {
            const { gl } = this;
            if (stencilTest) {
                this.enable(gl.STENCIL_TEST);
            } else {
                this.disable(gl.STENCIL_TEST);
            }
        }
        setStencilMask(stencilMask) {
            if (this.currentStencilMask !== stencilMask) {
                this.gl.stencilMask(stencilMask);
                this.currentStencilMask = stencilMask;
            }
        }
        setStencilFunc(stencilFunc, stencilRef, stencilMask) {
            if (this.currentStencilFunc !== stencilFunc ||
                this.currentStencilRef !== stencilRef ||
                this.currentStencilFuncMask !== stencilMask) {
                this.gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                this.currentStencilFunc = stencilFunc;
                this.currentStencilRef = stencilRef;
                this.currentStencilFuncMask = stencilMask;
            }
        }
        setStencilOp(stencilFail, stencilZFail, stencilZPass) {
            if (this.currentStencilFail !== stencilFail ||
                this.currentStencilZFail !== stencilZFail ||
                this.currentStencilZPass !== stencilZPass) {
                this.gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                this.currentStencilFail = stencilFail;
                this.currentStencilZFail = stencilZFail;
                this.currentStencilZPass = stencilZPass;
            }
        }
        setMaterial(material, frontFaceCW, hardwareClippingPlanes) {
            const { gl } = this;
            material.side === DoubleSide
                ? this.disable(gl.CULL_FACE)
                : this.enable(gl.CULL_FACE);
            let flipSided = (material.side === BackSide);
            if (frontFaceCW) flipSided = !flipSided;
            this.setFlipSided(flipSided);
            (material.blending === NormalBlending && material.transparent === false)
                ? this.setBlending(NoBlending)
                : this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
            this.setDepthFunc(material.depthFunc);
            this.setDepthTest(material.depthTest);
            this.setDepthMask(material.depthWrite);
            this.setColorMask(material.colorWrite);
            const stencilWrite = material.stencilWrite;
            this.setStencilTest(stencilWrite);
            if (stencilWrite) {
                this.setStencilMask(material.stencilWriteMask);
                this.setStencilFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
                this.setStencilOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
            }
            this.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
            material.alphaToCoverage === true && this.backend.renderer.samples > 1
                ? this.enable(gl.SAMPLE_ALPHA_TO_COVERAGE)
                : this.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
            if (hardwareClippingPlanes > 0) {
                if (this.currentClippingPlanes !== hardwareClippingPlanes) {
                    const CLIP_DISTANCE0_WEBGL = 0x3000;
                    for (let i = 0; i < 8; i++) {
                        if (i < hardwareClippingPlanes) {
                            this.enable(CLIP_DISTANCE0_WEBGL + i);
                        } else {
                            this.disable(CLIP_DISTANCE0_WEBGL + i);
                        }
                    }
                }
            }
        }
        setPolygonOffset(polygonOffset, factor, units) {
            const { gl } = this;
            if (polygonOffset) {
                this.enable(gl.POLYGON_OFFSET_FILL);
                if (this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units) {
                    gl.polygonOffset(factor, units);
                    this.currentPolygonOffsetFactor = factor;
                    this.currentPolygonOffsetUnits = units;
                }
            } else {
                this.disable(gl.POLYGON_OFFSET_FILL);
            }
        }
        useProgram(program) {
            if (this.currentProgram !== program) {
                this.gl.useProgram(program);
                this.currentProgram = program;
                return true;
            }
            return false;
        }
        setVertexState(vao, indexBuffer = null) {
            const gl = this.gl;
            if (this.currentVAO !== vao || this.currentIndex !== indexBuffer) {
                gl.bindVertexArray(vao);
                if (indexBuffer !== null) {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                }
                this.currentVAO = vao;
                this.currentIndex = indexBuffer;
                return true;
            }
            return false;
        }
        resetVertexState() {
            const gl = this.gl;
            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            this.currentVAO = null;
            this.currentIndex = null;
        }
        // framebuffer

        bindFramebuffer(target, framebuffer) {
            const { gl, currentBoundFramebuffers } = this;
            if (currentBoundFramebuffers[target] !== framebuffer) {
                gl.bindFramebuffer(target, framebuffer);
                currentBoundFramebuffers[target] = framebuffer;
                // gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER
                if (target === gl.DRAW_FRAMEBUFFER) {
                    currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
                }
                if (target === gl.FRAMEBUFFER) {
                    currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
                }
                return true;
            }
            return false;
        }
        drawBuffers(renderContext, framebuffer) {
            const { gl } = this;
            let drawBuffers = [];
            let needsUpdate = false;
            if (renderContext.textures !== null) {
                drawBuffers = this.currentDrawbuffers.get(framebuffer);
                if (drawBuffers === undefined) {
                    drawBuffers = [];
                    this.currentDrawbuffers.set(framebuffer, drawBuffers);
                }

                const textures = renderContext.textures;
                if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
                    for (let i = 0, il = textures.length; i < il; i++) {
                        drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;
                    }
                    drawBuffers.length = textures.length;
                    needsUpdate = true;
                }

            } else {
                if (drawBuffers[0] !== gl.BACK) {
                    drawBuffers[0] = gl.BACK;
                    needsUpdate = true;
                }
            }
            if (needsUpdate) {
                gl.drawBuffers(drawBuffers);
            }
        }

        // texture
        activeTexture(webglSlot) {
            const { gl, currentTextureSlot, maxTextures } = this;
            if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;
            if (currentTextureSlot !== webglSlot) {
                gl.activeTexture(webglSlot);
                this.currentTextureSlot = webglSlot;
            }
        }
        bindTexture(webglType, webglTexture, webglSlot) {
            const { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;
            if (webglSlot === undefined) {
                if (currentTextureSlot === null) {
                    webglSlot = gl.TEXTURE0 + maxTextures - 1;
                } else {
                    webglSlot = currentTextureSlot;
                }
            }
            let boundTexture = currentBoundTextures[webglSlot];
            if (boundTexture === undefined) {
                boundTexture = { type: undefined, texture: undefined };
                currentBoundTextures[webglSlot] = boundTexture;
            }
            if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
                if (currentTextureSlot !== webglSlot) {
                    gl.activeTexture(webglSlot);
                    this.currentTextureSlot = webglSlot;
                }
                gl.bindTexture(webglType, webglTexture);
                boundTexture.type = webglType;
                boundTexture.texture = webglTexture;
            }
        }
        bindBufferBase(target, index, buffer) {
            const { gl } = this;
            const key = `${target}-${index}`;
            if (this.currentBoundBufferBases[key] !== buffer) {
                gl.bindBufferBase(target, index, buffer);
                this.currentBoundBufferBases[key] = buffer;
                return true;
            }
            return false;
        }

        unbindTexture() {
            const { gl, currentTextureSlot, currentBoundTextures } = this;
            const boundTexture = currentBoundTextures[currentTextureSlot];
            if (boundTexture !== undefined && boundTexture.type !== undefined) {
                gl.bindTexture(boundTexture.type, null);
                boundTexture.type = undefined;
                boundTexture.texture = undefined;
            }
        }
    }
    class WebGLUtils {
        constructor(backend) {
            this.backend = backend;
            this.gl = this.backend.gl;
            this.extensions = backend.extensions;
        }
        convert(p, colorSpace = NoColorSpace) {
            const { gl, extensions } = this;
            let extension;
            const transfer = ColorManagement.getTransfer(colorSpace);
            if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
            if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
            if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
            if (p === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
            if (p === ByteType) return gl.BYTE;
            if (p === ShortType) return gl.SHORT;
            if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
            if (p === IntType) return gl.INT;
            if (p === UnsignedIntType) return gl.UNSIGNED_INT;
            if (p === FloatType) return gl.FLOAT;
            if (p === HalfFloatType) {
                return gl.HALF_FLOAT;
            }
            if (p === AlphaFormat) return gl.ALPHA;
            if (p === RGBFormat) return gl.RGB;
            if (p === RGBAFormat) return gl.RGBA;
            if (p === LuminanceFormat) return gl.LUMINANCE;
            if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
            if (p === DepthFormat) return gl.DEPTH_COMPONENT;
            if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
            // WebGL2 formats.
            if (p === RedFormat) return gl.RED;
            if (p === RedIntegerFormat) return gl.RED_INTEGER;
            if (p === RGFormat) return gl.RG;
            if (p === RGIntegerFormat) return gl.RG_INTEGER;
            if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;
            // S3TC
            if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
                if (transfer === SRGBTransfer) {
                    extension = extensions.get('WEBGL_compressed_texture_s3tc_srgb');
                    if (extension !== null) {
                        if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                        if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                        if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                        if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                    } else {
                        return null;
                    }
                } else {
                    extension = extensions.get('WEBGL_compressed_texture_s3tc');
                    if (extension !== null) {
                        if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    } else {
                        return null;
                    }
                }
            }
            // PVRTC
            if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
                extension = extensions.get('WEBGL_compressed_texture_pvrtc');
                if (extension !== null) {
                    if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                } else {
                    return null;
                }
            }
            // ETC
            if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
                extension = extensions.get('WEBGL_compressed_texture_etc');
                if (extension !== null) {
                    if (p === RGB_ETC1_Format || p === RGB_ETC2_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
                    if (p === RGBA_ETC2_EAC_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
                } else {
                    return null;
                }
            }
            // ASTC
            if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
                p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
                p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
                p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
                p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
                extension = extensions.get('WEBGL_compressed_texture_astc');
                if (extension !== null) {
                    if (p === RGBA_ASTC_4x4_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    if (p === RGBA_ASTC_5x4_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
                    if (p === RGBA_ASTC_5x5_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
                    if (p === RGBA_ASTC_6x5_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
                    if (p === RGBA_ASTC_6x6_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
                    if (p === RGBA_ASTC_8x5_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
                    if (p === RGBA_ASTC_8x6_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
                    if (p === RGBA_ASTC_8x8_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
                    if (p === RGBA_ASTC_10x5_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
                    if (p === RGBA_ASTC_10x6_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
                    if (p === RGBA_ASTC_10x8_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
                    if (p === RGBA_ASTC_10x10_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
                    if (p === RGBA_ASTC_12x10_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
                    if (p === RGBA_ASTC_12x12_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
                } else {
                    return null;
                }
            }
            // BPTC
            if (p === RGBA_BPTC_Format) {
                extension = extensions.get('EXT_texture_compression_bptc');
                if (extension !== null) {
                    if (p === RGBA_BPTC_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                } else {
                    return null;
                }
            }
            // RGTC
            if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {
                extension = extensions.get('EXT_texture_compression_rgtc');
                if (extension !== null) {
                    if (p === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
                    if (p === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                    if (p === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
                    if (p === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
                } else {
                    return null;
                }
            }
            //
            if (p === UnsignedInt248Type) {
                return gl.UNSIGNED_INT_24_8;
            }
            // if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)
            return (gl[p] !== undefined) ? gl[p] : null;
        }
        _clientWaitAsync() {
            const { gl } = this;
            const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
            gl.flush();
            return new Promise((resolve, reject) => {
                function test() {
                    const res = gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0);
                    if (res === gl.WAIT_FAILED) {
                        gl.deleteSync(sync);
                        reject();
                        return;
                    }
                    if (res === gl.TIMEOUT_EXPIRED) {
                        requestAnimationFrame(test);
                        return;
                    }
                    gl.deleteSync(sync);
                    resolve();
                }
                test();
            });
        }
    }
    let initialized = false, wrappingToGL, filterToGL, compareToGL;
    class WebGLTextureUtils {
        constructor(backend) {
            this.backend = backend;
            this.gl = backend.gl;
            this.extensions = backend.extensions;
            this.defaultTextures = {};
            if (initialized === false) {
                this._init();
                initialized = true;
            }
        }
        _init() {
            const gl = this.gl;
            // Store only WebGL constants here.
            wrappingToGL = {
                [RepeatWrapping]: gl.REPEAT,
                [ClampToEdgeWrapping]: gl.CLAMP_TO_EDGE,
                [MirroredRepeatWrapping]: gl.MIRRORED_REPEAT
            };
            filterToGL = {
                [NearestFilter]: gl.NEAREST,
                [NearestMipmapNearestFilter]: gl.NEAREST_MIPMAP_NEAREST,
                [NearestMipmapLinearFilter]: gl.NEAREST_MIPMAP_LINEAR,
                [LinearFilter]: gl.LINEAR,
                [LinearMipmapNearestFilter]: gl.LINEAR_MIPMAP_NEAREST,
                [LinearMipmapLinearFilter]: gl.LINEAR_MIPMAP_LINEAR
            };
            compareToGL = {
                [NeverCompare]: gl.NEVER,
                [AlwaysCompare]: gl.ALWAYS,
                [LessCompare]: gl.LESS,
                [LessEqualCompare]: gl.LEQUAL,
                [EqualCompare]: gl.EQUAL,
                [GreaterEqualCompare]: gl.GEQUAL,
                [GreaterCompare]: gl.GREATER,
                [NotEqualCompare]: gl.NOTEQUAL
            };
        }
        getGLTextureType(texture) {
            const { gl } = this;
            let glTextureType;
            if (texture.isCubeTexture === true) {
                glTextureType = gl.TEXTURE_CUBE_MAP;
            } else if (texture.isArrayTexture === true || texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true) {
                glTextureType = gl.TEXTURE_2D_ARRAY;
            } else if (texture.isData3DTexture === true) { // TODO: isCompressed3DTexture, wait for #26642
                glTextureType = gl.TEXTURE_3D;
            } else {
                glTextureType = gl.TEXTURE_2D;

            }
            return glTextureType;
        }
        getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
            const { gl, extensions } = this;
            if (internalFormatName !== null) {
                if (gl[internalFormatName] !== undefined) return gl[internalFormatName];
                console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
            }
            let internalFormat = glFormat;
            if (glFormat === gl.RED) {
                if (glType === gl.FLOAT) internalFormat = gl.R32F;
                if (glType === gl.HALF_FLOAT) internalFormat = gl.R16F;
                if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8;
                if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16;
                if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;
                if (glType === gl.BYTE) internalFormat = gl.R8I;
                if (glType === gl.SHORT) internalFormat = gl.R16I;
                if (glType === gl.INT) internalFormat = gl.R32I;
            }
            if (glFormat === gl.RED_INTEGER) {
                if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8UI;
                if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16UI;
                if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;
                if (glType === gl.BYTE) internalFormat = gl.R8I;
                if (glType === gl.SHORT) internalFormat = gl.R16I;
                if (glType === gl.INT) internalFormat = gl.R32I;
            }
            if (glFormat === gl.RG) {
                if (glType === gl.FLOAT) internalFormat = gl.RG32F;
                if (glType === gl.HALF_FLOAT) internalFormat = gl.RG16F;
                if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8;
                if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16;
                if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;
                if (glType === gl.BYTE) internalFormat = gl.RG8I;
                if (glType === gl.SHORT) internalFormat = gl.RG16I;
                if (glType === gl.INT) internalFormat = gl.RG32I;
            }
            if (glFormat === gl.RG_INTEGER) {
                if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8UI;
                if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16UI;
                if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;
                if (glType === gl.BYTE) internalFormat = gl.RG8I;
                if (glType === gl.SHORT) internalFormat = gl.RG16I;
                if (glType === gl.INT) internalFormat = gl.RG32I;
            }
            if (glFormat === gl.RGB) {
                const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
                if (glType === gl.FLOAT) internalFormat = gl.RGB32F;
                if (glType === gl.HALF_FLOAT) internalFormat = gl.RGB16F;
                if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8;
                if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16;
                if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;
                if (glType === gl.BYTE) internalFormat = gl.RGB8I;
                if (glType === gl.SHORT) internalFormat = gl.RGB16I;
                if (glType === gl.INT) internalFormat = gl.RGB32I;
                if (glType === gl.UNSIGNED_BYTE) internalFormat = (transfer === SRGBTransfer) ? gl.SRGB8 : gl.RGB8;
                if (glType === gl.UNSIGNED_SHORT_5_6_5) internalFormat = gl.RGB565;
                if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;
                if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGB4;
                if (glType === gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = gl.RGB9_E5;
            }
            if (glFormat === gl.RGB_INTEGER) {
                if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8UI;
                if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16UI;
                if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;
                if (glType === gl.BYTE) internalFormat = gl.RGB8I;
                if (glType === gl.SHORT) internalFormat = gl.RGB16I;
                if (glType === gl.INT) internalFormat = gl.RGB32I;
            }
            if (glFormat === gl.RGBA) {
                const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
                if (glType === gl.FLOAT) internalFormat = gl.RGBA32F;
                if (glType === gl.HALF_FLOAT) internalFormat = gl.RGBA16F;
                if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8;
                if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16;
                if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;
                if (glType === gl.BYTE) internalFormat = gl.RGBA8I;
                if (glType === gl.SHORT) internalFormat = gl.RGBA16I;
                if (glType === gl.INT) internalFormat = gl.RGBA32I;
                if (glType === gl.UNSIGNED_BYTE) internalFormat = (transfer === SRGBTransfer) ? gl.SRGB8_ALPHA8 : gl.RGBA8;
                if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGBA4;
                if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;
            }
            if (glFormat === gl.RGBA_INTEGER) {
                if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8UI;
                if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16UI;
                if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;
                if (glType === gl.BYTE) internalFormat = gl.RGBA8I;
                if (glType === gl.SHORT) internalFormat = gl.RGBA16I;
                if (glType === gl.INT) internalFormat = gl.RGBA32I;
            }
            if (glFormat === gl.DEPTH_COMPONENT) {
                if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.DEPTH_COMPONENT16;
                if (glType === gl.UNSIGNED_INT) internalFormat = gl.DEPTH_COMPONENT24;
                if (glType === gl.FLOAT) internalFormat = gl.DEPTH_COMPONENT32F;
            }
            if (glFormat === gl.DEPTH_STENCIL) {
                if (glType === gl.UNSIGNED_INT_24_8) internalFormat = gl.DEPTH24_STENCIL8;
            }
            if (internalFormat === gl.R16F || internalFormat === gl.R32F ||
                internalFormat === gl.RG16F || internalFormat === gl.RG32F ||
                internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F) {
                extensions.get('EXT_color_buffer_float');
            }
            return internalFormat;
        }
        setTextureParameters(textureType, texture) {
            const { gl, extensions, backend } = this;
            const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
            const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
            const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? gl.NONE : gl.BROWSER_DEFAULT_WEBGL;
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
            gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
            gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
            gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
            if (textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY) {
                // WebGL 2 does not support wrapping for depth 2D array textures
                if (!texture.isArrayTexture) {
                    gl.texParameteri(textureType, gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
                }
            }
            gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);

            const hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;
            // follow WebGPU backend mapping for texture filtering
            const minFilter = texture.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture.minFilter;
            gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, filterToGL[minFilter]);
            if (texture.compareFunction) {
                gl.texParameteri(textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
                gl.texParameteri(textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
            }
            if (extensions.has('EXT_texture_filter_anisotropic') === true) {
                if (texture.magFilter === NearestFilter) return;
                if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;
                if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2
                if (texture.anisotropy > 1) {
                    const extension = extensions.get('EXT_texture_filter_anisotropic');
                    gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, backend.getMaxAnisotropy()));
                }
            }
        }
        createDefaultTexture(texture) {
            const { gl, backend, defaultTextures } = this;

            const glTextureType = this.getGLTextureType(texture);
            let textureGPU = defaultTextures[glTextureType];
            if (textureGPU === undefined) {
                textureGPU = gl.createTexture();
                backend.state.bindTexture(glTextureType, textureGPU);
                gl.texParameteri(glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                // gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );
                defaultTextures[glTextureType] = textureGPU;
            }
            backend.set(texture, {
                textureGPU,
                glTextureType,
                isDefault: true
            });
        }
        createTexture(texture, options) {
            const { gl, backend } = this;
            const { levels, width, height, depth } = options;
            const glFormat = backend.utils.convert(texture.format, texture.colorSpace);
            const glType = backend.utils.convert(texture.type);
            const glInternalFormat = this.getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
            const textureGPU = gl.createTexture();
            const glTextureType = this.getGLTextureType(texture);
            backend.state.bindTexture(glTextureType, textureGPU);
            this.setTextureParameters(glTextureType, texture);
            if (texture.isArrayTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
                gl.texStorage3D(gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth);
            } else if (texture.isData3DTexture) {
                gl.texStorage3D(gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth);
            } else if (!texture.isVideoTexture) {
                gl.texStorage2D(glTextureType, levels, glInternalFormat, width, height);
            }
            backend.set(texture, {
                textureGPU,
                glTextureType,
                glFormat,
                glType,
                glInternalFormat
            });
        }
        copyBufferToTexture(buffer, texture) {
            const { gl, backend } = this;
            const { textureGPU, glTextureType, glFormat, glType } = backend.get(texture);
            const { width, height } = texture.source.data;
            gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, buffer);
            backend.state.bindTexture(glTextureType, textureGPU);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, 0);
            gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);
            backend.state.unbindTexture();
            // debug
            // const framebuffer = gl.createFramebuffer();
            // gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );
            // gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );
            // const readout = new Float32Array( width * height * 4 );
            // const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );
            // const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );
            // gl.readPixels( 0, 0, width, height, altFormat, altType, readout );
            // gl.bindFramebuffer( gl.FRAMEBUFFER, null );
            // console.log( readout );
        }
        updateTexture(texture, options) {
            const { gl } = this;
            const { width, height } = options;
            const { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get(texture);
            if (texture.isRenderTargetTexture || (textureGPU === undefined /* unsupported texture format */))
                return;
            this.backend.state.bindTexture(glTextureType, textureGPU);
            this.setTextureParameters(glTextureType, texture);
            if (texture.isCompressedTexture) {
                const mipmaps = texture.mipmaps;
                const image = options.image;
                for (let i = 0; i < mipmaps.length; i++) {
                    const mipmap = mipmaps[i];
                    if (texture.isCompressedArrayTexture) {

                        if (texture.format !== gl.RGBA) {
                            if (glFormat !== null) {
                                gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);
                            } else {
                                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                            }
                        } else {
                            gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
                        }
                    } else {
                        if (glFormat !== null) {
                            gl.compressedTexSubImage2D(gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                        } else {
                            console.warn('Unsupported compressed texture format');
                        }
                    }
                }

            } else if (texture.isCubeTexture) {
                const images = options.images;
                for (let i = 0; i < 6; i++) {
                    const image = getImage(images[i]);
                    gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image);
                }
            } else if (texture.isDataArrayTexture || texture.isArrayTexture) {
                const image = options.image;
                gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
            } else if (texture.isData3DTexture) {
                const image = options.image;
                gl.texSubImage3D(gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
            } else if (texture.isVideoTexture) {
                texture.update();
                gl.texImage2D(glTextureType, 0, glInternalFormat, glFormat, glType, options.image);

            } else {
                const image = getImage(options.image);
                gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, image);
            }
        }
        generateMipmaps(texture) {
            const { gl, backend } = this;
            const { textureGPU, glTextureType } = backend.get(texture);
            backend.state.bindTexture(glTextureType, textureGPU);
            gl.generateMipmap(glTextureType);
        }
        deallocateRenderBuffers(renderTarget) {
            const { gl, backend } = this;
            // remove framebuffer reference
            if (renderTarget) {
                const renderContextData = backend.get(renderTarget);
                renderContextData.renderBufferStorageSetup = undefined;
                if (renderContextData.framebuffers) {
                    for (const cacheKey in renderContextData.framebuffers) {
                        gl.deleteFramebuffer(renderContextData.framebuffers[cacheKey]);
                    }
                    delete renderContextData.framebuffers;
                }
                if (renderContextData.depthRenderbuffer) {
                    gl.deleteRenderbuffer(renderContextData.depthRenderbuffer);
                    delete renderContextData.depthRenderbuffer;
                }
                if (renderContextData.stencilRenderbuffer) {
                    gl.deleteRenderbuffer(renderContextData.stencilRenderbuffer);
                    delete renderContextData.stencilRenderbuffer;
                }
                if (renderContextData.msaaFrameBuffer) {
                    gl.deleteFramebuffer(renderContextData.msaaFrameBuffer);
                    delete renderContextData.msaaFrameBuffer;
                }
                if (renderContextData.msaaRenderbuffers) {
                    for (let i = 0; i < renderContextData.msaaRenderbuffers.length; i++) {
                        gl.deleteRenderbuffer(renderContextData.msaaRenderbuffers[i]);
                    }
                    delete renderContextData.msaaRenderbuffers;
                }
            }
        }
        destroyTexture(texture) {
            const { gl, backend } = this;
            const { textureGPU, renderTarget } = backend.get(texture);
            this.deallocateRenderBuffers(renderTarget);
            gl.deleteTexture(textureGPU);
            backend.delete(texture);
        }
        copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
            const { gl, backend } = this;
            const { state } = this.backend;
            const { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get(dstTexture);
            state.bindTexture(glTextureType, dstTextureGPU);
            // gather the necessary dimensions to copy
            let width, height, depth, minX, minY, minZ;
            let dstX, dstY, dstZ;
            const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[dstLevel] : srcTexture.image;
            if (srcRegion !== null) {
                width = srcRegion.max.x - srcRegion.min.x;
                height = srcRegion.max.y - srcRegion.min.y;
                depth = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
                minX = srcRegion.min.x;
                minY = srcRegion.min.y;
                minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;
            } else {
                const levelScale = Math.pow(2, - srcLevel);
                width = Math.floor(image.width * levelScale);
                height = Math.floor(image.height * levelScale);
                if (srcTexture.isDataArrayTexture || srcTexture.isArrayTexture) {
                    depth = image.depth;
                } else if (srcTexture.isData3DTexture) {
                    depth = Math.floor(image.depth * levelScale);
                } else {
                    depth = 1;
                }
                minX = 0;
                minY = 0;
                minZ = 0;
            }
            if (dstPosition !== null) {
                dstX = dstPosition.x;
                dstY = dstPosition.y;
                dstZ = dstPosition.z;
            } else {
                dstX = 0;
                dstY = 0;
                dstZ = 0;
            }

            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
            // used for copying data from cpu
            const currentUnpackRowLen = gl.getParameter(gl.UNPACK_ROW_LENGTH);
            const currentUnpackImageHeight = gl.getParameter(gl.UNPACK_IMAGE_HEIGHT);
            const currentUnpackSkipPixels = gl.getParameter(gl.UNPACK_SKIP_PIXELS);
            const currentUnpackSkipRows = gl.getParameter(gl.UNPACK_SKIP_ROWS);
            const currentUnpackSkipImages = gl.getParameter(gl.UNPACK_SKIP_IMAGES);
            gl.pixelStorei(gl.UNPACK_ROW_LENGTH, image.width);
            gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, image.height);
            gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, minX);
            gl.pixelStorei(gl.UNPACK_SKIP_ROWS, minY);
            gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, minZ);
            // set up the src texture
            const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture || dstTexture.isArrayTexture;
            if (srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture) {
                const srcTextureData = backend.get(srcTexture);
                const dstTextureData = backend.get(dstTexture);
                const srcRenderContextData = backend.get(srcTextureData.renderTarget);
                const dstRenderContextData = backend.get(dstTextureData.renderTarget);
                const srcFramebuffer = srcRenderContextData.framebuffers[srcTextureData.cacheKey];
                const dstFramebuffer = dstRenderContextData.framebuffers[dstTextureData.cacheKey];
                state.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFramebuffer);
                state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFramebuffer);
                let mask = gl.COLOR_BUFFER_BIT;
                if (srcTexture.isDepthTexture) mask = gl.DEPTH_BUFFER_BIT;
                gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, mask, gl.NEAREST);
                state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
                state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
            } else {
                if (isDst3D) {
                    // copy data into the 3d texture
                    if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
                        gl.texSubImage3D(glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image.data);
                    } else if (dstTexture.isCompressedArrayTexture) {
                        gl.compressedTexSubImage3D(glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, image.data);
                    } else {
                        gl.texSubImage3D(glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image);
                    }
                } else {
                    // copy data into the 2d texture
                    if (srcTexture.isDataTexture) {
                        gl.texSubImage2D(glTextureType, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data);
                    } else if (srcTexture.isCompressedTexture) {
                        gl.compressedTexSubImage2D(glTextureType, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data);
                    } else {
                        gl.texSubImage2D(glTextureType, dstLevel, dstX, dstY, width, height, glFormat, glType, image);
                    }
                }
            }
            // reset values
            gl.pixelStorei(gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
            gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
            gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
            gl.pixelStorei(gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
            gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
            // Generate mipmaps only when copying level 0
            if (dstLevel === 0 && dstTexture.generateMipmaps) {
                gl.generateMipmap(glTextureType);
            }
            state.unbindTexture();
        }

        copyFramebufferToTexture(texture, renderContext, rectangle) {
            const { gl } = this;
            const { state } = this.backend;
            const { textureGPU } = this.backend.get(texture);
            const { x, y, z: width, w: height } = rectangle;
            const requireDrawFrameBuffer = texture.isDepthTexture === true || (renderContext.renderTarget && renderContext.renderTarget.samples > 0);
            const srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.getDrawingBufferSize().y;
            if (requireDrawFrameBuffer) {
                const partial = (x !== 0 || y !== 0);
                let mask;
                let attachment;
                if (texture.isDepthTexture === true) {
                    mask = gl.DEPTH_BUFFER_BIT;
                    attachment = gl.DEPTH_ATTACHMENT;
                    if (renderContext.stencil) {
                        mask |= gl.STENCIL_BUFFER_BIT;
                    }
                } else {
                    mask = gl.COLOR_BUFFER_BIT;
                    attachment = gl.COLOR_ATTACHMENT0;
                }
                if (partial) {
                    const renderTargetContextData = this.backend.get(renderContext.renderTarget);
                    const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];
                    const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;
                    state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
                    state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);
                    const flippedY = srcHeight - y - height;
                    gl.blitFramebuffer(x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST);
                    state.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);
                    state.bindTexture(gl.TEXTURE_2D, textureGPU);
                    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height);
                    state.unbindTexture();
                } else {
                    const fb = gl.createFramebuffer();
                    state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
                    gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0);
                    gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);
                    gl.deleteFramebuffer(fb);
                }
            } else {
                state.bindTexture(gl.TEXTURE_2D, textureGPU);
                gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height);
                state.unbindTexture();
            }
            if (texture.generateMipmaps) this.generateMipmaps(texture);
            this.backend._setFramebuffer(renderContext);
        }
        setupRenderBufferStorage(renderbuffer, renderContext, samples, useMultisampledRTT = false) {
            const { gl } = this;
            const renderTarget = renderContext.renderTarget;
            const { depthTexture, depthBuffer, stencilBuffer, width, height } = renderTarget;
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
            if (depthBuffer && !stencilBuffer) {
                let glInternalFormat = gl.DEPTH_COMPONENT24;
                if (useMultisampledRTT === true) {
                    const multisampledRTTExt = this.extensions.get('WEBGL_multisampled_render_to_texture');
                    multisampledRTTExt.renderbufferStorageMultisampleEXT(gl.RENDERBUFFER, renderTarget.samples, glInternalFormat, width, height);
                } else if (samples > 0) {
                    if (depthTexture && depthTexture.isDepthTexture) {
                        if (depthTexture.type === gl.FLOAT) {
                            glInternalFormat = gl.DEPTH_COMPONENT32F;
                        }
                    }
                    gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, glInternalFormat, width, height);
                } else {
                    gl.renderbufferStorage(gl.RENDERBUFFER, glInternalFormat, width, height);
                }
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
            } else if (depthBuffer && stencilBuffer) {
                if (samples > 0) {
                    gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height);
                } else {
                    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
                }

                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
            }
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        }
        async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {
            const { backend, gl } = this;
            const { textureGPU, glFormat, glType } = this.backend.get(texture);
            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);
            const target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;
            gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0);
            const typedArrayType = this._getTypedArrayType(glType);
            const bytesPerTexel = this._getBytesPerTexel(glType, glFormat);
            const elementCount = width * height;
            const byteLength = elementCount * bytesPerTexel;
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);
            gl.bufferData(gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ);
            gl.readPixels(x, y, width, height, glFormat, glType, 0);
            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
            await backend.utils._clientWaitAsync();
            const dstBuffer = new typedArrayType(byteLength / typedArrayType.BYTES_PER_ELEMENT);
            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);
            gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dstBuffer);
            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
            gl.deleteFramebuffer(fb);
            return dstBuffer;
        }
        _getTypedArrayType(glType) {
            const { gl } = this;
            if (glType === gl.UNSIGNED_BYTE) return Uint8Array;
            if (glType === gl.UNSIGNED_SHORT_4_4_4_4) return Uint16Array;
            if (glType === gl.UNSIGNED_SHORT_5_5_5_1) return Uint16Array;
            if (glType === gl.UNSIGNED_SHORT_5_6_5) return Uint16Array;
            if (glType === gl.UNSIGNED_SHORT) return Uint16Array;
            if (glType === gl.UNSIGNED_INT) return Uint32Array;
            if (glType === gl.HALF_FLOAT) return Uint16Array;
            if (glType === gl.FLOAT) return Float32Array;
            throw new Error(`Unsupported WebGL type: ${glType}`);
        }
        _getBytesPerTexel(glType, glFormat) {
            const { gl } = this;
            let bytesPerComponent = 0;
            if (glType === gl.UNSIGNED_BYTE) bytesPerComponent = 1;
            if (glType === gl.UNSIGNED_SHORT_4_4_4_4 ||
                glType === gl.UNSIGNED_SHORT_5_5_5_1 ||
                glType === gl.UNSIGNED_SHORT_5_6_5 ||
                glType === gl.UNSIGNED_SHORT ||
                glType === gl.HALF_FLOAT) bytesPerComponent = 2;
            if (glType === gl.UNSIGNED_INT ||
                glType === gl.FLOAT) bytesPerComponent = 4;
            if (glFormat === gl.RGBA) return bytesPerComponent * 4;
            if (glFormat === gl.RGB) return bytesPerComponent * 3;
            if (glFormat === gl.ALPHA) return bytesPerComponent;
        }
    }
    function getImage(source) {
        if (source.isDataTexture) {
            return source.image.data;
        } else if ((typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement) ||
            (typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement) ||
            (typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap) ||
            (typeof OffscreenCanvas !== 'undefined' && source instanceof OffscreenCanvas)) {
            return source;
        }
        return source.data;
    }
    class WebGLExtensions {
        constructor(backend) {
            this.backend = backend;
            this.gl = this.backend.gl;
            this.availableExtensions = this.gl.getSupportedExtensions();
            this.extensions = {};
        }
        get(name) {
            let extension = this.extensions[name];
            if (extension === undefined) {
                extension = this.gl.getExtension(name);
                this.extensions[name] = extension;
            }
            return extension;
        }
        has(name) {
            return this.availableExtensions.includes(name);
        }
    }
    class WebGLCapabilities {
        constructor(backend) {
            this.backend = backend;
            this.maxAnisotropy = null;
        }
        getMaxAnisotropy() {
            if (this.maxAnisotropy !== null) return this.maxAnisotropy;
            const gl = this.backend.gl;
            const extensions = this.backend.extensions;
            if (extensions.has('EXT_texture_filter_anisotropic') === true) {
                const extension = extensions.get('EXT_texture_filter_anisotropic');
                this.maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else {
                this.maxAnisotropy = 0;
            }
            return this.maxAnisotropy;
        }
    }
    const GLFeatureName = {
        'WEBGL_multi_draw': 'WEBGL_multi_draw',
        'WEBGL_compressed_texture_astc': 'texture-compression-astc',
        'WEBGL_compressed_texture_etc': 'texture-compression-etc2',
        'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',
        'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',
        'WEBKIT_WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',
        'WEBGL_compressed_texture_s3tc': 'texture-compression-bc',
        'EXT_texture_compression_bptc': 'texture-compression-bptc',
        'EXT_disjoint_timer_query_webgl2': 'timestamp-query',
        'OVR_multiview2': 'OVR_multiview2'
    };
    class WebGLBufferRenderer {
        constructor(backend) {
            this.gl = backend.gl;
            this.extensions = backend.extensions;
            this.info = backend.renderer.info;
            this.mode = null;
            this.index = 0;
            this.type = null;
            this.object = null;
        }
        render(start, count) {
            const { gl, mode, object, type, info, index } = this;
            if (index !== 0) {
                gl.drawElements(mode, count, type, start);
            } else {
                gl.drawArrays(mode, start, count);
            }
            info.update(object, count, 1);
        }
        renderInstances(start, count, primcount) {
            const { gl, mode, type, index, object, info } = this;
            if (primcount === 0) return;
            if (index !== 0) {
                gl.drawElementsInstanced(mode, count, type, start, primcount);
            } else {
                gl.drawArraysInstanced(mode, start, count, primcount);
            }
            info.update(object, count, primcount);
        }
        renderMultiDraw(starts, counts, drawCount) {
            const { extensions, mode, object, info } = this;
            if (drawCount === 0) return;
            const extension = extensions.get('WEBGL_multi_draw');
            if (extension === null) {
                for (let i = 0; i < drawCount; i++) {
                    this.render(starts[i], counts[i]);
                }
            } else {
                if (this.index !== 0) {
                    extension.multiDrawElementsWEBGL(mode, counts, 0, this.type, starts, 0, drawCount);
                } else {
                    extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
                }
                let elementCount = 0;
                for (let i = 0; i < drawCount; i++) {
                    elementCount += counts[i];
                }
                info.update(object, elementCount, 1);
            }
        }
        renderMultiDrawInstances(starts, counts, drawCount, primcount) {
            const { extensions, mode, object, info } = this;
            if (drawCount === 0) return;
            const extension = extensions.get('WEBGL_multi_draw');
            if (extension === null) {
                for (let i = 0; i < drawCount; i++) {
                    this.renderInstances(starts[i], counts[i], primcount[i]);
                }
            } else {
                if (this.index !== 0) {
                    extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount);
                } else {
                    extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
                }
                let elementCount = 0;
                for (let i = 0; i < drawCount; i++) {
                    elementCount += counts[i] * primcount[i];
                }
                info.update(object, elementCount, 1);
            }
        }
        //
    }
    class TimestampQueryPool {
        constructor(maxQueries = 256) {
            this.trackTimestamp = true;
            this.maxQueries = maxQueries;
            this.currentQueryIndex = 0;
            this.queryOffsets = new Map();
            this.isDisposed = false;
            this.lastValue = 0;
            this.pendingResolve = false;
        }
        allocateQueriesForContext( /* renderContext */) { }
        async resolveQueriesAsync() { }
        dispose() { }
    }
    class WebGLTimestampQueryPool extends TimestampQueryPool {
        constructor(gl, type, maxQueries = 2048) {
            super(maxQueries);
            this.gl = gl;
            this.type = type;
            // Check for timer query extensions
            this.ext = gl.getExtension('EXT_disjoint_timer_query_webgl2') ||
                gl.getExtension('EXT_disjoint_timer_query');
            if (!this.ext) {
                console.warn('EXT_disjoint_timer_query not supported; timestamps will be disabled.');
                this.trackTimestamp = false;
                return;
            }
            // Create query objects
            this.queries = [];
            for (let i = 0; i < this.maxQueries; i++) {
                this.queries.push(gl.createQuery());
            }
            this.activeQuery = null;
            this.queryStates = new Map(); // Track state of each query: 'inactive', 'started', 'ended'
        }
        allocateQueriesForContext(renderContext) {
            if (!this.trackTimestamp) return null;
            // Check if we have enough space for a new query pair
            if (this.currentQueryIndex + 2 > this.maxQueries) {
                warnOnce(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`);
                return null;
            }
            const baseOffset = this.currentQueryIndex;
            this.currentQueryIndex += 2;
            // Initialize query states
            this.queryStates.set(baseOffset, 'inactive');
            this.queryOffsets.set(renderContext.id, baseOffset);
            return baseOffset;
        }
        beginQuery(renderContext) {
            if (!this.trackTimestamp || this.isDisposed) {
                return;
            }
            const baseOffset = this.queryOffsets.get(renderContext.id);
            if (baseOffset == null) {
                return;
            }
            // Don't start a new query if there's an active one
            if (this.activeQuery !== null) {
                return;
            }
            const query = this.queries[baseOffset];
            if (!query) {
                return;
            }
            try {
                // Only begin if query is inactive
                if (this.queryStates.get(baseOffset) === 'inactive') {
                    this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, query);
                    this.activeQuery = baseOffset;
                    this.queryStates.set(baseOffset, 'started');
                }
            } catch (error) {
                console.error('Error in beginQuery:', error);
                this.activeQuery = null;
                this.queryStates.set(baseOffset, 'inactive');
            }
        }
        endQuery(renderContext) {
            if (!this.trackTimestamp || this.isDisposed) {
                return;
            }
            const baseOffset = this.queryOffsets.get(renderContext.id);
            if (baseOffset == null) {
                return;
            }
            // Only end if this is the active query
            if (this.activeQuery !== baseOffset) {
                return;
            }
            try {
                this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);
                this.queryStates.set(baseOffset, 'ended');
                this.activeQuery = null;
            } catch (error) {
                console.error('Error in endQuery:', error);
                // Reset state on error
                this.queryStates.set(baseOffset, 'inactive');
                this.activeQuery = null;
            }
        }
        async resolveQueriesAsync() {
            if (!this.trackTimestamp || this.pendingResolve) {
                return this.lastValue;
            }
            this.pendingResolve = true;
            try {
                // Wait for all ended queries to complete
                const resolvePromises = [];
                for (const [baseOffset, state] of this.queryStates) {
                    if (state === 'ended') {
                        const query = this.queries[baseOffset];
                        resolvePromises.push(this.resolveQuery(query));
                    }
                }
                if (resolvePromises.length === 0) {
                    return this.lastValue;
                }
                const results = await Promise.all(resolvePromises);
                const totalDuration = results.reduce((acc, val) => acc + val, 0);
                // Store the last valid result
                this.lastValue = totalDuration;
                // Reset states
                this.currentQueryIndex = 0;
                this.queryOffsets.clear();
                this.queryStates.clear();
                this.activeQuery = null;
                return totalDuration;
            } catch (error) {
                console.error('Error resolving queries:', error);
                return this.lastValue;
            } finally {
                this.pendingResolve = false;
            }
        }
        async resolveQuery(query) {
            return new Promise((resolve) => {
                if (this.isDisposed) {
                    resolve(this.lastValue);
                    return;
                }
                let timeoutId;
                let isResolved = false;
                const cleanup = () => {
                    if (timeoutId) {
                        clearTimeout(timeoutId);
                        timeoutId = null;
                    }
                };
                const finalizeResolution = (value) => {
                    if (!isResolved) {
                        isResolved = true;
                        cleanup();
                        resolve(value);
                    }
                };
                const checkQuery = () => {
                    if (this.isDisposed) {
                        finalizeResolution(this.lastValue);
                        return;
                    }
                    try {
                        // Check if the GPU timer was disjoint (i.e., timing was unreliable)
                        const disjoint = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);
                        if (disjoint) {
                            finalizeResolution(this.lastValue);
                            return;
                        }
                        const available = this.gl.getQueryParameter(query, this.gl.QUERY_RESULT_AVAILABLE);
                        if (!available) {
                            timeoutId = setTimeout(checkQuery, 1);
                            return;
                        }
                        const elapsed = this.gl.getQueryParameter(query, this.gl.QUERY_RESULT);
                        resolve(Number(elapsed) / 1e6); // Convert nanoseconds to milliseconds
                    } catch (error) {
                        console.error('Error checking query:', error);
                        resolve(this.lastValue);
                    }
                };
                checkQuery();
            });
        }
        dispose() {
            if (this.isDisposed) {
                return;
            }
            this.isDisposed = true;
            if (!this.trackTimestamp) return;
            for (const query of this.queries) {
                this.gl.deleteQuery(query);
            }
            this.queries = [];
            this.queryStates.clear();
            this.queryOffsets.clear();
            this.lastValue = 0;
            this.activeQuery = null;
        }
    }
    class WebGLBackend extends Backend {

        constructor(parameters = {}) {
            super(parameters);
            this.isWebGLBackend = true;
            this.attributeUtils = null;
            this.extensions = null;
            this.capabilities = null;
            this.textureUtils = null;
            this.bufferRenderer = null;
            this.gl = null;
            this.state = null;
            this.utils = null;
            this.vaoCache = {};
            this.transformFeedbackCache = {};
            this.discard = false;
            this.disjoint = null;
            this.parallel = null;
            this._currentContext = null;
            this._knownBindings = new WeakSet();

            this._supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test(navigator.userAgent);
            this._xrFramebuffer = null;
        }
        init(renderer) {
            super.init(renderer);
            //
            const parameters = this.parameters;
            const contextAttributes = {
                antialias: renderer.samples > 0,
                alpha: true, // always true for performance reasons
                depth: renderer.depth,
                stencil: renderer.stencil
            };
            const glContext = (parameters.context !== undefined) ? parameters.context : renderer.domElement.getContext('webgl2', contextAttributes);
            function onContextLost(event) {
                event.preventDefault();
                const contextLossInfo = {
                    api: 'WebGL',
                    message: event.statusMessage || 'Unknown reason',
                    reason: null,
                    originalEvent: event
                };
                renderer.onDeviceLost(contextLossInfo);
            }
            this._onContextLost = onContextLost;
            renderer.domElement.addEventListener('webglcontextlost', onContextLost, false);
            this.gl = glContext;
            this.extensions = new WebGLExtensions(this);
            this.capabilities = new WebGLCapabilities(this);
            this.attributeUtils = new WebGLAttributeUtils(this);
            this.textureUtils = new WebGLTextureUtils(this);
            this.bufferRenderer = new WebGLBufferRenderer(this);
            this.state = new WebGLState(this);
            this.utils = new WebGLUtils(this);
            this.extensions.get('EXT_color_buffer_float');
            this.extensions.get('WEBGL_clip_cull_distance');
            this.extensions.get('OES_texture_float_linear');
            this.extensions.get('EXT_color_buffer_half_float');
            this.extensions.get('WEBGL_multisampled_render_to_texture');
            this.extensions.get('WEBGL_render_shared_exponent');
            this.extensions.get('WEBGL_multi_draw');
            this.extensions.get('OVR_multiview2');
            this.disjoint = this.extensions.get('EXT_disjoint_timer_query_webgl2');
            this.parallel = this.extensions.get('KHR_parallel_shader_compile');
        }
        get coordinateSystem() {
            return WebGLCoordinateSystem;
        }
        async getArrayBufferAsync(attribute) {
            return await this.attributeUtils.getArrayBufferAsync(attribute);
        }
        async waitForGPU() {
            await this.utils._clientWaitAsync();
        }
        async makeXRCompatible() {
            const attributes = this.gl.getContextAttributes();
            if (attributes.xrCompatible !== true) {
                await this.gl.makeXRCompatible();
            }
        }
        setXRTarget(xrFramebuffer) {
            this._xrFramebuffer = xrFramebuffer;
        }
        setXRRenderTargetTextures(renderTarget, colorTexture, depthTexture = null) {
            const gl = this.gl;
            this.set(renderTarget.texture, { textureGPU: colorTexture, glInternalFormat: gl.RGBA8 }); // see #24698 why RGBA8 and not SRGB8_ALPHA8 is used
            if (depthTexture !== null) {
                const glInternalFormat = renderTarget.stencilBuffer ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
                this.set(renderTarget.depthTexture, { textureGPU: depthTexture, glInternalFormat: glInternalFormat });
                // The multisample_render_to_texture extension doesn't work properly if there
                // are midframe flushes and an external depth texture.
                if ((this.extensions.has('WEBGL_multisampled_render_to_texture') === true) && renderTarget._autoAllocateDepthBuffer === true && renderTarget.multiview === false) {
                    console.warn('THREE.WebGLBackend: Render-to-texture extension was disabled because an external texture was provided');
                }
                renderTarget._autoAllocateDepthBuffer = false;
            }
        }
        initTimestampQuery(renderContext) {
            if (!this.disjoint || !this.trackTimestamp) return;
            const type = renderContext.isComputeNode ? 'compute' : 'render';
            if (!this.timestampQueryPool[type]) {
                // TODO: Variable maxQueries?
                this.timestampQueryPool[type] = new WebGLTimestampQueryPool(this.gl, type, 2048);
            }
            const timestampQueryPool = this.timestampQueryPool[type];
            const baseOffset = timestampQueryPool.allocateQueriesForContext(renderContext);
            if (baseOffset !== null) {
                timestampQueryPool.beginQuery(renderContext);
            }
        }
        // timestamp utils
        prepareTimestampBuffer(renderContext) {
            if (!this.disjoint || !this.trackTimestamp) return;
            const type = renderContext.isComputeNode ? 'compute' : 'render';
            const timestampQueryPool = this.timestampQueryPool[type];
            timestampQueryPool.endQuery(renderContext);
        }

        getContext() {
            return this.gl;
        }
        beginRender(renderContext) {
            const { state } = this;
            const renderContextData = this.get(renderContext);
            //
            if (renderContext.viewport) {
                this.updateViewport(renderContext);
            } else {
                const { width, height } = this.getDrawingBufferSize();
                state.viewport(0, 0, width, height);
            }
            if (renderContext.scissor) {
                const { x, y, width, height } = renderContext.scissorValue;
                state.scissor(x, renderContext.height - height - y, width, height);
            }
            //
            this.initTimestampQuery(renderContext);
            renderContextData.previousContext = this._currentContext;
            this._currentContext = renderContext;
            this._setFramebuffer(renderContext);
            this.clear(renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false);
            const occlusionQueryCount = renderContext.occlusionQueryCount;
            if (occlusionQueryCount > 0) {
                // Get a reference to the array of objects with queries. The renderContextData property
                // can be changed by another render pass before the async reading of all previous queries complete
                renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;
                renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;
                renderContextData.lastOcclusionObject = null;
                renderContextData.occlusionQueries = new Array(occlusionQueryCount);
                renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
                renderContextData.occlusionQueryIndex = 0;
            }
        }
        finishRender(renderContext) {
            const { gl, state } = this;
            const renderContextData = this.get(renderContext);
            const previousContext = renderContextData.previousContext;
            state.resetVertexState();
            const occlusionQueryCount = renderContext.occlusionQueryCount;
            if (occlusionQueryCount > 0) {
                if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {
                    gl.endQuery(gl.ANY_SAMPLES_PASSED);
                }
                this.resolveOccludedAsync(renderContext);
            }
            const textures = renderContext.textures;
            if (textures !== null) {
                for (let i = 0; i < textures.length; i++) {
                    const texture = textures[i];
                    if (texture.generateMipmaps) {
                        this.generateMipmaps(texture);
                    }
                }
            }
            this._currentContext = previousContext;
            const renderTarget = renderContext.renderTarget;
            if (renderContext.textures !== null && renderTarget) {
                const renderTargetContextData = this.get(renderTarget);
                if (renderTarget.samples > 0 && this._useMultisampledExtension(renderTarget) === false) {
                    const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];
                    let mask = gl.COLOR_BUFFER_BIT;
                    if (renderTarget.resolveDepthBuffer) {
                        if (renderTarget.depthBuffer) mask |= gl.DEPTH_BUFFER_BIT;
                        if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= gl.STENCIL_BUFFER_BIT;
                    }
                    const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;
                    const msaaRenderbuffers = renderTargetContextData.msaaRenderbuffers;
                    const textures = renderContext.textures;
                    const isMRT = textures.length > 1;
                    state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);
                    state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
                    if (isMRT) {
                        // blitFramebuffer() can only copy/resolve the first color attachment of a framebuffer. When using MRT,
                        // the engine temporarily removes all attachments and then configures each attachment for the resolve.
                        for (let i = 0; i < textures.length; i++) {
                            gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, null);
                            gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, null, 0);
                        }
                    }
                    for (let i = 0; i < textures.length; i++) {
                        if (isMRT) {
                            // configure attachment for resolve
                            const { textureGPU } = this.get(textures[i]);
                            gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, msaaRenderbuffers[i]);
                            gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureGPU, 0);
                        }
                        if (renderContext.scissor) {
                            const { x, y, width, height } = renderContext.scissorValue;
                            const viewY = renderContext.height - height - y;
                            gl.blitFramebuffer(x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST);
                        } else {
                            gl.blitFramebuffer(0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST);
                        }
                    }
                    if (isMRT) {
                        // restore attachments
                        for (let i = 0; i < textures.length; i++) {
                            const { textureGPU } = this.get(textures[i]);
                            gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[i]);
                            gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, textureGPU, 0);
                        }
                    }
                    if (this._supportsInvalidateFramebuffer === true) {
                        gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray);
                    }
                } else if (renderTarget.resolveDepthBuffer === false && renderTargetContextData.framebuffers) {
                    const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];
                    state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
                    gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER, renderTargetContextData.depthInvalidationArray);
                }
            }
            if (previousContext !== null) {
                this._setFramebuffer(previousContext);
                if (previousContext.viewport) {
                    this.updateViewport(previousContext);
                } else {
                    const { width, height } = this.getDrawingBufferSize();
                    state.viewport(0, 0, width, height);
                }
            }
            this.prepareTimestampBuffer(renderContext);
        }
        resolveOccludedAsync(renderContext) {
            const renderContextData = this.get(renderContext);
            // handle occlusion query results
            const { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;
            if (currentOcclusionQueries && currentOcclusionQueryObjects) {
                const occluded = new WeakSet();
                const { gl } = this;
                renderContextData.currentOcclusionQueryObjects = null;
                renderContextData.currentOcclusionQueries = null;
                const check = () => {
                    let completed = 0;
                    // check all queries and requeue as appropriate
                    for (let i = 0; i < currentOcclusionQueries.length; i++) {
                        const query = currentOcclusionQueries[i];
                        if (query === null) continue;
                        if (gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {
                            if (gl.getQueryParameter(query, gl.QUERY_RESULT) === 0) occluded.add(currentOcclusionQueryObjects[i]);
                            currentOcclusionQueries[i] = null;
                            gl.deleteQuery(query);
                            completed++;
                        }
                    }
                    if (completed < currentOcclusionQueries.length) {
                        requestAnimationFrame(check);
                    } else {
                        renderContextData.occluded = occluded;
                    }
                };
                check();
            }
        }
        isOccluded(renderContext, object) {
            const renderContextData = this.get(renderContext);
            return renderContextData.occluded && renderContextData.occluded.has(object);
        }
        updateViewport(renderContext) {
            const { state } = this;
            const { x, y, width, height } = renderContext.viewportValue;
            state.viewport(x, renderContext.height - height - y, width, height);
        }
        setScissorTest(boolean) {
            const state = this.state;
            state.setScissorTest(boolean);
        }
        getClearColor() {
            const clearColor = super.getClearColor();
            // Since the canvas is always created with alpha: true,
            // WebGL must always premultiply the clear color.
            clearColor.r *= clearColor.a;
            clearColor.g *= clearColor.a;
            clearColor.b *= clearColor.a;
            return clearColor;
        }
        clear(color, depth, stencil, descriptor = null, setFrameBuffer = true) {
            const { gl, renderer } = this;
            if (descriptor === null) {
                const clearColor = this.getClearColor();
                descriptor = {
                    textures: null,
                    clearColorValue: clearColor
                };
            }
            //
            let clear = 0;
            if (color) clear |= gl.COLOR_BUFFER_BIT;
            if (depth) clear |= gl.DEPTH_BUFFER_BIT;
            if (stencil) clear |= gl.STENCIL_BUFFER_BIT;
            if (clear !== 0) {
                let clearColor;
                if (descriptor.clearColorValue) {
                    clearColor = descriptor.clearColorValue;
                } else {
                    clearColor = this.getClearColor();
                }
                const clearDepth = renderer.getClearDepth();
                const clearStencil = renderer.getClearStencil();
                if (depth) this.state.setDepthMask(true);
                if (descriptor.textures === null) {
                    gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
                    gl.clear(clear);
                } else {
                    if (setFrameBuffer) this._setFramebuffer(descriptor);
                    if (color) {
                        for (let i = 0; i < descriptor.textures.length; i++) {
                            if (i === 0) {
                                gl.clearBufferfv(gl.COLOR, i, [clearColor.r, clearColor.g, clearColor.b, clearColor.a]);
                            } else {
                                gl.clearBufferfv(gl.COLOR, i, [0, 0, 0, 1]);
                            }
                        }
                    }
                    if (depth && stencil) {
                        gl.clearBufferfi(gl.DEPTH_STENCIL, 0, clearDepth, clearStencil);
                    } else if (depth) {
                        gl.clearBufferfv(gl.DEPTH, 0, [clearDepth]);
                    } else if (stencil) {
                        gl.clearBufferiv(gl.STENCIL, 0, [clearStencil]);
                    }
                }
            }
        }
        beginCompute(computeGroup) {
            const { state, gl } = this;
            state.bindFramebuffer(gl.FRAMEBUFFER, null);
            this.initTimestampQuery(computeGroup);
        }
        compute(computeGroup, computeNode, bindings, pipeline, count = null) {
            const { state, gl } = this;
            if (this.discard === false) {
                // required here to handle async behaviour of render.compute()
                gl.enable(gl.RASTERIZER_DISCARD);
                this.discard = true;
            }
            const { programGPU, transformBuffers, attributes } = this.get(pipeline);
            const vaoKey = this._getVaoKey(attributes);
            const vaoGPU = this.vaoCache[vaoKey];
            if (vaoGPU === undefined) {
                this.vaoCache[vaoKey] = this._createVao(attributes);
            } else {
                state.setVertexState(vaoGPU);
            }
            state.useProgram(programGPU);
            this._bindUniforms(bindings);
            const transformFeedbackGPU = this._getTransformFeedback(transformBuffers);
            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);
            gl.beginTransformFeedback(gl.POINTS);
            count = (count !== null) ? count : computeNode.count;
            if (Array.isArray(count)) {
                warnOnce('WebGLBackend.compute(): The count parameter must be a single number, not an array.');
                count = count[0];
            }
            if (attributes[0].isStorageInstancedBufferAttribute) {
                gl.drawArraysInstanced(gl.POINTS, 0, 1, count);
            } else {
                gl.drawArrays(gl.POINTS, 0, count);
            }
            gl.endTransformFeedback();
            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
            // switch active buffers
            for (let i = 0; i < transformBuffers.length; i++) {
                const dualAttributeData = transformBuffers[i];
                if (dualAttributeData.pbo && this.has(dualAttributeData.pbo)) {
                    this.textureUtils.copyBufferToTexture(dualAttributeData.transformBuffer, dualAttributeData.pbo);
                }
                dualAttributeData.switchBuffers();

            }
        }
        finishCompute(computeGroup) {
            const gl = this.gl;
            this.discard = false;
            gl.disable(gl.RASTERIZER_DISCARD);
            this.prepareTimestampBuffer(computeGroup);
            if (this._currentContext) {
                this._setFramebuffer(this._currentContext);
            }
        }
        _isRenderCameraDepthArray(renderContext) {
            return renderContext.depthTexture && renderContext.depthTexture.isArrayTexture && renderContext.camera.isArrayCamera;
        }
        draw(renderObject/*, info*/) {
            const { object, pipeline, material, context, hardwareClippingPlanes } = renderObject;
            const { programGPU } = this.get(pipeline);
            const { gl, state } = this;
            const contextData = this.get(context);
            const drawParams = renderObject.getDrawParameters();
            if (drawParams === null) return;
            //
            this._bindUniforms(renderObject.getBindings());
            const frontFaceCW = (object.isMesh && object.matrixWorld.determinant() < 0);
            state.setMaterial(material, frontFaceCW, hardwareClippingPlanes);
            state.useProgram(programGPU);
            // vertex state
            const attributes = renderObject.getAttributes();
            const attributesData = this.get(attributes);
            let vaoGPU = attributesData.vaoGPU;
            if (vaoGPU === undefined) {
                const vaoKey = this._getVaoKey(attributes);
                vaoGPU = this.vaoCache[vaoKey];
                if (vaoGPU === undefined) {
                    vaoGPU = this._createVao(attributes);
                    this.vaoCache[vaoKey] = vaoGPU;
                    attributesData.vaoGPU = vaoGPU;
                }
            }
            const index = renderObject.getIndex();
            const indexGPU = (index !== null) ? this.get(index).bufferGPU : null;
            state.setVertexState(vaoGPU, indexGPU);
            //
            const lastObject = contextData.lastOcclusionObject;
            if (lastObject !== object && lastObject !== undefined) {
                if (lastObject !== null && lastObject.occlusionTest === true) {
                    gl.endQuery(gl.ANY_SAMPLES_PASSED);
                    contextData.occlusionQueryIndex++;
                }
                if (object.occlusionTest === true) {
                    const query = gl.createQuery();
                    gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);
                    contextData.occlusionQueries[contextData.occlusionQueryIndex] = query;
                    contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] = object;
                }
                contextData.lastOcclusionObject = object;
            }
            //
            const renderer = this.bufferRenderer;
            if (object.isPoints) renderer.mode = gl.POINTS;
            else if (object.isLineSegments) renderer.mode = gl.LINES;
            else if (object.isLine) renderer.mode = gl.LINE_STRIP;
            else if (object.isLineLoop) renderer.mode = gl.LINE_LOOP;
            else {
                if (material.wireframe === true) {
                    state.setLineWidth(material.wireframeLinewidth * this.renderer.getPixelRatio());
                    renderer.mode = gl.LINES;
                } else {
                    renderer.mode = gl.TRIANGLES;
                }
            }
            //
            const { vertexCount, instanceCount } = drawParams;
            let { firstVertex } = drawParams;
            renderer.object = object;
            if (index !== null) {
                firstVertex *= index.array.BYTES_PER_ELEMENT;
                const indexData = this.get(index);
                renderer.index = index.count;
                renderer.type = indexData.type;
            } else {
                renderer.index = 0;
            }
            const draw = () => {
                if (object.isBatchedMesh) {
                    if (object._multiDrawInstances !== null) {
                        // @deprecated, r174
                        warnOnce('THREE.WebGLBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.');
                        renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
                    } else if (!this.hasFeature('WEBGL_multi_draw')) {
                        warnOnce('THREE.WebGLRenderer: WEBGL_multi_draw not supported.');
                    } else {
                        renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
                    }
                } else if (instanceCount > 1) {
                    renderer.renderInstances(firstVertex, vertexCount, instanceCount);
                } else {
                    renderer.render(firstVertex, vertexCount);
                }
            };
            if (renderObject.camera.isArrayCamera === true && renderObject.camera.cameras.length > 0 && renderObject.camera.isMultiViewCamera === false) {
                const cameraData = this.get(renderObject.camera);
                const cameras = renderObject.camera.cameras;
                const cameraIndex = renderObject.getBindingGroup('cameraIndex').bindings[0];
                if (cameraData.indexesGPU === undefined || cameraData.indexesGPU.length !== cameras.length) {
                    const data = new Uint32Array([0, 0, 0, 0]);
                    const indexesGPU = [];
                    for (let i = 0, len = cameras.length; i < len; i++) {
                        const bufferGPU = gl.createBuffer();
                        data[0] = i;
                        gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
                        gl.bufferData(gl.UNIFORM_BUFFER, data, gl.STATIC_DRAW);
                        indexesGPU.push(bufferGPU);
                    }
                    cameraData.indexesGPU = indexesGPU; // TODO: Create a global library for this
                }
                const cameraIndexData = this.get(cameraIndex);
                const pixelRatio = this.renderer.getPixelRatio();
                const renderTarget = this._currentContext.renderTarget;
                const isRenderCameraDepthArray = this._isRenderCameraDepthArray(this._currentContext);
                const prevActiveCubeFace = this._currentContext.activeCubeFace;
                if (isRenderCameraDepthArray) {
                    // Clear the depth texture
                    const textureData = this.get(renderTarget.depthTexture);
                    if (textureData.clearedRenderId !== this.renderer._nodes.nodeFrame.renderId) {
                        textureData.clearedRenderId = this.renderer._nodes.nodeFrame.renderId;
                        const { stencilBuffer } = renderTarget;
                        for (let i = 0, len = cameras.length; i < len; i++) {
                            this.renderer._activeCubeFace = i;
                            this._currentContext.activeCubeFace = i;
                            this._setFramebuffer(this._currentContext);
                            this.clear(false, true, stencilBuffer, this._currentContext, false);
                        }
                        this.renderer._activeCubeFace = prevActiveCubeFace;
                        this._currentContext.activeCubeFace = prevActiveCubeFace;
                    }
                }
                for (let i = 0, len = cameras.length; i < len; i++) {
                    const subCamera = cameras[i];
                    if (object.layers.test(subCamera.layers)) {
                        if (isRenderCameraDepthArray) {
                            // Update the active layer
                            this.renderer._activeCubeFace = i;
                            this._currentContext.activeCubeFace = i;
                            this._setFramebuffer(this._currentContext);
                        }
                        const vp = subCamera.viewport;
                        if (vp !== undefined) {
                            const x = vp.x * pixelRatio;
                            const y = vp.y * pixelRatio;
                            const width = vp.width * pixelRatio;
                            const height = vp.height * pixelRatio;
                            state.viewport(
                                Math.floor(x),
                                Math.floor(renderObject.context.height - height - y),
                                Math.floor(width),
                                Math.floor(height)
                            );
                        }
                        state.bindBufferBase(gl.UNIFORM_BUFFER, cameraIndexData.index, cameraData.indexesGPU[i]);
                        draw();
                    }
                    this._currentContext.activeCubeFace = prevActiveCubeFace;
                    this.renderer._activeCubeFace = prevActiveCubeFace;
                }
            } else {
                draw();
            }
        }
        needsRenderUpdate( /*renderObject*/) {
            return false;
        }
        getRenderCacheKey( /*renderObject*/) {
            return '';
        }
        // textures
        createDefaultTexture(texture) {
            this.textureUtils.createDefaultTexture(texture);
        }
        createTexture(texture, options) {
            this.textureUtils.createTexture(texture, options);
        }
        updateTexture(texture, options) {
            this.textureUtils.updateTexture(texture, options);
        }
        generateMipmaps(texture) {
            this.textureUtils.generateMipmaps(texture);
        }
        destroyTexture(texture) {
            this.textureUtils.destroyTexture(texture);
        }
        async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {
            return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);
        }
        createSampler( /*texture*/) {
            //console.warn( 'Abstract class.' );
        }
        destroySampler( /*texture*/) { }
        // node builder
        createNodeBuilder(object, renderer) {
            return new GLSLNodeBuilder(object, renderer);
        }
        // program
        createProgram(program) {
            const gl = this.gl;
            const { stage, code } = program;
            const shader = stage === 'fragment' ? gl.createShader(gl.FRAGMENT_SHADER) : gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(shader, code);
            gl.compileShader(shader);
            this.set(program, {
                shaderGPU: shader
            });
        }
        destroyProgram(program) {
            this.delete(program);
        }
        createRenderPipeline(renderObject, promises) {
            const gl = this.gl;
            const pipeline = renderObject.pipeline;
            // Program
            const { fragmentProgram, vertexProgram } = pipeline;
            const programGPU = gl.createProgram();
            const fragmentShader = this.get(fragmentProgram).shaderGPU;
            const vertexShader = this.get(vertexProgram).shaderGPU;
            gl.attachShader(programGPU, fragmentShader);
            gl.attachShader(programGPU, vertexShader);
            gl.linkProgram(programGPU);
            this.set(pipeline, {
                programGPU,
                fragmentShader,
                vertexShader
            });
            if (promises !== null && this.parallel) {
                const p = new Promise((resolve /*, reject*/) => {
                    const parallel = this.parallel;
                    const checkStatus = () => {
                        if (gl.getProgramParameter(programGPU, parallel.COMPLETION_STATUS_KHR)) {
                            this._completeCompile(renderObject, pipeline);
                            resolve();
                        } else {
                            requestAnimationFrame(checkStatus);
                        }
                    };
                    checkStatus();
                });
                promises.push(p);
                return;
            }
            this._completeCompile(renderObject, pipeline);
        }
        _handleSource(string, errorLine) {
            const lines = string.split('\n');
            const lines2 = [];
            const from = Math.max(errorLine - 6, 0);
            const to = Math.min(errorLine + 6, lines.length);
            for (let i = from; i < to; i++) {
                const line = i + 1;
                lines2.push(`${line === errorLine ? '>' : ' '} ${line}: ${lines[i]}`);
            }
            return lines2.join('\n');
        }
        _getShaderErrors(gl, shader, type) {
            const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            const shaderInfoLog = gl.getShaderInfoLog(shader) || '';
            const errors = shaderInfoLog.trim();
            if (status && errors === '') return '';
            const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
            if (errorMatches) {
                const errorLine = parseInt(errorMatches[1]);
                return type.toUpperCase() + '\n\n' + errors + '\n\n' + this._handleSource(gl.getShaderSource(shader), errorLine);
            } else {
                return errors;
            }
        }
        _logProgramError(programGPU, glFragmentShader, glVertexShader) {
            if (this.renderer.debug.checkShaderErrors) {
                const gl = this.gl;
                const programInfoLog = gl.getProgramInfoLog(programGPU) || '';
                const programLog = programInfoLog.trim();
                if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
                    if (typeof this.renderer.debug.onShaderError === 'function') {
                        this.renderer.debug.onShaderError(gl, programGPU, glVertexShader, glFragmentShader);
                    } else {
                        // default error reporting
                        const vertexErrors = this._getShaderErrors(gl, glVertexShader, 'vertex');
                        const fragmentErrors = this._getShaderErrors(gl, glFragmentShader, 'fragment');
                        console.error(
                            'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
                            'VALIDATE_STATUS ' + gl.getProgramParameter(programGPU, gl.VALIDATE_STATUS) + '\n\n' +
                            'Program Info Log: ' + programLog + '\n' +
                            vertexErrors + '\n' +
                            fragmentErrors
                        );
                    }
                } else if (programLog !== '') {
                    console.warn('THREE.WebGLProgram: Program Info Log:', programLog);
                }
            }
        }
        _completeCompile(renderObject, pipeline) {
            const { state, gl } = this;
            const pipelineData = this.get(pipeline);
            const { programGPU, fragmentShader, vertexShader } = pipelineData;
            if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
                this._logProgramError(programGPU, fragmentShader, vertexShader);
            }
            state.useProgram(programGPU);
            // Bindings
            const bindings = renderObject.getBindings();
            this._setupBindings(bindings, programGPU);
            //
            this.set(pipeline, {
                programGPU
            });
        }
        createComputePipeline(computePipeline, bindings) {
            const { state, gl } = this;
            // Program
            const fragmentProgram = {
                stage: 'fragment',
                code: '#version 300 es\nprecision highp float;\nvoid main() {}'
            };
            this.createProgram(fragmentProgram);
            const { computeProgram } = computePipeline;
            const programGPU = gl.createProgram();
            const fragmentShader = this.get(fragmentProgram).shaderGPU;
            const vertexShader = this.get(computeProgram).shaderGPU;
            const transforms = computeProgram.transforms;
            const transformVaryingNames = [];
            const transformAttributeNodes = [];
            for (let i = 0; i < transforms.length; i++) {
                const transform = transforms[i];
                transformVaryingNames.push(transform.varyingName);
                transformAttributeNodes.push(transform.attributeNode);
            }
            gl.attachShader(programGPU, fragmentShader);
            gl.attachShader(programGPU, vertexShader);
            gl.transformFeedbackVaryings(
                programGPU,
                transformVaryingNames,
                gl.SEPARATE_ATTRIBS
            );
            gl.linkProgram(programGPU);
            if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
                this._logProgramError(programGPU, fragmentShader, vertexShader);

            }
            state.useProgram(programGPU);
            // Bindings
            this._setupBindings(bindings, programGPU);
            const attributeNodes = computeProgram.attributes;
            const attributes = [];
            const transformBuffers = [];
            for (let i = 0; i < attributeNodes.length; i++) {
                const attribute = attributeNodes[i].node.attribute;
                attributes.push(attribute);
                if (!this.has(attribute)) this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);
            }
            for (let i = 0; i < transformAttributeNodes.length; i++) {
                const attribute = transformAttributeNodes[i].attribute;
                if (!this.has(attribute)) this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);
                const attributeData = this.get(attribute);
                transformBuffers.push(attributeData);
            }
            //
            this.set(computePipeline, {
                programGPU,
                transformBuffers,
                attributes
            });
        }
        createBindings(bindGroup, bindings /*, cacheIndex, version*/) {
            if (this._knownBindings.has(bindings) === false) {
                this._knownBindings.add(bindings);
                let uniformBuffers = 0;
                let textures = 0;
                for (const bindGroup of bindings) {
                    this.set(bindGroup, {
                        textures: textures,
                        uniformBuffers: uniformBuffers
                    });
                    for (const binding of bindGroup.bindings) {
                        if (binding.isUniformBuffer) uniformBuffers++;
                        if (binding.isSampledTexture) textures++;
                    }
                }
            }
            this.updateBindings(bindGroup, bindings);
        }
        updateBindings(bindGroup /*, bindings, cacheIndex, version*/) {
            const { gl } = this;
            const bindGroupData = this.get(bindGroup);
            let i = bindGroupData.uniformBuffers;
            let t = bindGroupData.textures;
            for (const binding of bindGroup.bindings) {
                if (binding.isUniformsGroup || binding.isUniformBuffer) {
                    const data = binding.buffer;
                    const bufferGPU = gl.createBuffer();
                    gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
                    gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
                    this.set(binding, {
                        index: i++,
                        bufferGPU
                    });
                } else if (binding.isSampledTexture) {
                    const { textureGPU, glTextureType } = this.get(binding.texture);
                    this.set(binding, {
                        index: t++,
                        textureGPU,
                        glTextureType
                    });
                }
            }
        }
        updateBinding(binding) {
            const gl = this.gl;
            if (binding.isUniformsGroup || binding.isUniformBuffer) {
                const bindingData = this.get(binding);
                const bufferGPU = bindingData.bufferGPU;
                const data = binding.buffer;
                gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
                gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
            }
        }
        // attributes
        createIndexAttribute(attribute) {
            const gl = this.gl;
            this.attributeUtils.createAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);
        }
        createAttribute(attribute) {
            if (this.has(attribute)) return;
            const gl = this.gl;
            this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);
        }
        createStorageAttribute(attribute) {
            if (this.has(attribute)) return;
            const gl = this.gl;
            this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);
        }
        updateAttribute(attribute) {
            this.attributeUtils.updateAttribute(attribute);
        }
        destroyAttribute(attribute) {
            this.attributeUtils.destroyAttribute(attribute);
        }
        hasFeature(name) {
            const keysMatching = Object.keys(GLFeatureName).filter(key => GLFeatureName[key] === name);
            const extensions = this.extensions;
            for (let i = 0; i < keysMatching.length; i++) {
                if (extensions.has(keysMatching[i])) return true;
            }
            return false;
        }
        getMaxAnisotropy() {
            return this.capabilities.getMaxAnisotropy();
        }
        copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
            this.textureUtils.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, srcLevel, dstLevel);
        }
        copyFramebufferToTexture(texture, renderContext, rectangle) {
            this.textureUtils.copyFramebufferToTexture(texture, renderContext, rectangle);
        }
        _setFramebuffer(descriptor) {
            const { gl, state } = this;
            let currentFrameBuffer = null;
            if (descriptor.textures !== null) {
                const renderTarget = descriptor.renderTarget;
                const renderTargetContextData = this.get(renderTarget);
                const { samples, depthBuffer, stencilBuffer } = renderTarget;
                const isCube = renderTarget.isWebGLCubeRenderTarget === true;
                const isRenderTarget3D = renderTarget.isRenderTarget3D === true;
                const isRenderTargetArray = renderTarget.depth > 1;
                const isXRRenderTarget = renderTarget.isXRRenderTarget === true;
                const _hasExternalTextures = (isXRRenderTarget === true && renderTarget._hasExternalTextures === true);
                let msaaFb = renderTargetContextData.msaaFrameBuffer;
                let depthRenderbuffer = renderTargetContextData.depthRenderbuffer;
                const multisampledRTTExt = this.extensions.get('WEBGL_multisampled_render_to_texture');
                const multiviewExt = this.extensions.get('OVR_multiview2');
                const useMultisampledRTT = this._useMultisampledExtension(renderTarget);
                const cacheKey = getCacheKey(descriptor);
                let fb;
                if (isCube) {
                    renderTargetContextData.cubeFramebuffers || (renderTargetContextData.cubeFramebuffers = {});
                    fb = renderTargetContextData.cubeFramebuffers[cacheKey];
                } else if (isXRRenderTarget && _hasExternalTextures === false) {
                    fb = this._xrFramebuffer;
                } else {
                    renderTargetContextData.framebuffers || (renderTargetContextData.framebuffers = {});
                    fb = renderTargetContextData.framebuffers[cacheKey];
                }
                if (fb === undefined) {
                    fb = gl.createFramebuffer();
                    state.bindFramebuffer(gl.FRAMEBUFFER, fb);
                    const textures = descriptor.textures;
                    const depthInvalidationArray = [];
                    if (isCube) {
                        renderTargetContextData.cubeFramebuffers[cacheKey] = fb;
                        const { textureGPU } = this.get(textures[0]);
                        const cubeFace = this.renderer._activeCubeFace;
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0);
                    } else {
                        renderTargetContextData.framebuffers[cacheKey] = fb;
                        for (let i = 0; i < textures.length; i++) {
                            const texture = textures[i];
                            const textureData = this.get(texture);
                            textureData.renderTarget = descriptor.renderTarget;
                            textureData.cacheKey = cacheKey; // required for copyTextureToTexture()
                            const attachment = gl.COLOR_ATTACHMENT0 + i;
                            if (renderTarget.multiview) {
                                multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, attachment, textureData.textureGPU, 0, samples, 0, 2);
                            } else if (isRenderTarget3D || isRenderTargetArray) {
                                const layer = this.renderer._activeCubeFace;
                                gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, textureData.textureGPU, 0, layer);
                            } else {
                                if (useMultisampledRTT) {
                                    multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0, samples);
                                } else {
                                    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0);
                                }
                            }
                        }
                    }
                    const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                    if (renderTarget._autoAllocateDepthBuffer === true) {
                        const renderbuffer = gl.createRenderbuffer();
                        this.textureUtils.setupRenderBufferStorage(renderbuffer, descriptor, 0, useMultisampledRTT);
                        renderTargetContextData.xrDepthRenderbuffer = renderbuffer;
                        depthInvalidationArray.push(stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT);
                        gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
                        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer);

                    } else {
                        if (descriptor.depthTexture !== null) {
                            depthInvalidationArray.push(stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT);
                            const textureData = this.get(descriptor.depthTexture);
                            textureData.renderTarget = descriptor.renderTarget;
                            textureData.cacheKey = cacheKey; // required for copyTextureToTexture()
                            if (renderTarget.multiview) {
                                multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, samples, 0, 2);
                            } else if (_hasExternalTextures && useMultisampledRTT) {
                                multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0, samples);
                            } else {
                                if (descriptor.depthTexture.isArrayTexture) {
                                    const layer = this.renderer._activeCubeFace;
                                    gl.framebufferTextureLayer(gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, layer);
                                } else {
                                    gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0);
                                }
                            }
                        }
                    }
                    renderTargetContextData.depthInvalidationArray = depthInvalidationArray;

                } else {
                    const isRenderCameraDepthArray = this._isRenderCameraDepthArray(descriptor);
                    if (isRenderCameraDepthArray) {
                        state.bindFramebuffer(gl.FRAMEBUFFER, fb);
                        const layer = this.renderer._activeCubeFace;
                        const depthData = this.get(descriptor.depthTexture);
                        const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                        gl.framebufferTextureLayer(
                            gl.FRAMEBUFFER,
                            depthStyle,
                            depthData.textureGPU,
                            0,
                            layer
                        );
                    }
                    // rebind external XR textures
                    if ((isXRRenderTarget || useMultisampledRTT || renderTarget.multiview) && (renderTarget._isOpaqueFramebuffer !== true)) {
                        state.bindFramebuffer(gl.FRAMEBUFFER, fb);
                        // rebind color
                        const textureData = this.get(descriptor.textures[0]);
                        if (renderTarget.multiview) {
                            multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, textureData.textureGPU, 0, samples, 0, 2);
                        } else if (useMultisampledRTT) {
                            multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0, samples);
                        } else {
                            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0);
                        }
                        // rebind depth
                        const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                        if (renderTarget._autoAllocateDepthBuffer === true) {
                            const renderbuffer = renderTargetContextData.xrDepthRenderbuffer;
                            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
                            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer);
                        } else {
                            const textureData = this.get(descriptor.depthTexture);
                            if (renderTarget.multiview) {
                                multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, samples, 0, 2);
                            } else if (useMultisampledRTT) {
                                multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0, samples);
                            } else {
                                gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0);
                            }
                        }
                    }
                }
                if (samples > 0 && useMultisampledRTT === false && !renderTarget.multiview) {
                    if (msaaFb === undefined) {
                        const invalidationArray = [];
                        msaaFb = gl.createFramebuffer();
                        state.bindFramebuffer(gl.FRAMEBUFFER, msaaFb);
                        const msaaRenderbuffers = [];
                        const textures = descriptor.textures;
                        for (let i = 0; i < textures.length; i++) {
                            msaaRenderbuffers[i] = gl.createRenderbuffer();
                            gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderbuffers[i]);
                            invalidationArray.push(gl.COLOR_ATTACHMENT0 + i);
                            const texture = descriptor.textures[i];
                            const textureData = this.get(texture);
                            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height);
                            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[i]);

                        }
                        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                        renderTargetContextData.msaaFrameBuffer = msaaFb;
                        renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;
                        if (depthBuffer && depthRenderbuffer === undefined) {
                            depthRenderbuffer = gl.createRenderbuffer();
                            this.textureUtils.setupRenderBufferStorage(depthRenderbuffer, descriptor, samples);
                            renderTargetContextData.depthRenderbuffer = depthRenderbuffer;
                            const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                            invalidationArray.push(depthStyle);
                        }
                        renderTargetContextData.invalidationArray = invalidationArray;
                    }
                    currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;
                } else {
                    currentFrameBuffer = fb;
                }
                state.drawBuffers(descriptor, fb);
            }
            state.bindFramebuffer(gl.FRAMEBUFFER, currentFrameBuffer);
        }
        _getVaoKey(attributes) {
            let key = '';
            for (let i = 0; i < attributes.length; i++) {
                const attributeData = this.get(attributes[i]);
                key += ':' + attributeData.id;
            }
            return key;
        }
        _createVao(attributes) {
            const { gl } = this;
            const vaoGPU = gl.createVertexArray();
            gl.bindVertexArray(vaoGPU);
            for (let i = 0; i < attributes.length; i++) {
                const attribute = attributes[i];
                const attributeData = this.get(attribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, attributeData.bufferGPU);
                gl.enableVertexAttribArray(i);
                let stride, offset;
                if (attribute.isInterleavedBufferAttribute === true) {
                    stride = attribute.data.stride * attributeData.bytesPerElement;
                    offset = attribute.offset * attributeData.bytesPerElement;
                } else {
                    stride = 0;
                    offset = 0;
                }
                if (attributeData.isInteger) {
                    gl.vertexAttribIPointer(i, attribute.itemSize, attributeData.type, stride, offset);
                } else {
                    gl.vertexAttribPointer(i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset);
                }
                if (attribute.isInstancedBufferAttribute && !attribute.isInterleavedBufferAttribute) {
                    gl.vertexAttribDivisor(i, attribute.meshPerAttribute);
                } else if (attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer) {
                    gl.vertexAttribDivisor(i, attribute.data.meshPerAttribute);
                }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            return vaoGPU;
        }
        _getTransformFeedback(transformBuffers) {
            let key = '';
            for (let i = 0; i < transformBuffers.length; i++) {
                key += ':' + transformBuffers[i].id;
            }
            let transformFeedbackGPU = this.transformFeedbackCache[key];
            if (transformFeedbackGPU !== undefined) {
                return transformFeedbackGPU;
            }
            const { gl } = this;
            transformFeedbackGPU = gl.createTransformFeedback();
            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);
            for (let i = 0; i < transformBuffers.length; i++) {
                const attributeData = transformBuffers[i];
                gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer);
            }
            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
            this.transformFeedbackCache[key] = transformFeedbackGPU;
            return transformFeedbackGPU;
        }
        _setupBindings(bindings, programGPU) {
            const gl = this.gl;
            for (const bindGroup of bindings) {
                for (const binding of bindGroup.bindings) {
                    const bindingData = this.get(binding);
                    const index = bindingData.index;
                    if (binding.isUniformsGroup || binding.isUniformBuffer) {
                        const location = gl.getUniformBlockIndex(programGPU, binding.name);
                        gl.uniformBlockBinding(programGPU, location, index);
                    } else if (binding.isSampledTexture) {
                        const location = gl.getUniformLocation(programGPU, binding.name);
                        gl.uniform1i(location, index);
                    }
                }
            }
        }
        _bindUniforms(bindings) {
            const { gl, state } = this;
            for (const bindGroup of bindings) {
                for (const binding of bindGroup.bindings) {
                    const bindingData = this.get(binding);
                    const index = bindingData.index;
                    if (binding.isUniformsGroup || binding.isUniformBuffer) {
                        // TODO USE bindBufferRange to group multiple uniform buffers
                        state.bindBufferBase(gl.UNIFORM_BUFFER, index, bindingData.bufferGPU);
                    } else if (binding.isSampledTexture) {
                        state.bindTexture(bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index);
                    }
                }
            }
        }
        _useMultisampledExtension(renderTarget) {
            if (renderTarget.multiview === true) {
                return true;
            }
            return renderTarget.samples > 0 && this.extensions.has('WEBGL_multisampled_render_to_texture') === true && renderTarget._autoAllocateDepthBuffer !== false;
        }
        dispose() {
            const extension = this.extensions.get('WEBGL_lose_context');
            if (extension) extension.loseContext();
            this.renderer.domElement.removeEventListener('webglcontextlost', this._onContextLost);
        }
    }
    const GPUPrimitiveTopology = {
        PointList: 'point-list',
        LineList: 'line-list',
        LineStrip: 'line-strip',
        TriangleList: 'triangle-list',
        TriangleStrip: 'triangle-strip',
    };
    const GPUCompareFunction = {
        Never: 'never',
        Less: 'less',
        Equal: 'equal',
        LessEqual: 'less-equal',
        Greater: 'greater',
        NotEqual: 'not-equal',
        GreaterEqual: 'greater-equal',
        Always: 'always'
    };
    const GPUStoreOp = {
        Store: 'store'
    };
    const GPULoadOp = {
        Load: 'load',
        Clear: 'clear'
    };
    const GPUFrontFace = {
        CCW: 'ccw'
    };
    const GPUCullMode = {
        None: 'none',
        Front: 'front',
        Back: 'back'
    };
    const GPUIndexFormat = {
        Uint16: 'uint16',
        Uint32: 'uint32'
    };
    const GPUTextureFormat = {
        // 8-bit formats
        R8Unorm: 'r8unorm',
        R8Snorm: 'r8snorm',
        R8Uint: 'r8uint',
        R8Sint: 'r8sint',
        // 16-bit formats
        R16Uint: 'r16uint',
        R16Sint: 'r16sint',
        R16Float: 'r16float',
        RG8Unorm: 'rg8unorm',
        RG8Snorm: 'rg8snorm',
        RG8Uint: 'rg8uint',
        RG8Sint: 'rg8sint',
        // 32-bit formats
        R32Uint: 'r32uint',
        R32Sint: 'r32sint',
        R32Float: 'r32float',
        RG16Uint: 'rg16uint',
        RG16Sint: 'rg16sint',
        RG16Float: 'rg16float',
        RGBA8Unorm: 'rgba8unorm',
        RGBA8UnormSRGB: 'rgba8unorm-srgb',
        RGBA8Snorm: 'rgba8snorm',
        RGBA8Uint: 'rgba8uint',
        RGBA8Sint: 'rgba8sint',
        BGRA8Unorm: 'bgra8unorm',
        BGRA8UnormSRGB: 'bgra8unorm-srgb',
        // Packed 32-bit formats
        RGB9E5UFloat: 'rgb9e5ufloat',
        RGB10A2Unorm: 'rgb10a2unorm',
        RG11B10UFloat: 'rgb10a2unorm',
        // 64-bit formats
        RG32Uint: 'rg32uint',
        RG32Sint: 'rg32sint',
        RG32Float: 'rg32float',
        RGBA16Uint: 'rgba16uint',
        RGBA16Sint: 'rgba16sint',
        RGBA16Float: 'rgba16float',
        // 128-bit formats
        RGBA32Uint: 'rgba32uint',
        RGBA32Sint: 'rgba32sint',
        RGBA32Float: 'rgba32float',
        Depth16Unorm: 'depth16unorm',
        Depth24Plus: 'depth24plus',
        Depth24PlusStencil8: 'depth24plus-stencil8',
        Depth32Float: 'depth32float',
        // 'depth32float-stencil8' extension
        Depth32FloatStencil8: 'depth32float-stencil8',
        // BC compressed formats usable if 'texture-compression-bc' is both
        // supported by the device/user agent and enabled in requestDevice.
        BC1RGBAUnorm: 'bc1-rgba-unorm',
        BC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',
        BC2RGBAUnorm: 'bc2-rgba-unorm',
        BC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',
        BC3RGBAUnorm: 'bc3-rgba-unorm',
        BC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',
        BC4RUnorm: 'bc4-r-unorm',
        BC4RSnorm: 'bc4-r-snorm',
        BC5RGUnorm: 'bc5-rg-unorm',
        BC5RGSnorm: 'bc5-rg-snorm',
        BC6HRGBUFloat: 'bc6h-rgb-ufloat',
        BC6HRGBFloat: 'bc6h-rgb-float',
        BC7RGBAUnorm: 'bc7-rgba-unorm',
        BC7RGBAUnormSRGB: 'bc7-rgba-srgb',
        // ETC2 compressed formats usable if 'texture-compression-etc2' is both
        // supported by the device/user agent and enabled in requestDevice.
        ETC2RGB8Unorm: 'etc2-rgb8unorm',
        ETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',
        ETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',
        ETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',
        ETC2RGBA8Unorm: 'etc2-rgba8unorm',
        ETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',
        EACR11Unorm: 'eac-r11unorm',
        EACR11Snorm: 'eac-r11snorm',
        EACRG11Unorm: 'eac-rg11unorm',
        EACRG11Snorm: 'eac-rg11snorm',
        // ASTC compressed formats usable if 'texture-compression-astc' is both
        // supported by the device/user agent and enabled in requestDevice.
        ASTC4x4Unorm: 'astc-4x4-unorm',
        ASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',
        ASTC5x4Unorm: 'astc-5x4-unorm',
        ASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',
        ASTC5x5Unorm: 'astc-5x5-unorm',
        ASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',
        ASTC6x5Unorm: 'astc-6x5-unorm',
        ASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',
        ASTC6x6Unorm: 'astc-6x6-unorm',
        ASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',
        ASTC8x5Unorm: 'astc-8x5-unorm',
        ASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',
        ASTC8x6Unorm: 'astc-8x6-unorm',
        ASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',
        ASTC8x8Unorm: 'astc-8x8-unorm',
        ASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',
        ASTC10x5Unorm: 'astc-10x5-unorm',
        ASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',
        ASTC10x6Unorm: 'astc-10x6-unorm',
        ASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',
        ASTC10x8Unorm: 'astc-10x8-unorm',
        ASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',
        ASTC10x10Unorm: 'astc-10x10-unorm',
        ASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',
        ASTC12x10Unorm: 'astc-12x10-unorm',
        ASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',
        ASTC12x12Unorm: 'astc-12x12-unorm',
        ASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb',
    };
    const GPUAddressMode = {
        ClampToEdge: 'clamp-to-edge',
        Repeat: 'repeat',
        MirrorRepeat: 'mirror-repeat'
    };
    const GPUFilterMode = {
        Linear: 'linear',
        Nearest: 'nearest'
    };
    const GPUBlendFactor = {
        Zero: 'zero',
        One: 'one',
        Src: 'src',
        OneMinusSrc: 'one-minus-src',
        SrcAlpha: 'src-alpha',
        OneMinusSrcAlpha: 'one-minus-src-alpha',
        Dst: 'dst',
        OneMinusDst: 'one-minus-dst',
        DstAlpha: 'dst-alpha',
        OneMinusDstAlpha: 'one-minus-dst-alpha',
        SrcAlphaSaturated: 'src-alpha-saturated',
        Constant: 'constant',
        OneMinusConstant: 'one-minus-constant'
    };
    const GPUBlendOperation = {
        Add: 'add',
        Subtract: 'subtract',
        ReverseSubtract: 'reverse-subtract',
        Min: 'min',
        Max: 'max'
    };
    const GPUColorWriteFlags = {
        None: 0,
        All: 0xF
    };
    const GPUStencilOperation = {
        Keep: 'keep',
        Zero: 'zero',
        Replace: 'replace',
        Invert: 'invert',
        IncrementClamp: 'increment-clamp',
        DecrementClamp: 'decrement-clamp',
        IncrementWrap: 'increment-wrap',
        DecrementWrap: 'decrement-wrap'
    };
    const GPUBufferBindingType = {
        Storage: 'storage',
        ReadOnlyStorage: 'read-only-storage'
    };
    const GPUStorageTextureAccess = {
        WriteOnly: 'write-only',
        ReadOnly: 'read-only',
        ReadWrite: 'read-write',
    };
    const GPUSamplerBindingType = {
        NonFiltering: 'non-filtering',
        Comparison: 'comparison'
    };
    const GPUTextureSampleType = {
        Float: 'float',
        UnfilterableFloat: 'unfilterable-float',
        Depth: 'depth',
        SInt: 'sint',
        UInt: 'uint'
    };
    const GPUTextureDimension = {
        TwoD: '2d',
        ThreeD: '3d'
    };
    const GPUTextureViewDimension = {
        TwoD: '2d',
        TwoDArray: '2d-array',
        Cube: 'cube',
        ThreeD: '3d'
    };
    const GPUTextureAspect = {
        All: 'all'
    };
    const GPUInputStepMode = {
        Vertex: 'vertex',
        Instance: 'instance'
    };
    const GPUFeatureName = {
        CoreFeaturesAndLimits: 'core-features-and-limits',
        DepthClipControl: 'depth-clip-control',
        Depth32FloatStencil8: 'depth32float-stencil8',
        TextureCompressionBC: 'texture-compression-bc',
        TextureCompressionBCSliced3D: 'texture-compression-bc-sliced-3d',
        TextureCompressionETC2: 'texture-compression-etc2',
        TextureCompressionASTC: 'texture-compression-astc',
        TextureCompressionASTCSliced3D: 'texture-compression-astc-sliced-3d',
        TimestampQuery: 'timestamp-query',
        IndirectFirstInstance: 'indirect-first-instance',
        ShaderF16: 'shader-f16',
        RG11B10UFloat: 'rg11b10ufloat-renderable',
        BGRA8UNormStorage: 'bgra8unorm-storage',
        Float32Filterable: 'float32-filterable',
        Float32Blendable: 'float32-blendable',
        ClipDistances: 'clip-distances',
        DualSourceBlending: 'dual-source-blending',
        Subgroups: 'subgroups',
        TextureFormatsTier1: 'texture-formats-tier1',
        TextureFormatsTier2: 'texture-formats-tier2'
    };
    class NodeSampler extends Sampler {
        constructor(name, textureNode, groupNode) {
            super(name, textureNode ? textureNode.value : null);
            this.textureNode = textureNode;
            this.groupNode = groupNode;
        }
        update() {
            this.texture = this.textureNode.value;
        }
    }
    class StorageBuffer extends Buffer {
        constructor(name, attribute) {
            super(name, attribute ? attribute.array : null);
            this.attribute = attribute;
            this.isStorageBuffer = true;
        }
    }
    let _id = 0;
    class NodeStorageBuffer extends StorageBuffer {
        constructor(nodeUniform, groupNode) {
            super('StorageBuffer_' + _id++, nodeUniform ? nodeUniform.value : null);
            this.nodeUniform = nodeUniform;
            this.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;
            this.groupNode = groupNode;
        }
        get buffer() {
            return this.nodeUniform.value;
        }
    }
    class WebGPUTexturePassUtils extends DataMap {
        constructor(device) {
            super();
            this.device = device;
            const mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};
@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {
	var Varys : VarysStruct;
	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);
	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);
	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );
	return Varys;
}
`;
            const mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;
@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;
@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {
	return textureSample( img, imgSampler, vTex );
}
`;
            const flipYFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;
@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;
@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {
	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );
}
`;
            this.mipmapSampler = device.createSampler({ minFilter: GPUFilterMode.Linear });
            this.flipYSampler = device.createSampler({ minFilter: GPUFilterMode.Nearest }); //@TODO?: Consider using textureLoad()
            this.transferPipelines = {};
            this.flipYPipelines = {};
            this.mipmapVertexShaderModule = device.createShaderModule({
                label: 'mipmapVertex',
                code: mipmapVertexSource
            });
            this.mipmapFragmentShaderModule = device.createShaderModule({
                label: 'mipmapFragment',
                code: mipmapFragmentSource
            });
            this.flipYFragmentShaderModule = device.createShaderModule({
                label: 'flipYFragment',
                code: flipYFragmentSource
            });
        }
        getTransferPipeline(format) {
            let pipeline = this.transferPipelines[format];
            if (pipeline === undefined) {
                pipeline = this.device.createRenderPipeline({
                    label: `mipmap-${format}`,
                    vertex: {
                        module: this.mipmapVertexShaderModule,
                        entryPoint: 'main'
                    },
                    fragment: {
                        module: this.mipmapFragmentShaderModule,
                        entryPoint: 'main',
                        targets: [{ format }]
                    },
                    primitive: {
                        topology: GPUPrimitiveTopology.TriangleStrip,
                        stripIndexFormat: GPUIndexFormat.Uint32
                    },
                    layout: 'auto'
                });
                this.transferPipelines[format] = pipeline;
            }
            return pipeline;
        }
        getFlipYPipeline(format) {
            let pipeline = this.flipYPipelines[format];
            if (pipeline === undefined) {
                pipeline = this.device.createRenderPipeline({
                    label: `flipY-${format}`,
                    vertex: {
                        module: this.mipmapVertexShaderModule,
                        entryPoint: 'main'
                    },
                    fragment: {
                        module: this.flipYFragmentShaderModule,
                        entryPoint: 'main',
                        targets: [{ format }]
                    },
                    primitive: {
                        topology: GPUPrimitiveTopology.TriangleStrip,
                        stripIndexFormat: GPUIndexFormat.Uint32
                    },
                    layout: 'auto'
                });
                this.flipYPipelines[format] = pipeline;
            }
            return pipeline;
        }
        flipY(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {
            const format = textureGPUDescriptor.format;
            const { width, height } = textureGPUDescriptor.size;
            const transferPipeline = this.getTransferPipeline(format);
            const flipYPipeline = this.getFlipYPipeline(format);
            const tempTexture = this.device.createTexture({
                size: { width, height, depthOrArrayLayers: 1 },
                format,
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
            });
            const srcView = textureGPU.createView({
                baseMipLevel: 0,
                mipLevelCount: 1,
                dimension: GPUTextureViewDimension.TwoD,
                baseArrayLayer
            });
            const dstView = tempTexture.createView({
                baseMipLevel: 0,
                mipLevelCount: 1,
                dimension: GPUTextureViewDimension.TwoD,
                baseArrayLayer: 0
            });
            const commandEncoder = this.device.createCommandEncoder({});
            const pass = (pipeline, sourceView, destinationView) => {
                const bindGroupLayout = pipeline.getBindGroupLayout(0); // @TODO: Consider making this static.
                const bindGroup = this.device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [{
                        binding: 0,
                        resource: this.flipYSampler
                    }, {
                        binding: 1,
                        resource: sourceView
                    }]
                });
                const passEncoder = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: destinationView,
                        loadOp: GPULoadOp.Clear,
                        storeOp: GPUStoreOp.Store,
                        clearValue: [0, 0, 0, 0]
                    }]
                });
                passEncoder.setPipeline(pipeline);
                passEncoder.setBindGroup(0, bindGroup);
                passEncoder.draw(4, 1, 0, 0);
                passEncoder.end();
            };
            pass(transferPipeline, srcView, dstView);
            pass(flipYPipeline, dstView, srcView);
            this.device.queue.submit([commandEncoder.finish()]);
            tempTexture.destroy();
        }
        generateMipmaps(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {
            const textureData = this.get(textureGPU);
            if (textureData.useCount === undefined) {
                textureData.useCount = 0;
                textureData.layers = [];
            }
            const passes = textureData.layers[baseArrayLayer] || this._mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer);
            const commandEncoder = this.device.createCommandEncoder({});
            this._mipmapRunBundles(commandEncoder, passes);
            this.device.queue.submit([commandEncoder.finish()]);
            if (textureData.useCount !== 0) textureData.layers[baseArrayLayer] = passes;
            textureData.useCount++;
        }
        _mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer) {
            const pipeline = this.getTransferPipeline(textureGPUDescriptor.format);
            const bindGroupLayout = pipeline.getBindGroupLayout(0); // @TODO: Consider making this static.
            let srcView = textureGPU.createView({
                baseMipLevel: 0,
                mipLevelCount: 1,
                dimension: GPUTextureViewDimension.TwoD,
                baseArrayLayer
            });
            const passes = [];
            for (let i = 1; i < textureGPUDescriptor.mipLevelCount; i++) {
                const bindGroup = this.device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [{
                        binding: 0,
                        resource: this.mipmapSampler
                    }, {
                        binding: 1,
                        resource: srcView
                    }]
                });
                const dstView = textureGPU.createView({
                    baseMipLevel: i,
                    mipLevelCount: 1,
                    dimension: GPUTextureViewDimension.TwoD,
                    baseArrayLayer
                });
                const passDescriptor = {
                    colorAttachments: [{
                        view: dstView,
                        loadOp: GPULoadOp.Clear,
                        storeOp: GPUStoreOp.Store,
                        clearValue: [0, 0, 0, 0]
                    }]
                };
                const passEncoder = this.device.createRenderBundleEncoder({
                    colorFormats: [textureGPUDescriptor.format]
                });
                passEncoder.setPipeline(pipeline);
                passEncoder.setBindGroup(0, bindGroup);
                passEncoder.draw(4, 1, 0, 0);
                passes.push({
                    renderBundles: [passEncoder.finish()],
                    passDescriptor
                });
                srcView = dstView;
            }
            return passes;
        }
        _mipmapRunBundles(commandEncoder, passes) {
            const levels = passes.length;
            for (let i = 0; i < levels; i++) {
                const pass = passes[i];
                const passEncoder = commandEncoder.beginRenderPass(pass.passDescriptor);
                passEncoder.executeBundles(pass.renderBundles);
                passEncoder.end();
            }
        }
    }
    const _compareToWebGPU = {
        [NeverCompare]: 'never',
        [LessCompare]: 'less',
        [EqualCompare]: 'equal',
        [LessEqualCompare]: 'less-equal',
        [GreaterCompare]: 'greater',
        [GreaterEqualCompare]: 'greater-equal',
        [AlwaysCompare]: 'always',
        [NotEqualCompare]: 'not-equal'
    };
    const _flipMap = [0, 1, 3, 2, 4, 5];
    class WebGPUTextureUtils {
        constructor(backend) {
            this.backend = backend;
            this._passUtils = null;
            this.defaultTexture = {};
            this.defaultCubeTexture = {};
            this.defaultVideoFrame = null;
            this.colorBuffer = null;
            this.depthTexture = new DepthTexture();
            this.depthTexture.name = 'depthBuffer';
        }
        createSampler(texture) {
            const backend = this.backend;
            const device = backend.device;
            const textureGPU = backend.get(texture);
            const samplerDescriptorGPU = {
                addressModeU: this._convertAddressMode(texture.wrapS),
                addressModeV: this._convertAddressMode(texture.wrapT),
                addressModeW: this._convertAddressMode(texture.wrapR),
                magFilter: this._convertFilterMode(texture.magFilter),
                minFilter: this._convertFilterMode(texture.minFilter),
                mipmapFilter: this._convertFilterMode(texture.minFilter),
                maxAnisotropy: 1
            };
            // anisotropy can only be used when all filter modes are set to linear.
            if (samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear) {
                samplerDescriptorGPU.maxAnisotropy = texture.anisotropy;
            }
            if (texture.isDepthTexture && texture.compareFunction !== null) {
                samplerDescriptorGPU.compare = _compareToWebGPU[texture.compareFunction];
            }
            textureGPU.sampler = device.createSampler(samplerDescriptorGPU);
        }
        createDefaultTexture(texture) {
            let textureGPU;
            const format = getFormat(texture);
            if (texture.isCubeTexture) {
                textureGPU = this._getDefaultCubeTextureGPU(format);
            } else {
                textureGPU = this._getDefaultTextureGPU(format);
            }
            this.backend.get(texture).texture = textureGPU;
        }
        createTexture(texture, options = {}) {
            const backend = this.backend;
            const textureData = backend.get(texture);
            if (textureData.initialized) {
                throw new Error('WebGPUTextureUtils: Texture already initialized.');
            }
            if (options.needsMipmaps === undefined) options.needsMipmaps = false;
            if (options.levels === undefined) options.levels = 1;
            if (options.depth === undefined) options.depth = 1;
            const { width, height, depth, levels } = options;
            if (texture.isFramebufferTexture) {
                if (options.renderTarget) {
                    options.format = this.backend.utils.getCurrentColorFormat(options.renderTarget);
                } else {
                    options.format = this.backend.utils.getPreferredCanvasFormat();
                }
            }
            const dimension = this._getDimension(texture);
            const format = texture.internalFormat || options.format || getFormat(texture, backend.device);
            textureData.format = format;
            const { samples, primarySamples, isMSAA } = backend.utils.getTextureSampleData(texture);
            let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
            if (texture.isStorageTexture === true) {
                usage |= GPUTextureUsage.STORAGE_BINDING;
            }
            if (texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true) {
                usage |= GPUTextureUsage.RENDER_ATTACHMENT;
            }
            const textureDescriptorGPU = {
                label: texture.name,
                size: {
                    width: width,
                    height: height,
                    depthOrArrayLayers: depth,
                },
                mipLevelCount: levels,
                sampleCount: primarySamples,
                dimension: dimension,
                format: format,
                usage: usage
            };
            // texture creation
            if (format === undefined) {
                console.warn('WebGPURenderer: Texture format not supported.');
                this.createDefaultTexture(texture);
                return;
            }
            if (texture.isCubeTexture) {
                textureDescriptorGPU.textureBindingViewDimension = GPUTextureViewDimension.Cube;
            }
            textureData.texture = backend.device.createTexture(textureDescriptorGPU);
            if (isMSAA) {
                const msaaTextureDescriptorGPU = Object.assign({}, textureDescriptorGPU);
                msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';
                msaaTextureDescriptorGPU.sampleCount = samples;
                textureData.msaaTexture = backend.device.createTexture(msaaTextureDescriptorGPU);
            }
            textureData.initialized = true;
            textureData.textureDescriptorGPU = textureDescriptorGPU;
        }
        destroyTexture(texture) {
            const backend = this.backend;
            const textureData = backend.get(texture);
            if (textureData.texture !== undefined) textureData.texture.destroy();
            if (textureData.msaaTexture !== undefined) textureData.msaaTexture.destroy();
            backend.delete(texture);
        }
        destroySampler(texture) {
            const backend = this.backend;
            const textureData = backend.get(texture);
            delete textureData.sampler;
        }
        generateMipmaps(texture) {
            const textureData = this.backend.get(texture);
            if (texture.isCubeTexture) {
                for (let i = 0; i < 6; i++) {
                    this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i);
                }
            } else {
                const depth = texture.image.depth || 1;
                for (let i = 0; i < depth; i++) {
                    this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i);
                }
            }
        }
        getColorBuffer() {
            if (this.colorBuffer) this.colorBuffer.destroy();
            const backend = this.backend;
            const { width, height } = backend.getDrawingBufferSize();
            this.colorBuffer = backend.device.createTexture({
                label: 'colorBuffer',
                size: {
                    width: width,
                    height: height,
                    depthOrArrayLayers: 1
                },
                sampleCount: backend.utils.getSampleCount(backend.renderer.samples),
                format: backend.utils.getPreferredCanvasFormat(),
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
            });
            return this.colorBuffer;
        }
        getDepthBuffer(depth = true, stencil = false) {
            const backend = this.backend;
            const { width, height } = backend.getDrawingBufferSize();
            const depthTexture = this.depthTexture;
            const depthTextureGPU = backend.get(depthTexture).texture;
            let format, type;
            if (stencil) {
                format = DepthStencilFormat;
                type = UnsignedInt248Type;
            } else if (depth) {
                format = DepthFormat;
                type = UnsignedIntType;
            }
            if (depthTextureGPU !== undefined) {
                if (depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type) {
                    return depthTextureGPU;
                }
                this.destroyTexture(depthTexture);
            }
            depthTexture.name = 'depthBuffer';
            depthTexture.format = format;
            depthTexture.type = type;
            depthTexture.image.width = width;
            depthTexture.image.height = height;
            this.createTexture(depthTexture, { width, height });
            return backend.get(depthTexture).texture;
        }
        updateTexture(texture, options) {
            const textureData = this.backend.get(texture);
            const { textureDescriptorGPU } = textureData;
            if (texture.isRenderTargetTexture || (textureDescriptorGPU === undefined /* unsupported texture format */))
                return;
            // transfer texture data
            if (texture.isDataTexture) {
                this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY);
            } else if (texture.isArrayTexture || texture.isDataArrayTexture || texture.isData3DTexture) {
                for (let i = 0; i < options.image.depth; i++) {
                    this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i);
                }
            } else if (texture.isCompressedTexture || texture.isCompressedArrayTexture) {
                this._copyCompressedBufferToTexture(texture.mipmaps, textureData.texture, textureDescriptorGPU);
            } else if (texture.isCubeTexture) {
                this._copyCubeMapToTexture(options.images, textureData.texture, textureDescriptorGPU, texture.flipY, texture.premultiplyAlpha);
            } else {
                this._copyImageToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY, texture.premultiplyAlpha);
            }
            //
            textureData.version = texture.version;
            if (texture.onUpdate) texture.onUpdate(texture);
        }
        async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {
            const device = this.backend.device;
            const textureData = this.backend.get(texture);
            const textureGPU = textureData.texture;
            const format = textureData.textureDescriptorGPU.format;
            const bytesPerTexel = this._getBytesPerTexel(format);
            let bytesPerRow = width * bytesPerTexel;
            bytesPerRow = Math.ceil(bytesPerRow / 256) * 256; // Align to 256 bytes
            const readBuffer = device.createBuffer(
                {
                    size: width * height * bytesPerTexel,
                    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
                }
            );
            const encoder = device.createCommandEncoder();
            encoder.copyTextureToBuffer(
                {
                    texture: textureGPU,
                    origin: { x, y, z: faceIndex },
                },
                {
                    buffer: readBuffer,
                    bytesPerRow: bytesPerRow
                },
                {
                    width: width,
                    height: height
                }
            );
            const typedArrayType = this._getTypedArrayType(format);
            device.queue.submit([encoder.finish()]);
            await readBuffer.mapAsync(GPUMapMode.READ);
            const buffer = readBuffer.getMappedRange();
            return new typedArrayType(buffer);
        }
        _getDefaultTextureGPU(format) {
            let defaultTexture = this.defaultTexture[format];
            if (defaultTexture === undefined) {
                const texture = new Texture();
                texture.minFilter = NearestFilter;
                texture.magFilter = NearestFilter;
                this.createTexture(texture, { width: 1, height: 1, format });
                this.defaultTexture[format] = defaultTexture = texture;
            }
            return this.backend.get(defaultTexture).texture;
        }
        _getDefaultCubeTextureGPU(format) {
            let defaultCubeTexture = this.defaultTexture[format];
            if (defaultCubeTexture === undefined) {
                const texture = new CubeTexture();
                texture.minFilter = NearestFilter;
                texture.magFilter = NearestFilter;
                this.createTexture(texture, { width: 1, height: 1, depth: 6 });
                this.defaultCubeTexture[format] = defaultCubeTexture = texture;
            }
            return this.backend.get(defaultCubeTexture).texture;
        }
        _copyCubeMapToTexture(images, textureGPU, textureDescriptorGPU, flipY, premultiplyAlpha) {
            for (let i = 0; i < 6; i++) {
                const image = images[i];
                const flipIndex = flipY === true ? _flipMap[i] : i;
                if (image.isDataTexture) {
                    this._copyBufferToTexture(image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY);
                } else {
                    this._copyImageToTexture(image, textureGPU, textureDescriptorGPU, flipIndex, flipY, premultiplyAlpha);
                }
            }
        }
        _copyImageToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY, premultiplyAlpha) {
            const device = this.backend.device;
            device.queue.copyExternalImageToTexture(
                {
                    source: image,
                    flipY: flipY
                }, {
                texture: textureGPU,
                mipLevel: 0,
                origin: { x: 0, y: 0, z: originDepth },
                premultipliedAlpha: premultiplyAlpha
            }, {
                width: textureDescriptorGPU.size.width,
                height: textureDescriptorGPU.size.height,
                depthOrArrayLayers: 1
            }
            );
        }
        _getPassUtils() {
            let passUtils = this._passUtils;
            if (passUtils === null) {
                this._passUtils = passUtils = new WebGPUTexturePassUtils(this.backend.device);
            }
            return passUtils;
        }
        _generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer = 0) {
            this._getPassUtils().generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer);
        }
        _flipY(textureGPU, textureDescriptorGPU, originDepth = 0) {
            this._getPassUtils().flipY(textureGPU, textureDescriptorGPU, originDepth);
        }
        _copyBufferToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0) {
            // @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()
            // @TODO: Consider to support valid buffer layouts with other formats like RGB
            const device = this.backend.device;
            const data = image.data;
            const bytesPerTexel = this._getBytesPerTexel(textureDescriptorGPU.format);
            const bytesPerRow = image.width * bytesPerTexel;
            device.queue.writeTexture(
                {
                    texture: textureGPU,
                    mipLevel: 0,
                    origin: { x: 0, y: 0, z: originDepth }
                },
                data,
                {
                    offset: image.width * image.height * bytesPerTexel * depth,
                    bytesPerRow
                },
                {
                    width: image.width,
                    height: image.height,
                    depthOrArrayLayers: 1
                });
            if (flipY === true) {
                this._flipY(textureGPU, textureDescriptorGPU, originDepth);
            }
        }
        _copyCompressedBufferToTexture(mipmaps, textureGPU, textureDescriptorGPU) {
            // @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()
            const device = this.backend.device;
            const blockData = this._getBlockData(textureDescriptorGPU.format);
            const isArrayTexture = textureDescriptorGPU.size.depthOrArrayLayers > 1;
            for (let i = 0; i < mipmaps.length; i++) {
                const mipmap = mipmaps[i];
                const width = mipmap.width;
                const height = mipmap.height;
                const depth = isArrayTexture ? textureDescriptorGPU.size.depthOrArrayLayers : 1;
                const bytesPerRow = Math.ceil(width / blockData.width) * blockData.byteLength;
                const bytesPerImage = bytesPerRow * Math.ceil(height / blockData.height);
                for (let j = 0; j < depth; j++) {
                    device.queue.writeTexture(
                        {
                            texture: textureGPU,
                            mipLevel: i,
                            origin: { x: 0, y: 0, z: j }
                        },
                        mipmap.data,
                        {
                            offset: j * bytesPerImage,
                            bytesPerRow,
                            rowsPerImage: Math.ceil(height / blockData.height)
                        },
                        {
                            width: Math.ceil(width / blockData.width) * blockData.width,
                            height: Math.ceil(height / blockData.height) * blockData.height,
                            depthOrArrayLayers: 1
                        }
                    );
                }
            }
        }
        _getBlockData(format) {
            if (format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB) return { byteLength: 8, width: 4, height: 4 }; // DXT1
            if (format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 }; // DXT3
            if (format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 }; // DXT5
            if (format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSnorm) return { byteLength: 8, width: 4, height: 4 }; // RGTC1
            if (format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm) return { byteLength: 16, width: 4, height: 4 }; // RGTC2
            if (format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)
            if (format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)
            if (format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
            if (format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
            if (format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
            if (format === GPUTextureFormat.EACR11Unorm) return { byteLength: 8, width: 4, height: 4 };
            if (format === GPUTextureFormat.EACR11Snorm) return { byteLength: 8, width: 4, height: 4 };
            if (format === GPUTextureFormat.EACRG11Unorm) return { byteLength: 16, width: 4, height: 4 };
            if (format === GPUTextureFormat.EACRG11Snorm) return { byteLength: 16, width: 4, height: 4 };
            if (format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
            if (format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB) return { byteLength: 16, width: 5, height: 4 };
            if (format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB) return { byteLength: 16, width: 5, height: 5 };
            if (format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB) return { byteLength: 16, width: 6, height: 5 };
            if (format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB) return { byteLength: 16, width: 6, height: 6 };
            if (format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB) return { byteLength: 16, width: 8, height: 5 };
            if (format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB) return { byteLength: 16, width: 8, height: 6 };
            if (format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB) return { byteLength: 16, width: 8, height: 8 };
            if (format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB) return { byteLength: 16, width: 10, height: 5 };
            if (format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB) return { byteLength: 16, width: 10, height: 6 };
            if (format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB) return { byteLength: 16, width: 10, height: 8 };
            if (format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB) return { byteLength: 16, width: 10, height: 10 };
            if (format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB) return { byteLength: 16, width: 12, height: 10 };
            if (format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB) return { byteLength: 16, width: 12, height: 12 };
        }
        _convertAddressMode(value) {
            let addressMode = GPUAddressMode.ClampToEdge;
            if (value === RepeatWrapping) {
                addressMode = GPUAddressMode.Repeat;
            } else if (value === MirroredRepeatWrapping) {
                addressMode = GPUAddressMode.MirrorRepeat;
            }
            return addressMode;
        }
        _convertFilterMode(value) {
            let filterMode = GPUFilterMode.Linear;
            if (value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter) {
                filterMode = GPUFilterMode.Nearest;
            }
            return filterMode;
        }
        _getBytesPerTexel(format) {
            // 8-bit formats
            if (format === GPUTextureFormat.R8Unorm ||
                format === GPUTextureFormat.R8Snorm ||
                format === GPUTextureFormat.R8Uint ||
                format === GPUTextureFormat.R8Sint) return 1;
            // 16-bit formats
            if (format === GPUTextureFormat.R16Uint ||
                format === GPUTextureFormat.R16Sint ||
                format === GPUTextureFormat.R16Float ||
                format === GPUTextureFormat.RG8Unorm ||
                format === GPUTextureFormat.RG8Snorm ||
                format === GPUTextureFormat.RG8Uint ||
                format === GPUTextureFormat.RG8Sint) return 2;
            // 32-bit formats
            if (format === GPUTextureFormat.R32Uint ||
                format === GPUTextureFormat.R32Sint ||
                format === GPUTextureFormat.R32Float ||
                format === GPUTextureFormat.RG16Uint ||
                format === GPUTextureFormat.RG16Sint ||
                format === GPUTextureFormat.RG16Float ||
                format === GPUTextureFormat.RGBA8Unorm ||
                format === GPUTextureFormat.RGBA8UnormSRGB ||
                format === GPUTextureFormat.RGBA8Snorm ||
                format === GPUTextureFormat.RGBA8Uint ||
                format === GPUTextureFormat.RGBA8Sint ||
                format === GPUTextureFormat.BGRA8Unorm ||
                format === GPUTextureFormat.BGRA8UnormSRGB ||
                // Packed 32-bit formats
                format === GPUTextureFormat.RGB9E5UFloat ||
                format === GPUTextureFormat.RGB10A2Unorm ||
                format === GPUTextureFormat.RG11B10UFloat ||
                format === GPUTextureFormat.Depth32Float ||
                format === GPUTextureFormat.Depth24Plus ||
                format === GPUTextureFormat.Depth24PlusStencil8 ||
                format === GPUTextureFormat.Depth32FloatStencil8) return 4;
            // 64-bit formats
            if (format === GPUTextureFormat.RG32Uint ||
                format === GPUTextureFormat.RG32Sint ||
                format === GPUTextureFormat.RG32Float ||
                format === GPUTextureFormat.RGBA16Uint ||
                format === GPUTextureFormat.RGBA16Sint ||
                format === GPUTextureFormat.RGBA16Float) return 8;
            // 128-bit formats
            if (format === GPUTextureFormat.RGBA32Uint ||
                format === GPUTextureFormat.RGBA32Sint ||
                format === GPUTextureFormat.RGBA32Float) return 16;

        }
        _getTypedArrayType(format) {
            if (format === GPUTextureFormat.R8Uint) return Uint8Array;
            if (format === GPUTextureFormat.R8Sint) return Int8Array;
            if (format === GPUTextureFormat.R8Unorm) return Uint8Array;
            if (format === GPUTextureFormat.R8Snorm) return Int8Array;
            if (format === GPUTextureFormat.RG8Uint) return Uint8Array;
            if (format === GPUTextureFormat.RG8Sint) return Int8Array;
            if (format === GPUTextureFormat.RG8Unorm) return Uint8Array;
            if (format === GPUTextureFormat.RG8Snorm) return Int8Array;
            if (format === GPUTextureFormat.RGBA8Uint) return Uint8Array;
            if (format === GPUTextureFormat.RGBA8Sint) return Int8Array;
            if (format === GPUTextureFormat.RGBA8Unorm) return Uint8Array;
            if (format === GPUTextureFormat.RGBA8Snorm) return Int8Array;

            if (format === GPUTextureFormat.R16Uint) return Uint16Array;
            if (format === GPUTextureFormat.R16Sint) return Int16Array;
            if (format === GPUTextureFormat.RG16Uint) return Uint16Array;
            if (format === GPUTextureFormat.RG16Sint) return Int16Array;
            if (format === GPUTextureFormat.RGBA16Uint) return Uint16Array;
            if (format === GPUTextureFormat.RGBA16Sint) return Int16Array;
            if (format === GPUTextureFormat.R16Float) return Uint16Array;
            if (format === GPUTextureFormat.RG16Float) return Uint16Array;
            if (format === GPUTextureFormat.RGBA16Float) return Uint16Array;

            if (format === GPUTextureFormat.R32Uint) return Uint32Array;
            if (format === GPUTextureFormat.R32Sint) return Int32Array;
            if (format === GPUTextureFormat.R32Float) return Float32Array;
            if (format === GPUTextureFormat.RG32Uint) return Uint32Array;
            if (format === GPUTextureFormat.RG32Sint) return Int32Array;
            if (format === GPUTextureFormat.RG32Float) return Float32Array;
            if (format === GPUTextureFormat.RGBA32Uint) return Uint32Array;
            if (format === GPUTextureFormat.RGBA32Sint) return Int32Array;
            if (format === GPUTextureFormat.RGBA32Float) return Float32Array;
            if (format === GPUTextureFormat.BGRA8Unorm) return Uint8Array;
            if (format === GPUTextureFormat.BGRA8UnormSRGB) return Uint8Array;
            if (format === GPUTextureFormat.RGB10A2Unorm) return Uint32Array;
            if (format === GPUTextureFormat.RGB9E5UFloat) return Uint32Array;
            if (format === GPUTextureFormat.RG11B10UFloat) return Uint32Array;
            if (format === GPUTextureFormat.Depth32Float) return Float32Array;
            if (format === GPUTextureFormat.Depth24Plus) return Uint32Array;
            if (format === GPUTextureFormat.Depth24PlusStencil8) return Uint32Array;
            if (format === GPUTextureFormat.Depth32FloatStencil8) return Float32Array;
        }
        _getDimension(texture) {
            let dimension;
            if (texture.is3DTexture || texture.isData3DTexture) {
                dimension = GPUTextureDimension.ThreeD;
            } else {
                dimension = GPUTextureDimension.TwoD;
            }
            return dimension;
        }
    }
    function getFormat(texture, device = null) {
        const format = texture.format;
        const type = texture.type;
        const colorSpace = texture.colorSpace;
        const transfer = ColorManagement.getTransfer(colorSpace);
        let formatGPU;
        if (texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true) {
            switch (format) {
                case RGBA_S3TC_DXT1_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;
                    break;
                case RGBA_S3TC_DXT3_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;
                    break;
                case RGBA_S3TC_DXT5_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;
                    break;
                case RGB_ETC2_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;
                    break;
                case RGBA_ETC2_EAC_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;
                    break;
                case RGBA_ASTC_4x4_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;
                    break;
                case RGBA_ASTC_5x4_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;
                    break;
                case RGBA_ASTC_5x5_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;
                    break;
                case RGBA_ASTC_6x5_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;
                    break;
                case RGBA_ASTC_6x6_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;
                    break;
                case RGBA_ASTC_8x5_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;
                    break;
                case RGBA_ASTC_8x6_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;
                    break;
                case RGBA_ASTC_8x8_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;
                    break;
                case RGBA_ASTC_10x5_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;
                    break;
                case RGBA_ASTC_10x6_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;
                    break;
                case RGBA_ASTC_10x8_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;
                    break;
                case RGBA_ASTC_10x10_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;
                    break;
                case RGBA_ASTC_12x10_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;
                    break;
                case RGBA_ASTC_12x12_Format:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;
                    break;
                case RGBAFormat:
                    formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
                    break;
                default:
                    console.error('WebGPURenderer: Unsupported texture format.', format);
            }
        } else {
            switch (format) {
                case RGBAFormat:
                    switch (type) {
                        case ByteType:
                            formatGPU = GPUTextureFormat.RGBA8Snorm;
                            break;
                        case ShortType:
                            formatGPU = GPUTextureFormat.RGBA16Sint;
                            break;
                        case UnsignedShortType:
                            formatGPU = GPUTextureFormat.RGBA16Uint;
                            break;
                        case UnsignedIntType:
                            formatGPU = GPUTextureFormat.RGBA32Uint;
                            break;
                        case IntType:
                            formatGPU = GPUTextureFormat.RGBA32Sint;
                            break;
                        case UnsignedByteType:
                            formatGPU = (transfer === SRGBTransfer) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
                            break;
                        case HalfFloatType:
                            formatGPU = GPUTextureFormat.RGBA16Float;
                            break;
                        case FloatType:
                            formatGPU = GPUTextureFormat.RGBA32Float;
                            break;
                        default:
                            console.error('WebGPURenderer: Unsupported texture type with RGBAFormat.', type);
                    }
                    break;
                case RGBFormat:
                    switch (type) {
                        case UnsignedInt5999Type:
                            formatGPU = GPUTextureFormat.RGB9E5UFloat;
                            break;
                        default:
                            console.error('WebGPURenderer: Unsupported texture type with RGBFormat.', type);
                    }
                    break;
                case RedFormat:
                    switch (type) {
                        case ByteType:
                            formatGPU = GPUTextureFormat.R8Snorm;
                            break;
                        case ShortType:
                            formatGPU = GPUTextureFormat.R16Sint;
                            break;
                        case UnsignedShortType:
                            formatGPU = GPUTextureFormat.R16Uint;
                            break;
                        case UnsignedIntType:
                            formatGPU = GPUTextureFormat.R32Uint;
                            break;
                        case IntType:
                            formatGPU = GPUTextureFormat.R32Sint;
                            break;
                        case UnsignedByteType:
                            formatGPU = GPUTextureFormat.R8Unorm;
                            break;
                        case HalfFloatType:
                            formatGPU = GPUTextureFormat.R16Float;
                            break;
                        case FloatType:
                            formatGPU = GPUTextureFormat.R32Float;
                            break;
                        default:
                            console.error('WebGPURenderer: Unsupported texture type with RedFormat.', type);
                    }
                    break;
                case RGFormat:
                    switch (type) {
                        case ByteType:
                            formatGPU = GPUTextureFormat.RG8Snorm;
                            break;
                        case ShortType:
                            formatGPU = GPUTextureFormat.RG16Sint;
                            break;
                        case UnsignedShortType:
                            formatGPU = GPUTextureFormat.RG16Uint;
                            break;
                        case UnsignedIntType:
                            formatGPU = GPUTextureFormat.RG32Uint;
                            break;
                        case IntType:
                            formatGPU = GPUTextureFormat.RG32Sint;
                            break;
                        case UnsignedByteType:
                            formatGPU = GPUTextureFormat.RG8Unorm;
                            break;
                        case HalfFloatType:
                            formatGPU = GPUTextureFormat.RG16Float;
                            break;
                        case FloatType:
                            formatGPU = GPUTextureFormat.RG32Float;
                            break;
                        default:
                            console.error('WebGPURenderer: Unsupported texture type with RGFormat.', type);
                    }
                    break;
                case DepthFormat:
                    switch (type) {
                        case UnsignedShortType:
                            formatGPU = GPUTextureFormat.Depth16Unorm;
                            break;
                        case UnsignedIntType:
                            formatGPU = GPUTextureFormat.Depth24Plus;
                            break;
                        case FloatType:
                            formatGPU = GPUTextureFormat.Depth32Float;
                            break;
                        default:
                            console.error('WebGPURenderer: Unsupported texture type with DepthFormat.', type);
                    }
                    break;
                case DepthStencilFormat:
                    switch (type) {
                        case UnsignedInt248Type:
                            formatGPU = GPUTextureFormat.Depth24PlusStencil8;
                            break;
                        case FloatType:
                            if (device && device.features.has(GPUFeatureName.Depth32FloatStencil8) === false) {
                                console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.');
                            }
                            formatGPU = GPUTextureFormat.Depth32FloatStencil8;
                            break;
                        default:
                            console.error('WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type);
                    }
                    break;
                case RedIntegerFormat:
                    switch (type) {
                        case IntType:
                            formatGPU = GPUTextureFormat.R32Sint;
                            break;
                        case UnsignedIntType:
                            formatGPU = GPUTextureFormat.R32Uint;
                            break;
                        default:
                            console.error('WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type);
                    }
                    break;
                case RGIntegerFormat:
                    switch (type) {
                        case IntType:
                            formatGPU = GPUTextureFormat.RG32Sint;
                            break;
                        case UnsignedIntType:
                            formatGPU = GPUTextureFormat.RG32Uint;
                            break;
                        default:
                            console.error('WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type);
                    }
                    break;
                case RGBAIntegerFormat:
                    switch (type) {
                        case IntType:
                            formatGPU = GPUTextureFormat.RGBA32Sint;
                            break;
                        case UnsignedIntType:
                            formatGPU = GPUTextureFormat.RGBA32Uint;
                            break;
                        default:
                            console.error('WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type);
                    }
                    break;
                default:
                    console.error('WebGPURenderer: Unsupported texture format.', format);
            }
        }
        return formatGPU;
    }
    const declarationRegexp = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i;
    const propertiesRegexp = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig;
    const wgslTypeLib$1 = {
        'f32': 'float',
        'i32': 'int',
        'u32': 'uint',
        'bool': 'bool',
        'vec2<f32>': 'vec2',
        'vec2<i32>': 'ivec2',
        'vec2<u32>': 'uvec2',
        'vec2<bool>': 'bvec2',
        'vec2f': 'vec2',
        'vec2i': 'ivec2',
        'vec2u': 'uvec2',
        'vec2b': 'bvec2',
        'vec3<f32>': 'vec3',
        'vec3<i32>': 'ivec3',
        'vec3<u32>': 'uvec3',
        'vec3<bool>': 'bvec3',
        'vec3f': 'vec3',
        'vec3i': 'ivec3',
        'vec3u': 'uvec3',
        'vec3b': 'bvec3',
        'vec4<f32>': 'vec4',
        'vec4<i32>': 'ivec4',
        'vec4<u32>': 'uvec4',
        'vec4<bool>': 'bvec4',
        'vec4f': 'vec4',
        'vec4i': 'ivec4',
        'vec4u': 'uvec4',
        'vec4b': 'bvec4',
        'mat2x2<f32>': 'mat2',
        'mat2x2f': 'mat2',
        'mat3x3<f32>': 'mat3',
        'mat3x3f': 'mat3',
        'mat4x4<f32>': 'mat4',
        'mat4x4f': 'mat4',
        'sampler': 'sampler',
        'texture_1d': 'texture',
        'texture_2d': 'texture',
        'texture_2d_array': 'texture',
        'texture_multisampled_2d': 'cubeTexture',
        'texture_depth_2d': 'depthTexture',
        'texture_depth_2d_array': 'depthTexture',
        'texture_depth_multisampled_2d': 'depthTexture',
        'texture_depth_cube': 'depthTexture',
        'texture_depth_cube_array': 'depthTexture',
        'texture_3d': 'texture3D',
        'texture_cube': 'cubeTexture',
        'texture_cube_array': 'cubeTexture',
        'texture_storage_1d': 'storageTexture',
        'texture_storage_2d': 'storageTexture',
        'texture_storage_2d_array': 'storageTexture',
        'texture_storage_3d': 'storageTexture'
    };
    const parse = (source) => {
        source = source.trim();
        const declaration = source.match(declarationRegexp);
        if (declaration !== null && declaration.length === 4) {
            const inputsCode = declaration[2];
            const propsMatches = [];
            let match = null;
            while ((match = propertiesRegexp.exec(inputsCode)) !== null) {
                propsMatches.push({ name: match[1], type: match[2] });
            }
            // Process matches to correctly pair names and types
            const inputs = [];
            for (let i = 0; i < propsMatches.length; i++) {
                const { name, type } = propsMatches[i];
                let resolvedType = type;
                if (resolvedType.startsWith('ptr')) {
                    resolvedType = 'pointer';
                } else {
                    if (resolvedType.startsWith('texture')) {
                        resolvedType = type.split('<')[0];
                    }
                    resolvedType = wgslTypeLib$1[resolvedType];
                }
                inputs.push(new NodeFunctionInput(resolvedType, name));
            }
            const blockCode = source.substring(declaration[0].length);
            const outputType = declaration[3] || 'void';
            const name = declaration[1] !== undefined ? declaration[1] : '';
            const type = wgslTypeLib$1[outputType] || outputType;
            return {
                type,
                inputs,
                name,
                inputsCode,
                blockCode,
                outputType
            };
        } else {
            throw new Error('FunctionNode: Function is not a WGSL code.');
        }
    };
    class WGSLNodeFunction extends NodeFunction {
        constructor(source) {
            const { type, inputs, name, inputsCode, blockCode, outputType } = parse(source);
            super(type, inputs, name);
            this.inputsCode = inputsCode;
            this.blockCode = blockCode;
            this.outputType = outputType;
        }
        getCode(name = this.name) {
            const outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';
            return `fn ${name} ( ${this.inputsCode.trim()} ) ${outputType}` + this.blockCode;
        }
    }
    class WGSLNodeParser extends NodeParser {
        parseFunction(source) {
            return new WGSLNodeFunction(source);
        }
    }
    // GPUShaderStage is not defined in browsers not supporting WebGPU
    const GPUShaderStage = (typeof self !== 'undefined') ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };
    const accessNames = {
        [NodeAccess.READ_ONLY]: 'read',
        [NodeAccess.WRITE_ONLY]: 'write',
        [NodeAccess.READ_WRITE]: 'read_write'
    };
    const wrapNames = {
        [RepeatWrapping]: 'repeat',
        [ClampToEdgeWrapping]: 'clamp',
        [MirroredRepeatWrapping]: 'mirror'
    };
    const gpuShaderStageLib = {
        'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,
        'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,
        'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4
    };
    const supports = {
        instance: true,
        swizzleAssign: false,
        storageBuffer: true
    };
    const wgslFnOpLib = {
        '^^': 'tsl_xor'
    };
    const wgslTypeLib = {
        float: 'f32',
        int: 'i32',
        uint: 'u32',
        bool: 'bool',
        color: 'vec3<f32>',
        vec2: 'vec2<f32>',
        ivec2: 'vec2<i32>',
        uvec2: 'vec2<u32>',
        bvec2: 'vec2<bool>',
        vec3: 'vec3<f32>',
        ivec3: 'vec3<i32>',
        uvec3: 'vec3<u32>',
        bvec3: 'vec3<bool>',
        vec4: 'vec4<f32>',
        ivec4: 'vec4<i32>',
        uvec4: 'vec4<u32>',
        bvec4: 'vec4<bool>',
        mat2: 'mat2x2<f32>',
        mat3: 'mat3x3<f32>',
        mat4: 'mat4x4<f32>'
    };
    const wgslCodeCache = {};
    const wgslPolyfill = {
        tsl_xor: new CodeNode('fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }'),
        mod_float: new CodeNode('fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }'),
        mod_vec2: new CodeNode('fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }'),
        mod_vec3: new CodeNode('fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }'),
        mod_vec4: new CodeNode('fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }'),
        equals_bool: new CodeNode('fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }'),
        equals_bvec2: new CodeNode('fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }'),
        equals_bvec3: new CodeNode('fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }'),
        equals_bvec4: new CodeNode('fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }'),
        repeatWrapping_float: new CodeNode('fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }'),
        mirrorWrapping_float: new CodeNode('fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }'),
        clampWrapping_float: new CodeNode('fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }'),
        biquadraticTexture: new CodeNode( /* wgsl */`
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {
	let res = vec2f( iRes );
	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;
	// https://www.shadertoy.com/view/WtyXRy
	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );
	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );
	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );
}
` )
    };
    const wgslMethods = {
        dFdx: 'dpdx',
        dFdy: '- dpdy',
        mod_float: 'tsl_mod_float',
        mod_vec2: 'tsl_mod_vec2',
        mod_vec3: 'tsl_mod_vec3',
        mod_vec4: 'tsl_mod_vec4',
        equals_bool: 'tsl_equals_bool',
        equals_bvec2: 'tsl_equals_bvec2',
        equals_bvec3: 'tsl_equals_bvec3',
        equals_bvec4: 'tsl_equals_bvec4',
        inversesqrt: 'inverseSqrt',
        bitcast: 'bitcast<f32>'
    };
    // WebGPU issue: does not support pow() with negative base on Windows
    if (typeof navigator !== 'undefined' && /Windows/g.test(navigator.userAgent)) {
        wgslPolyfill.pow_float = new CodeNode('fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }');
        wgslPolyfill.pow_vec2 = new CodeNode('fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [wgslPolyfill.pow_float]);
        wgslPolyfill.pow_vec3 = new CodeNode('fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [wgslPolyfill.pow_float]);
        wgslPolyfill.pow_vec4 = new CodeNode('fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [wgslPolyfill.pow_float]);
        wgslMethods.pow_float = 'tsl_pow_float';
        wgslMethods.pow_vec2 = 'tsl_pow_vec2';
        wgslMethods.pow_vec3 = 'tsl_pow_vec3';
        wgslMethods.pow_vec4 = 'tsl_pow_vec4';
    }
    //
    let diagnostics = '';
    if ((typeof navigator !== 'undefined' && /Firefox|Deno/g.test(navigator.userAgent)) !== true) {
        diagnostics += 'diagnostic( off, derivative_uniformity );\n';
    }
    class WGSLNodeBuilder extends NodeBuilder {
        constructor(object, renderer) {
            super(object, renderer, new WGSLNodeParser());
            this.uniformGroups = {};
            this.builtins = {};
            this.directives = {};
            this.scopedArrays = new Map();
        }
        _generateTextureSample(texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage) {
            if (shaderStage === 'fragment') {
                if (depthSnippet) {
                    return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;
                } else {
                    return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;
                }
            } else {
                return this.generateTextureSampleLevel(texture, textureProperty, uvSnippet, '0', depthSnippet);
            }
        }
        generateTextureSampleLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet) {
            if (this.isUnfilterable(texture) === false) {
                return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;
            } else if (this.isFilteredTexture(texture)) {
                return this.generateFilteredTexture(texture, textureProperty, uvSnippet, levelSnippet);
            } else {
                return this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, levelSnippet);
            }
        }
        generateWrapFunction(texture) {
            const functionName = `tsl_coord_${wrapNames[texture.wrapS]}S_${wrapNames[texture.wrapT]}_${texture.isData3DTexture ? '3d' : '2d'}T`;
            let nodeCode = wgslCodeCache[functionName];
            if (nodeCode === undefined) {
                const includes = [];
                // For 3D textures, use vec3f; for texture arrays, keep vec2f since array index is separate
                const coordType = texture.isData3DTexture ? 'vec3f' : 'vec2f';
                let code = `fn ${functionName}( coord : ${coordType} ) -> ${coordType} {\n\n\treturn ${coordType}(\n`;
                const addWrapSnippet = (wrap, axis) => {
                    if (wrap === RepeatWrapping) {
                        includes.push(wgslPolyfill.repeatWrapping_float);
                        code += `\t\ttsl_repeatWrapping_float( coord.${axis} )`;
                    } else if (wrap === ClampToEdgeWrapping) {
                        includes.push(wgslPolyfill.clampWrapping_float);
                        code += `\t\ttsl_clampWrapping_float( coord.${axis} )`;
                    } else if (wrap === MirroredRepeatWrapping) {
                        includes.push(wgslPolyfill.mirrorWrapping_float);
                        code += `\t\ttsl_mirrorWrapping_float( coord.${axis} )`;
                    } else {
                        code += `\t\tcoord.${axis}`;
                        console.warn(`WebGPURenderer: Unsupported texture wrap type "${wrap}" for vertex shader.`);
                    }
                };
                addWrapSnippet(texture.wrapS, 'x');
                code += ',\n';
                addWrapSnippet(texture.wrapT, 'y');
                if (texture.isData3DTexture) {
                    code += ',\n';
                    addWrapSnippet(texture.wrapR, 'z');
                }
                code += '\n\t);\n\n}\n';
                wgslCodeCache[functionName] = nodeCode = new CodeNode(code, includes);
            }
            nodeCode.build(this);
            return functionName;
        }
        generateArrayDeclaration(type, count) {
            return `array< ${this.getType(type)}, ${count} >`;
        }
        generateTextureDimension(texture, textureProperty, levelSnippet) {
            const textureData = this.getDataFromNode(texture, this.shaderStage, this.globalCache);
            if (textureData.dimensionsSnippet === undefined) textureData.dimensionsSnippet = {};
            let textureDimensionNode = textureData.dimensionsSnippet[levelSnippet];
            if (textureData.dimensionsSnippet[levelSnippet] === undefined) {
                let textureDimensionsParams;
                let dimensionType;
                const { primarySamples } = this.renderer.backend.utils.getTextureSampleData(texture);
                const isMultisampled = primarySamples > 1;
                if (texture.isData3DTexture) {
                    dimensionType = 'vec3<u32>';
                } else {
                    // Regular 2D textures, depth textures, etc.
                    dimensionType = 'vec2<u32>';
                }
                // Build parameters string based on texture type and multisampling
                if (isMultisampled || texture.isStorageTexture) {
                    textureDimensionsParams = textureProperty;
                } else {
                    textureDimensionsParams = `${textureProperty}${levelSnippet ? `, u32( ${levelSnippet} )` : ''}`;
                }
                textureDimensionNode = new VarNode(new ExpressionNode(`textureDimensions( ${textureDimensionsParams} )`, dimensionType));
                textureData.dimensionsSnippet[levelSnippet] = textureDimensionNode;
                if (texture.isArrayTexture || texture.isDataArrayTexture || texture.isData3DTexture) {
                    textureData.arrayLayerCount = new VarNode(
                        new ExpressionNode(
                            `textureNumLayers(${textureProperty})`,
                            'u32'
                        )
                    );
                }
                // For cube textures, we know it's always 6 faces
                if (texture.isTextureCube) {
                    textureData.cubeFaceCount = new VarNode(
                        new ExpressionNode('6u', 'u32')
                    );
                }
            }
            return textureDimensionNode.build(this);
        }
        generateFilteredTexture(texture, textureProperty, uvSnippet, levelSnippet = '0u') {
            this._include('biquadraticTexture');
            const wrapFunction = this.generateWrapFunction(texture);
            const textureDimension = this.generateTextureDimension(texture, textureProperty, levelSnippet);
            return `tsl_biquadraticTexture( ${textureProperty}, ${wrapFunction}( ${uvSnippet} ), ${textureDimension}, u32( ${levelSnippet} ) )`;
        }
        generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, levelSnippet = '0u') {
            const wrapFunction = this.generateWrapFunction(texture);
            const textureDimension = this.generateTextureDimension(texture, textureProperty, levelSnippet);
            const vecType = texture.isData3DTexture ? 'vec3' : 'vec2';
            const coordSnippet = `${vecType}<u32>( ${wrapFunction}( ${uvSnippet} ) * ${vecType}<f32>( ${textureDimension} ) )`;
            return this.generateTextureLoad(texture, textureProperty, coordSnippet, depthSnippet, levelSnippet);
        }
        generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u') {
            let snippet;
            if (depthSnippet) {
                snippet = `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, u32( ${levelSnippet} ) )`;
            } else {
                snippet = `textureLoad( ${textureProperty}, ${uvIndexSnippet}, u32( ${levelSnippet} ) )`;
                if (this.renderer.backend.compatibilityMode && texture.isDepthTexture) {
                    snippet += '.x';
                }
            }
            return snippet;
        }
        generateTextureStore(texture, textureProperty, uvIndexSnippet, depthSnippet, valueSnippet) {
            let snippet;
            if (depthSnippet) {
                snippet = `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, ${valueSnippet} )`;
            } else {
                snippet = `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${valueSnippet} )`;
            }
            return snippet;
        }
        isSampleCompare(texture) {
            return texture.isDepthTexture === true && texture.compareFunction !== null;
        }
        isUnfilterable(texture) {
            return this.getComponentTypeFromTexture(texture) !== 'float' ||
                (!this.isAvailable('float32Filterable') && texture.isDataTexture === true && texture.type === FloatType) ||
                (this.isSampleCompare(texture) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter) ||
                this.renderer.backend.utils.getTextureSampleData(texture).primarySamples > 1;
        }
        generateTexture(texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage) {
            let snippet = null;
            if (this.isUnfilterable(texture)) {
                snippet = this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage);
            } else {
                snippet = this._generateTextureSample(texture, textureProperty, uvSnippet, depthSnippet, shaderStage);
            }
            return snippet;
        }
        generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage) {
            if (shaderStage === 'fragment') {
                // TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy
                return `textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]} )`;
            } else {
                console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${shaderStage} shader.`);
            }
        }
        generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage) {
            if (shaderStage === 'fragment') {
                if (texture.isDepthTexture === true && texture.isArrayTexture === true) {
                    return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet}, ${compareSnippet} )`;
                }
                return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;
            } else {
                console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
            }
        }
        generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet) {
            if (this.isUnfilterable(texture) === false) {
                return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;
            } else if (this.isFilteredTexture(texture)) {
                return this.generateFilteredTexture(texture, textureProperty, uvSnippet, levelSnippet);
            } else {
                return this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, levelSnippet);
            }
        }
        generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, shaderStage = this.shaderStage) {
            if (shaderStage === 'fragment') {
                return `textureSampleBias( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;
            } else {
                console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${shaderStage} shader.`);
            }
        }
        getPropertyName(node, shaderStage = this.shaderStage) {
            if (node.isNodeVarying === true && node.needsInterpolation === true) {
                if (shaderStage === 'vertex') {
                    return `varyings.${node.name}`;
                }
            } else if (node.isNodeUniform === true) {
                const name = node.name;
                const type = node.type;
                if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') {
                    return name;
                } else if (type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer') {
                    if (this.isCustomStruct(node)) {
                        return name;
                    }
                    return name + '.value';
                } else {
                    return node.groupNode.name + '.' + name;
                }
            }
            return super.getPropertyName(node);
        }
        getOutputStructName() {
            return 'output';
        }
        getFunctionOperator(op) {
            const fnOp = wgslFnOpLib[op];
            if (fnOp !== undefined) {
                this._include(fnOp);
                return fnOp;
            }
            return null;
        }
        getNodeAccess(node, shaderStage) {
            if (shaderStage !== 'compute') {
                if (node.isAtomic === true) {
                    console.warn('WebGPURenderer: Atomic operations are only supported in compute shaders.');
                    return NodeAccess.READ_WRITE;
                }
                return NodeAccess.READ_ONLY;
            }
            return node.access;
        }
        getStorageAccess(node, shaderStage) {
            return accessNames[this.getNodeAccess(node, shaderStage)];
        }
        getUniformFromNode(node, type, shaderStage, name = null) {
            const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
            const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
            if (nodeData.uniformGPU === undefined) {
                let uniformGPU;
                const group = node.groupNode;
                const groupName = group.name;
                const bindings = this.getBindGroupArray(groupName, shaderStage);
                if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') {
                    let texture = null;
                    const access = this.getNodeAccess(node, shaderStage);
                    if (type === 'texture' || type === 'storageTexture') {
                        if (node.value.is3DTexture === true) {
                            texture = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group, access);
                        } else {
                            texture = new NodeSampledTexture(uniformNode.name, uniformNode.node, group, access);
                        }
                    } else if (type === 'cubeTexture') {
                        texture = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group, access);
                    } else if (type === 'texture3D') {
                        texture = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group, access);
                    }
                    texture.store = node.isStorageTextureNode === true;
                    texture.setVisibility(gpuShaderStageLib[shaderStage]);
                    if (this.isUnfilterable(node.value) === false && texture.store === false) {
                        const sampler = new NodeSampler(`${uniformNode.name}_sampler`, uniformNode.node, group);
                        sampler.setVisibility(gpuShaderStageLib[shaderStage]);
                        bindings.push(sampler, texture);
                        uniformGPU = [sampler, texture];
                    } else {
                        bindings.push(texture);
                        uniformGPU = [texture];
                    }
                } else if (type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer') {
                    const bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;
                    const buffer = new bufferClass(node, group);
                    buffer.setVisibility(gpuShaderStageLib[shaderStage]);
                    bindings.push(buffer);
                    uniformGPU = buffer;
                    uniformNode.name = name ? name : 'NodeBuffer_' + uniformNode.id;
                } else {
                    const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});
                    let uniformsGroup = uniformsStage[groupName];
                    if (uniformsGroup === undefined) {
                        uniformsGroup = new NodeUniformsGroup(groupName, group);
                        uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]);
                        uniformsStage[groupName] = uniformsGroup;
                        bindings.push(uniformsGroup);
                    }
                    uniformGPU = this.getNodeUniform(uniformNode, type);
                    uniformsGroup.addUniform(uniformGPU);
                }
                nodeData.uniformGPU = uniformGPU;
            }
            return uniformNode;
        }
        getBuiltin(name, property, type, shaderStage = this.shaderStage) {
            const map = this.builtins[shaderStage] || (this.builtins[shaderStage] = new Map());
            if (map.has(name) === false) {
                map.set(name, {
                    name,
                    property,
                    type
                });
            }
            return property;
        }
        hasBuiltin(name, shaderStage = this.shaderStage) {
            return (this.builtins[shaderStage] !== undefined && this.builtins[shaderStage].has(name));
        }
        getVertexIndex() {
            if (this.shaderStage === 'vertex') {
                return this.getBuiltin('vertex_index', 'vertexIndex', 'u32', 'attribute');
            }
            return 'vertexIndex';
        }
        buildFunctionCode(shaderNode) {
            const layout = shaderNode.layout;
            const flowData = this.flowShaderNode(shaderNode);
            const parameters = [];
            for (const input of layout.inputs) {
                parameters.push(input.name + ' : ' + this.getType(input.type));
            }
            //
            let code = `fn ${layout.name}( ${parameters.join(', ')} ) -> ${this.getType(layout.type)} {
${flowData.vars}
${flowData.code}
`;
            if (flowData.result) {
                code += `\treturn ${flowData.result};\n`;
            }
            code += '\n}\n';
            //
            return code;
        }
        getInstanceIndex() {
            if (this.shaderStage === 'vertex') {
                return this.getBuiltin('instance_index', 'instanceIndex', 'u32', 'attribute');
            }
            return 'instanceIndex';
        }
        getInvocationLocalIndex() {
            return this.getBuiltin('local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute');
        }
        getSubgroupSize() {
            this.enableSubGroups();
            return this.getBuiltin('subgroup_size', 'subgroupSize', 'u32', 'attribute');
        }
        getInvocationSubgroupIndex() {
            this.enableSubGroups();
            return this.getBuiltin('subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute');
        }
        getSubgroupIndex() {
            this.enableSubGroups();
            return this.getBuiltin('subgroup_id', 'subgroupIndex', 'u32', 'attribute');
        }
        getDrawIndex() {
            return null;
        }
        getFrontFacing() {
            return this.getBuiltin('front_facing', 'isFront', 'bool');
        }
        getFragCoord() {
            return this.getBuiltin('position', 'fragCoord', 'vec4<f32>') + '.xy';
        }
        getFragDepth() {
            return 'output.' + this.getBuiltin('frag_depth', 'depth', 'f32', 'output');
        }
        getClipDistance() {
            return 'varyings.hw_clip_distances';
        }
        isFlipY() {
            return false;
        }
        enableDirective(name, shaderStage = this.shaderStage) {
            const stage = this.directives[shaderStage] || (this.directives[shaderStage] = new Set());
            stage.add(name);
        }
        getDirectives(shaderStage) {
            const snippets = [];
            const directives = this.directives[shaderStage];
            if (directives !== undefined) {
                for (const directive of directives) {
                    snippets.push(`enable ${directive};`);
                }
            }
            return snippets.join('\n');
        }
        enableSubGroups() {
            this.enableDirective('subgroups');
        }
        enableSubgroupsF16() {
            this.enableDirective('subgroups-f16');
        }
        enableClipDistances() {
            this.enableDirective('clip_distances');
        }
        enableShaderF16() {
            this.enableDirective('f16');
        }
        enableDualSourceBlending() {
            this.enableDirective('dual_source_blending');
        }
        enableHardwareClipping(planeCount) {
            this.enableClipDistances();
            this.getBuiltin('clip_distances', 'hw_clip_distances', `array<f32, ${planeCount} >`, 'vertex');
        }
        getBuiltins(shaderStage) {
            const snippets = [];
            const builtins = this.builtins[shaderStage];
            if (builtins !== undefined) {
                for (const { name, property, type } of builtins.values()) {
                    snippets.push(`@builtin( ${name} ) ${property} : ${type}`);
                }
            }
            return snippets.join(',\n\t');
        }
        getScopedArray(name, scope, bufferType, bufferCount) {
            if (this.scopedArrays.has(name) === false) {
                this.scopedArrays.set(name, {
                    name,
                    scope,
                    bufferType,
                    bufferCount
                });
            }
            return name;
        }
        getScopedArrays(shaderStage) {
            if (shaderStage !== 'compute') {
                return;
            }
            const snippets = [];
            for (const { name, scope, bufferType, bufferCount } of this.scopedArrays.values()) {
                const type = this.getType(bufferType);
                snippets.push(`var<${scope}> ${name}: array< ${type}, ${bufferCount} >;`);
            }
            return snippets.join('\n');
        }
        getAttributes(shaderStage) {
            const snippets = [];
            if (shaderStage === 'compute') {
                this.getBuiltin('global_invocation_id', 'globalId', 'vec3<u32>', 'attribute');
                this.getBuiltin('workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute');
                this.getBuiltin('local_invocation_id', 'localId', 'vec3<u32>', 'attribute');
                this.getBuiltin('num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute');
                if (this.renderer.hasFeature('subgroups')) {
                    this.enableDirective('subgroups', shaderStage);
                    this.getBuiltin('subgroup_size', 'subgroupSize', 'u32', 'attribute');
                }
            }
            if (shaderStage === 'vertex' || shaderStage === 'compute') {
                const builtins = this.getBuiltins('attribute');
                if (builtins) snippets.push(builtins);
                const attributes = this.getAttributesArray();
                for (let index = 0, length = attributes.length; index < length; index++) {
                    const attribute = attributes[index];
                    const name = attribute.name;
                    const type = this.getType(attribute.type);
                    snippets.push(`@location( ${index} ) ${name} : ${type}`);
                }
            }
            return snippets.join(',\n\t');
        }
        getStructMembers(struct) {
            const snippets = [];
            for (const member of struct.members) {
                const prefix = struct.output ? '@location( ' + member.index + ' ) ' : '';
                let type = this.getType(member.type);
                if (member.atomic) {
                    type = 'atomic< ' + type + ' >';
                }
                snippets.push(`\t${prefix + member.name} : ${type}`);
            }
            if (struct.output) {
                snippets.push(`\t${this.getBuiltins('output')}`);
            }
            return snippets.join(',\n');
        }
        getStructs(shaderStage) {
            let result = '';
            const structs = this.structs[shaderStage];
            if (structs.length > 0) {
                const snippets = [];
                for (const struct of structs) {
                    let snippet = `struct ${struct.name} {\n`;
                    snippet += this.getStructMembers(struct);
                    snippet += '\n};';
                    snippets.push(snippet);
                }
                result = '\n' + snippets.join('\n\n') + '\n';
            }
            return result;
        }
        getVar(type, name, count = null) {
            let snippet = `var ${name} : `;
            if (count !== null) {
                snippet += this.generateArrayDeclaration(type, count);
            } else {
                snippet += this.getType(type);
            }
            return snippet;
        }
        getVars(shaderStage) {
            const snippets = [];
            const vars = this.vars[shaderStage];
            if (vars !== undefined) {
                for (const variable of vars) {
                    snippets.push(`\t${this.getVar(variable.type, variable.name, variable.count)};`);
                }
            }
            return `\n${snippets.join('\n')}\n`;
        }
        getVaryings(shaderStage) {
            const snippets = [];
            if (shaderStage === 'vertex') {
                this.getBuiltin('position', 'Vertex', 'vec4<f32>', 'vertex');
            }
            if (shaderStage === 'vertex' || shaderStage === 'fragment') {
                const varyings = this.varyings;
                const vars = this.vars[shaderStage];
                for (let index = 0; index < varyings.length; index++) {
                    const varying = varyings[index];
                    if (varying.needsInterpolation) {
                        let attributesSnippet = `@location( ${index} )`;
                        if (varying.interpolationType) {
                            const samplingSnippet = varying.interpolationSampling !== null ? `, ${varying.interpolationSampling} )` : ' )';
                            attributesSnippet += ` @interpolate( ${varying.interpolationType}${samplingSnippet}`;
                            // Otherwise, optimize interpolation when sensible
                        } else if (/^(int|uint|ivec|uvec)/.test(varying.type)) {
                            attributesSnippet += ` @interpolate( ${this.renderer.backend.compatibilityMode ? 'flat, either' : 'flat'} )`;
                        }
                        snippets.push(`${attributesSnippet} ${varying.name} : ${this.getType(varying.type)}`);
                    } else if (shaderStage === 'vertex' && vars.includes(varying) === false) {
                        vars.push(varying);
                    }
                }
            }
            const builtins = this.getBuiltins(shaderStage);
            if (builtins) snippets.push(builtins);
            const code = snippets.join(',\n\t');
            return shaderStage === 'vertex' ? this._getWGSLStruct('VaryingsStruct', '\t' + code) : code;
        }
        isCustomStruct(nodeUniform) {
            const attribute = nodeUniform.value;
            const bufferNode = nodeUniform.node;
            const isAttributeStructType = (attribute.isBufferAttribute || attribute.isInstancedBufferAttribute) && bufferNode.structTypeNode !== null;
            const isStructArray =
                (bufferNode.value && bufferNode.value.array) &&
                (typeof bufferNode.value.itemSize === 'number' && bufferNode.value.array.length > bufferNode.value.itemSize);
            return isAttributeStructType && !isStructArray;
        }
        getUniforms(shaderStage) {
            const uniforms = this.uniforms[shaderStage];
            const bindingSnippets = [];
            const bufferSnippets = [];
            const structSnippets = [];
            const uniformGroups = {};
            for (const uniform of uniforms) {
                const groupName = uniform.groupNode.name;
                const uniformIndexes = this.bindingsIndexes[groupName];
                if (uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D') {
                    const texture = uniform.node.value;
                    if (this.isUnfilterable(texture) === false && uniform.node.isStorageTextureNode !== true) {
                        if (this.isSampleCompare(texture)) {
                            bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name}_sampler : sampler_comparison;`);
                        } else {
                            bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name}_sampler : sampler;`);
                        }
                    }
                    let textureType;
                    let multisampled = '';
                    const { primarySamples } = this.renderer.backend.utils.getTextureSampleData(texture);
                    if (primarySamples > 1) {
                        multisampled = '_multisampled';
                    }
                    if (texture.isCubeTexture === true) {
                        textureType = 'texture_cube<f32>';
                    } else if (texture.isDepthTexture === true) {
                        if (this.renderer.backend.compatibilityMode && texture.compareFunction === null) {
                            textureType = `texture${multisampled}_2d<f32>`;
                        } else {
                            textureType = `texture_depth${multisampled}_2d${texture.isArrayTexture === true ? '_array' : ''}`;
                        }
                    } else if (uniform.node.isStorageTextureNode === true) {
                        const format = getFormat(texture);
                        const access = this.getStorageAccess(uniform.node, shaderStage);
                        const is3D = uniform.node.value.is3DTexture;
                        const isArrayTexture = uniform.node.value.isArrayTexture;
                        const dimension = is3D ? '3d' : `2d${isArrayTexture ? '_array' : ''}`;
                        textureType = `texture_storage_${dimension}<${format}, ${access}>`;
                    } else if (texture.isArrayTexture === true || texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true) {
                        textureType = 'texture_2d_array<f32>';
                    } else if (texture.is3DTexture === true || texture.isData3DTexture === true) {
                        textureType = 'texture_3d<f32>';
                    } else {
                        const componentPrefix = this.getComponentTypeFromTexture(texture).charAt(0);
                        textureType = `texture${multisampled}_2d<${componentPrefix}32>`;
                    }
                    bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name} : ${textureType};`);
                } else if (uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer') {
                    const bufferNode = uniform.node;
                    const bufferType = this.getType(bufferNode.getNodeType(this));
                    const bufferCount = bufferNode.bufferCount;
                    const bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';
                    const bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${this.getStorageAccess(bufferNode, shaderStage)}` : 'uniform';
                    if (this.isCustomStruct(uniform)) {
                        bufferSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var<${bufferAccessMode}> ${uniform.name} : ${bufferType};`);
                    } else {
                        const bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`;
                        const bufferSnippet = `\tvalue : array< ${bufferTypeSnippet}${bufferCountSnippet} >`;
                        bufferSnippets.push(this._getWGSLStructBinding(uniform.name, bufferSnippet, bufferAccessMode, uniformIndexes.binding++, uniformIndexes.group));
                    }
                } else {
                    const vectorType = this.getType(this.getVectorType(uniform.type));
                    const groupName = uniform.groupNode.name;
                    const group = uniformGroups[groupName] || (uniformGroups[groupName] = {
                        index: uniformIndexes.binding++,
                        id: uniformIndexes.group,
                        snippets: []
                    });
                    group.snippets.push(`\t${uniform.name} : ${vectorType}`);
                }
            }
            for (const name in uniformGroups) {
                const group = uniformGroups[name];
                structSnippets.push(this._getWGSLStructBinding(name, group.snippets.join(',\n'), 'uniform', group.index, group.id));
            }
            let code = bindingSnippets.join('\n');
            code += bufferSnippets.join('\n');
            code += structSnippets.join('\n');
            return code;
        }
        buildCode() {
            const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
            this.sortBindingGroups();
            for (const shaderStage in shadersData) {
                this.shaderStage = shaderStage;
                const stageData = shadersData[shaderStage];
                stageData.uniforms = this.getUniforms(shaderStage);
                stageData.attributes = this.getAttributes(shaderStage);
                stageData.varyings = this.getVaryings(shaderStage);
                stageData.structs = this.getStructs(shaderStage);
                stageData.vars = this.getVars(shaderStage);
                stageData.codes = this.getCodes(shaderStage);
                stageData.directives = this.getDirectives(shaderStage);
                stageData.scopedArrays = this.getScopedArrays(shaderStage);
                //
                let flow = '// code\n\n';
                flow += this.flowCode[shaderStage];
                const flowNodes = this.flowNodes[shaderStage];
                const mainNode = flowNodes[flowNodes.length - 1];
                const outputNode = mainNode.outputNode;
                const isOutputStruct = (outputNode !== undefined && outputNode.isOutputStructNode === true);
                for (const node of flowNodes) {
                    const flowSlotData = this.getFlowData(node/*, shaderStage*/);
                    const slotName = node.name;
                    if (slotName) {
                        if (flow.length > 0) flow += '\n';
                        flow += `\t// flow -> ${slotName}\n`;
                    }
                    flow += `${flowSlotData.code}\n\t`;
                    if (node === mainNode && shaderStage !== 'compute') {
                        flow += '// result\n\n\t';
                        if (shaderStage === 'vertex') {
                            flow += `varyings.Vertex = ${flowSlotData.result};`;
                        } else if (shaderStage === 'fragment') {
                            if (isOutputStruct) {
                                stageData.returnType = outputNode.getNodeType(this);
                                stageData.structs += 'var<private> output : ' + stageData.returnType + ';';
                                flow += `return ${flowSlotData.result};`;
                            } else {
                                let structSnippet = '\t@location(0) color: vec4<f32>';
                                const builtins = this.getBuiltins('output');
                                if (builtins) structSnippet += ',\n\t' + builtins;
                                stageData.returnType = 'OutputStruct';
                                stageData.structs += this._getWGSLStruct('OutputStruct', structSnippet);
                                stageData.structs += '\nvar<private> output : OutputStruct;';
                                flow += `output.color = ${flowSlotData.result};\n\n\treturn output;`;
                            }
                        }
                    }
                }
                stageData.flow = flow;
            }
            this.shaderStage = null;
            if (this.material !== null) {
                this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);
                this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);
            } else {
                // Early strictly validated in computeNode
                const workgroupSize = this.object.workgroupSize;
                this.computeShader = this._getWGSLComputeCode(shadersData.compute, workgroupSize);
            }
        }
        getMethod(method, output = null) {
            let wgslMethod;
            if (output !== null) {
                wgslMethod = this._getWGSLMethod(method + '_' + output);
            }
            if (wgslMethod === undefined) {
                wgslMethod = this._getWGSLMethod(method);
            }
            return wgslMethod || method;
        }
        getType(type) {
            return wgslTypeLib[type] || type;
        }
        isAvailable(name) {
            let result = supports[name];
            if (result === undefined) {
                if (name === 'float32Filterable') {
                    result = this.renderer.hasFeature('float32-filterable');
                } else if (name === 'clipDistance') {
                    result = this.renderer.hasFeature('clip-distances');
                }
                supports[name] = result;
            }
            return result;
        }
        _getWGSLMethod(method) {
            if (wgslPolyfill[method] !== undefined) {
                this._include(method);
            }
            return wgslMethods[method];
        }
        _include(name) {
            const codeNode = wgslPolyfill[name];
            codeNode.build(this);
            if (this.currentFunctionNode !== null) {
                this.currentFunctionNode.includes.push(codeNode);
            }
            return codeNode;
        }
        _getWGSLVertexCode(shaderData) {
            return `${this.getSignature()}
// directives
${shaderData.directives}
// structs
${shaderData.structs}
// uniforms
${shaderData.uniforms}
// varyings
${shaderData.varyings}
var<private> varyings : VaryingsStruct;
// codes
${shaderData.codes}
@vertex
fn main( ${shaderData.attributes} ) -> VaryingsStruct {
	// vars
	${shaderData.vars}
	// flow
	${shaderData.flow}
	return varyings;
}
`;
        }
        _getWGSLFragmentCode(shaderData) {
            return `${this.getSignature()}
// global
${diagnostics}
// structs
${shaderData.structs}
// uniforms
${shaderData.uniforms}
// codes
${shaderData.codes}
@fragment
fn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {
	// vars
	${shaderData.vars}
	// flow
	${shaderData.flow}
}
`;
        }
        _getWGSLComputeCode(shaderData, workgroupSize) {
            const [workgroupSizeX, workgroupSizeY, workgroupSizeZ] = workgroupSize;
            return `${this.getSignature()}
// directives
${shaderData.directives}
// system
var<private> instanceIndex : u32;
// locals
${shaderData.scopedArrays}
// structs
${shaderData.structs}
// uniforms
${shaderData.uniforms}
// codes
${shaderData.codes}
@compute @workgroup_size( ${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ} )
fn main( ${shaderData.attributes} ) {
	// system
	instanceIndex = globalId.x
		+ globalId.y * ( ${workgroupSizeX} * numWorkgroups.x )
		+ globalId.z * ( ${workgroupSizeX} * numWorkgroups.x ) * ( ${workgroupSizeY} * numWorkgroups.y );
	// vars
	${shaderData.vars}
	// flow
	${shaderData.flow}
}
`;
        }
        _getWGSLStruct(name, vars) {
            return `
struct ${name} {
${vars}
};`;
        }
        _getWGSLStructBinding(name, vars, access, binding = 0, group = 0) {
            const structName = name + 'Struct';
            const structSnippet = this._getWGSLStruct(structName, vars);
            return `${structSnippet}
@binding( ${binding} ) @group( ${group} )
var<${access}> ${name} : ${structName};`;
        }
    }
    class WebGPUUtils {
        constructor(backend) {
            this.backend = backend;
        }
        getCurrentDepthStencilFormat(renderContext) {
            let format;
            if (renderContext.depthTexture !== null) {
                format = this.getTextureFormatGPU(renderContext.depthTexture);
            } else if (renderContext.depth && renderContext.stencil) {
                format = GPUTextureFormat.Depth24PlusStencil8;
            } else if (renderContext.depth) {
                format = GPUTextureFormat.Depth24Plus;
            }
            return format;
        }
        getTextureFormatGPU(texture) {
            return this.backend.get(texture).format;
        }
        getTextureSampleData(texture) {
            let samples;
            if (texture.isFramebufferTexture) {
                samples = 1;
            } else if (texture.isDepthTexture && !texture.renderTarget) {
                const renderer = this.backend.renderer;
                const renderTarget = renderer.getRenderTarget();
                samples = renderTarget ? renderTarget.samples : renderer.samples;
            } else if (texture.renderTarget) {
                samples = texture.renderTarget.samples;
            }
            samples = samples || 1;
            const isMSAA = samples > 1 && texture.renderTarget !== null && (texture.isDepthTexture !== true && texture.isFramebufferTexture !== true);
            const primarySamples = isMSAA ? 1 : samples;
            return { samples, primarySamples, isMSAA };
        }
        getCurrentColorFormat(renderContext) {
            let format;
            if (renderContext.textures !== null) {
                format = this.getTextureFormatGPU(renderContext.textures[0]);
            } else {
                format = this.getPreferredCanvasFormat(); // default context format
            }
            return format;
        }
        getCurrentColorSpace(renderContext) {
            if (renderContext.textures !== null) {
                return renderContext.textures[0].colorSpace;
            }
            return this.backend.renderer.outputColorSpace;
        }
        getPrimitiveTopology(object, material) {
            if (object.isPoints) return GPUPrimitiveTopology.PointList;
            else if (object.isLineSegments || (object.isMesh && material.wireframe === true)) return GPUPrimitiveTopology.LineList;
            else if (object.isLine) return GPUPrimitiveTopology.LineStrip;
            else if (object.isMesh) return GPUPrimitiveTopology.TriangleList;
        }
        getSampleCount(sampleCount) {
            return sampleCount >= 4 ? 4 : 1;
        }
        getSampleCountRenderContext(renderContext) {
            if (renderContext.textures !== null) {
                return this.getSampleCount(renderContext.sampleCount);
            }
            return this.getSampleCount(this.backend.renderer.samples);
        }
        getPreferredCanvasFormat() {
            const outputType = this.backend.parameters.outputType;
            if (outputType === undefined) {
                return navigator.gpu.getPreferredCanvasFormat();
            } else if (outputType === UnsignedByteType) {
                return GPUTextureFormat.BGRA8Unorm;
            } else if (outputType === HalfFloatType) {
                return GPUTextureFormat.RGBA16Float;
            } else {
                throw new Error('Unsupported outputType');
            }
        }
    }
    const typedArraysToVertexFormatPrefix = new Map([
        [Int8Array, ['sint8', 'snorm8']],
        [Uint8Array, ['uint8', 'unorm8']],
        [Int16Array, ['sint16', 'snorm16']],
        [Uint16Array, ['uint16', 'unorm16']],
        [Int32Array, ['sint32', 'snorm32']],
        [Uint32Array, ['uint32', 'unorm32']],
        [Float32Array, ['float32',]],
    ]);
    if (typeof Float16Array !== 'undefined') {
        typedArraysToVertexFormatPrefix.set(Float16Array, ['float16']);
    }
    const typedAttributeToVertexFormatPrefix = new Map([
        [Float16BufferAttribute, ['float16',]],
    ]);
    const typeArraysToVertexFormatPrefixForItemSize1 = new Map([
        [Int32Array, 'sint32'],
        [Int16Array, 'sint32'], // patch for INT16
        [Uint32Array, 'uint32'],
        [Uint16Array, 'uint32'], // patch for UINT16
        [Float32Array, 'float32']
    ]);
    class WebGPUAttributeUtils {
        constructor(backend) {
            this.backend = backend;
        }
        createAttribute(attribute, usage) {
            const bufferAttribute = this._getBufferAttribute(attribute);
            const backend = this.backend;
            const bufferData = backend.get(bufferAttribute);
            let buffer = bufferData.buffer;
            if (buffer === undefined) {
                const device = backend.device;
                let array = bufferAttribute.array;
                // patch for INT16 and UINT16
                if (attribute.normalized === false) {
                    if (array.constructor === Int16Array || array.constructor === Int8Array) {
                        array = new Int32Array(array);
                    } else if (array.constructor === Uint16Array || array.constructor === Uint8Array) {
                        array = new Uint32Array(array);
                        if (usage & GPUBufferUsage.INDEX) {
                            for (let i = 0; i < array.length; i++) {
                                if (array[i] === 0xffff) array[i] = 0xffffffff; // use correct primitive restart index
                            }
                        }
                    }
                }
                bufferAttribute.array = array;
                if ((bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute) && bufferAttribute.itemSize === 3) {
                    array = new array.constructor(bufferAttribute.count * 4);
                    for (let i = 0; i < bufferAttribute.count; i++) {
                        array.set(bufferAttribute.array.subarray(i * 3, i * 3 + 3), i * 4);
                    }
                    // Update BufferAttribute
                    bufferAttribute.itemSize = 4;
                    bufferAttribute.array = array;
                    bufferData._force3to4BytesAlignment = true;
                }
                // ensure 4 byte alignment
                const byteLength = array.byteLength;
                const size = byteLength + ((4 - (byteLength % 4)) % 4);
                buffer = device.createBuffer({
                    label: bufferAttribute.name,
                    size: size,
                    usage: usage,
                    mappedAtCreation: true
                });
                new array.constructor(buffer.getMappedRange()).set(array);
                buffer.unmap();
                bufferData.buffer = buffer;
            }
        }
        updateAttribute(attribute) {
            const bufferAttribute = this._getBufferAttribute(attribute);
            const backend = this.backend;
            const device = backend.device;
            const bufferData = backend.get(bufferAttribute);
            const buffer = backend.get(bufferAttribute).buffer;
            let array = bufferAttribute.array;
            //  if storage buffer ensure 4 byte alignment
            if (bufferData._force3to4BytesAlignment === true) {
                array = new array.constructor(bufferAttribute.count * 4);
                for (let i = 0; i < bufferAttribute.count; i++) {
                    array.set(bufferAttribute.array.subarray(i * 3, i * 3 + 3), i * 4);
                }
                bufferAttribute.array = array;
            }

            const isTypedArray = this._isTypedArray(array);
            const updateRanges = bufferAttribute.updateRanges;
            if (updateRanges.length === 0) {
                // Not using update ranges
                device.queue.writeBuffer(
                    buffer,
                    0,
                    array,
                    0
                );
            } else {
                const byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;
                for (let i = 0, l = updateRanges.length; i < l; i++) {
                    const range = updateRanges[i];
                    let dataOffset, size;
                    if (bufferData._force3to4BytesAlignment === true) {
                        const vertexStart = Math.floor(range.start / 3);
                        const vertexCount = Math.ceil(range.count / 3);
                        dataOffset = vertexStart * 4 * byteOffsetFactor;
                        size = vertexCount * 4 * byteOffsetFactor;
                    } else {
                        dataOffset = range.start * byteOffsetFactor;
                        size = range.count * byteOffsetFactor;
                    }
                    const bufferOffset = dataOffset * (isTypedArray ? array.BYTES_PER_ELEMENT : 1); // bufferOffset is always in bytes
                    device.queue.writeBuffer(
                        buffer,
                        bufferOffset,
                        array,
                        dataOffset,
                        size
                    );
                }
                bufferAttribute.clearUpdateRanges();
            }
        }
        createShaderVertexBuffers(renderObject) {
            const attributes = renderObject.getAttributes();
            const vertexBuffers = new Map();
            for (let slot = 0; slot < attributes.length; slot++) {
                const geometryAttribute = attributes[slot];
                const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
                const bufferAttribute = this._getBufferAttribute(geometryAttribute);
                let vertexBufferLayout = vertexBuffers.get(bufferAttribute);
                if (vertexBufferLayout === undefined) {
                    let arrayStride, stepMode;
                    if (geometryAttribute.isInterleavedBufferAttribute === true) {
                        arrayStride = geometryAttribute.data.stride * bytesPerElement;
                        stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
                    } else {
                        arrayStride = geometryAttribute.itemSize * bytesPerElement;
                        stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
                    }
                    // patch for INT16 and UINT16
                    if (geometryAttribute.normalized === false && (geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array)) {
                        arrayStride = 4;
                    }
                    vertexBufferLayout = {
                        arrayStride,
                        attributes: [],
                        stepMode
                    };
                    vertexBuffers.set(bufferAttribute, vertexBufferLayout);
                }
                const format = this._getVertexFormat(geometryAttribute);
                const offset = (geometryAttribute.isInterleavedBufferAttribute === true) ? geometryAttribute.offset * bytesPerElement : 0;
                vertexBufferLayout.attributes.push({
                    shaderLocation: slot,
                    offset,
                    format
                });
            }
            return Array.from(vertexBuffers.values());
        }
        destroyAttribute(attribute) {
            const backend = this.backend;
            const data = backend.get(this._getBufferAttribute(attribute));
            data.buffer.destroy();
            backend.delete(attribute);
        }
        async getArrayBufferAsync(attribute) {
            const backend = this.backend;
            const device = backend.device;
            const data = backend.get(this._getBufferAttribute(attribute));
            const bufferGPU = data.buffer;
            const size = bufferGPU.size;
            const readBufferGPU = device.createBuffer({
                label: `${attribute.name}_readback`,
                size,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
            });
            const cmdEncoder = device.createCommandEncoder({
                label: `readback_encoder_${attribute.name}`
            });
            cmdEncoder.copyBufferToBuffer(
                bufferGPU,
                0,
                readBufferGPU,
                0,
                size
            );
            const gpuCommands = cmdEncoder.finish();
            device.queue.submit([gpuCommands]);
            await readBufferGPU.mapAsync(GPUMapMode.READ);
            const arrayBuffer = readBufferGPU.getMappedRange();
            const dstBuffer = new attribute.array.constructor(arrayBuffer.slice(0));
            readBufferGPU.unmap();
            return dstBuffer.buffer;
        }
        _getVertexFormat(geometryAttribute) {
            const { itemSize, normalized } = geometryAttribute;
            const ArrayType = geometryAttribute.array.constructor;
            const AttributeType = geometryAttribute.constructor;
            let format;
            if (itemSize === 1) {
                format = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);
            } else {
                const prefixOptions = typedAttributeToVertexFormatPrefix.get(AttributeType) || typedArraysToVertexFormatPrefix.get(ArrayType);
                const prefix = prefixOptions[normalized ? 1 : 0];
                if (prefix) {
                    const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
                    const paddedBytesPerUnit = Math.floor((bytesPerUnit + 3) / 4) * 4;
                    const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;
                    if (paddedItemSize % 1) {
                        throw new Error('THREE.WebGPUAttributeUtils: Bad vertex format item size.');
                    }
                    format = `${prefix}x${paddedItemSize}`;
                }
            }
            if (!format) {
                console.error('THREE.WebGPUAttributeUtils: Vertex format not supported yet.');
            }
            return format;
        }
        _isTypedArray(array) {
            return ArrayBuffer.isView(array) && !(array instanceof DataView);
        }
        _getBufferAttribute(attribute) {
            if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
            return attribute;
        }
    }
    class WebGPUBindingUtils {
        constructor(backend) {
            this.backend = backend;
            this.bindGroupLayoutCache = new WeakMap();
        }
        createBindingsLayout(bindGroup) {
            const backend = this.backend;
            const device = backend.device;
            const entries = [];
            let index = 0;
            for (const binding of bindGroup.bindings) {
                const bindingGPU = {
                    binding: index++,
                    visibility: binding.visibility
                };
                if (binding.isUniformBuffer || binding.isStorageBuffer) {
                    const buffer = {}; // GPUBufferBindingLayout
                    if (binding.isStorageBuffer) {
                        if (binding.visibility & 4) {
                            // compute
                            if (binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY) {
                                buffer.type = GPUBufferBindingType.Storage;
                            } else {
                                buffer.type = GPUBufferBindingType.ReadOnlyStorage;
                            }
                        } else {
                            buffer.type = GPUBufferBindingType.ReadOnlyStorage;
                        }
                    }
                    bindingGPU.buffer = buffer;
                } else if (binding.isSampledTexture && binding.store) {
                    const storageTexture = {}; // GPUStorageTextureBindingLayout
                    storageTexture.format = this.backend.get(binding.texture).texture.format;
                    const access = binding.access;
                    if (access === NodeAccess.READ_WRITE) {
                        storageTexture.access = GPUStorageTextureAccess.ReadWrite;
                    } else if (access === NodeAccess.WRITE_ONLY) {
                        storageTexture.access = GPUStorageTextureAccess.WriteOnly;
                    } else {
                        storageTexture.access = GPUStorageTextureAccess.ReadOnly;
                    }
                    if (binding.texture.isArrayTexture) {
                        storageTexture.viewDimension = GPUTextureViewDimension.TwoDArray;
                    } else if (binding.texture.is3DTexture) {
                        storageTexture.viewDimension = GPUTextureViewDimension.ThreeD;
                    }
                    bindingGPU.storageTexture = storageTexture;
                } else if (binding.isSampledTexture) {
                    const texture = {}; // GPUTextureBindingLayout
                    const { primarySamples } = backend.utils.getTextureSampleData(binding.texture);
                    if (primarySamples > 1) {
                        texture.multisampled = true;
                        if (!binding.texture.isDepthTexture) {
                            texture.sampleType = GPUTextureSampleType.UnfilterableFloat;
                        }
                    }
                    if (binding.texture.isDepthTexture) {
                        if (backend.compatibilityMode && binding.texture.compareFunction === null) {
                            texture.sampleType = GPUTextureSampleType.UnfilterableFloat;
                        } else {
                            texture.sampleType = GPUTextureSampleType.Depth;
                        }
                    } else if (binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture) {
                        const type = binding.texture.type;
                        if (type === IntType) {
                            texture.sampleType = GPUTextureSampleType.SInt;
                        } else if (type === UnsignedIntType) {
                            texture.sampleType = GPUTextureSampleType.UInt;
                        } else if (type === FloatType) {
                            if (this.backend.hasFeature('float32-filterable')) {
                                texture.sampleType = GPUTextureSampleType.Float;
                            } else {
                                texture.sampleType = GPUTextureSampleType.UnfilterableFloat;
                            }
                        }
                    }
                    if (binding.isSampledCubeTexture) {
                        texture.viewDimension = GPUTextureViewDimension.Cube;
                    } else if (binding.texture.isArrayTexture || binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) {
                        texture.viewDimension = GPUTextureViewDimension.TwoDArray;
                    } else if (binding.isSampledTexture3D) {
                        texture.viewDimension = GPUTextureViewDimension.ThreeD;
                    }
                    bindingGPU.texture = texture;
                } else if (binding.isSampler) {
                    const sampler = {}; // GPUSamplerBindingLayout
                    if (binding.texture.isDepthTexture) {
                        if (binding.texture.compareFunction !== null) {
                            sampler.type = GPUSamplerBindingType.Comparison;
                        } else if (backend.compatibilityMode) {
                            sampler.type = GPUSamplerBindingType.NonFiltering;
                        }
                    }
                    bindingGPU.sampler = sampler;
                } else {
                    console.error(`WebGPUBindingUtils: Unsupported binding "${binding}".`);
                }
                entries.push(bindingGPU);
            }
            return device.createBindGroupLayout({ entries });
        }
        createBindings(bindGroup, bindings, cacheIndex, version = 0) {
            const { backend, bindGroupLayoutCache } = this;
            const bindingsData = backend.get(bindGroup);
            // setup (static) binding layout and (dynamic) binding group
            let bindLayoutGPU = bindGroupLayoutCache.get(bindGroup.bindingsReference);
            if (bindLayoutGPU === undefined) {
                bindLayoutGPU = this.createBindingsLayout(bindGroup);
                bindGroupLayoutCache.set(bindGroup.bindingsReference, bindLayoutGPU);
            }
            let bindGroupGPU;
            if (cacheIndex > 0) {
                if (bindingsData.groups === undefined) {
                    bindingsData.groups = [];
                    bindingsData.versions = [];
                }
                if (bindingsData.versions[cacheIndex] === version) {
                    bindGroupGPU = bindingsData.groups[cacheIndex];
                }
            }
            if (bindGroupGPU === undefined) {
                bindGroupGPU = this.createBindGroup(bindGroup, bindLayoutGPU);
                if (cacheIndex > 0) {
                    bindingsData.groups[cacheIndex] = bindGroupGPU;
                    bindingsData.versions[cacheIndex] = version;
                }
            }
            bindingsData.group = bindGroupGPU;
            bindingsData.layout = bindLayoutGPU;
        }
        updateBinding(binding) {
            const backend = this.backend;
            const device = backend.device;
            const buffer = binding.buffer;
            const bufferGPU = backend.get(binding).buffer;
            device.queue.writeBuffer(bufferGPU, 0, buffer, 0);
        }
        createBindGroupIndex(data, layout) {
            const backend = this.backend;
            const device = backend.device;
            const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
            const index = data[0];
            const buffer = device.createBuffer({
                label: 'bindingCameraIndex_' + index,
                size: 16, // uint(4) * 4
                usage: usage
            });
            device.queue.writeBuffer(buffer, 0, data, 0);
            const entries = [{ binding: 0, resource: { buffer } }];
            return device.createBindGroup({
                label: 'bindGroupCameraIndex_' + index,
                layout,
                entries
            });
        }
        createBindGroup(bindGroup, layoutGPU) {
            const backend = this.backend;
            const device = backend.device;
            let bindingPoint = 0;
            const entriesGPU = [];
            for (const binding of bindGroup.bindings) {
                if (binding.isUniformBuffer) {
                    const bindingData = backend.get(binding);
                    if (bindingData.buffer === undefined) {
                        const byteLength = binding.byteLength;
                        const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
                        const bufferGPU = device.createBuffer({
                            label: 'bindingBuffer_' + binding.name,
                            size: byteLength,
                            usage: usage
                        });
                        bindingData.buffer = bufferGPU;
                    }
                    entriesGPU.push({ binding: bindingPoint, resource: { buffer: bindingData.buffer } });
                } else if (binding.isStorageBuffer) {
                    const bindingData = backend.get(binding);
                    if (bindingData.buffer === undefined) {
                        const attribute = binding.attribute;
                        //const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;
                        //backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer
                        bindingData.buffer = backend.get(attribute).buffer;
                    }
                    entriesGPU.push({ binding: bindingPoint, resource: { buffer: bindingData.buffer } });
                } else if (binding.isSampledTexture) {
                    const textureData = backend.get(binding.texture);
                    let resourceGPU;
                    if (textureData.externalTexture !== undefined) {
                        resourceGPU = device.importExternalTexture({ source: textureData.externalTexture });
                    } else {
                        const mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;
                        let propertyName = `view-${textureData.texture.width}-${textureData.texture.height}`;
                        if (textureData.texture.depthOrArrayLayers > 1) {
                            propertyName += `-${textureData.texture.depthOrArrayLayers}`;
                        }
                        propertyName += `-${mipLevelCount}`;
                        resourceGPU = textureData[propertyName];
                        if (resourceGPU === undefined) {
                            const aspectGPU = GPUTextureAspect.All;
                            let dimensionViewGPU;
                            if (binding.isSampledCubeTexture) {
                                dimensionViewGPU = GPUTextureViewDimension.Cube;
                            } else if (binding.isSampledTexture3D) {
                                dimensionViewGPU = GPUTextureViewDimension.ThreeD;
                            } else if (binding.texture.isArrayTexture || binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) {
                                dimensionViewGPU = GPUTextureViewDimension.TwoDArray;
                            } else {
                                dimensionViewGPU = GPUTextureViewDimension.TwoD;
                            }
                            resourceGPU = textureData[propertyName] = textureData.texture.createView({ aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount });
                        }
                    }
                    entriesGPU.push({ binding: bindingPoint, resource: resourceGPU });
                } else if (binding.isSampler) {
                    const textureGPU = backend.get(binding.texture);
                    entriesGPU.push({ binding: bindingPoint, resource: textureGPU.sampler });
                }
                bindingPoint++;
            }
            return device.createBindGroup({
                label: 'bindGroup_' + bindGroup.name,
                layout: layoutGPU,
                entries: entriesGPU
            });
        }
    }
    class WebGPUPipelineUtils {
        constructor(backend) {
            this.backend = backend;
            this._activePipelines = new WeakMap();
        }
        setPipeline(pass, pipeline) {
            const currentPipeline = this._activePipelines.get(pass);
            if (currentPipeline !== pipeline) {
                pass.setPipeline(pipeline);
                this._activePipelines.set(pass, pipeline);
            }
        }
        _getSampleCount(renderContext) {
            return this.backend.utils.getSampleCountRenderContext(renderContext);
        }
        createRenderPipeline(renderObject, promises) {
            const { object, material, geometry, pipeline } = renderObject;
            const { vertexProgram, fragmentProgram } = pipeline;
            const backend = this.backend;
            const device = backend.device;
            const utils = backend.utils;
            const pipelineData = backend.get(pipeline);
            // bind group layouts
            const bindGroupLayouts = [];
            for (const bindGroup of renderObject.getBindings()) {
                const bindingsData = backend.get(bindGroup);
                bindGroupLayouts.push(bindingsData.layout);
            }
            // vertex buffers
            const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers(renderObject);
            // blending
            let blending;
            if (material.blending !== NoBlending && (material.blending !== NormalBlending || material.transparent !== false)) {
                blending = this._getBlending(material);
            }
            // stencil
            let stencilFront = {};
            if (material.stencilWrite === true) {
                stencilFront = {
                    compare: this._getStencilCompare(material),
                    failOp: this._getStencilOperation(material.stencilFail),
                    depthFailOp: this._getStencilOperation(material.stencilZFail),
                    passOp: this._getStencilOperation(material.stencilZPass)
                };
            }
            const colorWriteMask = this._getColorWriteMask(material);
            const targets = [];
            if (renderObject.context.textures !== null) {
                const textures = renderObject.context.textures;
                for (let i = 0; i < textures.length; i++) {
                    const colorFormat = utils.getTextureFormatGPU(textures[i]);
                    targets.push({
                        format: colorFormat,
                        blend: blending,
                        writeMask: colorWriteMask
                    });
                }
            } else {
                const colorFormat = utils.getCurrentColorFormat(renderObject.context);
                targets.push({
                    format: colorFormat,
                    blend: blending,
                    writeMask: colorWriteMask
                });
            }
            const vertexModule = backend.get(vertexProgram).module;
            const fragmentModule = backend.get(fragmentProgram).module;
            const primitiveState = this._getPrimitiveState(object, geometry, material);
            const depthCompare = this._getDepthCompare(material);
            const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);
            const sampleCount = this._getSampleCount(renderObject.context);
            const pipelineDescriptor = {
                label: `renderPipeline_${material.name || material.type}_${material.id}`,
                vertex: Object.assign({}, vertexModule, { buffers: vertexBuffers }),
                fragment: Object.assign({}, fragmentModule, { targets }),
                primitive: primitiveState,
                multisample: {
                    count: sampleCount,
                    alphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1
                },
                layout: device.createPipelineLayout({
                    bindGroupLayouts
                })
            };

            const depthStencil = {};
            const renderDepth = renderObject.context.depth;
            const renderStencil = renderObject.context.stencil;
            if (renderDepth === true || renderStencil === true) {
                if (renderDepth === true) {
                    depthStencil.format = depthStencilFormat;
                    depthStencil.depthWriteEnabled = material.depthWrite;
                    depthStencil.depthCompare = depthCompare;
                }
                if (renderStencil === true) {
                    depthStencil.stencilFront = stencilFront;
                    depthStencil.stencilBack = {}; // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)
                    depthStencil.stencilReadMask = material.stencilFuncMask;
                    depthStencil.stencilWriteMask = material.stencilWriteMask;
                }
                if (material.polygonOffset === true) {
                    depthStencil.depthBias = material.polygonOffsetUnits;
                    depthStencil.depthBiasSlopeScale = material.polygonOffsetFactor;
                    depthStencil.depthBiasClamp = 0; // three.js does not provide an API to configure this value
                }
                pipelineDescriptor.depthStencil = depthStencil;
            }

            if (promises === null) {
                pipelineData.pipeline = device.createRenderPipeline(pipelineDescriptor);
            } else {
                const p = new Promise((resolve /*, reject*/) => {
                    device.createRenderPipelineAsync(pipelineDescriptor).then(pipeline => {
                        pipelineData.pipeline = pipeline;
                        resolve();
                    });
                });
                promises.push(p);
            }
        }
        createBundleEncoder(renderContext, label = 'renderBundleEncoder') {
            const backend = this.backend;
            const { utils, device } = backend;
            const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderContext);
            const colorFormat = utils.getCurrentColorFormat(renderContext);
            const sampleCount = this._getSampleCount(renderContext);
            const descriptor = {
                label: label,
                colorFormats: [colorFormat],
                depthStencilFormat,
                sampleCount
            };
            return device.createRenderBundleEncoder(descriptor);
        }
        createComputePipeline(pipeline, bindings) {
            const backend = this.backend;
            const device = backend.device;
            const computeProgram = backend.get(pipeline.computeProgram).module;
            const pipelineGPU = backend.get(pipeline);
            // bind group layouts
            const bindGroupLayouts = [];
            for (const bindingsGroup of bindings) {
                const bindingsData = backend.get(bindingsGroup);
                bindGroupLayouts.push(bindingsData.layout);
            }
            pipelineGPU.pipeline = device.createComputePipeline({
                compute: computeProgram,
                layout: device.createPipelineLayout({
                    bindGroupLayouts
                })
            });
        }
        _getBlending(material) {
            let color, alpha;
            const blending = material.blending;
            const blendSrc = material.blendSrc;
            const blendDst = material.blendDst;
            const blendEquation = material.blendEquation;

            if (blending === CustomBlending) {
                const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;
                const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;
                const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;
                color = {
                    srcFactor: this._getBlendFactor(blendSrc),
                    dstFactor: this._getBlendFactor(blendDst),
                    operation: this._getBlendOperation(blendEquation)
                };
                alpha = {
                    srcFactor: this._getBlendFactor(blendSrcAlpha),
                    dstFactor: this._getBlendFactor(blendDstAlpha),
                    operation: this._getBlendOperation(blendEquationAlpha)
                };
            } else {
                const premultipliedAlpha = material.premultipliedAlpha;
                const setBlend = (srcRGB, dstRGB, srcAlpha, dstAlpha) => {
                    color = {
                        srcFactor: srcRGB,
                        dstFactor: dstRGB,
                        operation: GPUBlendOperation.Add
                    };
                    alpha = {
                        srcFactor: srcAlpha,
                        dstFactor: dstAlpha,
                        operation: GPUBlendOperation.Add
                    };
                };
                if (premultipliedAlpha) {
                    switch (blending) {
                        case NormalBlending:
                            setBlend(GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);
                            break;
                        case AdditiveBlending:
                            setBlend(GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);
                            break;
                        case SubtractiveBlending:
                            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);
                            break;
                        case MultiplyBlending:
                            setBlend(GPUBlendFactor.Dst, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.Zero, GPUBlendFactor.One);
                            break;
                    }
                } else {
                    switch (blending) {
                        case NormalBlending:
                            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);
                            break;
                        case AdditiveBlending:
                            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);
                            break;
                        case SubtractiveBlending:
                            console.error('THREE.WebGPURenderer: SubtractiveBlending requires material.premultipliedAlpha = true');
                            break;
                        case MultiplyBlending:
                            console.error('THREE.WebGPURenderer: MultiplyBlending requires material.premultipliedAlpha = true');
                            break;
                    }
                }
            }
            if (color !== undefined && alpha !== undefined) {
                return { color, alpha };
            } else {
                console.error('THREE.WebGPURenderer: Invalid blending: ', blending);
            }
        }
        _getBlendFactor(blend) {
            let blendFactor;
            switch (blend) {
                case ZeroFactor:
                    blendFactor = GPUBlendFactor.Zero;
                    break;
                case OneFactor:
                    blendFactor = GPUBlendFactor.One;
                    break;
                case SrcColorFactor:
                    blendFactor = GPUBlendFactor.Src;
                    break;
                case OneMinusSrcColorFactor:
                    blendFactor = GPUBlendFactor.OneMinusSrc;
                    break;
                case SrcAlphaFactor:
                    blendFactor = GPUBlendFactor.SrcAlpha;
                    break;
                case OneMinusSrcAlphaFactor:
                    blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
                    break;
                case DstColorFactor:
                    blendFactor = GPUBlendFactor.Dst;
                    break;
                case OneMinusDstColorFactor:
                    blendFactor = GPUBlendFactor.OneMinusDst;
                    break;
                case DstAlphaFactor:
                    blendFactor = GPUBlendFactor.DstAlpha;
                    break;
                case OneMinusDstAlphaFactor:
                    blendFactor = GPUBlendFactor.OneMinusDstAlpha;
                    break;
                case SrcAlphaSaturateFactor:
                    blendFactor = GPUBlendFactor.SrcAlphaSaturated;
                    break;
                case BlendColorFactor:
                    blendFactor = GPUBlendFactor.Constant;
                    break;
                case OneMinusBlendColorFactor:
                    blendFactor = GPUBlendFactor.OneMinusConstant;
                    break;
                default:
                    console.error('THREE.WebGPURenderer: Blend factor not supported.', blend);
            }
            return blendFactor;
        }
        _getStencilCompare(material) {
            let stencilCompare;
            const stencilFunc = material.stencilFunc;
            switch (stencilFunc) {
                case NeverStencilFunc:
                    stencilCompare = GPUCompareFunction.Never;
                    break;
                case AlwaysStencilFunc:
                    stencilCompare = GPUCompareFunction.Always;
                    break;
                case LessStencilFunc:
                    stencilCompare = GPUCompareFunction.Less;
                    break;
                case LessEqualStencilFunc:
                    stencilCompare = GPUCompareFunction.LessEqual;
                    break;
                case EqualStencilFunc:
                    stencilCompare = GPUCompareFunction.Equal;
                    break;
                case GreaterEqualStencilFunc:
                    stencilCompare = GPUCompareFunction.GreaterEqual;
                    break;
                case GreaterStencilFunc:
                    stencilCompare = GPUCompareFunction.Greater;
                    break;
                case NotEqualStencilFunc:
                    stencilCompare = GPUCompareFunction.NotEqual;
                    break;
                default:
                    console.error('THREE.WebGPURenderer: Invalid stencil function.', stencilFunc);
            }
            return stencilCompare;
        }
        _getStencilOperation(op) {
            let stencilOperation;
            switch (op) {
                case KeepStencilOp:
                    stencilOperation = GPUStencilOperation.Keep;
                    break;
                case ZeroStencilOp:
                    stencilOperation = GPUStencilOperation.Zero;
                    break;
                case ReplaceStencilOp:
                    stencilOperation = GPUStencilOperation.Replace;
                    break;
                case InvertStencilOp:
                    stencilOperation = GPUStencilOperation.Invert;
                    break;
                case IncrementStencilOp:
                    stencilOperation = GPUStencilOperation.IncrementClamp;
                    break;
                case DecrementStencilOp:
                    stencilOperation = GPUStencilOperation.DecrementClamp;
                    break;
                case IncrementWrapStencilOp:
                    stencilOperation = GPUStencilOperation.IncrementWrap;
                    break;
                case DecrementWrapStencilOp:
                    stencilOperation = GPUStencilOperation.DecrementWrap;
                    break;
                default:
                    console.error('THREE.WebGPURenderer: Invalid stencil operation.', stencilOperation);
            }
            return stencilOperation;
        }
        _getBlendOperation(blendEquation) {
            let blendOperation;
            switch (blendEquation) {
                case AddEquation:
                    blendOperation = GPUBlendOperation.Add;
                    break;
                case SubtractEquation:
                    blendOperation = GPUBlendOperation.Subtract;
                    break;
                case ReverseSubtractEquation:
                    blendOperation = GPUBlendOperation.ReverseSubtract;
                    break;
                case MinEquation:
                    blendOperation = GPUBlendOperation.Min;
                    break;
                case MaxEquation:
                    blendOperation = GPUBlendOperation.Max;
                    break;
                default:
                    console.error('THREE.WebGPUPipelineUtils: Blend equation not supported.', blendEquation);
            }
            return blendOperation;
        }
        _getPrimitiveState(object, geometry, material) {
            const descriptor = {};
            const utils = this.backend.utils;
            descriptor.topology = utils.getPrimitiveTopology(object, material);
            if (geometry.index !== null && object.isLine === true && object.isLineSegments !== true) {
                descriptor.stripIndexFormat = (geometry.index.array instanceof Uint16Array) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
            }
            switch (material.side) {
                case FrontSide:
                    descriptor.frontFace = GPUFrontFace.CCW;
                    descriptor.cullMode = GPUCullMode.Back;
                    break;
                case BackSide:
                    descriptor.frontFace = GPUFrontFace.CCW;
                    descriptor.cullMode = GPUCullMode.Front;
                    break;
                case DoubleSide:
                    descriptor.frontFace = GPUFrontFace.CCW;
                    descriptor.cullMode = GPUCullMode.None;
                    break;
                default:
                    console.error('THREE.WebGPUPipelineUtils: Unknown material.side value.', material.side);
                    break;
            }
            return descriptor;
        }
        _getColorWriteMask(material) {
            return (material.colorWrite === true) ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;
        }
        _getDepthCompare(material) {
            let depthCompare;
            if (material.depthTest === false) {
                depthCompare = GPUCompareFunction.Always;
            } else {
                const depthFunc = material.depthFunc;
                switch (depthFunc) {
                    case NeverDepth:
                        depthCompare = GPUCompareFunction.Never;
                        break;
                    case AlwaysDepth:
                        depthCompare = GPUCompareFunction.Always;
                        break;
                    case LessDepth:
                        depthCompare = GPUCompareFunction.Less;
                        break;
                    case LessEqualDepth:
                        depthCompare = GPUCompareFunction.LessEqual;
                        break;
                    case EqualDepth:
                        depthCompare = GPUCompareFunction.Equal;
                        break;
                    case GreaterEqualDepth:
                        depthCompare = GPUCompareFunction.GreaterEqual;
                        break;
                    case GreaterDepth:
                        depthCompare = GPUCompareFunction.Greater;
                        break;
                    case NotEqualDepth:
                        depthCompare = GPUCompareFunction.NotEqual;
                        break;
                    default:
                        console.error('THREE.WebGPUPipelineUtils: Invalid depth function.', depthFunc);
                }
            }
            return depthCompare;
        }
    }
    class WebGPUTimestampQueryPool extends TimestampQueryPool {
        constructor(device, type, maxQueries = 2048) {
            super(maxQueries);
            this.device = device;
            this.type = type;
            this.querySet = this.device.createQuerySet({
                type: 'timestamp',
                count: this.maxQueries,
                label: `queryset_global_timestamp_${type}`
            });
            const bufferSize = this.maxQueries * 8;
            this.resolveBuffer = this.device.createBuffer({
                label: `buffer_timestamp_resolve_${type}`,
                size: bufferSize,
                usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
            });
            this.resultBuffer = this.device.createBuffer({
                label: `buffer_timestamp_result_${type}`,
                size: bufferSize,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
            });
        }
        allocateQueriesForContext(renderContext) {
            if (!this.trackTimestamp || this.isDisposed) return null;
            if (this.currentQueryIndex + 2 > this.maxQueries) {
                warnOnce(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`);
                return null;
            }
            const baseOffset = this.currentQueryIndex;
            this.currentQueryIndex += 2;
            this.queryOffsets.set(renderContext.id, baseOffset);
            return baseOffset;
        }
        async resolveQueriesAsync() {
            if (!this.trackTimestamp || this.currentQueryIndex === 0 || this.isDisposed) {
                return this.lastValue;
            }
            if (this.pendingResolve) {
                return this.pendingResolve;
            }
            this.pendingResolve = this._resolveQueries();
            try {
                const result = await this.pendingResolve;
                return result;
            } finally {
                this.pendingResolve = null;
            }
        }
        async _resolveQueries() {
            if (this.isDisposed) {
                return this.lastValue;
            }
            try {
                if (this.resultBuffer.mapState !== 'unmapped') {
                    return this.lastValue;
                }
                const currentOffsets = new Map(this.queryOffsets);
                const queryCount = this.currentQueryIndex;
                const bytesUsed = queryCount * 8;
                // Reset state before GPU work
                this.currentQueryIndex = 0;
                this.queryOffsets.clear();
                const commandEncoder = this.device.createCommandEncoder();
                commandEncoder.resolveQuerySet(
                    this.querySet,
                    0,
                    queryCount,
                    this.resolveBuffer,
                    0
                );
                commandEncoder.copyBufferToBuffer(
                    this.resolveBuffer,
                    0,
                    this.resultBuffer,
                    0,
                    bytesUsed
                );
                const commandBuffer = commandEncoder.finish();
                this.device.queue.submit([commandBuffer]);
                if (this.resultBuffer.mapState !== 'unmapped') {
                    return this.lastValue;
                }
                // Create and track the mapping operation
                await this.resultBuffer.mapAsync(GPUMapMode.READ, 0, bytesUsed);
                if (this.isDisposed) {
                    if (this.resultBuffer.mapState === 'mapped') {
                        this.resultBuffer.unmap();
                    }
                    return this.lastValue;
                }
                const times = new BigUint64Array(this.resultBuffer.getMappedRange(0, bytesUsed));
                let totalDuration = 0;
                for (const [, baseOffset] of currentOffsets) {
                    const startTime = times[baseOffset];
                    const endTime = times[baseOffset + 1];
                    const duration = Number(endTime - startTime) / 1e6;
                    totalDuration += duration;
                }
                this.resultBuffer.unmap();
                this.lastValue = totalDuration;
                return totalDuration;
            } catch (error) {
                console.error('Error resolving queries:', error);
                if (this.resultBuffer.mapState === 'mapped') {
                    this.resultBuffer.unmap();
                }
                return this.lastValue;
            }
        }
        async dispose() {
            if (this.isDisposed) {
                return;
            }
            this.isDisposed = true;
            // Wait for pending resolve operation
            if (this.pendingResolve) {
                try {
                    await this.pendingResolve;
                } catch (error) {
                    console.error('Error waiting for pending resolve:', error);
                }
            }
            // Ensure buffer is unmapped before destroying
            if (this.resultBuffer && this.resultBuffer.mapState === 'mapped') {
                try {
                    this.resultBuffer.unmap();
                } catch (error) {
                    console.error('Error unmapping buffer:', error);
                }
            }
            // Destroy resources
            if (this.querySet) {
                this.querySet.destroy();
                this.querySet = null;
            }
            if (this.resolveBuffer) {
                this.resolveBuffer.destroy();
                this.resolveBuffer = null;
            }
            if (this.resultBuffer) {
                this.resultBuffer.destroy();
                this.resultBuffer = null;
            }
            this.queryOffsets.clear();
            this.pendingResolve = null;
        }
    }
    /*// debugger tools
    import 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';
    //*/

    class WebGPUBackend extends Backend {

        constructor(parameters = {}) {
            super(parameters);
            this.isWebGPUBackend = true;
            // some parameters require default values other than "undefined"
            this.parameters.alpha = (parameters.alpha === undefined) ? true : parameters.alpha;
            this.parameters.compatibilityMode = (parameters.compatibilityMode === undefined) ? false : parameters.compatibilityMode;
            this.parameters.requiredLimits = (parameters.requiredLimits === undefined) ? {} : parameters.requiredLimits;
            this.compatibilityMode = this.parameters.compatibilityMode;
            this.device = null;
            this.context = null;
            this.colorBuffer = null;
            this.defaultRenderPassdescriptor = null;
            this.utils = new WebGPUUtils(this);
            this.attributeUtils = new WebGPUAttributeUtils(this);
            this.bindingUtils = new WebGPUBindingUtils(this);
            this.pipelineUtils = new WebGPUPipelineUtils(this);
            this.textureUtils = new WebGPUTextureUtils(this);
            this.occludedResolveCache = new Map();
        }
        async init(renderer) {
            await super.init(renderer);
            //
            const parameters = this.parameters;
            // create the device if it is not passed with parameters
            let device;
            if (parameters.device === undefined) {
                const adapterOptions = {
                    powerPreference: parameters.powerPreference,
                    featureLevel: parameters.compatibilityMode ? 'compatibility' : undefined
                };
                const adapter = (typeof navigator !== 'undefined') ? await navigator.gpu.requestAdapter(adapterOptions) : null;
                if (adapter === null) {
                    throw new Error('WebGPUBackend: Unable to create WebGPU adapter.');
                }
                // feature support
                const features = Object.values(GPUFeatureName);
                const supportedFeatures = [];
                for (const name of features) {
                    if (adapter.features.has(name)) {
                        supportedFeatures.push(name);
                    }
                }
                const deviceDescriptor = {
                    requiredFeatures: supportedFeatures,
                    requiredLimits: parameters.requiredLimits
                };
                device = await adapter.requestDevice(deviceDescriptor);
            } else {
                device = parameters.device;
            }
            device.lost.then((info) => {
                const deviceLossInfo = {
                    api: 'WebGPU',
                    message: info.message || 'Unknown reason',
                    reason: info.reason || null,
                    originalEvent: info
                };
                renderer.onDeviceLost(deviceLossInfo);
            });
            const context = (parameters.context !== undefined) ? parameters.context : renderer.domElement.getContext('webgpu');
            this.device = device;
            this.context = context;
            const alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';
            this.trackTimestamp = this.trackTimestamp && this.hasFeature(GPUFeatureName.TimestampQuery);
            this.context.configure({
                device: this.device,
                format: this.utils.getPreferredCanvasFormat(),
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                alphaMode: alphaMode
            });
            this.updateSize();
        }
        get coordinateSystem() {
            return WebGPUCoordinateSystem;
        }
        async getArrayBufferAsync(attribute) {
            return await this.attributeUtils.getArrayBufferAsync(attribute);
        }
        getContext() {
            return this.context;
        }
        _getDefaultRenderPassDescriptor() {
            let descriptor = this.defaultRenderPassdescriptor;
            if (descriptor === null) {
                const renderer = this.renderer;
                descriptor = {
                    colorAttachments: [{
                        view: null
                    }],
                };
                if (this.renderer.depth === true || this.renderer.stencil === true) {
                    descriptor.depthStencilAttachment = {
                        view: this.textureUtils.getDepthBuffer(renderer.depth, renderer.stencil).createView()
                    };
                }
                const colorAttachment = descriptor.colorAttachments[0];
                if (this.renderer.samples > 0) {
                    colorAttachment.view = this.colorBuffer.createView();
                } else {
                    colorAttachment.resolveTarget = undefined;
                }
                this.defaultRenderPassdescriptor = descriptor;
            }
            const colorAttachment = descriptor.colorAttachments[0];
            if (this.renderer.samples > 0) {
                colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();
            } else {
                colorAttachment.view = this.context.getCurrentTexture().createView();
            }
            return descriptor;
        }
        _isRenderCameraDepthArray(renderContext) {
            return renderContext.depthTexture && renderContext.depthTexture.image.depth > 1 && renderContext.camera.isArrayCamera;
        }
        _getRenderPassDescriptor(renderContext, colorAttachmentsConfig = {}) {
            const renderTarget = renderContext.renderTarget;
            const renderTargetData = this.get(renderTarget);
            let descriptors = renderTargetData.descriptors;
            if (descriptors === undefined ||
                renderTargetData.width !== renderTarget.width ||
                renderTargetData.height !== renderTarget.height ||
                renderTargetData.dimensions !== renderTarget.dimensions ||
                renderTargetData.activeMipmapLevel !== renderContext.activeMipmapLevel ||
                renderTargetData.activeCubeFace !== renderContext.activeCubeFace ||
                renderTargetData.samples !== renderTarget.samples
            ) {
                descriptors = {};
                renderTargetData.descriptors = descriptors;
                // dispose
                const onDispose = () => {
                    renderTarget.removeEventListener('dispose', onDispose);
                    this.delete(renderTarget);
                };
                if (renderTarget.hasEventListener('dispose', onDispose) === false) {
                    renderTarget.addEventListener('dispose', onDispose);
                }
            }
            const cacheKey = renderContext.getCacheKey();
            let descriptorBase = descriptors[cacheKey];
            if (descriptorBase === undefined) {
                const textures = renderContext.textures;
                const textureViews = [];
                let sliceIndex;
                const isRenderCameraDepthArray = this._isRenderCameraDepthArray(renderContext);
                for (let i = 0; i < textures.length; i++) {
                    const textureData = this.get(textures[i]);
                    const viewDescriptor = {
                        label: `colorAttachment_${i}`,
                        baseMipLevel: renderContext.activeMipmapLevel,
                        mipLevelCount: 1,
                        baseArrayLayer: renderContext.activeCubeFace,
                        arrayLayerCount: 1,
                        dimension: GPUTextureViewDimension.TwoD
                    };
                    if (renderTarget.isRenderTarget3D) {
                        sliceIndex = renderContext.activeCubeFace;
                        viewDescriptor.baseArrayLayer = 0;
                        viewDescriptor.dimension = GPUTextureViewDimension.ThreeD;
                        viewDescriptor.depthOrArrayLayers = textures[i].image.depth;
                    } else if (renderTarget.isRenderTarget && textures[i].image.depth > 1) {
                        if (isRenderCameraDepthArray === true) {
                            const cameras = renderContext.camera.cameras;
                            for (let layer = 0; layer < cameras.length; layer++) {
                                const layerViewDescriptor = {
                                    ...viewDescriptor,
                                    baseArrayLayer: layer,
                                    arrayLayerCount: 1,
                                    dimension: GPUTextureViewDimension.TwoD
                                };
                                const textureView = textureData.texture.createView(layerViewDescriptor);
                                textureViews.push({
                                    view: textureView,
                                    resolveTarget: undefined,
                                    depthSlice: undefined
                                });
                            }
                        } else {
                            viewDescriptor.dimension = GPUTextureViewDimension.TwoDArray;
                            viewDescriptor.depthOrArrayLayers = textures[i].image.depth;
                        }
                    }
                    if (isRenderCameraDepthArray !== true) {
                        const textureView = textureData.texture.createView(viewDescriptor);
                        let view, resolveTarget;
                        if (textureData.msaaTexture !== undefined) {
                            view = textureData.msaaTexture.createView();
                            resolveTarget = textureView;
                        } else {
                            view = textureView;
                            resolveTarget = undefined;
                        }
                        textureViews.push({
                            view,
                            resolveTarget,
                            depthSlice: sliceIndex
                        });
                    }
                }
                descriptorBase = { textureViews };
                if (renderContext.depth) {
                    const depthTextureData = this.get(renderContext.depthTexture);
                    const options = {};
                    if (renderContext.depthTexture.isArrayTexture) {
                        options.dimension = GPUTextureViewDimension.TwoD;
                        options.arrayLayerCount = 1;
                        options.baseArrayLayer = renderContext.activeCubeFace;
                    }
                    descriptorBase.depthStencilView = depthTextureData.texture.createView(options);
                }
                descriptors[cacheKey] = descriptorBase;
                renderTargetData.width = renderTarget.width;
                renderTargetData.height = renderTarget.height;
                renderTargetData.samples = renderTarget.samples;
                renderTargetData.activeMipmapLevel = renderContext.activeMipmapLevel;
                renderTargetData.activeCubeFace = renderContext.activeCubeFace;
                renderTargetData.dimensions = renderTarget.dimensions;
            }
            const descriptor = {
                colorAttachments: []
            };
            // Apply dynamic properties to cached views
            for (let i = 0; i < descriptorBase.textureViews.length; i++) {
                const viewInfo = descriptorBase.textureViews[i];
                let clearValue = { r: 0, g: 0, b: 0, a: 1 };
                if (i === 0 && colorAttachmentsConfig.clearValue) {
                    clearValue = colorAttachmentsConfig.clearValue;
                }
                descriptor.colorAttachments.push({
                    view: viewInfo.view,
                    depthSlice: viewInfo.depthSlice,
                    resolveTarget: viewInfo.resolveTarget,
                    loadOp: colorAttachmentsConfig.loadOp || GPULoadOp.Load,
                    storeOp: colorAttachmentsConfig.storeOp || GPUStoreOp.Store,
                    clearValue: clearValue
                });
            }
            if (descriptorBase.depthStencilView) {
                descriptor.depthStencilAttachment = {
                    view: descriptorBase.depthStencilView
                };
            }
            return descriptor;
        }
        beginRender(renderContext) {
            const renderContextData = this.get(renderContext);
            const device = this.device;
            const occlusionQueryCount = renderContext.occlusionQueryCount;
            let occlusionQuerySet;
            if (occlusionQueryCount > 0) {
                if (renderContextData.currentOcclusionQuerySet) renderContextData.currentOcclusionQuerySet.destroy();
                if (renderContextData.currentOcclusionQueryBuffer) renderContextData.currentOcclusionQueryBuffer.destroy();
                // Get a reference to the array of objects with queries. The renderContextData property
                // can be changed by another render pass before the buffer.mapAsyc() completes.
                renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;
                renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;
                renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;
                //
                occlusionQuerySet = device.createQuerySet({ type: 'occlusion', count: occlusionQueryCount, label: `occlusionQuerySet_${renderContext.id}` });
                renderContextData.occlusionQuerySet = occlusionQuerySet;
                renderContextData.occlusionQueryIndex = 0;
                renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
                renderContextData.lastOcclusionObject = null;
            }
            let descriptor;
            if (renderContext.textures === null) {
                descriptor = this._getDefaultRenderPassDescriptor();
            } else {
                descriptor = this._getRenderPassDescriptor(renderContext, { loadOp: GPULoadOp.Load });
            }
            this.initTimestampQuery(renderContext, descriptor);
            descriptor.occlusionQuerySet = occlusionQuerySet;
            const depthStencilAttachment = descriptor.depthStencilAttachment;
            if (renderContext.textures !== null) {
                const colorAttachments = descriptor.colorAttachments;
                for (let i = 0; i < colorAttachments.length; i++) {
                    const colorAttachment = colorAttachments[i];
                    if (renderContext.clearColor) {
                        colorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : { r: 0, g: 0, b: 0, a: 1 };
                        colorAttachment.loadOp = GPULoadOp.Clear;
                    } else {
                        colorAttachment.loadOp = GPULoadOp.Load;
                    }
                    colorAttachment.storeOp = GPUStoreOp.Store;
                }
            } else {
                const colorAttachment = descriptor.colorAttachments[0];
                if (renderContext.clearColor) {
                    colorAttachment.clearValue = renderContext.clearColorValue;
                    colorAttachment.loadOp = GPULoadOp.Clear;
                } else {
                    colorAttachment.loadOp = GPULoadOp.Load;
                }
                colorAttachment.storeOp = GPUStoreOp.Store;
            }
            //
            if (renderContext.depth) {
                if (renderContext.clearDepth) {
                    depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;
                    depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
                } else {
                    depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
                }
                depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
            }
            if (renderContext.stencil) {
                if (renderContext.clearStencil) {
                    depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;
                    depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
                } else {
                    depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
                }
                depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
            }
            //
            const encoder = device.createCommandEncoder({ label: 'renderContext_' + renderContext.id });
            // shadow arrays - prepare bundle encoders for each camera in an array camera
            if (this._isRenderCameraDepthArray(renderContext) === true) {
                const cameras = renderContext.camera.cameras;
                if (!renderContextData.layerDescriptors || renderContextData.layerDescriptors.length !== cameras.length) {
                    this._createDepthLayerDescriptors(renderContext, renderContextData, descriptor, cameras);
                } else {
                    this._updateDepthLayerDescriptors(renderContext, renderContextData, cameras);
                }
                // Create bundle encoders for each layer
                renderContextData.bundleEncoders = [];
                renderContextData.bundleSets = [];
                // Create separate bundle encoders for each camera in the array
                for (let i = 0; i < cameras.length; i++) {
                    const bundleEncoder = this.pipelineUtils.createBundleEncoder(
                        renderContext,
                        'renderBundleArrayCamera_' + i
                    );
                    // Initialize state tracking for this bundle
                    const bundleSets = {
                        attributes: {},
                        bindingGroups: [],
                        pipeline: null,
                        index: null
                    };
                    renderContextData.bundleEncoders.push(bundleEncoder);
                    renderContextData.bundleSets.push(bundleSets);
                }
                // We'll complete the bundles in finishRender
                renderContextData.currentPass = null;
            } else {
                const currentPass = encoder.beginRenderPass(descriptor);
                renderContextData.currentPass = currentPass;
                if (renderContext.viewport) {
                    this.updateViewport(renderContext);
                }
                if (renderContext.scissor) {
                    const { x, y, width, height } = renderContext.scissorValue;
                    currentPass.setScissorRect(x, y, width, height);
                }
            }
            //
            renderContextData.descriptor = descriptor;
            renderContextData.encoder = encoder;
            renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
            renderContextData.renderBundles = [];
        }
        _createDepthLayerDescriptors(renderContext, renderContextData, descriptor, cameras) {
            const depthStencilAttachment = descriptor.depthStencilAttachment;
            renderContextData.layerDescriptors = [];
            const depthTextureData = this.get(renderContext.depthTexture);
            if (!depthTextureData.viewCache) {
                depthTextureData.viewCache = [];
            }
            for (let i = 0; i < cameras.length; i++) {
                const layerDescriptor = {
                    ...descriptor,
                    colorAttachments: [{
                        ...descriptor.colorAttachments[0],
                        view: descriptor.colorAttachments[i].view
                    }]
                };
                if (descriptor.depthStencilAttachment) {
                    const layerIndex = i;
                    if (!depthTextureData.viewCache[layerIndex]) {
                        depthTextureData.viewCache[layerIndex] = depthTextureData.texture.createView({
                            dimension: GPUTextureViewDimension.TwoD,
                            baseArrayLayer: i,
                            arrayLayerCount: 1
                        });
                    }
                    layerDescriptor.depthStencilAttachment = {
                        view: depthTextureData.viewCache[layerIndex],
                        depthLoadOp: depthStencilAttachment.depthLoadOp || GPULoadOp.Clear,
                        depthStoreOp: depthStencilAttachment.depthStoreOp || GPUStoreOp.Store,
                        depthClearValue: depthStencilAttachment.depthClearValue || 1.0
                    };
                    if (renderContext.stencil) {
                        layerDescriptor.depthStencilAttachment.stencilLoadOp = depthStencilAttachment.stencilLoadOp;
                        layerDescriptor.depthStencilAttachment.stencilStoreOp = depthStencilAttachment.stencilStoreOp;
                        layerDescriptor.depthStencilAttachment.stencilClearValue = depthStencilAttachment.stencilClearValue;
                    }
                } else {
                    layerDescriptor.depthStencilAttachment = { ...depthStencilAttachment };
                }
                renderContextData.layerDescriptors.push(layerDescriptor);
            }
        }
        _updateDepthLayerDescriptors(renderContext, renderContextData, cameras) {
            for (let i = 0; i < cameras.length; i++) {
                const layerDescriptor = renderContextData.layerDescriptors[i];
                if (layerDescriptor.depthStencilAttachment) {
                    const depthAttachment = layerDescriptor.depthStencilAttachment;
                    if (renderContext.depth) {
                        if (renderContext.clearDepth) {
                            depthAttachment.depthClearValue = renderContext.clearDepthValue;
                            depthAttachment.depthLoadOp = GPULoadOp.Clear;
                        } else {
                            depthAttachment.depthLoadOp = GPULoadOp.Load;
                        }
                    }
                    if (renderContext.stencil) {
                        if (renderContext.clearStencil) {
                            depthAttachment.stencilClearValue = renderContext.clearStencilValue;
                            depthAttachment.stencilLoadOp = GPULoadOp.Clear;
                        } else {
                            depthAttachment.stencilLoadOp = GPULoadOp.Load;
                        }
                    }
                }
            }
        }
        finishRender(renderContext) {
            const renderContextData = this.get(renderContext);
            const occlusionQueryCount = renderContext.occlusionQueryCount;
            if (renderContextData.renderBundles.length > 0) {
                renderContextData.currentPass.executeBundles(renderContextData.renderBundles);
            }
            if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {
                renderContextData.currentPass.endOcclusionQuery();
            }
            // shadow arrays - Execute bundles for each layer
            const encoder = renderContextData.encoder;
            if (this._isRenderCameraDepthArray(renderContext) === true) {
                const bundles = [];
                for (let i = 0; i < renderContextData.bundleEncoders.length; i++) {
                    const bundleEncoder = renderContextData.bundleEncoders[i];
                    bundles.push(bundleEncoder.finish());
                }
                for (let i = 0; i < renderContextData.layerDescriptors.length; i++) {
                    if (i < bundles.length) {
                        const layerDescriptor = renderContextData.layerDescriptors[i];
                        const renderPass = encoder.beginRenderPass(layerDescriptor);
                        if (renderContext.viewport) {
                            const { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;
                            renderPass.setViewport(x, y, width, height, minDepth, maxDepth);
                        }
                        if (renderContext.scissor) {
                            const { x, y, width, height } = renderContext.scissorValue;
                            renderPass.setScissorRect(x, y, width, height);
                        }
                        renderPass.executeBundles([bundles[i]]);
                        renderPass.end();
                    }
                }
            } else if (renderContextData.currentPass) {
                renderContextData.currentPass.end();
            }
            if (occlusionQueryCount > 0) {
                const bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results
                //
                let queryResolveBuffer = this.occludedResolveCache.get(bufferSize);
                if (queryResolveBuffer === undefined) {
                    queryResolveBuffer = this.device.createBuffer(
                        {
                            size: bufferSize,
                            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
                        }
                    );
                    this.occludedResolveCache.set(bufferSize, queryResolveBuffer);
                }
                //
                const readBuffer = this.device.createBuffer(
                    {
                        size: bufferSize,
                        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
                    }
                );
                // two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined
                renderContextData.encoder.resolveQuerySet(renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0);
                renderContextData.encoder.copyBufferToBuffer(queryResolveBuffer, 0, readBuffer, 0, bufferSize);
                renderContextData.occlusionQueryBuffer = readBuffer;
                //
                this.resolveOccludedAsync(renderContext);
            }
            this.device.queue.submit([renderContextData.encoder.finish()]);

            //
            if (renderContext.textures !== null) {
                const textures = renderContext.textures;
                for (let i = 0; i < textures.length; i++) {
                    const texture = textures[i];
                    if (texture.generateMipmaps === true) {
                        this.textureUtils.generateMipmaps(texture);
                    }
                }
            }
        }
        isOccluded(renderContext, object) {
            const renderContextData = this.get(renderContext);
            return renderContextData.occluded && renderContextData.occluded.has(object);
        }
        async resolveOccludedAsync(renderContext) {
            const renderContextData = this.get(renderContext);
            // handle occlusion query results
            const { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;
            if (currentOcclusionQueryBuffer && currentOcclusionQueryObjects) {
                const occluded = new WeakSet();
                renderContextData.currentOcclusionQueryObjects = null;
                renderContextData.currentOcclusionQueryBuffer = null;
                await currentOcclusionQueryBuffer.mapAsync(GPUMapMode.READ);
                const buffer = currentOcclusionQueryBuffer.getMappedRange();
                const results = new BigUint64Array(buffer);
                for (let i = 0; i < currentOcclusionQueryObjects.length; i++) {
                    if (results[i] === BigInt(0)) {
                        occluded.add(currentOcclusionQueryObjects[i]);
                    }
                }
                currentOcclusionQueryBuffer.destroy();
                renderContextData.occluded = occluded;
            }
        }
        updateViewport(renderContext) {
            const { currentPass } = this.get(renderContext);
            const { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;
            currentPass.setViewport(x, y, width, height, minDepth, maxDepth);
        }
        getClearColor() {
            const clearColor = super.getClearColor();
            // only premultiply alpha when alphaMode is "premultiplied"
            if (this.renderer.alpha === true) {
                clearColor.r *= clearColor.a;
                clearColor.g *= clearColor.a;
                clearColor.b *= clearColor.a;
            }
            return clearColor;
        }
        clear(color, depth, stencil, renderTargetContext = null) {
            const device = this.device;
            const renderer = this.renderer;
            let colorAttachments = [];
            let depthStencilAttachment;
            let clearValue;
            let supportsDepth;
            let supportsStencil;
            if (color) {
                const clearColor = this.getClearColor();
                clearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };
            }
            if (renderTargetContext === null) {
                supportsDepth = renderer.depth;
                supportsStencil = renderer.stencil;
                const descriptor = this._getDefaultRenderPassDescriptor();
                if (color) {
                    colorAttachments = descriptor.colorAttachments;
                    const colorAttachment = colorAttachments[0];
                    colorAttachment.clearValue = clearValue;
                    colorAttachment.loadOp = GPULoadOp.Clear;
                    colorAttachment.storeOp = GPUStoreOp.Store;
                }
                if (supportsDepth || supportsStencil) {
                    depthStencilAttachment = descriptor.depthStencilAttachment;
                }
            } else {
                supportsDepth = renderTargetContext.depth;
                supportsStencil = renderTargetContext.stencil;
                const clearConfig = {
                    loadOp: color ? GPULoadOp.Clear : GPULoadOp.Load,
                    clearValue: color ? clearValue : undefined
                };
                if (supportsDepth) {
                    clearConfig.depthLoadOp = depth ? GPULoadOp.Clear : GPULoadOp.Load;
                    clearConfig.depthClearValue = depth ? renderer.getClearDepth() : undefined;
                    clearConfig.depthStoreOp = GPUStoreOp.Store;
                }
                if (supportsStencil) {
                    clearConfig.stencilLoadOp = stencil ? GPULoadOp.Clear : GPULoadOp.Load;
                    clearConfig.stencilClearValue = stencil ? renderer.getClearStencil() : undefined;
                    clearConfig.stencilStoreOp = GPUStoreOp.Store;
                }
                const descriptor = this._getRenderPassDescriptor(renderTargetContext, clearConfig);
                colorAttachments = descriptor.colorAttachments;
                depthStencilAttachment = descriptor.depthStencilAttachment;
            }
            if (supportsDepth && depthStencilAttachment) {
                if (depth) {
                    depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
                    depthStencilAttachment.depthClearValue = renderer.getClearDepth();
                    depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
                } else {
                    depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
                    depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
                }
            }
            //
            if (supportsStencil && depthStencilAttachment) {
                if (stencil) {
                    depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
                    depthStencilAttachment.stencilClearValue = renderer.getClearStencil();
                    depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
                } else {
                    depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
                    depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
                }
            }
            //
            const encoder = device.createCommandEncoder({ label: 'clear' });
            const currentPass = encoder.beginRenderPass({
                colorAttachments,
                depthStencilAttachment
            });
            currentPass.end();
            device.queue.submit([encoder.finish()]);
        }
        // compute
        beginCompute(computeGroup) {
            const groupGPU = this.get(computeGroup);
            const descriptor = {
                label: 'computeGroup_' + computeGroup.id
            };
            this.initTimestampQuery(computeGroup, descriptor);
            groupGPU.cmdEncoderGPU = this.device.createCommandEncoder({ label: 'computeGroup_' + computeGroup.id });
            groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass(descriptor);
        }
        compute(computeGroup, computeNode, bindings, pipeline, dispatchSizeOrCount = null) {
            const computeNodeData = this.get(computeNode);
            const { passEncoderGPU } = this.get(computeGroup);
            // pipeline
            const pipelineGPU = this.get(pipeline).pipeline;
            this.pipelineUtils.setPipeline(passEncoderGPU, pipelineGPU);
            // bind groups
            for (let i = 0, l = bindings.length; i < l; i++) {
                const bindGroup = bindings[i];
                const bindingsData = this.get(bindGroup);
                passEncoderGPU.setBindGroup(i, bindingsData.group);
            }
            let dispatchSize;
            if (dispatchSizeOrCount === null) {
                dispatchSizeOrCount = computeNode.count;
            }
            if (typeof dispatchSizeOrCount === 'number') {
                // If a single number is given, we calculate the dispatch size based on the workgroup size
                const count = dispatchSizeOrCount;
                if (computeNodeData.dispatchSize === undefined || computeNodeData.count !== count) {
                    // cache dispatch size to avoid recalculating it every time
                    computeNodeData.dispatchSize = [0, 1, 1];
                    computeNodeData.count = count;
                    const workgroupSize = computeNode.workgroupSize;
                    let size = workgroupSize[0];
                    for (let i = 1; i < workgroupSize.length; i++)
                        size *= workgroupSize[i];
                    const dispatchCount = Math.ceil(count / size);
                    //
                    const maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;
                    dispatchSize = [dispatchCount, 1, 1];
                    if (dispatchCount > maxComputeWorkgroupsPerDimension) {
                        dispatchSize[0] = Math.min(dispatchCount, maxComputeWorkgroupsPerDimension);
                        dispatchSize[1] = Math.ceil(dispatchCount / maxComputeWorkgroupsPerDimension);
                    }
                    computeNodeData.dispatchSize = dispatchSize;
                }
                dispatchSize = computeNodeData.dispatchSize;
            } else {
                dispatchSize = dispatchSizeOrCount;
            }
            //
            passEncoderGPU.dispatchWorkgroups(
                dispatchSize[0],
                dispatchSize[1] || 1,
                dispatchSize[2] || 1
            );
        }
        finishCompute(computeGroup) {
            const groupData = this.get(computeGroup);
            groupData.passEncoderGPU.end();
            this.device.queue.submit([groupData.cmdEncoderGPU.finish()]);
        }
        async waitForGPU() {
            await this.device.queue.onSubmittedWorkDone();
        }
        // render object
        draw(renderObject, info) {
            const { object, material, context, pipeline } = renderObject;
            const bindings = renderObject.getBindings();
            const renderContextData = this.get(context);
            const pipelineGPU = this.get(pipeline).pipeline;
            const index = renderObject.getIndex();
            const hasIndex = (index !== null);

            const drawParams = renderObject.getDrawParameters();
            if (drawParams === null) return;
            // pipeline
            const setPipelineAndBindings = (passEncoderGPU, currentSets) => {
                // pipeline
                this.pipelineUtils.setPipeline(passEncoderGPU, pipelineGPU);
                currentSets.pipeline = pipelineGPU;
                // bind groups
                const currentBindingGroups = currentSets.bindingGroups;
                for (let i = 0, l = bindings.length; i < l; i++) {
                    const bindGroup = bindings[i];
                    const bindingsData = this.get(bindGroup);
                    if (currentBindingGroups[bindGroup.index] !== bindGroup.id) {
                        passEncoderGPU.setBindGroup(bindGroup.index, bindingsData.group);
                        currentBindingGroups[bindGroup.index] = bindGroup.id;
                    }
                }
                // attributes
                // index
                if (hasIndex === true) {
                    if (currentSets.index !== index) {
                        const buffer = this.get(index).buffer;
                        const indexFormat = (index.array instanceof Uint16Array) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
                        passEncoderGPU.setIndexBuffer(buffer, indexFormat);
                        currentSets.index = index;
                    }
                }
                // vertex buffers
                const vertexBuffers = renderObject.getVertexBuffers();
                for (let i = 0, l = vertexBuffers.length; i < l; i++) {
                    const vertexBuffer = vertexBuffers[i];
                    if (currentSets.attributes[i] !== vertexBuffer) {
                        const buffer = this.get(vertexBuffer).buffer;
                        passEncoderGPU.setVertexBuffer(i, buffer);
                        currentSets.attributes[i] = vertexBuffer;
                    }
                }
                // stencil
                if (context.stencil === true && material.stencilWrite === true && renderContextData.currentStencilRef !== material.stencilRef) {
                    passEncoderGPU.setStencilReference(material.stencilRef);
                    renderContextData.currentStencilRef = material.stencilRef;
                }

            };
            // Define draw function
            const draw = (passEncoderGPU, currentSets) => {
                setPipelineAndBindings(passEncoderGPU, currentSets);
                if (object.isBatchedMesh === true) {
                    const starts = object._multiDrawStarts;
                    const counts = object._multiDrawCounts;
                    const drawCount = object._multiDrawCount;
                    const drawInstances = object._multiDrawInstances;
                    if (drawInstances !== null) {
                        // @deprecated, r174
                        warnOnce('THREE.WebGPUBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.');
                    }
                    for (let i = 0; i < drawCount; i++) {
                        const count = drawInstances ? drawInstances[i] : 1;
                        const firstInstance = count > 1 ? 0 : i;
                        if (hasIndex === true) {
                            passEncoderGPU.drawIndexed(counts[i], count, starts[i] / index.array.BYTES_PER_ELEMENT, 0, firstInstance);
                        } else {
                            passEncoderGPU.draw(counts[i], count, starts[i], firstInstance);
                        }
                        info.update(object, counts[i], count);
                    }
                } else if (hasIndex === true) {
                    const { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParams;
                    const indirect = renderObject.getIndirect();
                    if (indirect !== null) {
                        const buffer = this.get(indirect).buffer;
                        passEncoderGPU.drawIndexedIndirect(buffer, 0);
                    } else {
                        passEncoderGPU.drawIndexed(indexCount, instanceCount, firstIndex, 0, 0);
                    }
                    info.update(object, indexCount, instanceCount);
                } else {
                    const { vertexCount, instanceCount, firstVertex } = drawParams;
                    const indirect = renderObject.getIndirect();
                    if (indirect !== null) {
                        const buffer = this.get(indirect).buffer;
                        passEncoderGPU.drawIndirect(buffer, 0);
                    } else {
                        passEncoderGPU.draw(vertexCount, instanceCount, firstVertex, 0);
                    }
                    info.update(object, vertexCount, instanceCount);
                }
            };
            if (renderObject.camera.isArrayCamera && renderObject.camera.cameras.length > 0) {
                const cameraData = this.get(renderObject.camera);
                const cameras = renderObject.camera.cameras;
                const cameraIndex = renderObject.getBindingGroup('cameraIndex');
                if (cameraData.indexesGPU === undefined || cameraData.indexesGPU.length !== cameras.length) {
                    const bindingsData = this.get(cameraIndex);
                    const indexesGPU = [];
                    const data = new Uint32Array([0, 0, 0, 0]);
                    for (let i = 0, len = cameras.length; i < len; i++) {
                        data[0] = i;
                        const bindGroupIndex = this.bindingUtils.createBindGroupIndex(data, bindingsData.layout);
                        indexesGPU.push(bindGroupIndex);
                    }
                    cameraData.indexesGPU = indexesGPU; // TODO: Create a global library for this
                }
                const pixelRatio = this.renderer.getPixelRatio();
                for (let i = 0, len = cameras.length; i < len; i++) {
                    const subCamera = cameras[i];
                    if (object.layers.test(subCamera.layers)) {
                        const vp = subCamera.viewport;

                        let pass = renderContextData.currentPass;
                        let sets = renderContextData.currentSets;
                        if (renderContextData.bundleEncoders) {
                            const bundleEncoder = renderContextData.bundleEncoders[i];
                            const bundleSets = renderContextData.bundleSets[i];
                            pass = bundleEncoder;
                            sets = bundleSets;
                        }

                        if (vp) {
                            pass.setViewport(
                                Math.floor(vp.x * pixelRatio),
                                Math.floor(vp.y * pixelRatio),
                                Math.floor(vp.width * pixelRatio),
                                Math.floor(vp.height * pixelRatio),
                                context.viewportValue.minDepth,
                                context.viewportValue.maxDepth
                            );
                        }

                        // Set camera index binding for this layer
                        if (cameraIndex && cameraData.indexesGPU) {
                            pass.setBindGroup(cameraIndex.index, cameraData.indexesGPU[i]);
                            sets.bindingGroups[cameraIndex.index] = cameraIndex.id;
                        }
                        draw(pass, sets);

                    }
                }
            } else {
                // Regular single camera rendering
                if (renderContextData.currentPass) {
                    // Handle occlusion queries
                    if (renderContextData.occlusionQuerySet !== undefined) {
                        const lastObject = renderContextData.lastOcclusionObject;
                        if (lastObject !== object) {
                            if (lastObject !== null && lastObject.occlusionTest === true) {
                                renderContextData.currentPass.endOcclusionQuery();
                                renderContextData.occlusionQueryIndex++;
                            }
                            if (object.occlusionTest === true) {
                                renderContextData.currentPass.beginOcclusionQuery(renderContextData.occlusionQueryIndex);
                                renderContextData.occlusionQueryObjects[renderContextData.occlusionQueryIndex] = object;
                            }
                            renderContextData.lastOcclusionObject = object;
                        }
                    }
                    draw(renderContextData.currentPass, renderContextData.currentSets);
                }
            }
        }
        // cache key
        needsRenderUpdate(renderObject) {
            const data = this.get(renderObject);
            const { object, material } = renderObject;
            const utils = this.utils;
            const sampleCount = utils.getSampleCountRenderContext(renderObject.context);
            const colorSpace = utils.getCurrentColorSpace(renderObject.context);
            const colorFormat = utils.getCurrentColorFormat(renderObject.context);
            const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);
            const primitiveTopology = utils.getPrimitiveTopology(object, material);
            let needsUpdate = false;
            if (data.material !== material || data.materialVersion !== material.version ||
                data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||
                data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||
                data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||
                data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||
                data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||
                data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||
                data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||
                data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage ||
                data.sampleCount !== sampleCount || data.colorSpace !== colorSpace ||
                data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat ||
                data.primitiveTopology !== primitiveTopology ||
                data.clippingContextCacheKey !== renderObject.clippingContextCacheKey
            ) {
                data.material = material; data.materialVersion = material.version;
                data.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;
                data.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;
                data.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;
                data.colorWrite = material.colorWrite;
                data.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;
                data.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;
                data.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;
                data.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;
                data.side = material.side; data.alphaToCoverage = material.alphaToCoverage;
                data.sampleCount = sampleCount;
                data.colorSpace = colorSpace;
                data.colorFormat = colorFormat;
                data.depthStencilFormat = depthStencilFormat;
                data.primitiveTopology = primitiveTopology;
                data.clippingContextCacheKey = renderObject.clippingContextCacheKey;
                needsUpdate = true;
            }
            return needsUpdate;
        }
        getRenderCacheKey(renderObject) {
            const { object, material } = renderObject;
            const utils = this.utils;
            const renderContext = renderObject.context;
            return [
                material.transparent, material.blending, material.premultipliedAlpha,
                material.blendSrc, material.blendDst, material.blendEquation,
                material.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,
                material.colorWrite,
                material.depthWrite, material.depthTest, material.depthFunc,
                material.stencilWrite, material.stencilFunc,
                material.stencilFail, material.stencilZFail, material.stencilZPass,
                material.stencilFuncMask, material.stencilWriteMask,
                material.side,
                utils.getSampleCountRenderContext(renderContext),
                utils.getCurrentColorSpace(renderContext), utils.getCurrentColorFormat(renderContext), utils.getCurrentDepthStencilFormat(renderContext),
                utils.getPrimitiveTopology(object, material),
                renderObject.getGeometryCacheKey(),
                renderObject.clippingContextCacheKey
            ].join();
        }
        // textures
        createSampler(texture) {
            this.textureUtils.createSampler(texture);
        }
        destroySampler(texture) {
            this.textureUtils.destroySampler(texture);
        }
        createDefaultTexture(texture) {
            this.textureUtils.createDefaultTexture(texture);
        }
        createTexture(texture, options) {
            this.textureUtils.createTexture(texture, options);
        }
        updateTexture(texture, options) {
            this.textureUtils.updateTexture(texture, options);
        }
        generateMipmaps(texture) {
            this.textureUtils.generateMipmaps(texture);
        }
        destroyTexture(texture) {
            this.textureUtils.destroyTexture(texture);
        }
        async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {
            return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);
        }
        initTimestampQuery(renderContext, descriptor) {
            if (!this.trackTimestamp) return;
            const type = renderContext.isComputeNode ? 'compute' : 'render';
            if (!this.timestampQueryPool[type]) {
                // TODO: Variable maxQueries?
                this.timestampQueryPool[type] = new WebGPUTimestampQueryPool(this.device, type, 2048);
            }
            const timestampQueryPool = this.timestampQueryPool[type];
            const baseOffset = timestampQueryPool.allocateQueriesForContext(renderContext);
            descriptor.timestampWrites = {
                querySet: timestampQueryPool.querySet,
                beginningOfPassWriteIndex: baseOffset,
                endOfPassWriteIndex: baseOffset + 1,
            };
        }

        // node builder
        createNodeBuilder(object, renderer) {
            return new WGSLNodeBuilder(object, renderer);
        }
        // program
        createProgram(program) {
            const programGPU = this.get(program);
            programGPU.module = {
                module: this.device.createShaderModule({ code: program.code, label: program.stage + (program.name !== '' ? `_${program.name}` : '') }),
                entryPoint: 'main'
            };
        }
        destroyProgram(program) {
            this.delete(program);
        }
        // pipelines
        createRenderPipeline(renderObject, promises) {
            this.pipelineUtils.createRenderPipeline(renderObject, promises);
        }
        createComputePipeline(computePipeline, bindings) {
            this.pipelineUtils.createComputePipeline(computePipeline, bindings);
        }
        beginBundle(renderContext) {
            const renderContextData = this.get(renderContext);
            renderContextData._currentPass = renderContextData.currentPass;
            renderContextData._currentSets = renderContextData.currentSets;
            renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
            renderContextData.currentPass = this.pipelineUtils.createBundleEncoder(renderContext);
        }
        finishBundle(renderContext, bundle) {
            const renderContextData = this.get(renderContext);
            const bundleEncoder = renderContextData.currentPass;
            const bundleGPU = bundleEncoder.finish();
            this.get(bundle).bundleGPU = bundleGPU;
            // restore render pass state
            renderContextData.currentSets = renderContextData._currentSets;
            renderContextData.currentPass = renderContextData._currentPass;
        }
        addBundle(renderContext, bundle) {
            const renderContextData = this.get(renderContext);
            renderContextData.renderBundles.push(this.get(bundle).bundleGPU);
        }
        // bindings
        createBindings(bindGroup, bindings, cacheIndex, version) {
            this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);
        }
        updateBindings(bindGroup, bindings, cacheIndex, version) {
            this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);
        }
        updateBinding(binding) {
            this.bindingUtils.updateBinding(binding);
        }
        // attributes
        createIndexAttribute(attribute) {
            let usage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;
            if (attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute) {
                usage |= GPUBufferUsage.STORAGE;
            }
            this.attributeUtils.createAttribute(attribute, usage);
        }
        createAttribute(attribute) {
            this.attributeUtils.createAttribute(attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
        }
        createStorageAttribute(attribute) {
            this.attributeUtils.createAttribute(attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
        }
        createIndirectStorageAttribute(attribute) {
            this.attributeUtils.createAttribute(attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
        }
        updateAttribute(attribute) {
            this.attributeUtils.updateAttribute(attribute);
        }
        destroyAttribute(attribute) {
            this.attributeUtils.destroyAttribute(attribute);
        }
        // canvas
        updateSize() {
            this.colorBuffer = this.textureUtils.getColorBuffer();
            this.defaultRenderPassdescriptor = null;
        }
        // utils public
        getMaxAnisotropy() {
            return 16;
        }
        hasFeature(name) {
            return this.device.features.has(name);
        }
        copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
            let dstX = 0;
            let dstY = 0;
            let dstZ = 0;
            let srcX = 0;
            let srcY = 0;
            let srcZ = 0;
            let srcWidth = srcTexture.image.width;
            let srcHeight = srcTexture.image.height;
            let srcDepth = 1;

            if (srcRegion !== null) {
                if (srcRegion.isBox3 === true) {
                    srcX = srcRegion.min.x;
                    srcY = srcRegion.min.y;
                    srcZ = srcRegion.min.z;
                    srcWidth = srcRegion.max.x - srcRegion.min.x;
                    srcHeight = srcRegion.max.y - srcRegion.min.y;
                    srcDepth = srcRegion.max.z - srcRegion.min.z;
                } else {
                    // Assume it's a Box2
                    srcX = srcRegion.min.x;
                    srcY = srcRegion.min.y;
                    srcWidth = srcRegion.max.x - srcRegion.min.x;
                    srcHeight = srcRegion.max.y - srcRegion.min.y;
                    srcDepth = 1;
                }
            }

            if (dstPosition !== null) {
                dstX = dstPosition.x;
                dstY = dstPosition.y;
                dstZ = dstPosition.z || 0;
            }
            const encoder = this.device.createCommandEncoder({ label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id });
            const sourceGPU = this.get(srcTexture).texture;
            const destinationGPU = this.get(dstTexture).texture;
            encoder.copyTextureToTexture(
                {
                    texture: sourceGPU,
                    mipLevel: srcLevel,
                    origin: { x: srcX, y: srcY, z: srcZ }
                },
                {
                    texture: destinationGPU,
                    mipLevel: dstLevel,
                    origin: { x: dstX, y: dstY, z: dstZ }
                },
                [
                    srcWidth,
                    srcHeight,
                    srcDepth
                ]
            );
            this.device.queue.submit([encoder.finish()]);
            if (dstLevel === 0 && dstTexture.generateMipmaps) {
                this.textureUtils.generateMipmaps(dstTexture);
            }
        }
        copyFramebufferToTexture(texture, renderContext, rectangle) {
            const renderContextData = this.get(renderContext);
            let sourceGPU = null;
            if (renderContext.renderTarget) {
                if (texture.isDepthTexture) {
                    sourceGPU = this.get(renderContext.depthTexture).texture;
                } else {
                    sourceGPU = this.get(renderContext.textures[0]).texture;
                }
            } else {
                if (texture.isDepthTexture) {
                    sourceGPU = this.textureUtils.getDepthBuffer(renderContext.depth, renderContext.stencil);
                } else {
                    sourceGPU = this.context.getCurrentTexture();
                }
            }
            const destinationGPU = this.get(texture).texture;
            if (sourceGPU.format !== destinationGPU.format) {
                console.error('WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format);
                return;
            }
            let encoder;
            if (renderContextData.currentPass) {
                renderContextData.currentPass.end();
                encoder = renderContextData.encoder;
            } else {
                encoder = this.device.createCommandEncoder({ label: 'copyFramebufferToTexture_' + texture.id });
            }
            encoder.copyTextureToTexture(
                {
                    texture: sourceGPU,
                    origin: [rectangle.x, rectangle.y, 0],
                },
                {
                    texture: destinationGPU
                },
                [
                    rectangle.z,
                    rectangle.w
                ]
            );
            if (renderContextData.currentPass) {
                const { descriptor } = renderContextData;
                for (let i = 0; i < descriptor.colorAttachments.length; i++) {
                    descriptor.colorAttachments[i].loadOp = GPULoadOp.Load;
                }
                if (renderContext.depth) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
                if (renderContext.stencil) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
                renderContextData.currentPass = encoder.beginRenderPass(descriptor);
                renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
                if (renderContext.viewport) {
                    this.updateViewport(renderContext);
                }
                if (renderContext.scissor) {
                    const { x, y, width, height } = renderContext.scissorValue;
                    renderContextData.currentPass.setScissorRect(x, y, width, height);
                }
            } else {
                this.device.queue.submit([encoder.finish()]);
            }
            if (texture.generateMipmaps) {
                this.textureUtils.generateMipmaps(texture);
            }
        }
    }
    class IESSpotLight extends SpotLight {
        constructor(color, intensity, distance, angle, penumbra, decay) {
            super(color, intensity, distance, angle, penumbra, decay);
            this.iesMap = null;
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.iesMap = source.iesMap;
            return this;
        }
    }
    class ProjectorLight extends SpotLight {
        constructor(color, intensity, distance, angle, penumbra, decay) {
            super(color, intensity, distance, angle, penumbra, decay);
            this.aspect = null;
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.aspect = source.aspect;
            return this;
        }
    }
    class StandardNodeLibrary extends NodeLibrary {
        constructor() {
            super();
            this.addMaterial(MeshPhongNodeMaterial, 'MeshPhongMaterial');
            this.addMaterial(MeshStandardNodeMaterial, 'MeshStandardMaterial');
            this.addMaterial(MeshPhysicalNodeMaterial, 'MeshPhysicalMaterial');
            this.addMaterial(MeshToonNodeMaterial, 'MeshToonMaterial');
            this.addMaterial(MeshBasicNodeMaterial, 'MeshBasicMaterial');
            this.addMaterial(MeshLambertNodeMaterial, 'MeshLambertMaterial');
            this.addMaterial(MeshNormalNodeMaterial, 'MeshNormalMaterial');
            this.addMaterial(MeshMatcapNodeMaterial, 'MeshMatcapMaterial');
            this.addMaterial(LineBasicNodeMaterial, 'LineBasicMaterial');
            this.addMaterial(LineDashedNodeMaterial, 'LineDashedMaterial');
            this.addMaterial(PointsNodeMaterial, 'PointsMaterial');
            this.addMaterial(SpriteNodeMaterial, 'SpriteMaterial');
            this.addMaterial(ShadowNodeMaterial, 'ShadowMaterial');
            this.addLight(PointLightNode, PointLight);
            this.addLight(DirectionalLightNode, DirectionalLight);
            this.addLight(RectAreaLightNode, RectAreaLight);
            this.addLight(SpotLightNode, SpotLight);
            this.addLight(AmbientLightNode, AmbientLight);
            this.addLight(HemisphereLightNode, HemisphereLight);
            this.addLight(LightProbeNode, LightProbe);
            this.addLight(IESSpotLightNode, IESSpotLight);
            this.addLight(ProjectorLightNode, ProjectorLight);
            this.addToneMapping(linearToneMapping, LinearToneMapping);
            this.addToneMapping(reinhardToneMapping, ReinhardToneMapping);
            this.addToneMapping(cineonToneMapping, CineonToneMapping);
            this.addToneMapping(acesFilmicToneMapping, ACESFilmicToneMapping);
            this.addToneMapping(agxToneMapping, AgXToneMapping);
            this.addToneMapping(neutralToneMapping, NeutralToneMapping);
        }
    }
    /*
    const debugHandler = {
        get: function ( target, name ) {
            // Add |update
            if ( /^(create|destroy)/.test( name ) ) console.log( 'WebGPUBackend.' + name );
            return target[ name ];
        }
    };
    */
    class WebGPURenderer extends Renderer {

        constructor(parameters = {}) {
            let BackendClass;
            if (parameters.forceWebGL) {
                BackendClass = WebGLBackend;
            } else {
                BackendClass = WebGPUBackend;
                parameters.getFallback = () => {
                    console.warn('THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.');
                    return new WebGLBackend(parameters);
                };
            }
            const backend = new BackendClass(parameters);
            //super( new Proxy( backend, debugHandler ) );
            super(backend, parameters);
            this.library = new StandardNodeLibrary();
            this.isWebGPURenderer = true;
            if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
                __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
            }
        }
    }
    class BundleGroup extends Group {
        constructor() {
            super();
            this.isBundleGroup = true;
            this.type = 'BundleGroup';
            this.static = true;
            this.version = 0;
        }
        set needsUpdate(value) {
            if (value === true) this.version++;
        }
    }
    class PostProcessing {
        constructor(renderer, outputNode = vec4(0, 0, 1, 1)) {
            this.renderer = renderer;
            this.outputNode = outputNode;
            this.outputColorTransform = true;
            this.needsUpdate = true;
            const material = new NodeMaterial();
            material.name = 'PostProcessing';
            this._quadMesh = new QuadMesh(material);
            this._context = null;
        }
        render() {
            const renderer = this.renderer;
            this._update();
            if (this._context.onBeforePostProcessing !== null) this._context.onBeforePostProcessing();
            const toneMapping = renderer.toneMapping;
            const outputColorSpace = renderer.outputColorSpace;
            renderer.toneMapping = NoToneMapping;
            renderer.outputColorSpace = ColorManagement.workingColorSpace;
            //
            const currentXR = renderer.xr.enabled;
            renderer.xr.enabled = false;
            this._quadMesh.render(renderer);
            renderer.xr.enabled = currentXR;
            //
            renderer.toneMapping = toneMapping;
            renderer.outputColorSpace = outputColorSpace;
            if (this._context.onAfterPostProcessing !== null) this._context.onAfterPostProcessing();
        }
        get context() {
            return this._context;
        }
        dispose() {
            this._quadMesh.material.dispose();
        }
        _update() {
            if (this.needsUpdate === true) {
                const renderer = this.renderer;
                const toneMapping = renderer.toneMapping;
                const outputColorSpace = renderer.outputColorSpace;
                const context = {
                    postProcessing: this,
                    onBeforePostProcessing: null,
                    onAfterPostProcessing: null
                };
                let outputNode = this.outputNode;
                if (this.outputColorTransform === true) {
                    outputNode = outputNode.context(context);
                    outputNode = renderOutput(outputNode, toneMapping, outputColorSpace);
                } else {
                    context.toneMapping = toneMapping;
                    context.outputColorSpace = outputColorSpace;
                    outputNode = outputNode.context(context);
                }
                this._context = context;
                this._quadMesh.material.fragmentNode = outputNode;
                this._quadMesh.material.needsUpdate = true;
                this.needsUpdate = false;
            }
        }
        async renderAsync() {
            this._update();
            if (this._context.onBeforePostProcessing !== null) this._context.onBeforePostProcessing();
            const renderer = this.renderer;
            const toneMapping = renderer.toneMapping;
            const outputColorSpace = renderer.outputColorSpace;
            renderer.toneMapping = NoToneMapping;
            renderer.outputColorSpace = ColorManagement.workingColorSpace;
            //
            const currentXR = renderer.xr.enabled;
            renderer.xr.enabled = false;
            await this._quadMesh.renderAsync(renderer);
            renderer.xr.enabled = currentXR;
            //
            renderer.toneMapping = toneMapping;
            renderer.outputColorSpace = outputColorSpace;
            if (this._context.onAfterPostProcessing !== null) this._context.onAfterPostProcessing();
        }
    }
    class StorageTexture extends Texture {
        constructor(width = 1, height = 1) {
            super();
            this.image = { width, height };
            this.magFilter = LinearFilter;
            this.minFilter = LinearFilter;
            this.isStorageTexture = true;
        }
        setSize(width, height) {
            if (this.image.width !== width || this.image.height !== height) {
                this.image.width = width;
                this.image.height = height;
                this.dispose();
            }
        }
    }
    class Storage3DTexture extends Texture {
        constructor(width = 1, height = 1, depth = 1) {
            super();
            //inherited from texture. Must be false for 3DTexture
            this.isArrayTexture = false;
            this.image = { width, height, depth };
            this.magFilter = LinearFilter;
            this.minFilter = LinearFilter;
            this.wrapR = ClampToEdgeWrapping;
            this.isStorageTexture = true;
            this.is3DTexture = true;
        }
        setSize(width, height, depth) {
            if (this.image.width !== width || this.image.height !== height || this.image.depth !== depth) {
                this.image.width = width;
                this.image.height = height;
                this.image.depth = depth;
                this.dispose();
            }
        }
    }
    class StorageArrayTexture extends Texture {
        constructor(width = 1, height = 1, depth = 1) {
            super();
            //inherited from texture
            this.isArrayTexture = true;
            this.image = { width, height, depth };
            this.magFilter = LinearFilter;
            this.minFilter = LinearFilter;
            this.isStorageTexture = true;
        }
        setSize(width, height, depth) {
            if (this.image.width !== width || this.image.height !== height || this.image.depth !== depth) {
                this.image.width = width;
                this.image.height = height;
                this.image.depth = depth;
                this.dispose();
            }
        }
    }
    class IndirectStorageBufferAttribute extends StorageBufferAttribute {
        constructor(count, itemSize) {
            super(count, itemSize, Uint32Array);
            this.isIndirectStorageBufferAttribute = true;
        }
    }
    class NodeLoader extends Loader {
        constructor(manager) {
            super(manager);
            this.textures = {};
            this.nodes = {};
        }
        load(url, onLoad, onProgress, onError) {
            const loader = new FileLoader(this.manager);
            loader.setPath(this.path);
            loader.setRequestHeader(this.requestHeader);
            loader.setWithCredentials(this.withCredentials);
            loader.load(url, (text) => {
                try {
                    onLoad(this.parse(JSON.parse(text)));
                } catch (e) {
                    if (onError) {
                        onError(e);
                    } else {
                        console.error(e);
                    }
                    this.manager.itemError(url);
                }
            }, onProgress, onError);
        }
        parseNodes(json) {
            const nodes = {};
            if (json !== undefined) {
                for (const nodeJSON of json) {
                    const { uuid, type } = nodeJSON;
                    nodes[uuid] = this.createNodeFromType(type);
                    nodes[uuid].uuid = uuid;
                }
                const meta = { nodes, textures: this.textures };
                for (const nodeJSON of json) {
                    nodeJSON.meta = meta;
                    const node = nodes[nodeJSON.uuid];
                    node.deserialize(nodeJSON);
                    delete nodeJSON.meta;
                }
            }
            return nodes;
        }
        parse(json) {
            const node = this.createNodeFromType(json.type);
            node.uuid = json.uuid;
            const nodes = this.parseNodes(json.nodes);
            const meta = { nodes, textures: this.textures };
            json.meta = meta;
            node.deserialize(json);
            delete json.meta;
            return node;
        }
        setTextures(value) {
            this.textures = value;
            return this;
        }
        setNodes(value) {
            this.nodes = value;
            return this;
        }
        createNodeFromType(type) {
            if (this.nodes[type] === undefined) {
                console.error('THREE.NodeLoader: Node type not found:', type);
                return float();
            }
            return nodeObject(new this.nodes[type]());
        }
    }
    class NodeMaterialLoader extends MaterialLoader {
        constructor(manager) {
            super(manager);
            this.nodes = {};
            this.nodeMaterials = {};
        }
        parse(json) {
            const material = super.parse(json);
            const nodes = this.nodes;
            const inputNodes = json.inputNodes;
            for (const property in inputNodes) {
                const uuid = inputNodes[property];
                material[property] = nodes[uuid];
            }
            return material;
        }
        setNodes(value) {
            this.nodes = value;
            return this;
        }
        setNodeMaterials(value) {
            this.nodeMaterials = value;
            return this;
        }
        createMaterialFromType(type) {
            const materialClass = this.nodeMaterials[type];
            if (materialClass !== undefined) {
                return new materialClass();
            }
            return super.createMaterialFromType(type);
        }
    }
    class NodeObjectLoader extends ObjectLoader {
        constructor(manager) {
            super(manager);
            this.nodes = {};
            this.nodeMaterials = {};
            this._nodesJSON = null;
        }
        setNodes(value) {
            this.nodes = value;
            return this;
        }
        setNodeMaterials(value) {
            this.nodeMaterials = value;
            return this;
        }
        parse(json, onLoad) {
            this._nodesJSON = json.nodes;
            const data = super.parse(json, onLoad);
            this._nodesJSON = null; // dispose
            return data;
        }
        parseNodes(json, textures) {
            if (json !== undefined) {
                const loader = new NodeLoader();
                loader.setNodes(this.nodes);
                loader.setTextures(textures);
                return loader.parseNodes(json);
            }
            return {};
        }
        parseMaterials(json, textures) {
            const materials = {};
            if (json !== undefined) {
                const nodes = this.parseNodes(this._nodesJSON, textures);
                const loader = new NodeMaterialLoader();
                loader.setTextures(textures);
                loader.setNodes(nodes);
                loader.setNodeMaterials(this.nodeMaterials);
                for (let i = 0, l = json.length; i < l; i++) {
                    const data = json[i];
                    materials[data.uuid] = loader.parse(data);
                }
            }
            return materials;
        }
    }
    class ClippingGroup extends Group {
        constructor() {
            super();
            this.isClippingGroup = true;
            this.clippingPlanes = [];
            this.enabled = true;
            this.clipIntersection = false;
            this.clipShadows = false;
        }
    }


    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
            detail: {
                revision: REVISION,
            }
        }));
    }
    if (typeof window !== 'undefined') {
        if (window.__THREE__) {
            console.warn('WARNING: Multiple instances of Three.js being imported.');
        } else {
            window.__THREE__ = REVISION;
        }
    }


    window.ACESFilmicToneMapping = ACESFilmicToneMapping;
    window.AddEquation = AddEquation;
    window.AddOperation = AddOperation;
    window.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
    window.AdditiveBlending = AdditiveBlending;
    window.AlphaFormat = AlphaFormat;
    window.AlwaysDepth = AlwaysDepth;
    window.AlwaysStencilFunc = AlwaysStencilFunc;
    window.AmbientLight = AmbientLight;
    window.AnimationClip = AnimationClip;
    window.AnimationLoader = AnimationLoader;
    window.AnimationMixer = AnimationMixer;
    window.AnimationObjectGroup = AnimationObjectGroup;
    window.AnimationUtils = AnimationUtils;
    window.ArcCurve = ArcCurve;
    window.ArrayCamera = ArrayCamera;
    window.ArrowHelper = ArrowHelper;
    window.Audio = Audio;
    window.AudioAnalyser = AudioAnalyser;
    window.AudioContext = AudioContext;
    window.AudioListener = AudioListener;
    window.AudioLoader = AudioLoader;
    window.AxesHelper = AxesHelper;
    window.BackSide = BackSide;
    window.BasicDepthPacking = BasicDepthPacking;
    window.BasicShadowMap = BasicShadowMap;
    window.Bone = Bone;
    window.BooleanKeyframeTrack = BooleanKeyframeTrack;
    window.Box2 = Box2;
    window.Box3 = Box3;
    window.Box3Helper = Box3Helper;
    window.BoxGeometry = BoxGeometry;
    window.BoxHelper = BoxHelper;
    window.BufferAttribute = BufferAttribute;
    window.BufferGeometry = BufferGeometry;
    window.BufferGeometryLoader = BufferGeometryLoader;
    window.ByteType = ByteType;
    window.Cache = Cache;
    window.Camera = Camera;
    window.CameraHelper = CameraHelper;
    window.CanvasTexture = CanvasTexture;
    window.CapsuleGeometry = CapsuleGeometry;
    window.CatmullRomCurve3 = CatmullRomCurve3;
    window.CineonToneMapping = CineonToneMapping;
    window.CircleGeometry = CircleGeometry;
    window.ClampToEdgeWrapping = ClampToEdgeWrapping;
    window.Clock = Clock;
    window.Color = Color;
    window.ColorKeyframeTrack = ColorKeyframeTrack;
    window.ColorManagement = ColorManagement;
    window.CompressedArrayTexture = CompressedArrayTexture;
    window.CompressedTexture = CompressedTexture;
    window.CompressedTextureLoader = CompressedTextureLoader;
    window.ConeGeometry = ConeGeometry;
    window.CubeCamera = CubeCamera;
    window.CubeReflectionMapping = CubeReflectionMapping;
    window.CubeRefractionMapping = CubeRefractionMapping;
    window.CubeTexture = CubeTexture;
    window.CubeTextureLoader = CubeTextureLoader;
    window.CubeUVReflectionMapping = CubeUVReflectionMapping;
    window.CubicBezierCurve = CubicBezierCurve;
    window.CubicBezierCurve3 = CubicBezierCurve3;
    window.CubicInterpolant = CubicInterpolant;
    window.CullFaceBack = CullFaceBack;
    window.CullFaceFront = CullFaceFront;
    window.CullFaceFrontBack = CullFaceFrontBack;
    window.CullFaceNone = CullFaceNone;
    window.Curve = Curve;
    window.CurvePath = CurvePath;
    window.CustomBlending = CustomBlending;
    window.CustomToneMapping = CustomToneMapping;
    window.CylinderGeometry = CylinderGeometry;
    window.Cylindrical = Cylindrical;
    window.Data3DTexture = Data3DTexture;
    window.DataArrayTexture = DataArrayTexture;
    window.DataTexture = DataTexture;
    window.DataTextureLoader = DataTextureLoader;
    window.DataUtils = DataUtils;
    window.DecrementStencilOp = DecrementStencilOp;
    window.DecrementWrapStencilOp = DecrementWrapStencilOp;
    window.DefaultLoadingManager = DefaultLoadingManager;
    window.DepthFormat = DepthFormat;
    window.DepthStencilFormat = DepthStencilFormat;
    window.DepthTexture = DepthTexture;
    window.DirectionalLight = DirectionalLight;
    window.DirectionalLightHelper = DirectionalLightHelper;
    window.DiscreteInterpolant = DiscreteInterpolant;
    window.DodecahedronGeometry = DodecahedronGeometry;
    window.DoubleSide = DoubleSide;
    window.DstAlphaFactor = DstAlphaFactor;
    window.DstColorFactor = DstColorFactor;
    window.DynamicCopyUsage = DynamicCopyUsage;
    window.DynamicDrawUsage = DynamicDrawUsage;
    window.DynamicReadUsage = DynamicReadUsage;
    window.EdgesGeometry = EdgesGeometry;
    window.EllipseCurve = EllipseCurve;
    window.EqualDepth = EqualDepth;
    window.EqualStencilFunc = EqualStencilFunc;
    window.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
    window.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
    window.Euler = Euler;
    window.EventDispatcher = EventDispatcher;
    window.ExtrudeGeometry = ExtrudeGeometry;
    window.FileLoader = FileLoader;
    window.Float16BufferAttribute = Float16BufferAttribute;
    window.Float32BufferAttribute = Float32BufferAttribute;
    window.FloatType = FloatType;
    window.Fog = Fog;
    window.FogExp2 = FogExp2;
    window.FramebufferTexture = FramebufferTexture;
    window.FrontSide = FrontSide;
    window.Frustum = Frustum;
    window.GLBufferAttribute = GLBufferAttribute;
    window.GLSL1 = GLSL1;
    window.GLSL3 = GLSL3;
    window.GreaterDepth = GreaterDepth;
    window.GreaterEqualDepth = GreaterEqualDepth;
    window.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
    window.GreaterStencilFunc = GreaterStencilFunc;
    window.GridHelper = GridHelper;
    window.Group = Group;
    window.HalfFloatType = HalfFloatType;
    window.HemisphereLight = HemisphereLight;
    window.HemisphereLightHelper = HemisphereLightHelper;
    window.IcosahedronGeometry = IcosahedronGeometry;
    window.ImageBitmapLoader = ImageBitmapLoader;
    window.ImageLoader = ImageLoader;
    window.ImageUtils = ImageUtils;
    window.IncrementStencilOp = IncrementStencilOp;
    window.IncrementWrapStencilOp = IncrementWrapStencilOp;
    window.InstancedBufferAttribute = InstancedBufferAttribute;
    window.InstancedBufferGeometry = InstancedBufferGeometry;
    window.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
    window.InstancedMesh = InstancedMesh;
    window.Int16BufferAttribute = Int16BufferAttribute;
    window.Int32BufferAttribute = Int32BufferAttribute;
    window.Int8BufferAttribute = Int8BufferAttribute;
    window.IntType = IntType;
    window.InterleavedBuffer = InterleavedBuffer;
    window.InterleavedBufferAttribute = InterleavedBufferAttribute;
    window.Interpolant = Interpolant;
    window.InterpolateDiscrete = InterpolateDiscrete;
    window.InterpolateLinear = InterpolateLinear;
    window.InterpolateSmooth = InterpolateSmooth;
    window.InvertStencilOp = InvertStencilOp;
    window.KeepStencilOp = KeepStencilOp;
    window.KeyframeTrack = KeyframeTrack;
    window.LOD = LOD;
    window.LatheGeometry = LatheGeometry;
    window.Layers = Layers;
    window.LessDepth = LessDepth;
    window.LessEqualDepth = LessEqualDepth;
    window.LessEqualStencilFunc = LessEqualStencilFunc;
    window.LessStencilFunc = LessStencilFunc;
    window.Light = Light;
    window.LightProbe = LightProbe;
    window.Line = Line;
    window.Line3 = Line3;
    window.LineBasicMaterial = LineBasicMaterial;
    window.LineCurve = LineCurve;
    window.LineCurve3 = LineCurve3;
    window.LineDashedMaterial = LineDashedMaterial;
    window.LineLoop = LineLoop;
    window.LineSegments = LineSegments;
    window.LinearFilter = LinearFilter;
    window.LinearInterpolant = LinearInterpolant;
    window.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
    window.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
    window.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
    window.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
    window.LinearSRGBColorSpace = LinearSRGBColorSpace;
    window.LinearToneMapping = LinearToneMapping;
    window.Loader = Loader;
    window.LoaderUtils = LoaderUtils;
    window.LoadingManager = LoadingManager;
    window.LoopOnce = LoopOnce;
    window.LoopPingPong = LoopPingPong;
    window.LoopRepeat = LoopRepeat;
    window.LuminanceAlphaFormat = LuminanceAlphaFormat;
    window.LuminanceFormat = LuminanceFormat;
    window.MOUSE = MOUSE;
    window.Material = Material;
    window.MaterialLoader = MaterialLoader;
    window.MathUtils = MathUtils;
    window.Matrix3 = Matrix3;
    window.Matrix4 = Matrix4;
    window.MaxEquation = MaxEquation;
    window.Mesh = Mesh;
    window.MeshBasicMaterial = MeshBasicMaterial;
    window.MeshDepthMaterial = MeshDepthMaterial;
    window.MeshDistanceMaterial = MeshDistanceMaterial;
    window.MeshLambertMaterial = MeshLambertMaterial;
    window.MeshMatcapMaterial = MeshMatcapMaterial;
    window.MeshNormalMaterial = MeshNormalMaterial;
    window.MeshPhongMaterial = MeshPhongMaterial;
    window.MeshPhysicalMaterial = MeshPhysicalMaterial;
    window.MeshStandardMaterial = MeshStandardMaterial;
    window.MeshToonMaterial = MeshToonMaterial;
    window.MinEquation = MinEquation;
    window.MirroredRepeatWrapping = MirroredRepeatWrapping;
    window.MixOperation = MixOperation;
    window.MultiplyBlending = MultiplyBlending;
    window.MultiplyOperation = MultiplyOperation;
    window.NearestFilter = NearestFilter;
    window.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
    window.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
    window.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
    window.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
    window.NeverDepth = NeverDepth;
    window.NeverStencilFunc = NeverStencilFunc;
    window.NoBlending = NoBlending;
    window.NoColorSpace = NoColorSpace;
    window.NoToneMapping = NoToneMapping;
    window.NormalAnimationBlendMode = NormalAnimationBlendMode;
    window.NormalBlending = NormalBlending;
    window.NotEqualDepth = NotEqualDepth;
    window.NotEqualStencilFunc = NotEqualStencilFunc;
    window.NumberKeyframeTrack = NumberKeyframeTrack;
    window.Object3D = Object3D;
    window.ObjectLoader = ObjectLoader;
    window.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
    window.OctahedronGeometry = OctahedronGeometry;
    window.OneFactor = OneFactor;
    window.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
    window.OneMinusDstColorFactor = OneMinusDstColorFactor;
    window.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
    window.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
    window.OrthographicCamera = OrthographicCamera;
    window.PCFShadowMap = PCFShadowMap;
    window.PCFSoftShadowMap = PCFSoftShadowMap;
    window.PMREMGenerator = PMREMGenerator;
    window.Path = Path;
    window.PerspectiveCamera = PerspectiveCamera;
    window.Plane = Plane;
    window.PlaneGeometry = PlaneGeometry;
    window.PlaneHelper = PlaneHelper;
    window.PointLight = PointLight;
    window.PointLightHelper = PointLightHelper;
    window.Points = Points;
    window.PointsMaterial = PointsMaterial;
    window.PolarGridHelper = PolarGridHelper;
    window.PolyhedronGeometry = PolyhedronGeometry;
    window.PositionalAudio = PositionalAudio;
    window.PropertyBinding = PropertyBinding;
    window.PropertyMixer = PropertyMixer;
    window.QuadraticBezierCurve = QuadraticBezierCurve;
    window.QuadraticBezierCurve3 = QuadraticBezierCurve3;
    window.Quaternion = Quaternion;
    window.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
    window.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
    window.RED_GREEN_RGTC2_Format = RED_GREEN_RGTC2_Format;
    window.RED_RGTC1_Format = RED_RGTC1_Format;
    window.REVISION = REVISION;
    window.RGBADepthPacking = RGBADepthPacking;
    window.RGBAFormat = RGBAFormat;
    window.RGBAIntegerFormat = RGBAIntegerFormat;
    window.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
    window.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
    window.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
    window.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
    window.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
    window.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
    window.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
    window.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
    window.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
    window.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
    window.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
    window.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
    window.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
    window.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
    window.RGBA_BPTC_Format = RGBA_BPTC_Format;
    window.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
    window.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
    window.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
    window.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
    window.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
    window.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
    window.RGB_ETC1_Format = RGB_ETC1_Format;
    window.RGB_ETC2_Format = RGB_ETC2_Format;
    window.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
    window.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
    window.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
    window.RGFormat = RGFormat;
    window.RGIntegerFormat = RGIntegerFormat;
    window.RawShaderMaterial = RawShaderMaterial;
    window.Ray = Ray;
    window.Raycaster = Raycaster;
    window.RectAreaLight = RectAreaLight;
    window.RedFormat = RedFormat;
    window.RedIntegerFormat = RedIntegerFormat;
    window.ReinhardToneMapping = ReinhardToneMapping;
    window.RepeatWrapping = RepeatWrapping;
    window.ReplaceStencilOp = ReplaceStencilOp;
    window.ReverseSubtractEquation = ReverseSubtractEquation;
    window.RingGeometry = RingGeometry;
    window.SIGNED_RED_GREEN_RGTC2_Format = SIGNED_RED_GREEN_RGTC2_Format;
    window.SIGNED_RED_RGTC1_Format = SIGNED_RED_RGTC1_Format;
    window.SRGBColorSpace = SRGBColorSpace;
    window.Scene = Scene;
    window.ShaderMaterial = ShaderMaterial;
    window.ShadowMaterial = ShadowMaterial;
    window.Shape = Shape;
    window.ShapeGeometry = ShapeGeometry;
    window.ShapePath = ShapePath;
    window.ShapeUtils = ShapeUtils;
    window.ShortType = ShortType;
    window.Skeleton = Skeleton;
    window.SkeletonHelper = SkeletonHelper;
    window.SkinnedMesh = SkinnedMesh;
    window.Source = Source;
    window.Sphere = Sphere;
    window.SphereGeometry = SphereGeometry;
    window.Spherical = Spherical;
    window.SphericalHarmonics3 = SphericalHarmonics3;
    window.SplineCurve = SplineCurve;
    window.SpotLight = SpotLight;
    window.SpotLightHelper = SpotLightHelper;
    window.Sprite = Sprite;
    window.SpriteMaterial = SpriteMaterial;
    window.SrcAlphaFactor = SrcAlphaFactor;
    window.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
    window.SrcColorFactor = SrcColorFactor;
    window.StaticCopyUsage = StaticCopyUsage;
    window.StaticDrawUsage = StaticDrawUsage;
    window.StaticReadUsage = StaticReadUsage;
    window.StereoCamera = StereoCamera;
    window.StreamCopyUsage = StreamCopyUsage;
    window.StreamDrawUsage = StreamDrawUsage;
    window.StreamReadUsage = StreamReadUsage;
    window.StringKeyframeTrack = StringKeyframeTrack;
    window.SubtractEquation = SubtractEquation;
    window.SubtractiveBlending = SubtractiveBlending;
    window.TOUCH = TOUCH;
    window.TangentSpaceNormalMap = TangentSpaceNormalMap;
    window.TetrahedronGeometry = TetrahedronGeometry;
    window.Texture = Texture;
    window.TextureLoader = TextureLoader;
    window.TorusGeometry = TorusGeometry;
    window.TorusKnotGeometry = TorusKnotGeometry;
    window.Triangle = Triangle;
    window.TriangleFanDrawMode = TriangleFanDrawMode;
    window.TriangleStripDrawMode = TriangleStripDrawMode;
    window.TrianglesDrawMode = TrianglesDrawMode;
    window.TubeGeometry = TubeGeometry;
    window.UVMapping = UVMapping;
    window.Uint16BufferAttribute = Uint16BufferAttribute;
    window.Uint32BufferAttribute = Uint32BufferAttribute;
    window.Uint8BufferAttribute = Uint8BufferAttribute;
    window.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
    window.Uniform = Uniform;
    window.UniformsGroup = UniformsGroup;
    window.UnsignedByteType = UnsignedByteType;
    window.UnsignedInt248Type = UnsignedInt248Type;
    window.UnsignedIntType = UnsignedIntType;
    window.UnsignedShort4444Type = UnsignedShort4444Type;
    window.UnsignedShort5551Type = UnsignedShort5551Type;
    window.UnsignedShortType = UnsignedShortType;
    window.VSMShadowMap = VSMShadowMap;
    window.Vector2 = Vector2;
    window.Vector3 = Vector3;
    window.Vector4 = Vector4;
    window.VectorKeyframeTrack = VectorKeyframeTrack;
    window.VideoTexture = VideoTexture;
    window.WebGL3DRenderTarget = WebGL3DRenderTarget;
    window.WebGLArrayRenderTarget = WebGLArrayRenderTarget;
    window.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
    window.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;
    window.WebGLRenderTarget = WebGLRenderTarget;
    window.WebGPUCoordinateSystem = WebGPUCoordinateSystem;
    window.WebGPURenderer = WebGPURenderer;
    window.WebGLUtils = WebGLUtils;
    window.WireframeGeometry = WireframeGeometry;
    window.WrapAroundEnding = WrapAroundEnding;
    window.ZeroCurvatureEnding = ZeroCurvatureEnding;
    window.ZeroFactor = ZeroFactor;
    window.ZeroSlopeEnding = ZeroSlopeEnding;
    window.ZeroStencilOp = ZeroStencilOp;

    if (!window.THREE) {
        window.THREE = {};
    }

    const THREE = window.THREE;

    THREE.nodeObject = nodeObject;
    THREE.nodeObjects = nodeObjects;
    THREE.PostProcessing = PostProcessing;
    THREE.RendererUtils = RendererUtils;
    THREE.RenderTarget = RenderTarget;
    THREE.tsl = {
        add,
        float,
        Fn,
        int,
        Loop,
        luminance,
        mix,
        NodeMaterial,
        nodeObject,
        NodeUpdateType,
        pass,
        passTexture,
        QuadMesh,
        smoothstep,
        TempNode,
        texture,
        uniform,
        uniformArray,
        uv,
        vec4,
        mrt,
        output
    }
})();
